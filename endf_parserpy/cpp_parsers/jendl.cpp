// File generated by endf_parserpy.compiler.endf2cpp.py::generate_cpp_module_code
// MD5 hash of file content below this line: f8d24267c522a406939be51c64248bb7
#define PYTHON_COMPILE
#ifndef CPP_ENDF_FLOAT_HPP
#define CPP_ENDF_FLOAT_HPP


#include <pybind11/pybind11.h>
#include <iostream>
#include <string>


namespace py = pybind11;


#define DOUBLE_TYPE EndfFloatCpp


// This class must be in sync with the
// Python class EndfFloat class in endf_parserpy.utils.math_utils

class EndfFloatCpp {
public:
    EndfFloatCpp()
        : _value(0.0), _orig_str("") {}

    EndfFloatCpp(double value)
        : _value(value), _orig_str("") {}

    EndfFloatCpp(double value, const std::string& orig_str)
        : _value(value), _orig_str(orig_str) {}

    EndfFloatCpp(const EndfFloatCpp& other)
        : _value(other._value), _orig_str(other._orig_str) {}

    std::string get_original_string() const {
        return _orig_str; }
    bool operator==(const EndfFloatCpp& other) const {
        return static_cast<double>(_value) == static_cast<double>(other._value);
    }

    bool operator!=(const EndfFloatCpp& other) const {
        return static_cast<double>(_value) != static_cast<double>(other._value);
    }

    bool operator<(const EndfFloatCpp& other) const {
        return static_cast<double>(_value) < static_cast<double>(other._value);
    }


    template<typename T>
    bool operator==(T other) const {
        return static_cast<double>(_value) == static_cast<double>(other);
    }

    template<typename T>
    bool operator!=(T other) const {
        return static_cast<double>(_value) != static_cast<double>(other);
    }

    template<typename T>
    bool operator<(T other) const {
        return static_cast<double>(_value) < static_cast<double>(other);
    }

    friend std::ostream& operator<<(std::ostream& os, const EndfFloatCpp& obj) {
        os << static_cast<double>(obj);
        return os;
    }

    operator double() const {
        return _value;
    }

    operator int() const {
        return static_cast<int>(_value);
    }

private:
    double _value;
    std::string _orig_str;
};


namespace PYBIND11_NAMESPACE { namespace detail {

    // Establish conversion between Python float and EndfFloatCpp
    template <> struct type_caster<EndfFloatCpp> {
    public:
        PYBIND11_TYPE_CASTER(EndfFloatCpp, const_name("EndfFloatCpp"));

        bool load(handle src, bool) {
            static py::object PyEndfFloat = (
                py::module::import("endf_parserpy.utils.math_utils").attr("EndfFloat")
            );
            // case 1: cast Python float to EndfFloatCpp
            if (py::isinstance<py::float_>(src)) {
                py::float_ tmp = py::cast<py::float_>(src);
                double float_value = tmp.cast<double>();
                value = EndfFloatCpp(float_value);
                return !(float_value == -1 && PyErr_Occurred());
            }

            // case 2: cast Python int to EndfFloatCpp
            else if (py::isinstance<py::int_>(src)) {
                py::int_ tmp = py::cast<py::int_>(src);
                double int_value = tmp.cast<double>() ;
                value = EndfFloatCpp(int_value);
                return true;
            }

            // case 3: cast Python float to EndfFloatCpp
            else if (py::isinstance(src, PyEndfFloat)) {
				auto float_method = src.attr("__float__");
				double float_value = float_method().cast<double>();
				std::string orig_str = src.attr("get_original_string")().cast<std::string>();
				value = EndfFloatCpp(float_value, orig_str);
                return true;
            }
            return false;
        }

        static handle cast(const EndfFloatCpp& src, return_value_policy, handle) {
            static py::object PyEndfFloat = (
                py::module::import("endf_parserpy.utils.math_utils").attr("EndfFloat")
            );
            double float_value = static_cast<double>(src);
            std::string orig_str = src.get_original_string();
            if (orig_str.empty()) {
                return py::float_(static_cast<double>(src)).release();
            } else {
                py::object endf_float = PyEndfFloat(
                   py::float_(float_value), py::str(orig_str)
                );
                return endf_float.release();
            }
        }
    };


}} // namespace PYBIND11_NAMESPACE::detail


#endif // CPP_ENDF_FLOAT_HPP
#ifndef INDEX_SHIFTER_HPP
#define INDEX_SHIFTER_HPP


#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <map>
#include <string>


namespace py = pybind11;


class IndexShifter {

private:
    int start_index;
    bool accessed;
    bool list_mode;
    std::vector<IndexShifter> next_level;

    IndexShifter& get_next_level(int idx) {
        if (idx == next_level.size()) {
            next_level.push_back(IndexShifter(list_mode));
        }
        return next_level[idx];
    }

    bool key_exists(py::list obj, int key) {
        return key < obj.size();
    }

    bool key_exists(py::dict obj, int key) {
        return obj.contains(py::cast(key));
    }

    void insert_obj(py::list pyobj, int key, py::object elem) {
        if (key == pyobj.size()) {
            pyobj.append(elem);
        } else {
            pyobj[key] = elem;
        }
    }

    void insert_obj(py::dict pyobj, int key, py::object elem) {
        pyobj[py::cast(key)] = elem;
    }

    template <typename V>
    py::object setdefault_i(
        V pyobj, const std::vector<int>& recipe_indices, py::object defval, int i
    ) {
        int py_index_value = recipe_indices[i];
        if (!accessed) {
            accessed = true;
            start_index = py_index_value;
        }
        int index_value = py_index_value - start_index;
        if (list_mode) {
            py_index_value = index_value;
            if (py_index_value < 0) {
                throw std::out_of_range("list index out of range");
            }
        }
        if (i+1 < recipe_indices.size()) {
            auto& next_level = get_next_level(index_value);
            if (! defval.is_none() & ! key_exists(pyobj, py_index_value)) {
                insert_obj(pyobj, py_index_value, V());
            }
            return next_level.setdefault_i(
                py::cast<V>(pyobj[py::cast(py_index_value)]), recipe_indices, defval, i+1
            );
        } else {
            if (! defval.is_none() & ! key_exists(pyobj, py_index_value)) {
                insert_obj(pyobj, py_index_value, defval);
            }
            return pyobj[py::cast(py_index_value)];
        }
    }

public:
    IndexShifter()
        : start_index(0), accessed(false), list_mode(false) {}

    IndexShifter(bool list_mode)
        : start_index(0), accessed(false), list_mode(list_mode) {}

    IndexShifter(const IndexShifter &other)
        : start_index(other.start_index), accessed(other.accessed),
          list_mode(other.list_mode), next_level(other.next_level) {}

    IndexShifter& operator=(const IndexShifter& other) {
        if (this != &other) {
            start_index = other.start_index;
            accessed = other.accessed;
            list_mode = other.list_mode;
            next_level = other.next_level;
        }
        return *this;
    }

    py::object setdefault(py::object pyobj, const std::vector<int> recipe_indices, py::object defval) {
        if (list_mode) {
            return setdefault_i(pyobj.cast<py::list>(), recipe_indices, defval, 0);
        } else {
            return setdefault_i(pyobj.cast<py::dict>(), recipe_indices, defval, 0);
        }
    }

    py::object get_value(py::object pyobj, const std::vector<int> recipe_indices) {
        return setdefault(pyobj, recipe_indices, py::none());
    }

};


class IndexShifterStore {

private:
    using IndexShifterMap = std::map<std::string, IndexShifter>;

    bool list_mode;
    py::dict refdict;
    IndexShifterMap index_shifter_map;

public:
    IndexShifterStore()
        : list_mode(false) {}

    IndexShifterStore(py::dict refdict, bool list_mode)
        : refdict(refdict), list_mode(list_mode) {}

    IndexShifterStore(const IndexShifterStore &other)
        : list_mode(other.list_mode), refdict(other.refdict),
          index_shifter_map(other.index_shifter_map) {}

    IndexShifterStore& operator=(const IndexShifterStore &other) {
        if (this != &other) {
            list_mode = other.list_mode;
            refdict = other.refdict;
            index_shifter_map = other.index_shifter_map;
        }
        return *this;
    }

    py::object setdefault(std::string varname, std::vector<int> indices, py::object defval) {
        if (!defval.is_none() && !refdict.contains(varname)) {
            if (indices.empty()) {
                refdict[py::cast(varname)] = defval;
                return defval;
            } else if (list_mode) {
                refdict[py::cast(varname)] = py::list();
            } else {
                refdict[py::cast(varname)] = py::dict();
            }
        }
        auto pyobj = refdict[py::cast(varname)];
        if (indices.empty()) {
            return pyobj;
        }
        IndexShifterMap::iterator it = index_shifter_map.find(varname);
        if (it == index_shifter_map.end()) {
            index_shifter_map[varname] = IndexShifter(list_mode);
        }
        auto &index_shifter = index_shifter_map[varname];
        return index_shifter.setdefault(pyobj, indices, defval);
    }

    py::object get_value(std::string varname, std::vector<int> indices, py::object defval=py::none()) {
        if (! defval.is_none() & ! refdict.contains(varname)) {
            return defval;
        }
        return setdefault(varname, indices, py::none());
    }

};


#endif // INDEX_SHIFTER_HPP
#ifndef MODULE_HEADER_HPP
#define MODULE_HEADER_HPP


#include <pybind11/pybind11.h>
#include <pybind11/stl.h> // Necessary for STL containers like std::map

#include <stdexcept>
#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <vector>
#include <string>
#include <cassert>
#include <algorithm>  // for std::sort
#include <cstddef>

// When Python merges the various
// C++ files, there is no need
// to include them here
#ifndef PYTHON_COMPILE
#include "endf_float_cpp.hpp"
#include "index_shifter.hpp"
#endif

namespace py = pybind11;


#ifndef DOUBLE_TYPE
#define DOUBLE_TYPE double
#endif


struct Tab1Body {
  std::vector<int> INT;
  std::vector<int> NBT;
  std::vector<DOUBLE_TYPE> X;
  std::vector<DOUBLE_TYPE> Y;
};


struct Tab2Body {
  std::vector<int> INT;
  std::vector<int> NBT;
};


bool seq_contains(py::sequence seq, py::object value) {
  int i = 0;
  for (const auto& item : seq) {
    if (py::cast<py::object>(item).equal(value)) {
      return true;
    }
  }
  return false;
}


bool should_parse_section(int mf, int mt, py::object& exclude, py::object& include) {
  py::tuple mf_mt_tup = py::make_tuple(mf, mt);
  if (! exclude.is_none()) {
    if (! py::isinstance<py::sequence>(exclude)) {
      throw std::runtime_error("`exclude` argument must be of sequence type");
    }
    if (seq_contains(exclude, py::int_(mf)) || seq_contains(exclude, mf_mt_tup)) {
      return false;
    } else {
      return true;
    }
  } else if (! include.is_none()) {
    if (! py::isinstance<py::sequence>(include)) {
      throw std::runtime_error("`include` argument must be of sequence type");
    }
    if (seq_contains(include, py::int_(mf)) || seq_contains(include, mf_mt_tup)) {
      return true;
    } else {
      return false;
    }
  } else {
    return true;
  }
}

#endif // MODULE_HEADER_HPP
#ifndef MODULE_HEADER_READING_HPP
#define MODULE_HEADER_READING_HPP

// When Python merges the various
// C++ files, there is no need
// to include them here
#ifndef PYTHON_COMPILE
#include "module_header.hpp"
#endif

#ifndef DOUBLE_TYPE
#define DOUBLE_TYPE double
#endif


struct ParsingOptions {
  bool ignore_number_mismatch;
  bool ignore_zero_mismatch;
  bool ignore_varspec_mismatch;
  bool accept_spaces;
  bool ignore_blank_lines;
  bool ignore_send_records;
  bool ignore_missing_tpid;
  bool preserve_value_strings;
  bool validate_control_records;
  std::string array_type;
};


ParsingOptions default_parsing_options() {
  return ParsingOptions{
    false,  // ignore_number_mismatch
    true,  // ignore_zero_mismatch
    true,  // ignore_varspec_mismatch
    true,  // accept_spaces
    false,  // ignore_blank_lines
    false,  // ignore_send_records
    false,  // ignore_missing_tpid
    false,  // preserve_value_strings
    false,  // validate_control_records
    "dict"  // array_type
  };
}


namespace pybind11 { namespace detail {
  template <> struct type_caster<ParsingOptions> {
  public:
    PYBIND11_TYPE_CASTER(ParsingOptions, _("ParsingOptions"));

    // conversion from Python to C++
    bool load(handle src, bool) {
      if (!py::isinstance<py::dict>(src))
        return false;
      auto d = reinterpret_borrow<py::dict>(src);
      py::object keys = d.attr("keys")();
      for (auto key : keys) {
        std::string key_str = py::str(key);
        if (key_str == "ignore_number_mismatch")
          value.ignore_number_mismatch = d["ignore_number_mismatch"].cast<bool>();
        else if (key_str == "ignore_zero_mismatch")
          value.ignore_zero_mismatch = d["ignore_zero_mismatch"].cast<bool>();
        else if (key_str == "ignore_varspec_mismatch")
          value.ignore_varspec_mismatch = d["ignore_varspec_mismatch"].cast<bool>();
        else if (key_str == "accept_spaces")
          value.accept_spaces = d["accept_spaces"].cast<bool>();
        else if (key_str == "ignore_blank_lines")
          value.ignore_blank_lines = d["ignore_blank_lines"].cast<bool>();
        else if (key_str == "ignore_send_records")
          value.ignore_send_records = d["ignore_send_records"].cast<bool>();
        else if (key_str == "ignore_missing_tpid")
          value.ignore_missing_tpid = d["ignore_missing_tpid"].cast<bool>();
        else if (key_str == "preserve_value_strings")
          value.preserve_value_strings = d["preserve_value_strings"].cast<bool>();
        else if (key_str == "validate_control_records")
          value.validate_control_records = d["validate_control_records"].cast<bool>();
        else if (key_str == "array_type")
          value.array_type = d["array_type"].cast<std::string>();
        else
          throw std::runtime_error("unknown option `" + key_str + "` provided");
      }

      // use default values for missing options
      ParsingOptions default_opts = default_parsing_options();

      if (! d.contains("ignore_number_mismatch")) {
        value.ignore_number_mismatch = default_opts.ignore_number_mismatch;
      }

      if (! d.contains("ignore_zero_mismatch")) {
        value.ignore_zero_mismatch = default_opts.ignore_zero_mismatch;
      }

      if (! d.contains("ignore_varspec_mismatch")) {
        value.ignore_varspec_mismatch = default_opts.ignore_varspec_mismatch;
      }

      if (! d.contains("accept_spaces")) {
        value.accept_spaces = default_opts.accept_spaces;
      }

      if (! d.contains("ignore_blank_lines")) {
        value.ignore_blank_lines = default_opts.ignore_blank_lines;
      }

      if (! d.contains("ignore_send_records")) {
        value.ignore_send_records = default_opts.ignore_send_records;
      }

      if (! d.contains("ignore_missing_tpid")) {
        value.ignore_missing_tpid = default_opts.ignore_missing_tpid;
      }

      if (! d.contains("preserve_value_strings")) {
        value.preserve_value_strings = default_opts.preserve_value_strings;
      }

      if (! d.contains("validate_control_records")) {
        value.validate_control_records = default_opts.validate_control_records;
      }

      if (! d.contains("array_type")) {
        value.array_type = default_opts.array_type;
      }

      return true;
    }

    // conversion from C++ to Python
    static handle cast(const ParsingOptions &src, return_value_policy, handle) {
      py::dict d;
      d["ignore_number_mismatch"] = src.ignore_number_mismatch;
      d["ignore_zero_mismatch"] = src.ignore_zero_mismatch;
      d["ignore_varspec_mismatch"] = src.ignore_varspec_mismatch;
      d["accept_spaces"] = src.accept_spaces;
      d["ignore_blank_lines"] = src.ignore_blank_lines;
      d["ignore_send_records"] = src.ignore_send_records;
      d["ignore_missing_tpid"] = src.ignore_missing_tpid;
      d["preserve_value_strings"] = src.preserve_value_strings;
      d["validate_control_records"] = src.validate_control_records;
      d["array_type"] = src.array_type;
      return d.release();
    }

  };
}}


py::object py_create_container(bool list_mode) {
    if (list_mode) {
        return py::list();
    } else {
        return py::dict();
    }
}


py::object py_append_container(py::object pyobj, int key, bool list_mode, py::object elem=py::none()) {
    if (list_mode) {
        if (elem.is_none()) {
            elem = py::list();
        }
        py::list list = pyobj;
        list.append(elem);
        return elem;
    } else {
        if (elem.is_none()) {
            elem = py::dict();
        }
        return pyobj.attr("setdefault")(py::cast(key), elem);
    }
}


template<typename U, typename V, typename W>
void throw_mismatch_error(
  U quantity, V expected_value, W actual_value,
  std::string line, std::string template_line
) {
  std::stringstream errmsg;
  errmsg << "Invalid " << quantity << " encountered! "
         << "Expected " << quantity << "=" << expected_value
         << " but found " << quantity <<"=" << actual_value << std::endl;
  if (template_line.size() > 0) {
    errmsg << "Template: " << template_line << std::endl;
  }
  if (line.size() > 0) {
    errmsg << "Line: " << line << std::endl;
  }
  throw std::runtime_error(errmsg.str());
}


template<typename V, typename W>
void throw_number_mismatch_error(
  V expected_value, W actual_value,
  std::string line, std::string template_line
) {
  std::stringstream errmsg;
  errmsg << "Expected a field to contain the value " << expected_value
         << " but found instead the value " << actual_value << "." << std::endl;
  if (template_line.size() > 0) {
    errmsg << "Template: " << template_line << std::endl;
  }
  if (line.size() > 0) {
    errmsg << "Line: " << line << std::endl;
  }
  throw std::runtime_error(errmsg.str());
}


double endfstr2float(const char* str, ParsingOptions &parse_opts) {
  char tbuf[13];
  int j = 0;
  bool in_number = false;
  bool in_exponent = false;
  int last_nonspace_pos=-1;
  for (int i=10; i >= 0; i--) {
    if (str[i] != ' ') {
      last_nonspace_pos = i;
      break;
    }
  }
  if (last_nonspace_pos == -1) {
    return 0.0;
  }
  for (int i=0; i <= last_nonspace_pos; i++) {
    char c = str[i];
    if (c == ' ') {
      if (parse_opts.accept_spaces || ! in_number) {
        continue;
      } else {
        std::stringstream errmsg;
        errmsg << "encontered number with spaces: \""
               << std::string(str, 11) << "\"" << std::endl;
        throw std::runtime_error(errmsg.str());
      }
    }
    if (in_number) {
      if (!in_exponent) {
        if (c=='+' || c=='-') {
          tbuf[j++] = 'e';
          in_exponent = true;
        } else if (c=='e' || c=='E') {
          in_exponent = true;
        }
      }
    } else {
      if (c == '.' || (c >= '0' && c <= '9') || c == '-' || c == '+') {
        in_number = true;
      }
    }
    tbuf[j++] = c;
  }
  if (j==0) tbuf[j++] = '0';
  tbuf[j++] = '\0';
  return std::stod(tbuf);
}


int endfstr2int(const char* str, ParsingOptions &parse_opts) {
  char strzero[12];
  std::memcpy(strzero, str, 11);
  strzero[11] = '\0';
  for (int i=0; i < 11; i++) {
    if (str[i] != ' ') {
      return std::atoi(strzero);
    }
  }
  return 0;
}

// case for EndfFloatCpp
EndfFloatCpp cpp_read_field_EndfFloatCpp(
  const char *str, const char fieldnum, ParsingOptions &parse_opts
) {
  double float_value = endfstr2float(str+fieldnum*11, parse_opts);
  if (parse_opts.preserve_value_strings) {
    std::string orig_str(str+fieldnum*11, 11);
    return EndfFloatCpp(float_value, orig_str);
  } else {
    return EndfFloatCpp(float_value);
  }
}


template<typename T>
T cpp_read_field(const char *str, const char fieldnum, ParsingOptions &parse_opts) {
  static_assert(
    std::is_same<T, EndfFloatCpp>::value
    || std::is_same<T, int>::value
    || std::is_same<T, double>::value
    , "T must be int or double"
  );
  if (std::is_same<T, double>::value) {
    return endfstr2float(str+fieldnum*11, parse_opts);
  } if (std::is_same<T, EndfFloatCpp>::value) {
    return cpp_read_field_EndfFloatCpp(str, fieldnum, parse_opts);
  } else {
    return endfstr2int(str+fieldnum*11, parse_opts);
  }
}


// the next couple of functions are for handling
// are auxiliary functions to amek cpp_validate_field
// for different types (in particular std::vector and std::string)

template<typename T>
typename std::enable_if<std::is_scalar<T>::value, bool>::type
is_zero_check(const T value) {
  return value == 0;
}


template<typename T>
typename std::enable_if<! std::is_scalar<T>::value, bool>::type
is_zero_check(const T value) {
  return false;
}


template<typename U, typename V>
typename std::enable_if<
  (!std::is_scalar<U>::value && !std::is_same<U, DOUBLE_TYPE>::value)
  || (!std::is_scalar<V>::value && !std::is_same<V, DOUBLE_TYPE>::value), void
>::type
cpp_validate_field(
  U expected_value,
  V actual_value,
  bool contains_variable,
  bool contains_desired_number,
  bool contains_inconsistent_varspec,
  std::string exprstr,
  std::string &line_template,
  std::string &line,
  ParsingOptions &parse_opts
) {
  std::stringstream errmsg;
  errmsg << "Both the expected and actual value are vectors --- "
         << "not implemented at the moment" << std::endl;
  throw std::runtime_error(errmsg.str());
}


template<typename U, typename V>
typename std::enable_if<
  (std::is_scalar<U>::value || std::is_same<U, DOUBLE_TYPE>::value)
   && (std::is_scalar<V>::value || std::is_same<V, DOUBLE_TYPE>::value), void
>::type
cpp_validate_field(
  U expected_value,
  V actual_value,
  bool contains_variable,
  bool contains_desired_number,
  bool contains_inconsistent_varspec,
  std::string exprstr,
  std::string &line_template,
  std::string &line,
  ParsingOptions &parse_opts
) {
  if (static_cast<double>(expected_value) == static_cast<double>(actual_value)) return;

  // inconsistency detected
  if (! contains_variable) {
    // dealing with a number
    // ignore zero mismatch only active for scalar data types
    if (is_zero_check(expected_value) && parse_opts.ignore_zero_mismatch) return;
    if (contains_desired_number && parse_opts.ignore_number_mismatch) return;
    throw_number_mismatch_error(expected_value, actual_value, line, line_template);
  } else {
    // dealing with an expression with variables
    if (contains_inconsistent_varspec && parse_opts.ignore_varspec_mismatch) return;
    throw_mismatch_error(exprstr, expected_value, actual_value, line, line_template);
  }
}

// we are done with the cpp_validate_field related functionality

int cpp_read_custom_int_field(const char *str, int start_pos, int length) {
  std::vector<char> strzero(length+1);
  std::memcpy(strzero.data(), str+start_pos, length);
  strzero[length] = '\0';
  for (int i=0; i < length; i++) {
    if (strzero[i] != ' ') {
      return std::atoi(strzero.data());
    }
  }
  return 0;
}


int cpp_read_mat_number(const char *str) {
  return cpp_read_custom_int_field(str, 66, 4);
}


int cpp_read_mf_number(const char *str) {
  return cpp_read_custom_int_field(str, 70, 2);
}


int cpp_read_mt_number(const char *str) {
  return cpp_read_custom_int_field(str, 72, 3);
}


std::string cpp_read_raw_line(std::istream& cont) {
  std::string line;
  std::getline(cont, line);
  return line;
}


std::string cpp_read_line(
  std::istream& cont, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  std::string line;
  std::getline(cont, line);
  if (parse_opts.validate_control_records) {
    int curmat = cpp_read_mat_number(line.c_str());
    int curmf = cpp_read_mf_number(line.c_str());
    int curmt = cpp_read_mt_number(line.c_str());
    if (curmat != mat)
      throw_mismatch_error("MAT", mat, curmat, line, "");
    if (curmf != mf)
      throw_mismatch_error("MF", mf, curmf, line, "");
    if (curmt != mt)
      throw_mismatch_error("MT", mt, curmt, line, "");
  }
  return line;
}


std::string cpp_read_send(std::istream& cont, int mat, int mf, ParsingOptions &parse_opts) {
  std::string line = cpp_read_line(cont, mat, mf, 0, parse_opts);
  int mtnum = cpp_read_mt_number(line.c_str());
  if (cpp_read_field<DOUBLE_TYPE>(line.c_str(), 0, parse_opts) != 0.0 ||
    cpp_read_field<DOUBLE_TYPE>(line.c_str(), 1, parse_opts) != 0.0 ||
    cpp_read_field<int>(line.c_str(), 2, parse_opts) != 0 ||
    cpp_read_field<int>(line.c_str(), 3, parse_opts) != 0 ||
    cpp_read_field<int>(line.c_str(), 4, parse_opts) != 0 ||
    cpp_read_field<int>(line.c_str(), 5, parse_opts) != 0 ||
    mtnum != 0) {

    std::stringstream errmsg;
    errmsg << "Expected SEND record does not contain one!" << std::endl
           << "Line: " << line << std::endl;
    throw std::runtime_error(errmsg.str());
  }
  if (parse_opts.validate_control_records) {
    int curmat = cpp_read_mat_number(line.c_str());
    int curmf = cpp_read_mf_number(line.c_str());
    if (curmat != mat)
      throw_mismatch_error("MAT", mat, curmat, line, "");
    if (curmf != mf)
      throw_mismatch_error("MF", mf, curmf, line, "");
  }
  return line;
}


bool cpp_is_fend_record(std::string line, int mat, ParsingOptions &parse_opts) {
  int curmat = cpp_read_mat_number(line.c_str());
  if (mat != curmat && parse_opts.validate_control_records) {
      throw_mismatch_error("MAT", mat, curmat, line, "");
  }
  int mf = cpp_read_mf_number(line.c_str());
  int mt = cpp_read_mt_number(line.c_str());
  double c1 = cpp_read_field<DOUBLE_TYPE>(line.c_str(), 0, parse_opts);
  double c2 = cpp_read_field<DOUBLE_TYPE>(line.c_str(), 1, parse_opts);
  int n1 = cpp_read_field<int>(line.c_str(), 2, parse_opts);
  int n2 = cpp_read_field<int>(line.c_str(), 3, parse_opts);
  int l1 = cpp_read_field<int>(line.c_str(), 4, parse_opts);
  int l2 = cpp_read_field<int>(line.c_str(), 5, parse_opts);
  bool cond = (c1 == 0.0 && c2 == 0.0 && n1 == 0 && n2 == 0);
  cond &= (l1 == 0 && l2 == 0 && mf == 0 && mt == 0);
  return cond;
}


bool cpp_is_mend_record(std::string line, ParsingOptions &parse_opts) {
  int mat = cpp_read_mat_number(line.c_str());
  bool cond = cpp_is_fend_record(line, 0, parse_opts);
  cond &= (mat == 0);
  return cond;
}


bool cpp_is_tend_record(std::string line, ParsingOptions &parse_opts) {
  int mat = cpp_read_mat_number(line.c_str());
  bool cond = cpp_is_fend_record(line, -1, parse_opts);
  cond &= (mat == -1);
  return cond;
}


bool cpp_is_blank_line(std::string line) {
  for (int i=0; i < line.size(); i++) {
    if (line[i] != ' ') return false;
  }
  return true;
}

template<typename T>
std::vector<T> cpp_read_vec(
  std::istream& cont, const int numel, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  int j = 0;
  std::vector<T> res;
  std::string line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  for (int i=0; i < numel; i++) {
    res.push_back(cpp_read_field<T>(line.c_str(), j++, parse_opts));
    if (j > 5 && i+1 < numel) {
      line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      j = 0;
    }
  }
  return res;
}


template<typename T>
std::vector<T> cpp_read_vec_debug(
  std::istream& cont, std::string& line, const int numel, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  int j = 0;
  std::vector<T> res;
  std::ostringstream oss;
  std::string curline = cpp_read_line(cont, mat, mf, mt, parse_opts);
  for (int i=0; i < numel; i++) {
    res.push_back(cpp_read_field<T>(curline.c_str(), j++, parse_opts));
    if (j > 5 && i+1 < numel) {
      oss << curline << std::endl;
      curline = cpp_read_line(cont, mat, mf, mt, parse_opts);
      j = 0;
    }
  }
  oss << curline << std::endl;
  line = oss.str();
  return res;
}


Tab2Body read_tab2_body_debug(
  std::istream& cont, std::string& line, int nr, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  std::ostringstream oss;
  std::string tmpline;
  Tab2Body tab_body;
  std::vector<int> interp = cpp_read_vec_debug<int>(cont, tmpline, 2*nr, mat, mf, mt, parse_opts);
  oss << tmpline;
  int j = 0;
  for (int i=0; i < nr; i++) {
    tab_body.NBT.push_back(interp[j++]);
    tab_body.INT.push_back(interp[j++]);
  }
  line = oss.str();
  return tab_body;
}


Tab2Body read_tab2_body(
  std::istream& cont, int nr, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  Tab2Body tab_body;
  std::vector<int> interp = cpp_read_vec<int>(cont, 2*nr, mat, mf, mt, parse_opts);
  int j = 0;
  for (int i=0; i < nr; i++) {
    tab_body.NBT.push_back(interp[j++]);
    tab_body.INT.push_back(interp[j++]);
  }
  return tab_body;
}


Tab1Body read_tab1_body_debug(
  std::istream& cont, std::string& line, int nr, int np,
  int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  std::ostringstream oss;
  std::string tmpline;
  Tab1Body tab_body;
  std::vector<int> interp = cpp_read_vec_debug<int>(cont, tmpline, 2*nr, mat, mf, mt, parse_opts);
  oss << tmpline;
  int j = 0;
  for (int i=0; i < nr; i++) {
    tab_body.NBT.push_back(interp[j++]);
    tab_body.INT.push_back(interp[j++]);
  }
  std::vector<DOUBLE_TYPE> data = cpp_read_vec_debug<DOUBLE_TYPE>(cont, tmpline, 2*np, mat, mf, mt, parse_opts);
  oss << tmpline;
  j = 0;
  for (int i=0; i < np; i++) {
    tab_body.X.push_back(data[j++]);
    tab_body.Y.push_back(data[j++]);
  }
  line = oss.str();
  return tab_body;
}


Tab1Body read_tab1_body(
  std::istream& cont, int nr, int np,
  int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  Tab1Body tab_body;
  std::vector<int> interp = cpp_read_vec<int>(cont, 2*nr, mat, mf, mt, parse_opts);
  int j = 0;
  for (int i=0; i < nr; i++) {
    tab_body.NBT.push_back(interp[j++]);
    tab_body.INT.push_back(interp[j++]);
  }
  std::vector<DOUBLE_TYPE> data = cpp_read_vec<DOUBLE_TYPE>(cont, 2*np, mat, mf, mt, parse_opts);
  j = 0;
  for (int i=0; i < np; i++) {
    tab_body.X.push_back(data[j++]);
    tab_body.Y.push_back(data[j++]);
  }
  return tab_body;
}


std::vector<std::string> read_section_verbatim(
    int mat, int mf, int mt, std::istream& cont, bool is_first, ParsingOptions &parse_opts
) {
  std::streampos curpos;
  std::string line;
  std::vector<std::string> secvec;
  int curmf;
  int curmt;
  size_t lastpos;
  while (! cont.eof()) {
    line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // remove trailing \r that we may
    // get from reading win-style line endings
    lastpos = line.size() - 1;
    if (line[lastpos] == '\r') {
      line.erase(lastpos);
    }
    curmf = std::stoi(line.substr(70, 2));
    curmt = std::stoi(line.substr(72, 3));
    if (curmf != mf || curmt != mt) break;
    // the newline for compatibility with the Python parser
    secvec.push_back(line + "\n");
    curpos = cont.tellg();
  }
  if (! is_first && (curmf != mf || curmt != 0)) {
     std::string errmsg = "expected SEND of MF/MT " +
                          std::to_string(mf) + "/" + std::to_string(mt);
     throw std::runtime_error(errmsg);
  }
  if (is_first) {
    // we rewind one line because in the case of MF0/MT0 (tapeid)
    // we have also consumed the HEAD record of the next section
    cont.seekg(curpos);
  }
  return secvec;
}

#endif // MODULE_HEADER_READING_HPP
#ifndef MODULE_HEADER_WRITING_HPP
#define MODULE_HEADER_WRITING_HPP

// When Python merges the various
// C++ files, there is no need
// to include it here
#ifndef PYTHON_COMPILE
#include "module_header.hpp"
#endif

#ifndef DOUBLE_TYPE
#define DOUBLE_TYPE double
#endif


struct WritingOptions {
  bool abuse_signpos;
  bool keep_E;
  bool prefer_noexp;
  bool skip_intzero;
  bool preserve_value_strings;
  bool include_linenum;
  std::string array_type;
};


WritingOptions default_writing_options() {
  return WritingOptions{
    false,  // abuse_signpos
    false,  // keep_E
    false,  // prefer_noexp
    false,  // skip_intzero
    false,  // preserve_value_strings
    true,   // include_linenum
    "dict"  // array_type
  };
}


namespace pybind11 { namespace detail {
  template <> struct type_caster<WritingOptions> {
  public:
    PYBIND11_TYPE_CASTER(WritingOptions, _("WritingOptions"));

    // conversion from Python to C++
    bool load(handle src, bool) {
      if (!py::isinstance<py::dict>(src))
        return false;
      auto d = reinterpret_borrow<py::dict>(src);
      py::object keys = d.attr("keys")();
      for (auto key : keys) {
        std::string key_str = py::str(key);
        if (key_str == "abuse_signpos")
          value.abuse_signpos = d["abuse_signpos"].cast<bool>();
        else if (key_str == "keep_E")
          value.keep_E = d["keep_E"].cast<bool>();
        else if (key_str == "prefer_noexp")
          value.prefer_noexp = d["prefer_noexp"].cast<bool>();
        else if (key_str == "skip_intzero")
          value.skip_intzero = d["skip_intzero"].cast<bool>();
        else if (key_str == "include_linenum")
          value.include_linenum = d["include_linenum"].cast<bool>();
        else if (key_str == "preserve_value_strings")
          value.preserve_value_strings = d["preserve_value_strings"].cast<bool>();
        else if (key_str == "array_type")
          value.array_type = d["array_type"].cast<std::string>();
        else
          throw std::runtime_error("unknown option `" + key_str + "` provided");
      }

      // use default values for missing options
      WritingOptions default_opts = default_writing_options();

      if (! d.contains("abuse_signpos")) {
        value.abuse_signpos = default_opts.abuse_signpos;
      }
      if (! d.contains("keep_E")) {
        value.keep_E = default_opts.keep_E;
      }
      if (! d.contains("prefer_noexp")) {
        value.prefer_noexp = default_opts.prefer_noexp;
      }
      if (! d.contains("skip_intzero")) {
        value.skip_intzero = default_opts.skip_intzero;
      }
      if (! d.contains("preserve_value_strings")) {
        value.preserve_value_strings = default_opts.preserve_value_strings;
      }
      if (! d.contains("include_linenum")) {
        value.include_linenum = default_opts.include_linenum;
      }
      if (! d.contains("array_type")) {
        value.array_type = default_opts.array_type;
      }
      return true;
    }

    // conversion from C++ to Python
    static handle cast(const WritingOptions &src, return_value_policy, handle) {
      py::dict d;
      d["abuse_signpos"] = src.abuse_signpos;
      d["keep_E"] = src.keep_E;
      d["prefer_noexp"] = src.prefer_noexp;
      d["skip_intzero"] = src.skip_intzero;
      d["preserve_value_strings"] = src.preserve_value_strings;
      d["include_linenum"] = src.include_linenum;
      d["array_type"] = src.array_type;
      return d.release();
    }

  };
}}


void cpp_write_custom_int_field(std::string &str, int start, int length, int value) {
  std::ostringstream oss;
  oss << std::right << std::setw(length) << value;
  str.replace(start, length, oss.str());
}


void cpp_write_mat_number(std::string& str, int value) {
  cpp_write_custom_int_field(str, 66, 4, value);
}


void cpp_write_mf_number(std::string& str, int value) {
  cpp_write_custom_int_field(str, 70, 2, value);
}


void cpp_write_mt_number(std::string& str, int value) {
  cpp_write_custom_int_field(str, 72, 3, value);
}


void cpp_write_line_number(std::string& str, int value) {
  cpp_write_custom_int_field(str, 75, 5, value);
}


std::string cpp_prepare_line(
  int mat, int mf, int mt, int &linenum, WritingOptions &write_opts
) {
  int line_width = (write_opts.include_linenum) ? 80 : 75;
  std::string line(line_width, ' ');
  line += '\n';
  cpp_write_mat_number(line, mat);
  cpp_write_mf_number(line, mf);
  cpp_write_mt_number(line, mt);
  if (write_opts.include_linenum) {
    cpp_write_line_number(line, (linenum % 99999)+1);
  }
  linenum++;
  return line;
}


void normalize_exponent(std::string& numstr) {
  size_t strsize = numstr.size();
  size_t zerostart = std::string::npos;
  size_t exp_pos = numstr.find("e");
  if (exp_pos == std::string::npos) {
    throw std::runtime_error("`e` character not found");
  }
  size_t expnum_start = exp_pos+2;
  for (int i=expnum_start; i < strsize; i++) {
    if (numstr[i] != '0') {
      numstr.erase(expnum_start, i-expnum_start);
      return;
    } else if (i+1 == strsize) {
      numstr.erase(expnum_start, i-expnum_start);
      return;
    }
  }
}


std::string get_scientific_numstr(double value, int precision, bool abuse_signpos) {
  std::ostringstream oss;
  oss << std::scientific << std::setprecision(precision) << value;
  std::string numstr = oss.str();
  normalize_exponent(numstr);
  if (! abuse_signpos && value >= 0) {
    numstr.insert(0, " ");
  }
  return numstr;
}


std::string float2endfstr_helper(double value, size_t width, WritingOptions &write_opts)
{
  std::string numstr = get_scientific_numstr(value, 6, write_opts.abuse_signpos);
  // re-calculate precision to match width specification
  size_t prec = 6 - (numstr.size() - width);
  numstr = get_scientific_numstr(value, prec, write_opts.abuse_signpos);
  // in rare cases, we may still be off the desired width due to
  // situations like 9.9999e-10 vs 1.000e-9
  if (numstr.size() < width) {
    std::string old_numstr;
    do {
      old_numstr = numstr;
      numstr = get_scientific_numstr(value, ++prec, write_opts.abuse_signpos);
    } while (numstr.size() <= width);
    numstr = old_numstr;
    if (numstr.size() < width) {
      numstr.insert(0, " ");
    }
  } else if (numstr.size() > width) {
    do {
      numstr = get_scientific_numstr(value, --prec, write_opts.abuse_signpos);
    } while (numstr.size() > width);
  }
  return numstr;
}


std::string float2endfstr_decimal_helper(
  double value, int width, WritingOptions &write_opts
) {
  std::stringstream ss;
  std::string numstr;
  int commapos;
  ss << std::fixed << std::setprecision(16) << value;
  numstr = ss.str();
  commapos = numstr.find('.');
  if (commapos == std::string::npos) {
    throw std::runtime_error("error occured while converting float to string");
  }
  bool is_intzero_case = (
    write_opts.skip_intzero && static_cast<int>(value) == 0
  );
  int prec = width - commapos - 1;
  if (value >= 0 && ! write_opts.abuse_signpos) {
    prec--;
  }
  if (is_intzero_case) {
    prec++;
  }
  if (prec < 0) {
    prec = 0;
  }
  std::stringstream ss2;
  ss2 << std::fixed << std::setprecision(prec) << value;
  // strip insignificant trailing zeros for compatibility with Python output
  std::string sout = ss2.str();
  commapos = numstr.find('.');
  if (commapos != std::string::npos) {
    int last_nonzero_pos = sout.substr(commapos).find_last_not_of('0');
    sout.erase(commapos + last_nonzero_pos + 1);
    if (sout.back() == '.') {
      sout.pop_back();
    } else if (is_intzero_case) {
      // strip unnecessary integer zero
      if (numstr[commapos-1] != '0') {
        throw std::runtime_error("integer zero matching failed");
      }
      sout.erase(commapos-1, 1);
    }
  }
  if (! write_opts.abuse_signpos && value >= 0) {
    sout.insert(0, " ");
  }
  // right-adjust the number
  std::ostringstream oss3;
  oss3 << std::right << std::setw(width) << sout;
  return oss3.str();
}


std::string float2endfstr(double value, WritingOptions &write_opts) {
  std::ostringstream oss;
  std::string numstr;
  int width = 11;
  int effwidth = width;
  if (! write_opts.keep_E) {
      effwidth++;
  }
  numstr = float2endfstr_helper(
    value, effwidth, write_opts
  );
  if (write_opts.prefer_noexp) {
    std::string numstr_noexp = float2endfstr_decimal_helper(
      value, width, write_opts
    );
    if (numstr_noexp.size() <= width) {
      double recon_value = std::stod(numstr);
      double recon_value_noexp = std::stod(numstr_noexp);
      double recon_value_diff = std::abs(recon_value - value);
      double recon_value_reldiff = recon_value_diff / (std::abs(value)+1e-12);
      double recon_value_noexp_diff = std::abs(recon_value_noexp - value);
      double recon_value_noexp_reldiff =  recon_value_noexp_diff / (std::abs(value)+1e-12);
      if (recon_value_reldiff >= recon_value_noexp_reldiff) {
          return numstr_noexp;
      }
    }
  }
  // delete exp character if demanded
  if (! write_opts.keep_E) {
    size_t exp_pos = numstr.find('e');
    numstr.erase(exp_pos, 1);
  }
  return numstr;
}


std::string int2endfstr(int value) {
  std::ostringstream oss;
  oss << std::right << std::setw(11) << value;
  return oss.str();
}


void field_size_check(const std::string& field) {
  if (field.size() != 11) {
    throw std::runtime_error(
      std::string("wrong size")
      + std::to_string(field.size())
      + std::string("  ") + field
    );
  }
}


// value is float case
void cpp_write_field_double(
  std::string& line, const char fieldnum, const double& value,
  WritingOptions& write_opts
) {
  std::string fieldstr = float2endfstr(value, write_opts);
  field_size_check(fieldstr);
  line.replace(fieldnum*11, 11, fieldstr);
}


// value is EndfFloatCpp case
void cpp_write_field_EndfFloatCpp(
  std::string& line, const char fieldnum, const EndfFloatCpp& value,
  WritingOptions& write_opts
) {
  std::string fieldstr;
  std::string orig_str = value.get_original_string();
  if (orig_str.empty() || !write_opts.preserve_value_strings) {
    fieldstr = float2endfstr(value, write_opts);
  } else {
    fieldstr = orig_str;
  }
  field_size_check(fieldstr);
  line.replace(fieldnum*11, 11, fieldstr);
}


// value is int case
void cpp_write_field_int(
  std::string& line, const char fieldnum, const int& value,
  WritingOptions& write_opts
) {
  std::string fieldstr = int2endfstr(value);
  line.replace(fieldnum*11, 11, fieldstr);
}


// templated cpp_write_field
template<typename T>
 void cpp_write_field(
  std::string& line, const char fieldnum, const T& value,
  WritingOptions& write_opts
) {
  static_assert(
    std::is_same<T, double>::value
    || std::is_same<T, EndfFloatCpp>::value
    || std::is_same<T, int>::value
    , "T must be int, double or EndfFloatCpp"
  );
  if (std::is_same<T, double>::value) {
    return cpp_write_field_double(line, fieldnum, value, write_opts);
  } else if (std::is_same<T, EndfFloatCpp>::value) {
    return cpp_write_field_EndfFloatCpp(line, fieldnum, value, write_opts);
  } else {
    return cpp_write_field_int(line, fieldnum, value, write_opts);
  }
}


void write_tab1_body(
  std::string& line, Tab1Body tab_body, int mat, int mf, int mt, int& linenum, WritingOptions &write_opts
) {
  assert(tab_body.INT.size() == tab_body.NBT.size() && "INT and NBT must have same size");
  assert(tab_body.X.size() == tab_body.Y.size() && "X and Y must have same size");
  int nr = tab_body.INT.size();
  int np = tab_body.X.size();
  std::ostringstream oss;
  std::string curline = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  int j = 0;
  for (int i=0; i < nr; i++) {
    cpp_write_field(curline, j++, tab_body.NBT[i], write_opts);
    cpp_write_field(curline, j++, tab_body.INT[i], write_opts);
    if (j > 5 && i+1 < nr) {
      oss << curline;
      curline = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      j = 0;
    }
  }
  oss << curline;

  j = 0;
  curline = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  for (int i=0; i < np; i++) {
    cpp_write_field(curline, j++, tab_body.X[i], write_opts);
    cpp_write_field(curline, j++, tab_body.Y[i], write_opts);
    if (j > 5 && i+1 < np) {
      oss << curline;
      curline = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      j = 0;
    }
  }
  oss << curline;
  line = oss.str();
}


void write_tab2_body(
  std::string& line, Tab2Body tab_body, int mat, int mf, int mt, int& linenum, WritingOptions &write_opts
) {
  assert(tab_body.INT.size() == tab_body.NBT.size() && "INT and NBT must have same size");
  int nr = tab_body.INT.size();
  std::ostringstream oss;
  std::string curline = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  int j = 0;
  for (int i=0; i < nr; i++) {
    cpp_write_field(curline, j++, tab_body.NBT[i], write_opts);
    cpp_write_field(curline, j++, tab_body.INT[i], write_opts);
    if (j > 5 && i+1 < nr) {
      oss << curline;
      curline = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      j = 0;
    }
  }
  oss << curline;
  line = oss.str();
}


std::string cpp_prepare_send(
  int mat, int mf, WritingOptions &write_opts, bool newline=true) {
  int line_width = (write_opts.include_linenum) ? 80 : 75;
  std::string line(line_width, ' ');
  if (newline) {
      line += '\n';
  }
  cpp_write_mat_number(line, mat);
  cpp_write_mf_number(line, mf);
  cpp_write_mt_number(line, 0);
  cpp_write_field<DOUBLE_TYPE>(line, 0, 0.0, write_opts);
  cpp_write_field<DOUBLE_TYPE>(line, 1, 0.0, write_opts);
  cpp_write_field<int>(line, 2, 0, write_opts);
  cpp_write_field<int>(line, 3, 0, write_opts);
  cpp_write_field<int>(line, 4, 0, write_opts);
  cpp_write_field<int>(line, 5, 0, write_opts);
  if (write_opts.include_linenum) {
    if (mf == 0) {
      // for writing FEND/MEND/TEND record
      cpp_write_line_number(line, 0);
    } else {
      cpp_write_line_number(line, 99999);
    }
  }
  return line;
}


int get_mat_from_mfmt_section(py::object mfmt_section) {
  int mat;
  if (py::isinstance<py::dict>(mfmt_section)) {
    py::dict mfmt_section_dict = py::cast<py::dict>(mfmt_section);
    mat = py::cast<int>(mfmt_section_dict["MAT"]);
    return mat;
  }
  if (! py::isinstance<py::list>(mfmt_section)) {
    throw std::runtime_error(
      "expect section to be represented by `list` or `dict`"
    );
  }
  py::list mfmt_section_list = py::cast<py::list>(mfmt_section);
  if (mfmt_section_list.size() == 0) {
    throw std::runtime_error("list representing section is empty");
  }
  std::string first_line = py::cast<std::string>(mfmt_section_list[0]);
  std::string matstr = first_line.substr(66, 4);
  mat = std::stoi(matstr);
  return mat;
}


void write_section_verbatim(
  std::ostream& oss, py::list mfmt_section, WritingOptions &write_opts
) {
  if (mfmt_section.size() == 0) {
    throw std::runtime_error("an MF/MT section must not be represented by an empty list");
  }
  std::string first_line = py::cast<std::string>(mfmt_section[0]);
  int mat = cpp_read_mat_number(first_line.c_str());
  int mf = cpp_read_mf_number(first_line.c_str());
  int mt = cpp_read_mt_number(first_line.c_str());
  int linenum = (mf != 0) ? 1 : 0;  // linenum starts at 0 for tape head
  for (const auto& item : mfmt_section) {
    std::string linestr = py::cast<std::string>(item);
    if (write_opts.include_linenum) {
      linestr.resize(80);
      cpp_write_line_number(linestr, linenum++);
    } else {
      linestr.erase(75, std::string::npos);
    }
    if (linestr.back() != '\n') {
      linestr.push_back('\n');
    }
    oss << linestr;
  }
  if (mf != 0) {
      std::string send_line = cpp_prepare_send(mat, mf, write_opts);
      oss << send_line;
  }
}

#endif // MODULE_HEADER_WRITING_HPP

enum vartype {
  MATRIX2D_DOUBLE,
  MATRIX2D_FLOATVEC,
  MATRIX2D_INT,
  MATRIX2D_INTVEC,
  MATRIX2D_STRING,
  NESTEDVECTOR_DOUBLE,
  NESTEDVECTOR_FLOATVEC,
  NESTEDVECTOR_INT,
  NESTEDVECTOR_INTVEC,
  NESTEDVECTOR_STRING,
  SCALAR_DOUBLE,
  SCALAR_FLOATVEC,
  SCALAR_INT,
  SCALAR_INTVEC,
  SCALAR_STRING,
  UNKNOWN
};

std::string vartype2str(vartype vt) {
    switch (vt) {
        case MATRIX2D_DOUBLE:  return "MATRIX2D_DOUBLE";
        case MATRIX2D_INT:  return "MATRIX2D_INT";
        case MATRIX2D_STRING:  return "MATRIX2D_STRING";
        case MATRIX2D_INTVEC:  return "MATRIX2D_INTVEC";
        case MATRIX2D_FLOATVEC:  return "MATRIX2D_FLOATVEC";
        case NESTEDVECTOR_DOUBLE:  return "NESTEDVECTOR_DOUBLE";
        case NESTEDVECTOR_INT:  return "NESTEDVECTOR_INT";
        case NESTEDVECTOR_STRING:  return "NESTEDVECTOR_STRING";
        case NESTEDVECTOR_INTVEC:  return "NESTEDVECTOR_INTVEC";
        case NESTEDVECTOR_FLOATVEC:  return "NESTEDVECTOR_FLOATVEC";
        case SCALAR_DOUBLE:  return "SCALAR_DOUBLE";
        case SCALAR_INT:  return "SCALAR_INT";
        case SCALAR_STRING:  return "SCALAR_STRING";
        case SCALAR_INTVEC:  return "SCALAR_INTVEC";
        case SCALAR_FLOATVEC:  return "SCALAR_FLOATVEC";
    }
    throw std::runtime_error("should not arrivere here");
    return "should not arrive here";
}


void validate_vartype_consistency(std::string varname, vartype current_type, vartype expected_type) {
  if (current_type != expected_type && expected_type != UNKNOWN) {
    std::string current_type_str = vartype2str(current_type);
    std::string expected_type_str = vartype2str(expected_type);
    std::stringstream errmsg;
    errmsg << "variable `" << varname << "` is now encountered "
          << "with type `" << current_type_str << "` but was "
          << "previously encountered with type `" << expected_type_str << ". "
          << "Either the ENDF recipe is wrongly specified or the ENDF file "
          << "contains some forbidden flag values." << std::endl;
    throw std::runtime_error(errmsg.str());
  }
}

template<typename T>
class Matrix2d {

  private:
    std::vector<T> data;
    size_t num_rows;
    size_t num_cols;
    size_t row_start;
    size_t col_start;
    bool initialized;
    bool accessed;
    bool triagonal;
    bool lower;

  public:

    Matrix2d() : initialized(false), accessed(false),
                 triagonal(false), lower(false) {};

    void init(size_t first_row_idx, size_t last_row_idx,
              size_t first_col_idx, size_t last_col_idx,
              bool triagonal=false, bool lower=false) {
      this->num_rows = last_row_idx - first_row_idx + 1;
      this->num_cols = last_col_idx - first_col_idx + 1;
      this->row_start = first_row_idx;
      this->col_start = first_col_idx;
      this->data.resize(this->num_rows * this->num_cols);
      this->initialized = true;
      this->triagonal = triagonal;
      this->lower = lower;
    }

    bool is_initialized() {
      return initialized;
    }

    bool did_read() {
      return accessed;
    }

    T& operator()(size_t i, size_t j) {
      accessed = true;
      return data.at((i-row_start)*num_cols + (j-col_start));
    }

    int get_row_start_index() const {
      return row_start;
    }

    int get_row_last_index() const {
      return row_start + num_rows - 1;
    }

    int get_col_start_index() const {
      return col_start;
    }

    int get_col_start_index(int i) const {
      if (! triagonal || lower) {
        return col_start;
      } else {
        return col_start + (i - row_start);
      }
    }

    int get_col_last_index() const {
      return col_start + num_cols - 1;
    }

    int get_col_last_index(int i) {
      if (! triagonal || ! lower) {
        return col_start + num_cols - 1;
      } else {
        return col_start + (i - row_start);
      }
    }

    py::object to_pyobj(bool list_mode) {
      if (list_mode) {
        py::list ret;
        int rsidx = get_row_start_index();
        int rfidx = get_row_last_index();
        for (int i=rsidx; i <= rfidx; ++i) {
          py::list row_list;
          int csidx = get_col_start_index(i);
          int cfidx = get_col_last_index(i);
          for (int j=csidx; j <= cfidx; ++j) {
            row_list.append(Matrix2d::operator()(i, j));
          }
          ret.append(row_list);
        }
        return ret;
      } else {
        py::dict ret;
        int rsidx = get_row_start_index();
        int rfidx = get_row_last_index();
        for (int i=rsidx; i <= rfidx; ++i) {
          py::dict row_dict;
          int csidx = get_col_start_index(i);
          int cfidx = get_col_last_index(i);
          for (int j=csidx; j <= cfidx; ++j) {
            row_dict[py::cast(j)] = Matrix2d::operator()(i, j);
          }
          ret[py::cast(i)] = row_dict;
        }
        return ret;
      }
    }
};

template<typename T>
class NestedVector : public std::vector<T> {
  private:
    int startIndex;
    int lastIndex;

  public:
    // default constructor
    NestedVector() : startIndex(0), lastIndex(-1) {}

    // copy constructor
    NestedVector(const NestedVector<T>& other) :
      std::vector<T>(other), startIndex(other.startIndex),
      lastIndex(other.lastIndex) {}

    // assignment constructor
    NestedVector<T>& operator=(const NestedVector<T>& other) {
      if (this != &other) {
        std::vector<T>::operator=(other);
        startIndex = other.startIndex;
        lastIndex = other.lastIndex;
      }
      return *this;
    }

    void set_start_index(int start) {
      this->startIndex = start;
    }

    int get_start_index() const {
      return this->startIndex;
    }

    void set_last_index(int lastIndex) {
      this->lastIndex = lastIndex;
    }

    int get_last_index() const {
      return this->lastIndex;
    }

    T& operator[](int index) {
      if (! contains(index)) {
        throw std::out_of_range("index out of range 1");
      }
      return std::vector<T>::operator[](index - startIndex);
    }

    T& at(int index) {
      return std::vector<T>::at(index - startIndex);
    }

    T* prepare(int index) {
      if (contains(index)) return &((*this)[index]);
      T cpp_curel;
      set(index, cpp_curel);
      return &(*this)[index];
    }

    void set(int index, const T& value) {
      bool is_first = false;
      if (this->lastIndex == -1) {
        this->startIndex = index;
        this->lastIndex = index;
        is_first = true;
      }
      if (index == startIndex + (int)this->size()) {
        std::vector<T>::push_back(value);
        if (! is_first) {
          this->lastIndex++;
        }
      } else if (index >= startIndex && index < startIndex + (int)this->size())  {
        std::vector<T>::operator[](index - startIndex) = value;
      } else {
        throw std::out_of_range("index out of range 2");
      }
    }

    bool contains(int index) {
      return (this->startIndex <= index && index <= this->lastIndex);
    }

    py::object to_pyobj(bool list_mode) {
      if (list_mode) {
        py::list ret;
        to_pylist(ret, (*this));
        return ret;
      } else {
        py::dict ret;
        to_pydict(ret, (*this));
        return ret;
      }
    }

    template <typename U>
    void to_pylist(py::list cur, const NestedVector<NestedVector<U>>& curvec) {
      for (const auto& elem : curvec) {
        py::list sublist;
        to_pylist(sublist, elem);
        cur.append(sublist);
      }
    }

    template <typename U>
    void to_pylist(py::list cur, const NestedVector<U>& curvec) {
      for (const auto& elem : curvec) {
          cur.append(py::cast(elem));
      }
    }

    template <typename U>
    void to_pydict(py::dict cur, const NestedVector<NestedVector<U>>& curvec) {
      int cnt = curvec.get_start_index();
      for (const auto& elem : curvec) {
        py::dict subdict;
        to_pydict(subdict, elem);
        cur[py::cast(cnt++)] = subdict;
      }
    }

    template <typename U>
    void to_pydict(py::dict cur, const NestedVector<U>& curvec) {
      int cnt = curvec.get_start_index();
      for (const auto& elem : curvec) {
        cur[py::cast(cnt++)] = py::cast(elem);
      }
    }

};


// MD5 hash of ENDF recipe underlying the following function: a38e6e76968fb4463ab67282d5c7f80d
// MD5 hash of the following function definition: 86632c4e57f453e615c07e60c802d408
py::dict parse_mf0mt0_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  std::string var_TAPEDESCR_0d_string_Scalar;
  bool aux_TAPEDESCR_read = false;
  vartype aux_last_type_read_for_TAPEDESCR = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 0;
  int mt = 0;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 0;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 0;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 0 , 0 / TAPEDESCR ] TEXT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // assign expression to variable TAPEDESCR
  var_TAPEDESCR_0d_string_Scalar = cpp_line.substr(0, 66);
  aux_TAPEDESCR_read = true;
  validate_vartype_consistency("TAPEDESCR", SCALAR_STRING, aux_last_type_read_for_TAPEDESCR);
  aux_last_type_read_for_TAPEDESCR = SCALAR_STRING;
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_TAPEDESCR == SCALAR_STRING) && (aux_TAPEDESCR_read == true))) {
    cpp_current_dict["TAPEDESCR"] = var_TAPEDESCR_0d_string_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 58de2de2b82537497333c5e7a5bc310c
// MD5 hash of the following function definition: 54897077156bcffe8ee2ac83216279cf
py::dict parse_mf1mt451_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LRP_0d_int_Scalar;
  bool aux_LRP_read = false;
  vartype aux_last_type_read_for_LRP = UNKNOWN;
  int var_LFI_0d_int_Scalar;
  bool aux_LFI_read = false;
  vartype aux_last_type_read_for_LFI = UNKNOWN;
  int var_NLIB_0d_int_Scalar;
  bool aux_NLIB_read = false;
  vartype aux_last_type_read_for_NLIB = UNKNOWN;
  int var_NMOD_0d_int_Scalar;
  bool aux_NMOD_read = false;
  vartype aux_last_type_read_for_NMOD = UNKNOWN;
  EndfFloatCpp var_ELIS_0d_double_Scalar;
  bool aux_ELIS_read = false;
  vartype aux_last_type_read_for_ELIS = UNKNOWN;
  EndfFloatCpp var_STA_0d_double_Scalar;
  bool aux_STA_read = false;
  vartype aux_last_type_read_for_STA = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_LISO_0d_int_Scalar;
  bool aux_LISO_read = false;
  vartype aux_last_type_read_for_LISO = UNKNOWN;
  int var_NFOR_0d_int_Scalar;
  bool aux_NFOR_read = false;
  vartype aux_last_type_read_for_NFOR = UNKNOWN;
  EndfFloatCpp var_AWI_0d_double_Scalar;
  bool aux_AWI_read = false;
  vartype aux_last_type_read_for_AWI = UNKNOWN;
  EndfFloatCpp var_EMAX_0d_double_Scalar;
  bool aux_EMAX_read = false;
  vartype aux_last_type_read_for_EMAX = UNKNOWN;
  int var_LREL_0d_int_Scalar;
  bool aux_LREL_read = false;
  vartype aux_last_type_read_for_LREL = UNKNOWN;
  int var_NSUB_0d_int_Scalar;
  bool aux_NSUB_read = false;
  vartype aux_last_type_read_for_NSUB = UNKNOWN;
  int var_NVER_0d_int_Scalar;
  bool aux_NVER_read = false;
  vartype aux_last_type_read_for_NVER = UNKNOWN;
  EndfFloatCpp var_TEMP_0d_double_Scalar;
  bool aux_TEMP_read = false;
  vartype aux_last_type_read_for_TEMP = UNKNOWN;
  int var_LDRV_0d_int_Scalar;
  bool aux_LDRV_read = false;
  vartype aux_last_type_read_for_LDRV = UNKNOWN;
  int var_NWD_0d_int_Scalar;
  bool aux_NWD_read = false;
  vartype aux_last_type_read_for_NWD = UNKNOWN;
  int var_NXC_0d_int_Scalar;
  bool aux_NXC_read = false;
  vartype aux_last_type_read_for_NXC = UNKNOWN;
  std::string var_ZSYMAM_0d_string_Scalar;
  bool aux_ZSYMAM_read = false;
  vartype aux_last_type_read_for_ZSYMAM = UNKNOWN;
  std::string var_ALAB_0d_string_Scalar;
  bool aux_ALAB_read = false;
  vartype aux_last_type_read_for_ALAB = UNKNOWN;
  std::string var_EDATE_0d_string_Scalar;
  bool aux_EDATE_read = false;
  vartype aux_last_type_read_for_EDATE = UNKNOWN;
  std::string var_AUTH_0d_string_Scalar;
  bool aux_AUTH_read = false;
  vartype aux_last_type_read_for_AUTH = UNKNOWN;
  std::string var_REF_0d_string_Scalar;
  bool aux_REF_read = false;
  vartype aux_last_type_read_for_REF = UNKNOWN;
  std::string var_DDATE_0d_string_Scalar;
  bool aux_DDATE_read = false;
  vartype aux_last_type_read_for_DDATE = UNKNOWN;
  std::string var_RDATE_0d_string_Scalar;
  bool aux_RDATE_read = false;
  vartype aux_last_type_read_for_RDATE = UNKNOWN;
  std::string var_ENDATE_0d_string_Scalar;
  bool aux_ENDATE_read = false;
  vartype aux_last_type_read_for_ENDATE = UNKNOWN;
  NestedVector<std::string> var_HSUB_1d_string_NestedVector;
  vartype aux_last_type_read_for_HSUB = UNKNOWN;
  NestedVector<std::string> var_DESCRIPTION_1d_string_NestedVector;
  vartype aux_last_type_read_for_DESCRIPTION = UNKNOWN;
  NestedVector<int> var_MFx_1d_int_NestedVector;
  vartype aux_last_type_read_for_MFx = UNKNOWN;
  NestedVector<int> var_MTx_1d_int_NestedVector;
  vartype aux_last_type_read_for_MTx = UNKNOWN;
  NestedVector<int> var_NCx_1d_int_NestedVector;
  vartype aux_last_type_read_for_NCx = UNKNOWN;
  NestedVector<int> var_MOD_1d_int_NestedVector;
  vartype aux_last_type_read_for_MOD = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 1;
  int mt = 451;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 451;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 1 , 451 / ZA , AWR , LRP , LFI , NLIB , NMOD ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LRP
  var_LRP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LRP_read = true;
  validate_vartype_consistency("LRP", SCALAR_INT, aux_last_type_read_for_LRP);
  aux_last_type_read_for_LRP = SCALAR_INT;
  // assign expression to variable LFI
  var_LFI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LFI_read = true;
  validate_vartype_consistency("LFI", SCALAR_INT, aux_last_type_read_for_LFI);
  aux_last_type_read_for_LFI = SCALAR_INT;
  // assign expression to variable NLIB
  var_NLIB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NLIB_read = true;
  validate_vartype_consistency("NLIB", SCALAR_INT, aux_last_type_read_for_NLIB);
  aux_last_type_read_for_NLIB = SCALAR_INT;
  // assign expression to variable NMOD
  var_NMOD_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NMOD_read = true;
  validate_vartype_consistency("NMOD", SCALAR_INT, aux_last_type_read_for_NMOD);
  aux_last_type_read_for_NMOD = SCALAR_INT;
  cpp_template = "[ MAT , 1 , 451 / ELIS , STA , LIS , LISO , 0 , NFOR ] CONT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ELIS
  var_ELIS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ELIS_read = true;
  validate_vartype_consistency("ELIS", SCALAR_DOUBLE, aux_last_type_read_for_ELIS);
  aux_last_type_read_for_ELIS = SCALAR_DOUBLE;
  // assign expression to variable STA
  var_STA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_STA_read = true;
  validate_vartype_consistency("STA", SCALAR_DOUBLE, aux_last_type_read_for_STA);
  aux_last_type_read_for_STA = SCALAR_DOUBLE;
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  // assign expression to variable LISO
  var_LISO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LISO_read = true;
  validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
  aux_last_type_read_for_LISO = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NFOR
  var_NFOR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NFOR_read = true;
  validate_vartype_consistency("NFOR", SCALAR_INT, aux_last_type_read_for_NFOR);
  aux_last_type_read_for_NFOR = SCALAR_INT;
  cpp_template = "[ MAT , 1 , 451 / AWI , EMAX , LREL , 0 , NSUB , NVER ] CONT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable AWI
  var_AWI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_AWI_read = true;
  validate_vartype_consistency("AWI", SCALAR_DOUBLE, aux_last_type_read_for_AWI);
  aux_last_type_read_for_AWI = SCALAR_DOUBLE;
  // assign expression to variable EMAX
  var_EMAX_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_EMAX_read = true;
  validate_vartype_consistency("EMAX", SCALAR_DOUBLE, aux_last_type_read_for_EMAX);
  aux_last_type_read_for_EMAX = SCALAR_DOUBLE;
  // assign expression to variable LREL
  var_LREL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LREL_read = true;
  validate_vartype_consistency("LREL", SCALAR_INT, aux_last_type_read_for_LREL);
  aux_last_type_read_for_LREL = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NSUB
  var_NSUB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NSUB_read = true;
  validate_vartype_consistency("NSUB", SCALAR_INT, aux_last_type_read_for_NSUB);
  aux_last_type_read_for_NSUB = SCALAR_INT;
  // assign expression to variable NVER
  var_NVER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NVER_read = true;
  validate_vartype_consistency("NVER", SCALAR_INT, aux_last_type_read_for_NVER);
  aux_last_type_read_for_NVER = SCALAR_INT;
  cpp_template = "[ MAT , 1 , 451 / TEMP , 0.0 , LDRV , 0 , NWD , NXC ] CONT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable TEMP
  var_TEMP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_TEMP_read = true;
  validate_vartype_consistency("TEMP", SCALAR_DOUBLE, aux_last_type_read_for_TEMP);
  aux_last_type_read_for_TEMP = SCALAR_DOUBLE;
  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LDRV
  var_LDRV_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LDRV_read = true;
  validate_vartype_consistency("LDRV", SCALAR_INT, aux_last_type_read_for_LDRV);
  aux_last_type_read_for_LDRV = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NWD
  var_NWD_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NWD_read = true;
  validate_vartype_consistency("NWD", SCALAR_INT, aux_last_type_read_for_NWD);
  aux_last_type_read_for_NWD = SCALAR_INT;
  // assign expression to variable NXC
  var_NXC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NXC_read = true;
  validate_vartype_consistency("NXC", SCALAR_INT, aux_last_type_read_for_NXC);
  aux_last_type_read_for_NXC = SCALAR_INT;
  cpp_template = "[ MAT , 1 , 451 / ZSYMAM { 11 } , ALAB { 11 } , EDATE { 10 } , { 1 } , AUTH { 33 } ] TEXT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // assign expression to variable ZSYMAM
  var_ZSYMAM_0d_string_Scalar = cpp_line.substr(0, 11);
  aux_ZSYMAM_read = true;
  validate_vartype_consistency("ZSYMAM", SCALAR_STRING, aux_last_type_read_for_ZSYMAM);
  aux_last_type_read_for_ZSYMAM = SCALAR_STRING;
  // assign expression to variable ALAB
  var_ALAB_0d_string_Scalar = cpp_line.substr(11, 11);
  aux_ALAB_read = true;
  validate_vartype_consistency("ALAB", SCALAR_STRING, aux_last_type_read_for_ALAB);
  aux_last_type_read_for_ALAB = SCALAR_STRING;
  // assign expression to variable EDATE
  var_EDATE_0d_string_Scalar = cpp_line.substr(22, 10);
  aux_EDATE_read = true;
  validate_vartype_consistency("EDATE", SCALAR_STRING, aux_last_type_read_for_EDATE);
  aux_last_type_read_for_EDATE = SCALAR_STRING;
  // assign expression to variable AUTH
  var_AUTH_0d_string_Scalar = cpp_line.substr(33, 33);
  aux_AUTH_read = true;
  validate_vartype_consistency("AUTH", SCALAR_STRING, aux_last_type_read_for_AUTH);
  aux_last_type_read_for_AUTH = SCALAR_STRING;
  cpp_template = "[ MAT , 1 , 451 / { 1 } , REF { 21 } , DDATE { 10 } , { 1 } , \n RDATE { 10 } , { 12 } , ENDATE { 8 } , { 3 } ] TEXT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // assign expression to variable REF
  var_REF_0d_string_Scalar = cpp_line.substr(1, 21);
  aux_REF_read = true;
  validate_vartype_consistency("REF", SCALAR_STRING, aux_last_type_read_for_REF);
  aux_last_type_read_for_REF = SCALAR_STRING;
  // assign expression to variable DDATE
  var_DDATE_0d_string_Scalar = cpp_line.substr(22, 10);
  aux_DDATE_read = true;
  validate_vartype_consistency("DDATE", SCALAR_STRING, aux_last_type_read_for_DDATE);
  aux_last_type_read_for_DDATE = SCALAR_STRING;
  // assign expression to variable RDATE
  var_RDATE_0d_string_Scalar = cpp_line.substr(33, 10);
  aux_RDATE_read = true;
  validate_vartype_consistency("RDATE", SCALAR_STRING, aux_last_type_read_for_RDATE);
  aux_last_type_read_for_RDATE = SCALAR_STRING;
  // assign expression to variable ENDATE
  var_ENDATE_0d_string_Scalar = cpp_line.substr(55, 8);
  aux_ENDATE_read = true;
  validate_vartype_consistency("ENDATE", SCALAR_STRING, aux_last_type_read_for_ENDATE);
  aux_last_type_read_for_ENDATE = SCALAR_STRING;

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= 3; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 1 , 451 / HSUB [ i ] ] TEXT";
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // assign expression to variable HSUB
    var_HSUB_1d_string_NestedVector.set(var_i_0d_int_Scalar, cpp_line.substr(0, 66));
    validate_vartype_consistency("HSUB", NESTEDVECTOR_STRING, aux_last_type_read_for_HSUB);
    aux_last_type_read_for_HSUB = NESTEDVECTOR_STRING;
  }

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= (var_NWD_0d_int_Scalar-5); var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 1 , 451 / DESCRIPTION [ i ] ] TEXT";
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // assign expression to variable DESCRIPTION
    var_DESCRIPTION_1d_string_NestedVector.set(var_i_0d_int_Scalar, cpp_line.substr(0, 66));
    validate_vartype_consistency("DESCRIPTION", NESTEDVECTOR_STRING, aux_last_type_read_for_DESCRIPTION);
    aux_last_type_read_for_DESCRIPTION = NESTEDVECTOR_STRING;
  }

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NXC_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 1 , 451 / blank , blank , MFx , MTx , NCx , MOD ] DIR";
    // read TEXT record
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // assign expression to variable MFx
    var_MFx_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
    validate_vartype_consistency("MFx", NESTEDVECTOR_INT, aux_last_type_read_for_MFx);
    aux_last_type_read_for_MFx = NESTEDVECTOR_INT;
    // assign expression to variable MTx
    var_MTx_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
    validate_vartype_consistency("MTx", NESTEDVECTOR_INT, aux_last_type_read_for_MTx);
    aux_last_type_read_for_MTx = NESTEDVECTOR_INT;
    // assign expression to variable NCx
    var_NCx_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
    validate_vartype_consistency("NCx", NESTEDVECTOR_INT, aux_last_type_read_for_NCx);
    aux_last_type_read_for_NCx = NESTEDVECTOR_INT;
    // assign expression to variable MOD
    var_MOD_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
    validate_vartype_consistency("MOD", NESTEDVECTOR_INT, aux_last_type_read_for_MOD);
    aux_last_type_read_for_MOD = NESTEDVECTOR_INT;
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LRP == SCALAR_INT) && (aux_LRP_read == true))) {
    cpp_current_dict["LRP"] = var_LRP_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LFI == SCALAR_INT) && (aux_LFI_read == true))) {
    cpp_current_dict["LFI"] = var_LFI_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NLIB == SCALAR_INT) && (aux_NLIB_read == true))) {
    cpp_current_dict["NLIB"] = var_NLIB_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NMOD == SCALAR_INT) && (aux_NMOD_read == true))) {
    cpp_current_dict["NMOD"] = var_NMOD_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ELIS == SCALAR_DOUBLE) && (aux_ELIS_read == true))) {
    cpp_current_dict["ELIS"] = var_ELIS_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_STA == SCALAR_DOUBLE) && (aux_STA_read == true))) {
    cpp_current_dict["STA"] = var_STA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LIS == SCALAR_INT) && (aux_LIS_read == true))) {
    cpp_current_dict["LIS"] = var_LIS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LISO == SCALAR_INT) && (aux_LISO_read == true))) {
    cpp_current_dict["LISO"] = var_LISO_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NFOR == SCALAR_INT) && (aux_NFOR_read == true))) {
    cpp_current_dict["NFOR"] = var_NFOR_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_AWI == SCALAR_DOUBLE) && (aux_AWI_read == true))) {
    cpp_current_dict["AWI"] = var_AWI_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_EMAX == SCALAR_DOUBLE) && (aux_EMAX_read == true))) {
    cpp_current_dict["EMAX"] = var_EMAX_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LREL == SCALAR_INT) && (aux_LREL_read == true))) {
    cpp_current_dict["LREL"] = var_LREL_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NSUB == SCALAR_INT) && (aux_NSUB_read == true))) {
    cpp_current_dict["NSUB"] = var_NSUB_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NVER == SCALAR_INT) && (aux_NVER_read == true))) {
    cpp_current_dict["NVER"] = var_NVER_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_TEMP == SCALAR_DOUBLE) && (aux_TEMP_read == true))) {
    cpp_current_dict["TEMP"] = var_TEMP_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LDRV == SCALAR_INT) && (aux_LDRV_read == true))) {
    cpp_current_dict["LDRV"] = var_LDRV_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NWD == SCALAR_INT) && (aux_NWD_read == true))) {
    cpp_current_dict["NWD"] = var_NWD_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NXC == SCALAR_INT) && (aux_NXC_read == true))) {
    cpp_current_dict["NXC"] = var_NXC_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZSYMAM == SCALAR_STRING) && (aux_ZSYMAM_read == true))) {
    cpp_current_dict["ZSYMAM"] = var_ZSYMAM_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_ALAB == SCALAR_STRING) && (aux_ALAB_read == true))) {
    cpp_current_dict["ALAB"] = var_ALAB_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_EDATE == SCALAR_STRING) && (aux_EDATE_read == true))) {
    cpp_current_dict["EDATE"] = var_EDATE_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_AUTH == SCALAR_STRING) && (aux_AUTH_read == true))) {
    cpp_current_dict["AUTH"] = var_AUTH_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_REF == SCALAR_STRING) && (aux_REF_read == true))) {
    cpp_current_dict["REF"] = var_REF_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_DDATE == SCALAR_STRING) && (aux_DDATE_read == true))) {
    cpp_current_dict["DDATE"] = var_DDATE_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_RDATE == SCALAR_STRING) && (aux_RDATE_read == true))) {
    cpp_current_dict["RDATE"] = var_RDATE_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_ENDATE == SCALAR_STRING) && (aux_ENDATE_read == true))) {
    cpp_current_dict["ENDATE"] = var_ENDATE_0d_string_Scalar;
  }
  if ((var_HSUB_1d_string_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["HSUB"] = var_HSUB_1d_string_NestedVector.to_pyobj(list_mode);
  }
  if ((var_DESCRIPTION_1d_string_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["DESCRIPTION"] = var_DESCRIPTION_1d_string_NestedVector.to_pyobj(list_mode);
  }
  if ((var_MFx_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["MFx"] = var_MFx_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_MTx_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["MTx"] = var_MTx_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_NCx_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["NCx"] = var_NCx_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_MOD_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["MOD"] = var_MOD_1d_int_NestedVector.to_pyobj(list_mode);
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 714e5d90ebe6fa41e07bef414c2ac8f4
// MD5 hash of the following function definition: 22727af1fc87a949dcebfb65413c9821
py::dict parse_mf1mt452_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LNU_0d_int_Scalar;
  bool aux_LNU_read = false;
  vartype aux_last_type_read_for_LNU = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  NestedVector<EndfFloatCpp> var_C_1d_double_NestedVector;
  vartype aux_last_type_read_for_C = UNKNOWN;
  std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<EndfFloatCpp> var_nu_0d_floatvec_Scalar;
  bool aux_nu_read = false;
  vartype aux_last_type_read_for_nu = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 1;
  int mt = 452;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 452;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 1 , 452 / ZA , AWR , 0 , LNU , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LNU
  var_LNU_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LNU_read = true;
  validate_vartype_consistency("LNU", SCALAR_INT, aux_last_type_read_for_LNU);
  aux_last_type_read_for_LNU = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 1 , 452 / 0.0 , 0.0 , 0 , 0 , NC , 0 / { C } { k = 1 to NC } ] LIST";
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        // read LIST record
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        // assign expression to variable NC
        var_NC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        aux_NC_read = true;
        validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
        aux_last_type_read_for_NC = SCALAR_INT;
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        {
          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          int cpp_i = 0;
          int cpp_j = 0;
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST body

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NC_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // read LIST body
            // assign expression to variable C
            var_C_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
            validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
            aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
          }
          if (cpp_i != cpp_npl) {
            throw std::runtime_error("not exactly NPL elements consumed");
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 452 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nu ] TAB1";
          // read TAB1 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          {
            Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Eint
            var_Eint_0d_floatvec_Scalar = tab_body.X;
            aux_Eint_read = true;
            validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
            aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
            // assign expression to variable nu
            var_nu_0d_floatvec_Scalar = tab_body.Y;
            aux_nu_read = true;
            validate_vartype_consistency("nu", SCALAR_FLOATVEC, aux_last_type_read_for_nu);
            aux_last_type_read_for_nu = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LNU == SCALAR_INT) && (aux_LNU_read == true))) {
    cpp_current_dict["LNU"] = var_LNU_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
    cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
  }
  if ((var_C_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["C"] = var_C_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
    cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_nu == SCALAR_FLOATVEC) && (aux_nu_read == true))) {
    cpp_current_dict["nu"] = var_nu_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 6372082f09eb7576770b456ddd80b3fb
// MD5 hash of the following function definition: 0c90cb39cfbf6d57f24439d4de87ef33
py::dict parse_mf1mt455_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LDG_0d_int_Scalar;
  bool aux_LDG_read = false;
  vartype aux_last_type_read_for_LDG = UNKNOWN;
  int var_LNU_0d_int_Scalar;
  bool aux_LNU_read = false;
  vartype aux_last_type_read_for_LNU = UNKNOWN;
  int var_NNF_0d_int_Scalar;
  bool aux_NNF_read = false;
  vartype aux_last_type_read_for_NNF = UNKNOWN;
  NestedVector<EndfFloatCpp> var_lambda_1d_double_NestedVector;
  vartype aux_last_type_read_for_lambda = UNKNOWN;
  std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<EndfFloatCpp> var_nubar_d_0d_floatvec_Scalar;
  EndfFloatCpp var_nubar_d_0d_double_Scalar;
  bool aux_nubar_d_read = false;
  vartype aux_last_type_read_for_nubar_d = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int var_NE_0d_int_Scalar;
  bool aux_NE_read = false;
  vartype aux_last_type_read_for_NE = UNKNOWN;
  NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_lambda_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_lambda_2d_idx0;
  NestedVector<NestedVector<EndfFloatCpp>> var_alpha_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_alpha_2d_idx0;
  vartype aux_last_type_read_for_alpha = UNKNOWN;
  EndfFloatCpp var_E1_0d_double_Scalar;
  bool aux_E1_read = false;
  vartype aux_last_type_read_for_E1 = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  NestedVector<EndfFloatCpp> var_nubar_d_1d_double_NestedVector;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 1;
  int mt = 455;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 455;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 1 , 455 / ZA , AWR , LDG , LNU , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LDG
  var_LDG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LDG_read = true;
  validate_vartype_consistency("LDG", SCALAR_INT, aux_last_type_read_for_LDG);
  aux_last_type_read_for_LDG = SCALAR_INT;
  // assign expression to variable LNU
  var_LNU_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LNU_read = true;
  validate_vartype_consistency("LNU", SCALAR_INT, aux_last_type_read_for_LNU);
  aux_last_type_read_for_LNU = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(0)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NNF , 0 / \n { lambda } { k = 1 to NNF } ] LIST";
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        // read LIST record
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        // assign expression to variable NNF
        var_NNF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        aux_NNF_read = true;
        validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
        aux_last_type_read_for_NNF = SCALAR_INT;
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        {
          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          int cpp_i = 0;
          int cpp_j = 0;
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST body

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // read LIST body
            // assign expression to variable lambda
            var_lambda_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
            validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
            aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
          }
          if (cpp_i != cpp_npl) {
            throw std::runtime_error("not exactly NPL elements consumed");
          }
        }
        cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nubar_d ] TAB1";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
        {
          Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
          // assign expression to variable Eint
          var_Eint_0d_floatvec_Scalar = tab_body.X;
          aux_Eint_read = true;
          validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
          aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
          // assign expression to variable nubar_d
          var_nubar_d_0d_floatvec_Scalar = tab_body.Y;
          aux_nubar_d_read = true;
          validate_vartype_consistency("nubar_d", SCALAR_FLOATVEC, aux_last_type_read_for_nubar_d);
          aux_last_type_read_for_nubar_d = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(1)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
          // read TAB2 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NE
          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NE_read = true;
          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
          aux_last_type_read_for_NE = SCALAR_INT;
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          {
            Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            cpp_template = "[ MAT , 1 , 455 / 0.0 , E , 0 , 0 , (NNF*2) , 0 / \n { lambda , alpha } { l = 1 to NNF } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable cpp_int_val
            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_cpp_int_val_read = true;
            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
            // assign expression to variable NNF
            var_NNF_0d_int_Scalar = (cpp_int_val/2);
            aux_NNF_read = true;
            validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
            aux_last_type_read_for_NNF = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body
              ptr_lambda_2d_idx0 = var_lambda_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
              ptr_alpha_2d_idx0 = var_alpha_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                // read LIST body
                // assign expression to variable lambda
                ptr_lambda_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
                aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable alpha
                ptr_alpha_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("alpha", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_alpha);
                aux_last_type_read_for_alpha = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
          }
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nubar_d ] TAB1";
          // read TAB1 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          {
            Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Eint
            var_Eint_0d_floatvec_Scalar = tab_body.X;
            aux_Eint_read = true;
            validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
            aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
            // assign expression to variable nubar_d
            var_nubar_d_0d_floatvec_Scalar = tab_body.Y;
            aux_nubar_d_read = true;
            validate_vartype_consistency("nubar_d", SCALAR_FLOATVEC, aux_last_type_read_for_nubar_d);
            aux_last_type_read_for_nubar_d = SCALAR_FLOATVEC;
            if ((! (aux_INT_read == true))) {
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
            } else {
              cpp_validate_field(var_INT_0d_intvec_Scalar, tab_body.INT,  true, false, false, "INT",
                cpp_template, cpp_line, parse_opts);
            }
            if ((! (aux_NBT_read == true))) {
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            } else {
              cpp_validate_field(var_NBT_0d_intvec_Scalar, tab_body.NBT,  true, false, false, "NBT",
                cpp_template, cpp_line, parse_opts);
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(0)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NNF , 0 / { lambda } { k = 1 to NNF } ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NNF
          var_NNF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NNF_read = true;
          validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
          aux_last_type_read_for_NNF = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              // assign expression to variable lambda
              var_lambda_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
              aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , 1 , 0 / nubar_d ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(1, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "1",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body
            // assign expression to variable nubar_d
            var_nubar_d_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_nubar_d_read = true;
            validate_vartype_consistency("nubar_d", SCALAR_DOUBLE, aux_last_type_read_for_nubar_d);
            aux_last_type_read_for_nubar_d = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(1)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
          // read TAB2 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NE
          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NE_read = true;
          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
          aux_last_type_read_for_NE = SCALAR_INT;
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          {
            Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            cpp_template = "[ MAT , 1 , 455 / 0.0 , E1 , 0 , 0 , (NNF*2) , 0 / \n { lambda , alpha } { l = 1 to NNF } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable E1
            var_E1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_E1_read = true;
            validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
            aux_last_type_read_for_E1 = SCALAR_DOUBLE;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable cpp_int_val
            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_cpp_int_val_read = true;
            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
            // assign expression to variable NNF
            var_NNF_0d_int_Scalar = (cpp_int_val/2);
            aux_NNF_read = true;
            validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
            aux_last_type_read_for_NNF = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body
              ptr_lambda_2d_idx0 = var_lambda_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
              ptr_alpha_2d_idx0 = var_alpha_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                // read LIST body
                // assign expression to variable lambda
                ptr_lambda_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
                aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable alpha
                ptr_alpha_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("alpha", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_alpha);
                aux_last_type_read_for_alpha = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
          }
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NC , 0 / { nubar_d } { k = 1 to NC } ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NC
          var_NC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NC_read = true;
          validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
          aux_last_type_read_for_NC = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NC_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              // assign expression to variable nubar_d
              var_nubar_d_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("nubar_d", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_nubar_d);
              aux_last_type_read_for_nubar_d = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LDG == SCALAR_INT) && (aux_LDG_read == true))) {
    cpp_current_dict["LDG"] = var_LDG_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LNU == SCALAR_INT) && (aux_LNU_read == true))) {
    cpp_current_dict["LNU"] = var_LNU_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NNF == SCALAR_INT) && (aux_NNF_read == true))) {
    cpp_current_dict["NNF"] = var_NNF_0d_int_Scalar;
  }
  if ((var_lambda_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["lambda"] = var_lambda_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
    cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_nubar_d == SCALAR_FLOATVEC) && (aux_nubar_d_read == true))) {
    cpp_current_dict["nubar_d"] = var_nubar_d_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_nubar_d == SCALAR_DOUBLE) && (aux_nubar_d_read == true))) {
    cpp_current_dict["nubar_d"] = var_nubar_d_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
    cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
  }
  if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_lambda_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["lambda"] = var_lambda_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_alpha_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["alpha"] = var_alpha_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_E1 == SCALAR_DOUBLE) && (aux_E1_read == true))) {
    cpp_current_dict["E1"] = var_E1_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
    cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
  }
  if ((var_nubar_d_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["nubar_d"] = var_nubar_d_1d_double_NestedVector.to_pyobj(list_mode);
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: dc95e75784d9f676b28daf84959ecfb2
// MD5 hash of the following function definition: d2d3052454cf2317935dff1bb326c082
py::dict parse_mf1mt456_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LNU_0d_int_Scalar;
  bool aux_LNU_read = false;
  vartype aux_last_type_read_for_LNU = UNKNOWN;
  std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<EndfFloatCpp> var_nubar_p_0d_floatvec_Scalar;
  EndfFloatCpp var_nubar_p_0d_double_Scalar;
  bool aux_nubar_p_read = false;
  vartype aux_last_type_read_for_nubar_p = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 1;
  int mt = 456;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 456;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 1 , 456 / ZA , AWR , 0 , LNU , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LNU
  var_LNU_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LNU_read = true;
  validate_vartype_consistency("LNU", SCALAR_INT, aux_last_type_read_for_LNU);
  aux_last_type_read_for_LNU = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 1 , 456 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nubar_p ] TAB1";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
        {
          Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
          // assign expression to variable Eint
          var_Eint_0d_floatvec_Scalar = tab_body.X;
          aux_Eint_read = true;
          validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
          aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
          // assign expression to variable nubar_p
          var_nubar_p_0d_floatvec_Scalar = tab_body.Y;
          aux_nubar_p_read = true;
          validate_vartype_consistency("nubar_p", SCALAR_FLOATVEC, aux_last_type_read_for_nubar_p);
          aux_last_type_read_for_nubar_p = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 456 / 0.0 , 0.0 , 0 , 0 , 1 , 0 / nubar_p ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(1, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "1",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body
            // assign expression to variable nubar_p
            var_nubar_p_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_nubar_p_read = true;
            validate_vartype_consistency("nubar_p", SCALAR_DOUBLE, aux_last_type_read_for_nubar_p);
            aux_last_type_read_for_nubar_p = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LNU == SCALAR_INT) && (aux_LNU_read == true))) {
    cpp_current_dict["LNU"] = var_LNU_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
    cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_nubar_p == SCALAR_FLOATVEC) && (aux_nubar_p_read == true))) {
    cpp_current_dict["nubar_p"] = var_nubar_p_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_nubar_p == SCALAR_DOUBLE) && (aux_nubar_p_read == true))) {
    cpp_current_dict["nubar_p"] = var_nubar_p_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 5b7d22a0815ff99a2cbd6db8a6ad59a3
// MD5 hash of the following function definition: dc70b28365e9441ea4206c240b07138a
py::dict parse_mf1mt458_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LFC_0d_int_Scalar;
  bool aux_LFC_read = false;
  vartype aux_last_type_read_for_LFC = UNKNOWN;
  int var_NPLY_0d_int_Scalar;
  bool aux_NPLY_read = false;
  vartype aux_last_type_read_for_NPLY = UNKNOWN;
  EndfFloatCpp var_EFR_0d_double_Scalar;
  bool aux_EFR_read = false;
  vartype aux_last_type_read_for_EFR = UNKNOWN;
  EndfFloatCpp var_dEFR_0d_double_Scalar;
  bool aux_dEFR_read = false;
  vartype aux_last_type_read_for_dEFR = UNKNOWN;
  EndfFloatCpp var_ENP_0d_double_Scalar;
  bool aux_ENP_read = false;
  vartype aux_last_type_read_for_ENP = UNKNOWN;
  EndfFloatCpp var_dENP_0d_double_Scalar;
  bool aux_dENP_read = false;
  vartype aux_last_type_read_for_dENP = UNKNOWN;
  EndfFloatCpp var_END_0d_double_Scalar;
  bool aux_END_read = false;
  vartype aux_last_type_read_for_END = UNKNOWN;
  EndfFloatCpp var_dEND_0d_double_Scalar;
  bool aux_dEND_read = false;
  vartype aux_last_type_read_for_dEND = UNKNOWN;
  EndfFloatCpp var_EGP_0d_double_Scalar;
  bool aux_EGP_read = false;
  vartype aux_last_type_read_for_EGP = UNKNOWN;
  EndfFloatCpp var_dEGP_0d_double_Scalar;
  bool aux_dEGP_read = false;
  vartype aux_last_type_read_for_dEGP = UNKNOWN;
  EndfFloatCpp var_EGD_0d_double_Scalar;
  bool aux_EGD_read = false;
  vartype aux_last_type_read_for_EGD = UNKNOWN;
  EndfFloatCpp var_dEGD_0d_double_Scalar;
  bool aux_dEGD_read = false;
  vartype aux_last_type_read_for_dEGD = UNKNOWN;
  EndfFloatCpp var_EB_0d_double_Scalar;
  bool aux_EB_read = false;
  vartype aux_last_type_read_for_EB = UNKNOWN;
  EndfFloatCpp var_dEB_0d_double_Scalar;
  bool aux_dEB_read = false;
  vartype aux_last_type_read_for_dEB = UNKNOWN;
  EndfFloatCpp var_ENU_0d_double_Scalar;
  bool aux_ENU_read = false;
  vartype aux_last_type_read_for_ENU = UNKNOWN;
  EndfFloatCpp var_dENU_0d_double_Scalar;
  bool aux_dENU_read = false;
  vartype aux_last_type_read_for_dENU = UNKNOWN;
  EndfFloatCpp var_ER_0d_double_Scalar;
  bool aux_ER_read = false;
  vartype aux_last_type_read_for_ER = UNKNOWN;
  EndfFloatCpp var_dER_0d_double_Scalar;
  bool aux_dER_read = false;
  vartype aux_last_type_read_for_dER = UNKNOWN;
  EndfFloatCpp var_ET_0d_double_Scalar;
  bool aux_ET_read = false;
  vartype aux_last_type_read_for_ET = UNKNOWN;
  EndfFloatCpp var_dET_0d_double_Scalar;
  bool aux_dET_read = false;
  vartype aux_last_type_read_for_dET = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_EFR_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EFR = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_EFR_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EFR = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_ENP_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ENP = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_ENP_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ENP = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_END_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_END = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_END_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_END = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_EGP_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EGP = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_EGP_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EGP = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_EGD_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EGD = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_EGD_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EGD = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_EB_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EB = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_EB_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EB = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_ENU_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ENU = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_ENU_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ENU = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_ER_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ER = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_ER_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ER = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_ET_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ET = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_ET_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ET = UNKNOWN;
  int var_NFC_0d_int_Scalar;
  bool aux_NFC_read = false;
  vartype aux_last_type_read_for_NFC = UNKNOWN;
  NestedVector<int> var_LDRV_1d_int_NestedVector;
  vartype aux_last_type_read_for_LDRV = UNKNOWN;
  NestedVector<int> var_IFC_1d_int_NestedVector;
  vartype aux_last_type_read_for_IFC = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 1;
  int mt = 458;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 458;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        std::streampos cpp_old_streampos = cont.tellg();
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LFC_0d_int_Scalar = var_LFC_0d_int_Scalar;
          int var_LFC_0d_int_Scalar = glob_var_LFC_0d_int_Scalar;
          bool& glob_aux_LFC_read = aux_LFC_read;
          bool aux_LFC_read = glob_aux_LFC_read;
          vartype aux_last_type_read_for_LFC = UNKNOWN;
          int& glob_var_NPLY_0d_int_Scalar = var_NPLY_0d_int_Scalar;
          int var_NPLY_0d_int_Scalar = glob_var_NPLY_0d_int_Scalar;
          bool& glob_aux_NPLY_read = aux_NPLY_read;
          bool aux_NPLY_read = glob_aux_NPLY_read;
          vartype aux_last_type_read_for_NPLY = UNKNOWN;
          try {
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
            cpp_line = cpp_read_raw_line(cont);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
            cpp_line = cpp_read_raw_line(cont);
            // read LIST record
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
          } catch (const std::out_of_range& e) {
            // // accept failure in lookahead
          }
          if (((((((((aux_LFC_read == true)) && ((var_LFC_0d_int_Scalar)==(0)))))&&((((aux_NPLY_read == true)) && ((var_NPLY_0d_int_Scalar)==(0)))))))) {
            cpp_found_match = true;
          }
          cont.seekg(cpp_old_streampos);
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable LFC
          var_LFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_LFC_read = true;
          validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
          aux_last_type_read_for_LFC = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NPLY
          var_NPLY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_NPLY_read = true;
          validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
          aux_last_type_read_for_NPLY = SCALAR_INT;
          cpp_validate_field(18, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "18",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(9, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "9",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body
            // assign expression to variable EFR
            var_EFR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_EFR_read = true;
            validate_vartype_consistency("EFR", SCALAR_DOUBLE, aux_last_type_read_for_EFR);
            aux_last_type_read_for_EFR = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dEFR
            var_dEFR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dEFR_read = true;
            validate_vartype_consistency("dEFR", SCALAR_DOUBLE, aux_last_type_read_for_dEFR);
            aux_last_type_read_for_dEFR = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable ENP
            var_ENP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_ENP_read = true;
            validate_vartype_consistency("ENP", SCALAR_DOUBLE, aux_last_type_read_for_ENP);
            aux_last_type_read_for_ENP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dENP
            var_dENP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dENP_read = true;
            validate_vartype_consistency("dENP", SCALAR_DOUBLE, aux_last_type_read_for_dENP);
            aux_last_type_read_for_dENP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable END
            var_END_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_END_read = true;
            validate_vartype_consistency("END", SCALAR_DOUBLE, aux_last_type_read_for_END);
            aux_last_type_read_for_END = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dEND
            var_dEND_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dEND_read = true;
            validate_vartype_consistency("dEND", SCALAR_DOUBLE, aux_last_type_read_for_dEND);
            aux_last_type_read_for_dEND = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable EGP
            var_EGP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_EGP_read = true;
            validate_vartype_consistency("EGP", SCALAR_DOUBLE, aux_last_type_read_for_EGP);
            aux_last_type_read_for_EGP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dEGP
            var_dEGP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dEGP_read = true;
            validate_vartype_consistency("dEGP", SCALAR_DOUBLE, aux_last_type_read_for_dEGP);
            aux_last_type_read_for_dEGP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable EGD
            var_EGD_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_EGD_read = true;
            validate_vartype_consistency("EGD", SCALAR_DOUBLE, aux_last_type_read_for_EGD);
            aux_last_type_read_for_EGD = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dEGD
            var_dEGD_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dEGD_read = true;
            validate_vartype_consistency("dEGD", SCALAR_DOUBLE, aux_last_type_read_for_dEGD);
            aux_last_type_read_for_dEGD = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable EB
            var_EB_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_EB_read = true;
            validate_vartype_consistency("EB", SCALAR_DOUBLE, aux_last_type_read_for_EB);
            aux_last_type_read_for_EB = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dEB
            var_dEB_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dEB_read = true;
            validate_vartype_consistency("dEB", SCALAR_DOUBLE, aux_last_type_read_for_dEB);
            aux_last_type_read_for_dEB = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable ENU
            var_ENU_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_ENU_read = true;
            validate_vartype_consistency("ENU", SCALAR_DOUBLE, aux_last_type_read_for_ENU);
            aux_last_type_read_for_ENU = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dENU
            var_dENU_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dENU_read = true;
            validate_vartype_consistency("dENU", SCALAR_DOUBLE, aux_last_type_read_for_dENU);
            aux_last_type_read_for_dENU = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable ER
            var_ER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_ER_read = true;
            validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
            aux_last_type_read_for_ER = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dER
            var_dER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dER_read = true;
            validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
            aux_last_type_read_for_dER = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable ET
            var_ET_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_ET_read = true;
            validate_vartype_consistency("ET", SCALAR_DOUBLE, aux_last_type_read_for_ET);
            aux_last_type_read_for_ET = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dET
            var_dET_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dET_read = true;
            validate_vartype_consistency("dET", SCALAR_DOUBLE, aux_last_type_read_for_dET);
            aux_last_type_read_for_dET = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LFC_0d_int_Scalar = var_LFC_0d_int_Scalar;
            int var_LFC_0d_int_Scalar = glob_var_LFC_0d_int_Scalar;
            bool& glob_aux_LFC_read = aux_LFC_read;
            bool aux_LFC_read = glob_aux_LFC_read;
            vartype aux_last_type_read_for_LFC = UNKNOWN;
            int& glob_var_NPLY_0d_int_Scalar = var_NPLY_0d_int_Scalar;
            int var_NPLY_0d_int_Scalar = glob_var_NPLY_0d_int_Scalar;
            bool& glob_aux_NPLY_read = aux_NPLY_read;
            bool aux_NPLY_read = glob_aux_NPLY_read;
            vartype aux_last_type_read_for_NPLY = UNKNOWN;
            int& glob_cpp_int_val = cpp_int_val;
            int cpp_int_val = glob_cpp_int_val;
            bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
            bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
            try {
              cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
              cpp_line = cpp_read_raw_line(cont);
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LFC
              var_LFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LFC_read = true;
              validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
              aux_last_type_read_for_LFC = SCALAR_INT;
              cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , (18*(NPLY+1)) , (9*(NPLY+1)) / \n { c_EFR , dc_EFR , c_ENP , dc_ENP , c_END , dc_END , \n c_EGP , dc_EGP , c_EGD , dc_EGD , c_EB , dc_EB , \n c_ENU , dc_ENU , c_ER , dc_ER , c_ET , dc_ET } { k = 0 to NPLY } ] LIST";
              cpp_line = cpp_read_raw_line(cont);
              // read LIST record
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
              if ((! (aux_NPLY_read == true))) {
                // assign expression to variable cpp_int_val
                cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                aux_cpp_int_val_read = true;
                validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                // assign expression to variable NPLY
                var_NPLY_0d_int_Scalar = ((cpp_int_val+(-18))/18);
                aux_NPLY_read = true;
                validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
                aux_last_type_read_for_NPLY = SCALAR_INT;
              } else {
              }
              if ((! (aux_NPLY_read == true))) {
                // assign expression to variable cpp_int_val
                cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                aux_cpp_int_val_read = true;
                validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                // assign expression to variable NPLY
                var_NPLY_0d_int_Scalar = ((cpp_int_val+(-9))/9);
                aux_NPLY_read = true;
                validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
                aux_last_type_read_for_NPLY = SCALAR_INT;
              } else {
              }
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if (((((((((aux_LFC_read == true)) && ((var_LFC_0d_int_Scalar)==(0)))))&&((((aux_NPLY_read == true)) && ((var_NPLY_0d_int_Scalar)>(0)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , (18*(NPLY+1)) , (9*(NPLY+1)) / \n { c_EFR , dc_EFR , c_ENP , dc_ENP , c_END , dc_END , \n c_EGP , dc_EGP , c_EGD , dc_EGD , c_EB , dc_EB , \n c_ENU , dc_ENU , c_ER , dc_ER , c_ET , dc_ET } { k = 0 to NPLY } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
            if ((! (aux_NPLY_read == true))) {
              // assign expression to variable cpp_int_val
              cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = ((cpp_int_val+(-18))/18);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } else {
              cpp_validate_field((18*(var_NPLY_0d_int_Scalar+1)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(18*(NPLY+1))",
                cpp_template, cpp_line, parse_opts);
            }
            if ((! (aux_NPLY_read == true))) {
              // assign expression to variable cpp_int_val
              cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = ((cpp_int_val+(-9))/9);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } else {
              cpp_validate_field((9*(var_NPLY_0d_int_Scalar+1)), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "(9*(NPLY+1))",
                cpp_template, cpp_line, parse_opts);
            }
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body

              for (int var_k_0d_int_Scalar = 0;
                 var_k_0d_int_Scalar <= var_NPLY_0d_int_Scalar; var_k_0d_int_Scalar++) {
                bool aux_k_read = true;
                // read LIST body
                // assign expression to variable c_EFR
                var_c_EFR_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_EFR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EFR);
                aux_last_type_read_for_c_EFR = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_EFR
                var_dc_EFR_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_EFR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EFR);
                aux_last_type_read_for_dc_EFR = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_ENP
                var_c_ENP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_ENP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ENP);
                aux_last_type_read_for_c_ENP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_ENP
                var_dc_ENP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_ENP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ENP);
                aux_last_type_read_for_dc_ENP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_END
                var_c_END_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_END", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_END);
                aux_last_type_read_for_c_END = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_END
                var_dc_END_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_END", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_END);
                aux_last_type_read_for_dc_END = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_EGP
                var_c_EGP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_EGP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EGP);
                aux_last_type_read_for_c_EGP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_EGP
                var_dc_EGP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_EGP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EGP);
                aux_last_type_read_for_dc_EGP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_EGD
                var_c_EGD_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_EGD", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EGD);
                aux_last_type_read_for_c_EGD = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_EGD
                var_dc_EGD_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_EGD", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EGD);
                aux_last_type_read_for_dc_EGD = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_EB
                var_c_EB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_EB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EB);
                aux_last_type_read_for_c_EB = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_EB
                var_dc_EB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_EB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EB);
                aux_last_type_read_for_dc_EB = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_ENU
                var_c_ENU_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_ENU", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ENU);
                aux_last_type_read_for_c_ENU = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_ENU
                var_dc_ENU_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_ENU", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ENU);
                aux_last_type_read_for_dc_ENU = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_ER
                var_c_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ER);
                aux_last_type_read_for_c_ER = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_ER
                var_dc_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ER);
                aux_last_type_read_for_dc_ER = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_ET
                var_c_ET_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_ET", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ET);
                aux_last_type_read_for_c_ET = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_ET
                var_dc_ET_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_ET", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ET);
                aux_last_type_read_for_dc_ET = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LFC_0d_int_Scalar = var_LFC_0d_int_Scalar;
            int var_LFC_0d_int_Scalar = glob_var_LFC_0d_int_Scalar;
            bool& glob_aux_LFC_read = aux_LFC_read;
            bool aux_LFC_read = glob_aux_LFC_read;
            vartype aux_last_type_read_for_LFC = UNKNOWN;
            int& glob_var_NFC_0d_int_Scalar = var_NFC_0d_int_Scalar;
            int var_NFC_0d_int_Scalar = glob_var_NFC_0d_int_Scalar;
            bool& glob_aux_NFC_read = aux_NFC_read;
            bool aux_NFC_read = glob_aux_NFC_read;
            vartype aux_last_type_read_for_NFC = UNKNOWN;
            int& glob_var_NPLY_0d_int_Scalar = var_NPLY_0d_int_Scalar;
            int var_NPLY_0d_int_Scalar = glob_var_NPLY_0d_int_Scalar;
            bool& glob_aux_NPLY_read = aux_NPLY_read;
            bool aux_NPLY_read = glob_aux_NPLY_read;
            vartype aux_last_type_read_for_NPLY = UNKNOWN;
            try {
              cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , NFC ] HEAD";
              cpp_line = cpp_read_raw_line(cont);
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LFC
              var_LFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LFC_read = true;
              validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
              aux_last_type_read_for_LFC = SCALAR_INT;
              // assign expression to variable NFC
              var_NFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NFC_read = true;
              validate_vartype_consistency("NFC", SCALAR_INT, aux_last_type_read_for_NFC);
              aux_last_type_read_for_NFC = SCALAR_INT;
              cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
              cpp_line = cpp_read_raw_line(cont);
              // read LIST record
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if (((((((((aux_LFC_read == true)) && ((var_LFC_0d_int_Scalar)==(1)))))&&((((aux_NPLY_read == true)) && ((var_NPLY_0d_int_Scalar)==(0)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , NFC ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable NFC
            var_NFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NFC_read = true;
            validate_vartype_consistency("NFC", SCALAR_INT, aux_last_type_read_for_NFC);
            aux_last_type_read_for_NFC = SCALAR_INT;
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
            cpp_validate_field(18, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "18",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(9, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "9",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body
              // assign expression to variable EFR
              var_EFR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_EFR_read = true;
              validate_vartype_consistency("EFR", SCALAR_DOUBLE, aux_last_type_read_for_EFR);
              aux_last_type_read_for_EFR = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dEFR
              var_dEFR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dEFR_read = true;
              validate_vartype_consistency("dEFR", SCALAR_DOUBLE, aux_last_type_read_for_dEFR);
              aux_last_type_read_for_dEFR = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable ENP
              var_ENP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_ENP_read = true;
              validate_vartype_consistency("ENP", SCALAR_DOUBLE, aux_last_type_read_for_ENP);
              aux_last_type_read_for_ENP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dENP
              var_dENP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dENP_read = true;
              validate_vartype_consistency("dENP", SCALAR_DOUBLE, aux_last_type_read_for_dENP);
              aux_last_type_read_for_dENP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable END
              var_END_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_END_read = true;
              validate_vartype_consistency("END", SCALAR_DOUBLE, aux_last_type_read_for_END);
              aux_last_type_read_for_END = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dEND
              var_dEND_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dEND_read = true;
              validate_vartype_consistency("dEND", SCALAR_DOUBLE, aux_last_type_read_for_dEND);
              aux_last_type_read_for_dEND = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable EGP
              var_EGP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_EGP_read = true;
              validate_vartype_consistency("EGP", SCALAR_DOUBLE, aux_last_type_read_for_EGP);
              aux_last_type_read_for_EGP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dEGP
              var_dEGP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dEGP_read = true;
              validate_vartype_consistency("dEGP", SCALAR_DOUBLE, aux_last_type_read_for_dEGP);
              aux_last_type_read_for_dEGP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable EGD
              var_EGD_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_EGD_read = true;
              validate_vartype_consistency("EGD", SCALAR_DOUBLE, aux_last_type_read_for_EGD);
              aux_last_type_read_for_EGD = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dEGD
              var_dEGD_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dEGD_read = true;
              validate_vartype_consistency("dEGD", SCALAR_DOUBLE, aux_last_type_read_for_dEGD);
              aux_last_type_read_for_dEGD = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable EB
              var_EB_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_EB_read = true;
              validate_vartype_consistency("EB", SCALAR_DOUBLE, aux_last_type_read_for_EB);
              aux_last_type_read_for_EB = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dEB
              var_dEB_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dEB_read = true;
              validate_vartype_consistency("dEB", SCALAR_DOUBLE, aux_last_type_read_for_dEB);
              aux_last_type_read_for_dEB = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable ENU
              var_ENU_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_ENU_read = true;
              validate_vartype_consistency("ENU", SCALAR_DOUBLE, aux_last_type_read_for_ENU);
              aux_last_type_read_for_ENU = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dENU
              var_dENU_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dENU_read = true;
              validate_vartype_consistency("dENU", SCALAR_DOUBLE, aux_last_type_read_for_dENU);
              aux_last_type_read_for_dENU = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable ER
              var_ER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_ER_read = true;
              validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
              aux_last_type_read_for_ER = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dER
              var_dER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dER_read = true;
              validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
              aux_last_type_read_for_dER = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable ET
              var_ET_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_ET_read = true;
              validate_vartype_consistency("ET", SCALAR_DOUBLE, aux_last_type_read_for_ET);
              aux_last_type_read_for_ET = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dET
              var_dET_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dET_read = true;
              validate_vartype_consistency("dET", SCALAR_DOUBLE, aux_last_type_read_for_dET);
              aux_last_type_read_for_dET = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NFC_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , LDRV , IFC , NR , NP / Eint / EIFC ] TAB1 ( fiscomp [ k ] )";
              // read TAB1 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable LDRV
              var_LDRV_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
              validate_vartype_consistency("LDRV", NESTEDVECTOR_INT, aux_last_type_read_for_LDRV);
              aux_last_type_read_for_LDRV = NESTEDVECTOR_INT;
              // assign expression to variable IFC
              var_IFC_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
              validate_vartype_consistency("IFC", NESTEDVECTOR_INT, aux_last_type_read_for_IFC);
              aux_last_type_read_for_IFC = NESTEDVECTOR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.setdefault("fiscomp", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                // variable declarations
                std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
                bool aux_Eint_read = false;
                vartype aux_last_type_read_for_Eint = UNKNOWN;
                std::vector<EndfFloatCpp> var_EIFC_0d_floatvec_Scalar;
                bool aux_EIFC_read = false;
                vartype aux_last_type_read_for_EIFC = UNKNOWN;
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                  // assign expression to variable EIFC
                  var_EIFC_0d_floatvec_Scalar = tab_body.Y;
                  aux_EIFC_read = true;
                  validate_vartype_consistency("EIFC", SCALAR_FLOATVEC, aux_last_type_read_for_EIFC);
                  aux_last_type_read_for_EIFC = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
                  cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
                }
                if (((aux_last_type_read_for_EIFC == SCALAR_FLOATVEC) && (aux_EIFC_read == true))) {
                  cpp_current_dict["EIFC"] = var_EIFC_0d_floatvec_Scalar;
                }
                if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                  cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                }
                if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                  cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LFC == SCALAR_INT) && (aux_LFC_read == true))) {
    cpp_current_dict["LFC"] = var_LFC_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NPLY == SCALAR_INT) && (aux_NPLY_read == true))) {
    cpp_current_dict["NPLY"] = var_NPLY_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_EFR == SCALAR_DOUBLE) && (aux_EFR_read == true))) {
    cpp_current_dict["EFR"] = var_EFR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dEFR == SCALAR_DOUBLE) && (aux_dEFR_read == true))) {
    cpp_current_dict["dEFR"] = var_dEFR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_ENP == SCALAR_DOUBLE) && (aux_ENP_read == true))) {
    cpp_current_dict["ENP"] = var_ENP_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dENP == SCALAR_DOUBLE) && (aux_dENP_read == true))) {
    cpp_current_dict["dENP"] = var_dENP_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_END == SCALAR_DOUBLE) && (aux_END_read == true))) {
    cpp_current_dict["END"] = var_END_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dEND == SCALAR_DOUBLE) && (aux_dEND_read == true))) {
    cpp_current_dict["dEND"] = var_dEND_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_EGP == SCALAR_DOUBLE) && (aux_EGP_read == true))) {
    cpp_current_dict["EGP"] = var_EGP_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dEGP == SCALAR_DOUBLE) && (aux_dEGP_read == true))) {
    cpp_current_dict["dEGP"] = var_dEGP_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_EGD == SCALAR_DOUBLE) && (aux_EGD_read == true))) {
    cpp_current_dict["EGD"] = var_EGD_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dEGD == SCALAR_DOUBLE) && (aux_dEGD_read == true))) {
    cpp_current_dict["dEGD"] = var_dEGD_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_EB == SCALAR_DOUBLE) && (aux_EB_read == true))) {
    cpp_current_dict["EB"] = var_EB_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dEB == SCALAR_DOUBLE) && (aux_dEB_read == true))) {
    cpp_current_dict["dEB"] = var_dEB_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_ENU == SCALAR_DOUBLE) && (aux_ENU_read == true))) {
    cpp_current_dict["ENU"] = var_ENU_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dENU == SCALAR_DOUBLE) && (aux_dENU_read == true))) {
    cpp_current_dict["dENU"] = var_dENU_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_ER == SCALAR_DOUBLE) && (aux_ER_read == true))) {
    cpp_current_dict["ER"] = var_ER_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dER == SCALAR_DOUBLE) && (aux_dER_read == true))) {
    cpp_current_dict["dER"] = var_dER_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_ET == SCALAR_DOUBLE) && (aux_ET_read == true))) {
    cpp_current_dict["ET"] = var_ET_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dET == SCALAR_DOUBLE) && (aux_dET_read == true))) {
    cpp_current_dict["dET"] = var_dET_0d_double_Scalar;
  }
  if ((var_c_EFR_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["c_EFR"] = var_c_EFR_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_dc_EFR_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["dc_EFR"] = var_dc_EFR_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_c_ENP_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["c_ENP"] = var_c_ENP_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_dc_ENP_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["dc_ENP"] = var_dc_ENP_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_c_END_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["c_END"] = var_c_END_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_dc_END_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["dc_END"] = var_dc_END_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_c_EGP_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["c_EGP"] = var_c_EGP_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_dc_EGP_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["dc_EGP"] = var_dc_EGP_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_c_EGD_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["c_EGD"] = var_c_EGD_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_dc_EGD_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["dc_EGD"] = var_dc_EGD_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_c_EB_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["c_EB"] = var_c_EB_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_dc_EB_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["dc_EB"] = var_dc_EB_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_c_ENU_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["c_ENU"] = var_c_ENU_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_dc_ENU_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["dc_ENU"] = var_dc_ENU_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_c_ER_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["c_ER"] = var_c_ER_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_dc_ER_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["dc_ER"] = var_dc_ER_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_c_ET_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["c_ET"] = var_c_ET_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_dc_ET_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["dc_ET"] = var_dc_ET_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_NFC == SCALAR_INT) && (aux_NFC_read == true))) {
    cpp_current_dict["NFC"] = var_NFC_0d_int_Scalar;
  }
  if ((var_LDRV_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["LDRV"] = var_LDRV_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_IFC_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["IFC"] = var_IFC_1d_int_NestedVector.to_pyobj(list_mode);
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: e21d94e5c8e9c65689f5e8851bc9d1cf
// MD5 hash of the following function definition: a3acbbf7316258b1ed8f155bba582b05
py::dict parse_mf1mt460_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LO_0d_int_Scalar;
  bool aux_LO_read = false;
  vartype aux_last_type_read_for_LO = UNKNOWN;
  int var_NG_0d_int_Scalar;
  bool aux_NG_read = false;
  vartype aux_last_type_read_for_NG = UNKNOWN;
  NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  int var_NNF_0d_int_Scalar;
  bool aux_NNF_read = false;
  vartype aux_last_type_read_for_NNF = UNKNOWN;
  NestedVector<EndfFloatCpp> var_lambda_1d_double_NestedVector;
  vartype aux_last_type_read_for_lambda = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 1;
  int mt = 460;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 460;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        std::streampos cpp_old_streampos = cont.tellg();
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
          int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
          bool& glob_aux_LO_read = aux_LO_read;
          bool aux_LO_read = glob_aux_LO_read;
          vartype aux_last_type_read_for_LO = UNKNOWN;
          int& glob_var_NG_0d_int_Scalar = var_NG_0d_int_Scalar;
          int var_NG_0d_int_Scalar = glob_var_NG_0d_int_Scalar;
          bool& glob_aux_NG_read = aux_NG_read;
          bool aux_NG_read = glob_aux_NG_read;
          vartype aux_last_type_read_for_NG = UNKNOWN;
          try {
            cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , NG , 0 ] HEAD";
            cpp_line = cpp_read_raw_line(cont);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LO
            var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            // assign expression to variable NG
            var_NG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NG_read = true;
            validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
            aux_last_type_read_for_NG = SCALAR_INT;
          } catch (const std::out_of_range& e) {
            // // accept failure in lookahead
          }
          if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(1)))))))) {
            cpp_found_match = true;
          }
          cont.seekg(cpp_old_streampos);
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , NG , 0 ] HEAD";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LO
          var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LO_read = true;
          validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
          aux_last_type_read_for_LO = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NG
          var_NG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NG_read = true;
          validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
          aux_last_type_read_for_NG = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_NG_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 1 , 460 / E , 0.0 , i , 0 , NR , NP / tint / T ] TAB1 ( table [ i ] )";
            // read TAB1 record
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            if ((! (aux_i_read == true))) {
              // assign expression to variable i
            } else {
              cpp_validate_field(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "i",
                cpp_template, cpp_line, parse_opts);
            }
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.setdefault("table", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              // variable declarations
              std::vector<EndfFloatCpp> var_tint_0d_floatvec_Scalar;
              bool aux_tint_read = false;
              vartype aux_last_type_read_for_tint = UNKNOWN;
              std::vector<EndfFloatCpp> var_T_0d_floatvec_Scalar;
              bool aux_T_read = false;
              vartype aux_last_type_read_for_T = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                // assign expression to variable tint
                var_tint_0d_floatvec_Scalar = tab_body.X;
                aux_tint_read = true;
                validate_vartype_consistency("tint", SCALAR_FLOATVEC, aux_last_type_read_for_tint);
                aux_last_type_read_for_tint = SCALAR_FLOATVEC;
                // assign expression to variable T
                var_T_0d_floatvec_Scalar = tab_body.Y;
                aux_T_read = true;
                validate_vartype_consistency("T", SCALAR_FLOATVEC, aux_last_type_read_for_T);
                aux_last_type_read_for_T = SCALAR_FLOATVEC;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              // store data in Python dictionary
              if (((aux_last_type_read_for_tint == SCALAR_FLOATVEC) && (aux_tint_read == true))) {
                cpp_current_dict["tint"] = var_tint_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_T == SCALAR_FLOATVEC) && (aux_T_read == true))) {
                cpp_current_dict["T"] = var_T_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
              }
              if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
            int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
            bool& glob_aux_LO_read = aux_LO_read;
            bool aux_LO_read = glob_aux_LO_read;
            vartype aux_last_type_read_for_LO = UNKNOWN;
            try {
              cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , 0 , 0 ] HEAD";
              cpp_line = cpp_read_raw_line(cont);
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LO
              var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LO_read = true;
              validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
              aux_last_type_read_for_LO = SCALAR_INT;
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(2)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , 0 , 0 ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LO
            var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_template = "[ MAT , 1 , 460 / 0.0 , 0.0 , 0 , 0 , NNF , 0 / \n { lambda } { i = 1 to NNF } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable NNF
            var_NNF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NNF_read = true;
            validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
            aux_last_type_read_for_NNF = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body

              for (int var_i_0d_int_Scalar = 1;
                 var_i_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_i_0d_int_Scalar++) {
                bool aux_i_read = true;
                // read LIST body
                // assign expression to variable lambda
                var_lambda_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
                aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LO == SCALAR_INT) && (aux_LO_read == true))) {
    cpp_current_dict["LO"] = var_LO_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NG == SCALAR_INT) && (aux_NG_read == true))) {
    cpp_current_dict["NG"] = var_NG_0d_int_Scalar;
  }
  if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_NNF == SCALAR_INT) && (aux_NNF_read == true))) {
    cpp_current_dict["NNF"] = var_NNF_0d_int_Scalar;
  }
  if ((var_lambda_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["lambda"] = var_lambda_1d_double_NestedVector.to_pyobj(list_mode);
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 5fa12bb2c8f7635e2932396375ed29d8
// MD5 hash of the following function definition: 3f195ee52673ae393c41c67456cb07d6
py::dict parse_mf2mt151_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NIS_0d_int_Scalar;
  bool aux_NIS_read = false;
  vartype aux_last_type_read_for_NIS = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 2;
  int mt = 151;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 2;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 151;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 2 , 151 / ZA , AWR , 0 , 0 , NIS , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NIS
  var_NIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NIS_read = true;
  validate_vartype_consistency("NIS", SCALAR_INT, aux_last_type_read_for_NIS);
  aux_last_type_read_for_NIS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NIS_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    // open section isotope
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.setdefault("isotope", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_ZAI_0d_double_Scalar;
      bool aux_ZAI_read = false;
      vartype aux_last_type_read_for_ZAI = UNKNOWN;
      EndfFloatCpp var_ABN_0d_double_Scalar;
      bool aux_ABN_read = false;
      vartype aux_last_type_read_for_ABN = UNKNOWN;
      int var_LFW_0d_int_Scalar;
      bool aux_LFW_read = false;
      vartype aux_last_type_read_for_LFW = UNKNOWN;
      int var_NER_0d_int_Scalar;
      bool aux_NER_read = false;
      vartype aux_last_type_read_for_NER = UNKNOWN;
      cpp_template = "[ MAT , 2 , 151 / ZAI , ABN , 0 , LFW , NER , 0 ] CONT";
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read CONT record
      // assign expression to variable ZAI
      var_ZAI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
      aux_ZAI_read = true;
      validate_vartype_consistency("ZAI", SCALAR_DOUBLE, aux_last_type_read_for_ZAI);
      aux_last_type_read_for_ZAI = SCALAR_DOUBLE;
      // assign expression to variable ABN
      var_ABN_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
      aux_ABN_read = true;
      validate_vartype_consistency("ABN", SCALAR_DOUBLE, aux_last_type_read_for_ABN);
      aux_last_type_read_for_ABN = SCALAR_DOUBLE;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
      // assign expression to variable LFW
      var_LFW_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LFW_read = true;
      validate_vartype_consistency("LFW", SCALAR_INT, aux_last_type_read_for_LFW);
      aux_last_type_read_for_LFW = SCALAR_INT;
      // assign expression to variable NER
      var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      aux_NER_read = true;
      validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
      aux_last_type_read_for_NER = SCALAR_INT;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);

      for (int var_j_0d_int_Scalar = 1;
         var_j_0d_int_Scalar <= var_NER_0d_int_Scalar; var_j_0d_int_Scalar++) {
        bool aux_j_read = true;
        // open section range
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.setdefault("range", std::vector<int>({var_j_0d_int_Scalar}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          // variable declarations
          EndfFloatCpp var_EL_0d_double_Scalar;
          bool aux_EL_read = false;
          vartype aux_last_type_read_for_EL = UNKNOWN;
          EndfFloatCpp var_EH_0d_double_Scalar;
          bool aux_EH_read = false;
          vartype aux_last_type_read_for_EH = UNKNOWN;
          int var_LRU_0d_int_Scalar;
          bool aux_LRU_read = false;
          vartype aux_last_type_read_for_LRU = UNKNOWN;
          int var_LRF_0d_int_Scalar;
          bool aux_LRF_read = false;
          vartype aux_last_type_read_for_LRF = UNKNOWN;
          int var_NRO_0d_int_Scalar;
          bool aux_NRO_read = false;
          vartype aux_last_type_read_for_NRO = UNKNOWN;
          int var_NAPS_0d_int_Scalar;
          bool aux_NAPS_read = false;
          vartype aux_last_type_read_for_NAPS = UNKNOWN;
          EndfFloatCpp var_SPI_0d_double_Scalar;
          bool aux_SPI_read = false;
          vartype aux_last_type_read_for_SPI = UNKNOWN;
          EndfFloatCpp var_AP_0d_double_Scalar;
          std::vector<EndfFloatCpp> var_AP_0d_floatvec_Scalar;
          bool aux_AP_read = false;
          vartype aux_last_type_read_for_AP = UNKNOWN;
          int var_NLS_0d_int_Scalar;
          bool aux_NLS_read = false;
          vartype aux_last_type_read_for_NLS = UNKNOWN;
          std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
          bool aux_Eint_read = false;
          vartype aux_last_type_read_for_Eint = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          int var_LAD_0d_int_Scalar;
          bool aux_LAD_read = false;
          vartype aux_last_type_read_for_LAD = UNKNOWN;
          int var_NLSC_0d_int_Scalar;
          bool aux_NLSC_read = false;
          vartype aux_last_type_read_for_NLSC = UNKNOWN;
          int var_IFG_0d_int_Scalar;
          bool aux_IFG_read = false;
          vartype aux_last_type_read_for_IFG = UNKNOWN;
          int var_KRM_0d_int_Scalar;
          bool aux_KRM_read = false;
          vartype aux_last_type_read_for_KRM = UNKNOWN;
          int var_NJS_0d_int_Scalar;
          bool aux_NJS_read = false;
          vartype aux_last_type_read_for_NJS = UNKNOWN;
          int var_KRL_0d_int_Scalar;
          bool aux_KRL_read = false;
          vartype aux_last_type_read_for_KRL = UNKNOWN;
          int var_NPP_0d_int_Scalar;
          bool aux_NPP_read = false;
          vartype aux_last_type_read_for_NPP = UNKNOWN;
          int cpp_int_val;
          bool aux_cpp_int_val_read = false;
          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
          NestedVector<EndfFloatCpp> var_MA_1d_double_NestedVector;
          vartype aux_last_type_read_for_MA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_MB_1d_double_NestedVector;
          vartype aux_last_type_read_for_MB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_ZA_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_ZB_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_IA_1d_double_NestedVector;
          vartype aux_last_type_read_for_IA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_IB_1d_double_NestedVector;
          vartype aux_last_type_read_for_IB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_Q_1d_double_NestedVector;
          vartype aux_last_type_read_for_Q = UNKNOWN;
          NestedVector<EndfFloatCpp> var_PNT_1d_double_NestedVector;
          vartype aux_last_type_read_for_PNT = UNKNOWN;
          NestedVector<EndfFloatCpp> var_SHF_1d_double_NestedVector;
          vartype aux_last_type_read_for_SHF = UNKNOWN;
          NestedVector<EndfFloatCpp> var_MT_1d_double_NestedVector;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          NestedVector<EndfFloatCpp> var_PA_1d_double_NestedVector;
          vartype aux_last_type_read_for_PA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_PB_1d_double_NestedVector;
          vartype aux_last_type_read_for_PB = UNKNOWN;
          int var_LSSF_0d_int_Scalar;
          bool aux_LSSF_read = false;
          vartype aux_last_type_read_for_LSSF = UNKNOWN;
          int var_NE_0d_int_Scalar;
          bool aux_NE_read = false;
          vartype aux_last_type_read_for_NE = UNKNOWN;
          NestedVector<EndfFloatCpp> var_ES_1d_double_NestedVector;
          vartype aux_last_type_read_for_ES = UNKNOWN;
          cpp_template = "[ MAT , 2 , 151 / EL , EH , LRU , LRF , NRO , NAPS ] CONT";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable EL
          var_EL_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_EL_read = true;
          validate_vartype_consistency("EL", SCALAR_DOUBLE, aux_last_type_read_for_EL);
          aux_last_type_read_for_EL = SCALAR_DOUBLE;
          // assign expression to variable EH
          var_EH_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
          aux_EH_read = true;
          validate_vartype_consistency("EH", SCALAR_DOUBLE, aux_last_type_read_for_EH);
          aux_last_type_read_for_EH = SCALAR_DOUBLE;
          // assign expression to variable LRU
          var_LRU_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LRU_read = true;
          validate_vartype_consistency("LRU", SCALAR_INT, aux_last_type_read_for_LRU);
          aux_last_type_read_for_LRU = SCALAR_INT;
          // assign expression to variable LRF
          var_LRF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_LRF_read = true;
          validate_vartype_consistency("LRF", SCALAR_INT, aux_last_type_read_for_LRF);
          aux_last_type_read_for_LRF = SCALAR_INT;
          // assign expression to variable NRO
          var_NRO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NRO_read = true;
          validate_vartype_consistency("NRO", SCALAR_INT, aux_last_type_read_for_NRO);
          aux_last_type_read_for_NRO = SCALAR_INT;
          // assign expression to variable NAPS
          var_NAPS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NAPS_read = true;
          validate_vartype_consistency("NAPS", SCALAR_INT, aux_last_type_read_for_NAPS);
          aux_last_type_read_for_NAPS = SCALAR_INT;
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((((((aux_NIS_read == true)) && ((var_NIS_0d_int_Scalar)==(1)))))&&((((aux_ZAI_read == true)) && ((var_ZAI_0d_double_Scalar)==(var_ZA_0d_double_Scalar)))))&&((((aux_ABN_read == true)) && ((var_ABN_0d_double_Scalar)==(1)))))&&((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(0)))))&&((((aux_NER_read == true)) && ((var_NER_0d_int_Scalar)==(1)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if (((((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(0)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(0)))))&&((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)==(0)))))&&((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      // evaluate if-elif-else clause
                      {
                        bool cpp_found_match = false;
                        if (! cpp_found_match) {
                          // if statement evaluation with lookahead
                          {
                            std::streampos cpp_old_streampos = cont.tellg();
                            {
                              // variable declarations
                              EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                              EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                              bool& glob_aux_EL_read = aux_EL_read;
                              bool aux_EL_read = glob_aux_EL_read;
                              vartype aux_last_type_read_for_EL = UNKNOWN;
                              EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                              EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                              bool& glob_aux_EH_read = aux_EH_read;
                              bool aux_EH_read = glob_aux_EH_read;
                              vartype aux_last_type_read_for_EH = UNKNOWN;
                              int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                              int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                              bool& glob_aux_LRU_read = aux_LRU_read;
                              bool aux_LRU_read = glob_aux_LRU_read;
                              vartype aux_last_type_read_for_LRU = UNKNOWN;
                              int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                              int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                              bool& glob_aux_LRF_read = aux_LRF_read;
                              bool aux_LRF_read = glob_aux_LRF_read;
                              vartype aux_last_type_read_for_LRF = UNKNOWN;
                              int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                              int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                              bool& glob_aux_NRO_read = aux_NRO_read;
                              bool aux_NRO_read = glob_aux_NRO_read;
                              vartype aux_last_type_read_for_NRO = UNKNOWN;
                              int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                              int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                              bool& glob_aux_NAPS_read = aux_NAPS_read;
                              bool aux_NAPS_read = glob_aux_NAPS_read;
                              vartype aux_last_type_read_for_NAPS = UNKNOWN;
                              EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                              EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                              bool& glob_aux_SPI_read = aux_SPI_read;
                              bool aux_SPI_read = glob_aux_SPI_read;
                              vartype aux_last_type_read_for_SPI = UNKNOWN;
                              EndfFloatCpp& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                              EndfFloatCpp var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                              bool& glob_aux_AP_read = aux_AP_read;
                              bool aux_AP_read = glob_aux_AP_read;
                              vartype aux_last_type_read_for_AP = UNKNOWN;
                              int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                              int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                              bool& glob_aux_NLS_read = aux_NLS_read;
                              bool aux_NLS_read = glob_aux_NLS_read;
                              vartype aux_last_type_read_for_NLS = UNKNOWN;
                              try {
                                cpp_template = "[ MAT , 2 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                                cpp_line = cpp_read_raw_line(cont);
                                // read CONT record
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                                // assign expression to variable AP
                                var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                aux_AP_read = true;
                                validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                                aux_last_type_read_for_AP = SCALAR_DOUBLE;
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } catch (const std::out_of_range& e) {
                                // // accept failure in lookahead
                              }
                              if ((((((((aux_NLS_read == true)) && ((var_NLS_0d_int_Scalar)==(0)))))))) {
                                cpp_found_match = true;
                              }
                              cont.seekg(cpp_old_streampos);
                            }
                            if (cpp_found_match) {
                              cpp_template = "[ MAT , 2 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read CONT record
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if (((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      // evaluate if-elif-else clause
                      {
                        bool cpp_found_match = false;
                        if (! cpp_found_match) {
                          if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                            // if statement evaluation
                            cpp_found_match = true;
                            cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                            // read TAB1 record
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            {
                              Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                              // assign expression to variable Eint
                              var_Eint_0d_floatvec_Scalar = tab_body.X;
                              aux_Eint_read = true;
                              validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                              aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                              if ((! (aux_AP_read == true))) {
                                // assign expression to variable AP
                                var_AP_0d_floatvec_Scalar = tab_body.Y;
                                aux_AP_read = true;
                                validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                              } else {
                                if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                  cpp_validate_field(var_AP_0d_double_Scalar, tab_body.Y,  true, false, false, "AP",
                                    cpp_template, cpp_line, parse_opts);
                                } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                  cpp_validate_field(var_AP_0d_floatvec_Scalar, tab_body.Y,  true, false, false, "AP",
                                    cpp_template, cpp_line, parse_opts);
                                }
                              }
                              // assign expression to variable INT
                              var_INT_0d_intvec_Scalar = tab_body.INT;
                              aux_INT_read = true;
                              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                              aux_last_type_read_for_INT = SCALAR_INTVEC;
                              // assign expression to variable NBT
                              var_NBT_0d_intvec_Scalar = tab_body.NBT;
                              aux_NBT_read = true;
                              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                              aux_last_type_read_for_NBT = SCALAR_INTVEC;
                            }
                          }
                        }
                      }
                      // evaluate if-elif-else clause
                      {
                        bool cpp_found_match = false;
                        if (! cpp_found_match) {
                          if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                            // if statement evaluation
                            cpp_found_match = true;
                            cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , 0 , 0 , NLS , 0 ] CONT";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read CONT record
                            if ((! (aux_SPI_read == true))) {
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                            } else {
                              cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                cpp_template, cpp_line, parse_opts);
                            }
                            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            if ((! (aux_NLS_read == true))) {
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                cpp_template, cpp_line, parse_opts);
                            }
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                          }
                        }
                        if (! cpp_found_match) {
                          cpp_template = "[ MAT , 2 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read CONT record
                          if ((! (aux_SPI_read == true))) {
                            // assign expression to variable SPI
                            var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                            aux_SPI_read = true;
                            validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                            aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                          } else {
                            cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                              cpp_template, cpp_line, parse_opts);
                          }
                          if ((! (aux_AP_read == true))) {
                            // assign expression to variable AP
                            var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                            aux_AP_read = true;
                            validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                            aux_last_type_read_for_AP = SCALAR_DOUBLE;
                          } else {
                            if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                              cpp_validate_field(var_AP_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                cpp_template, cpp_line, parse_opts);
                            } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                              cpp_validate_field(var_AP_0d_floatvec_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                cpp_template, cpp_line, parse_opts);
                            }
                          }
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          if ((! (aux_NLS_read == true))) {
                            // assign expression to variable NLS
                            var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_NLS_read = true;
                            validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                            aux_last_type_read_for_NLS = SCALAR_INT;
                          } else {
                            cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                              cpp_template, cpp_line, parse_opts);
                          }
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                        }
                      }

                      for (int var_m_0d_int_Scalar = 1;
                         var_m_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                        bool aux_m_read = true;
                        // open section spingroup
                        {
                          py::dict cpp_parent_dict = cpp_current_dict;
                          cpp_current_dict = cpp_index_shifter_store.setdefault("spingroup", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                          // variable declarations
                          EndfFloatCpp var_AWRI_0d_double_Scalar;
                          bool aux_AWRI_read = false;
                          vartype aux_last_type_read_for_AWRI = UNKNOWN;
                          EndfFloatCpp var_QX_0d_double_Scalar;
                          bool aux_QX_read = false;
                          vartype aux_last_type_read_for_QX = UNKNOWN;
                          int var_L_0d_int_Scalar;
                          bool aux_L_read = false;
                          vartype aux_last_type_read_for_L = UNKNOWN;
                          int var_LRX_0d_int_Scalar;
                          bool aux_LRX_read = false;
                          vartype aux_last_type_read_for_LRX = UNKNOWN;
                          int cpp_int_val;
                          bool aux_cpp_int_val_read = false;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int var_NRS_0d_int_Scalar;
                          bool aux_NRS_read = false;
                          vartype aux_last_type_read_for_NRS = UNKNOWN;
                          NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                          vartype aux_last_type_read_for_ER = UNKNOWN;
                          NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                          vartype aux_last_type_read_for_AJ = UNKNOWN;
                          NestedVector<EndfFloatCpp> var_GT_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GT = UNKNOWN;
                          NestedVector<EndfFloatCpp> var_GN_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GN = UNKNOWN;
                          NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GG = UNKNOWN;
                          NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GF = UNKNOWN;
                          cpp_template = "[ MAT , 2 , 151 / AWRI , QX , L , LRX , (6*NRS) , NRS / \n { ER , AJ , GT , GN , GG , GF } { k = 1 to NRS } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          // assign expression to variable AWRI
                          var_AWRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                          aux_AWRI_read = true;
                          validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                          aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                          // assign expression to variable QX
                          var_QX_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                          aux_QX_read = true;
                          validate_vartype_consistency("QX", SCALAR_DOUBLE, aux_last_type_read_for_QX);
                          aux_last_type_read_for_QX = SCALAR_DOUBLE;
                          // assign expression to variable L
                          var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_L_read = true;
                          validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                          aux_last_type_read_for_L = SCALAR_INT;
                          // assign expression to variable LRX
                          var_LRX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LRX_read = true;
                          validate_vartype_consistency("LRX", SCALAR_INT, aux_last_type_read_for_LRX);
                          aux_last_type_read_for_LRX = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NRS
                          var_NRS_0d_int_Scalar = (cpp_int_val/6);
                          aux_NRS_read = true;
                          validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                          aux_last_type_read_for_NRS = SCALAR_INT;
                          if ((! (aux_NRS_read == true))) {
                            // assign expression to variable NRS
                            var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NRS_read = true;
                            validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                            aux_last_type_read_for_NRS = SCALAR_INT;
                          } else {
                            cpp_validate_field(var_NRS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NRS",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable ER
                              var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                              aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable AJ
                              var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                              aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable GT
                              var_GT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                              aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable GN
                              var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                              aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable GG
                              var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                              aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable GF
                              var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                              aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          // store data in Python dictionary
                          if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                            cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_QX == SCALAR_DOUBLE) && (aux_QX_read == true))) {
                            cpp_current_dict["QX"] = var_QX_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                            cpp_current_dict["L"] = var_L_0d_int_Scalar;
                          }
                          if (((aux_last_type_read_for_LRX == SCALAR_INT) && (aux_LRX_read == true))) {
                            cpp_current_dict["LRX"] = var_LRX_0d_int_Scalar;
                          }
                          if (((aux_last_type_read_for_NRS == SCALAR_INT) && (aux_NRS_read == true))) {
                            cpp_current_dict["NRS"] = var_NRS_0d_int_Scalar;
                          }
                          if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                            cpp_current_dict["ER"] = var_ER_1d_double_NestedVector.to_pyobj(list_mode);
                          }
                          if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                            cpp_current_dict["AJ"] = var_AJ_1d_double_NestedVector.to_pyobj(list_mode);
                          }
                          if ((var_GT_1d_double_NestedVector.get_last_index() != -1)) {
                            cpp_current_dict["GT"] = var_GT_1d_double_NestedVector.to_pyobj(list_mode);
                          }
                          if ((var_GN_1d_double_NestedVector.get_last_index() != -1)) {
                            cpp_current_dict["GN"] = var_GN_1d_double_NestedVector.to_pyobj(list_mode);
                          }
                          if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                            cpp_current_dict["GG"] = var_GG_1d_double_NestedVector.to_pyobj(list_mode);
                          }
                          if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
                            cpp_current_dict["GF"] = var_GF_1d_double_NestedVector.to_pyobj(list_mode);
                          }
                          cpp_current_dict = cpp_parent_dict;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if ((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(3)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                              // read TAB1 record
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              {
                                Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                                // assign expression to variable Eint
                                var_Eint_0d_floatvec_Scalar = tab_body.X;
                                aux_Eint_read = true;
                                validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                                aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                                if ((! (aux_AP_read == true))) {
                                  // assign expression to variable AP
                                  var_AP_0d_floatvec_Scalar = tab_body.Y;
                                  aux_AP_read = true;
                                  validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                  aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                                } else {
                                  if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                    cpp_validate_field(var_AP_0d_double_Scalar, tab_body.Y,  true, false, false, "AP",
                                      cpp_template, cpp_line, parse_opts);
                                  } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                    cpp_validate_field(var_AP_0d_floatvec_Scalar, tab_body.Y,  true, false, false, "AP",
                                      cpp_template, cpp_line, parse_opts);
                                  }
                                }
                                // assign expression to variable INT
                                var_INT_0d_intvec_Scalar = tab_body.INT;
                                aux_INT_read = true;
                                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                aux_last_type_read_for_INT = SCALAR_INTVEC;
                                // assign expression to variable NBT
                                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                aux_NBT_read = true;
                                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                aux_last_type_read_for_NBT = SCALAR_INTVEC;
                              }
                            }
                          }
                        }
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , LAD , 0 , NLS , NLSC ] CONT";
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read CONT record
                              if ((! (aux_SPI_read == true))) {
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              } else {
                                cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                  cpp_template, cpp_line, parse_opts);
                              }
                              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable LAD
                              var_LAD_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                              aux_LAD_read = true;
                              validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                              aux_last_type_read_for_LAD = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              if ((! (aux_NLS_read == true))) {
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } else {
                                cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                  cpp_template, cpp_line, parse_opts);
                              }
                              // assign expression to variable NLSC
                              var_NLSC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              aux_NLSC_read = true;
                              validate_vartype_consistency("NLSC", SCALAR_INT, aux_last_type_read_for_NLSC);
                              aux_last_type_read_for_NLSC = SCALAR_INT;
                            }
                          }
                          if (! cpp_found_match) {
                            cpp_template = "[ MAT , 2 , 151 / SPI , AP , LAD , 0 , NLS , NLSC ] CONT";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read CONT record
                            if ((! (aux_SPI_read == true))) {
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                            } else {
                              cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                cpp_template, cpp_line, parse_opts);
                            }
                            if ((! (aux_AP_read == true))) {
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                            } else {
                              if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                cpp_validate_field(var_AP_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                  cpp_template, cpp_line, parse_opts);
                              } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                cpp_validate_field(var_AP_0d_floatvec_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                  cpp_template, cpp_line, parse_opts);
                              }
                            }
                            // assign expression to variable LAD
                            var_LAD_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_LAD_read = true;
                            validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                            aux_last_type_read_for_LAD = SCALAR_INT;
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            if ((! (aux_NLS_read == true))) {
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                cpp_template, cpp_line, parse_opts);
                            }
                            // assign expression to variable NLSC
                            var_NLSC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NLSC_read = true;
                            validate_vartype_consistency("NLSC", SCALAR_INT, aux_last_type_read_for_NLSC);
                            aux_last_type_read_for_NLSC = SCALAR_INT;
                          }
                        }

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // open section spingroup
                          {
                            py::dict cpp_parent_dict = cpp_current_dict;
                            cpp_current_dict = cpp_index_shifter_store.setdefault("spingroup", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                            // variable declarations
                            EndfFloatCpp var_AWRI_0d_double_Scalar;
                            bool aux_AWRI_read = false;
                            vartype aux_last_type_read_for_AWRI = UNKNOWN;
                            EndfFloatCpp var_APL_0d_double_Scalar;
                            bool aux_APL_read = false;
                            vartype aux_last_type_read_for_APL = UNKNOWN;
                            int var_L_0d_int_Scalar;
                            bool aux_L_read = false;
                            vartype aux_last_type_read_for_L = UNKNOWN;
                            int cpp_int_val;
                            bool aux_cpp_int_val_read = false;
                            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                            int var_NRS_0d_int_Scalar;
                            bool aux_NRS_read = false;
                            vartype aux_last_type_read_for_NRS = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                            vartype aux_last_type_read_for_ER = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                            vartype aux_last_type_read_for_AJ = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_GN_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GN = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GG = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_GFA_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GFA = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_GFB_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GFB = UNKNOWN;
                            cpp_template = "[ MAT , 2 , 151 / AWRI , APL , L , 0 , (6*NRS) , NRS / \n { ER , AJ , GN , GG , GFA , GFB } { k = 1 to NRS } ] LIST";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST record
                            // assign expression to variable AWRI
                            var_AWRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                            aux_AWRI_read = true;
                            validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                            aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                            // assign expression to variable APL
                            var_APL_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                            aux_APL_read = true;
                            validate_vartype_consistency("APL", SCALAR_DOUBLE, aux_last_type_read_for_APL);
                            aux_last_type_read_for_APL = SCALAR_DOUBLE;
                            // assign expression to variable L
                            var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_L_read = true;
                            validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                            aux_last_type_read_for_L = SCALAR_INT;
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NRS
                            var_NRS_0d_int_Scalar = (cpp_int_val/6);
                            aux_NRS_read = true;
                            validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                            aux_last_type_read_for_NRS = SCALAR_INT;
                            if ((! (aux_NRS_read == true))) {
                              // assign expression to variable NRS
                              var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              aux_NRS_read = true;
                              validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                              aux_last_type_read_for_NRS = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NRS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NRS",
                                cpp_template, cpp_line, parse_opts);
                            }
                            {
                              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read LIST body

                              for (int var_k_0d_int_Scalar = 1;
                                 var_k_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                                bool aux_k_read = true;
                                // read LIST body
                                // assign expression to variable ER
                                var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                                aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable AJ
                                var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                                aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable GN
                                var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                                aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable GG
                                var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                                aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable GFA
                                var_GFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("GFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFA);
                                aux_last_type_read_for_GFA = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable GFB
                                var_GFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("GFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFB);
                                aux_last_type_read_for_GFB = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            // store data in Python dictionary
                            if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                              cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_APL == SCALAR_DOUBLE) && (aux_APL_read == true))) {
                              cpp_current_dict["APL"] = var_APL_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                              cpp_current_dict["L"] = var_L_0d_int_Scalar;
                            }
                            if (((aux_last_type_read_for_NRS == SCALAR_INT) && (aux_NRS_read == true))) {
                              cpp_current_dict["NRS"] = var_NRS_0d_int_Scalar;
                            }
                            if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["ER"] = var_ER_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["AJ"] = var_AJ_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_GN_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["GN"] = var_GN_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["GG"] = var_GG_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_GFA_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["GFA"] = var_GFA_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_GFB_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["GFB"] = var_GFB_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            cpp_current_dict = cpp_parent_dict;
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if ((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(7)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , IFG , KRM , NJS , KRL ] CONT";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read CONT record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable IFG
                        var_IFG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_IFG_read = true;
                        validate_vartype_consistency("IFG", SCALAR_INT, aux_last_type_read_for_IFG);
                        aux_last_type_read_for_IFG = SCALAR_INT;
                        // assign expression to variable KRM
                        var_KRM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_KRM_read = true;
                        validate_vartype_consistency("KRM", SCALAR_INT, aux_last_type_read_for_KRM);
                        aux_last_type_read_for_KRM = SCALAR_INT;
                        // assign expression to variable NJS
                        var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_NJS_read = true;
                        validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                        aux_last_type_read_for_NJS = SCALAR_INT;
                        // assign expression to variable KRL
                        var_KRL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_KRL_read = true;
                        validate_vartype_consistency("KRL", SCALAR_INT, aux_last_type_read_for_KRL);
                        aux_last_type_read_for_KRL = SCALAR_INT;
                        cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , NPP , 0 , (12*NPP) , (2*NPP) / \n { MA , MB , ZA , ZB , IA , IB , \n Q , PNT , SHF , MT , PA , PB } { k = 1 to NPP } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable NPP
                        var_NPP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_NPP_read = true;
                        validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                        aux_last_type_read_for_NPP = SCALAR_INT;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        if ((! (aux_NPP_read == true))) {
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NPP
                          var_NPP_0d_int_Scalar = (cpp_int_val/12);
                          aux_NPP_read = true;
                          validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                          aux_last_type_read_for_NPP = SCALAR_INT;
                        } else {
                          cpp_validate_field((12*var_NPP_0d_int_Scalar), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(12*NPP)",
                            cpp_template, cpp_line, parse_opts);
                        }
                        if ((! (aux_NPP_read == true))) {
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NPP
                          var_NPP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NPP_read = true;
                          validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                          aux_last_type_read_for_NPP = SCALAR_INT;
                        } else {
                          cpp_validate_field((2*var_NPP_0d_int_Scalar), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "(2*NPP)",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NPP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable MA
                            var_MA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("MA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MA);
                            aux_last_type_read_for_MA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable MB
                            var_MB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("MB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MB);
                            aux_last_type_read_for_MB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable ZA
                            var_ZA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("ZA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZA);
                            aux_last_type_read_for_ZA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable ZB
                            var_ZB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("ZB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZB);
                            aux_last_type_read_for_ZB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable IA
                            var_IA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("IA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IA);
                            aux_last_type_read_for_IA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable IB
                            var_IB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("IB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IB);
                            aux_last_type_read_for_IB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable Q
                            var_Q_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Q", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Q);
                            aux_last_type_read_for_Q = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable PNT
                            var_PNT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("PNT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PNT);
                            aux_last_type_read_for_PNT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable SHF
                            var_SHF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("SHF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SHF);
                            aux_last_type_read_for_SHF = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable MT
                            var_MT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("MT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MT);
                            aux_last_type_read_for_MT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable PA
                            var_PA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("PA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PA);
                            aux_last_type_read_for_PA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable PB
                            var_PB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("PB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PB);
                            aux_last_type_read_for_PB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }

                        for (int var_k_0d_int_Scalar = 1;
                           var_k_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                          bool aux_k_read = true;
                          // open section spingroup
                          {
                            py::dict cpp_parent_dict = cpp_current_dict;
                            cpp_current_dict = cpp_index_shifter_store.setdefault("spingroup", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                            // variable declarations
                            EndfFloatCpp var_AJ_0d_double_Scalar;
                            bool aux_AJ_read = false;
                            vartype aux_last_type_read_for_AJ = UNKNOWN;
                            EndfFloatCpp var_PJ_0d_double_Scalar;
                            bool aux_PJ_read = false;
                            vartype aux_last_type_read_for_PJ = UNKNOWN;
                            int var_KBK_0d_int_Scalar;
                            bool aux_KBK_read = false;
                            vartype aux_last_type_read_for_KBK = UNKNOWN;
                            int var_KPS_0d_int_Scalar;
                            bool aux_KPS_read = false;
                            vartype aux_last_type_read_for_KPS = UNKNOWN;
                            int cpp_int_val;
                            bool aux_cpp_int_val_read = false;
                            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                            int var_NCH_0d_int_Scalar;
                            bool aux_NCH_read = false;
                            vartype aux_last_type_read_for_NCH = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_PPI_1d_double_NestedVector;
                            vartype aux_last_type_read_for_PPI = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_L_1d_double_NestedVector;
                            vartype aux_last_type_read_for_L = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_SCH_1d_double_NestedVector;
                            vartype aux_last_type_read_for_SCH = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_BND_1d_double_NestedVector;
                            vartype aux_last_type_read_for_BND = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_APE_1d_double_NestedVector;
                            vartype aux_last_type_read_for_APE = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_APT_1d_double_NestedVector;
                            vartype aux_last_type_read_for_APT = UNKNOWN;
                            int var_NRS_0d_int_Scalar;
                            bool aux_NRS_read = false;
                            vartype aux_last_type_read_for_NRS = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                            vartype aux_last_type_read_for_ER = UNKNOWN;
                            Matrix2d<EndfFloatCpp> var_GAM_2d_double_Matrix2d;
                            vartype aux_last_type_read_for_GAM = UNKNOWN;
                            int var_NX_0d_int_Scalar;
                            bool aux_NX_read = false;
                            vartype aux_last_type_read_for_NX = UNKNOWN;
                            int var_LCH_0d_int_Scalar;
                            bool aux_LCH_read = false;
                            vartype aux_last_type_read_for_LCH = UNKNOWN;
                            int var_LBK_0d_int_Scalar;
                            bool aux_LBK_read = false;
                            vartype aux_last_type_read_for_LBK = UNKNOWN;
                            EndfFloatCpp var_ED_0d_double_Scalar;
                            bool aux_ED_read = false;
                            vartype aux_last_type_read_for_ED = UNKNOWN;
                            EndfFloatCpp var_EU_0d_double_Scalar;
                            bool aux_EU_read = false;
                            vartype aux_last_type_read_for_EU = UNKNOWN;
                            EndfFloatCpp var_R0_0d_double_Scalar;
                            bool aux_R0_read = false;
                            vartype aux_last_type_read_for_R0 = UNKNOWN;
                            EndfFloatCpp var_R1_0d_double_Scalar;
                            bool aux_R1_read = false;
                            vartype aux_last_type_read_for_R1 = UNKNOWN;
                            EndfFloatCpp var_R2_0d_double_Scalar;
                            bool aux_R2_read = false;
                            vartype aux_last_type_read_for_R2 = UNKNOWN;
                            EndfFloatCpp var_S0_0d_double_Scalar;
                            bool aux_S0_read = false;
                            vartype aux_last_type_read_for_S0 = UNKNOWN;
                            EndfFloatCpp var_S1_0d_double_Scalar;
                            bool aux_S1_read = false;
                            vartype aux_last_type_read_for_S1 = UNKNOWN;
                            EndfFloatCpp var_GA_0d_double_Scalar;
                            bool aux_GA_read = false;
                            vartype aux_last_type_read_for_GA = UNKNOWN;
                            int var_LPS_0d_int_Scalar;
                            bool aux_LPS_read = false;
                            vartype aux_last_type_read_for_LPS = UNKNOWN;
                            cpp_template = "[ MAT , 2 , 151 / AJ , PJ , KBK , KPS , (6*NCH) , NCH / \n { PPI , L , SCH , BND , APE , APT } { l = 1 to NCH } ] LIST";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST record
                            // assign expression to variable AJ
                            var_AJ_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                            aux_AJ_read = true;
                            validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                            aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                            // assign expression to variable PJ
                            var_PJ_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                            aux_PJ_read = true;
                            validate_vartype_consistency("PJ", SCALAR_DOUBLE, aux_last_type_read_for_PJ);
                            aux_last_type_read_for_PJ = SCALAR_DOUBLE;
                            // assign expression to variable KBK
                            var_KBK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_KBK_read = true;
                            validate_vartype_consistency("KBK", SCALAR_INT, aux_last_type_read_for_KBK);
                            aux_last_type_read_for_KBK = SCALAR_INT;
                            // assign expression to variable KPS
                            var_KPS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                            aux_KPS_read = true;
                            validate_vartype_consistency("KPS", SCALAR_INT, aux_last_type_read_for_KPS);
                            aux_last_type_read_for_KPS = SCALAR_INT;
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NCH
                            var_NCH_0d_int_Scalar = (cpp_int_val/6);
                            aux_NCH_read = true;
                            validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                            aux_last_type_read_for_NCH = SCALAR_INT;
                            if ((! (aux_NCH_read == true))) {
                              // assign expression to variable NCH
                              var_NCH_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              aux_NCH_read = true;
                              validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                              aux_last_type_read_for_NCH = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NCH_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NCH",
                                cpp_template, cpp_line, parse_opts);
                            }
                            {
                              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read LIST body

                              for (int var_l_0d_int_Scalar = 1;
                                 var_l_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_l_0d_int_Scalar++) {
                                bool aux_l_read = true;
                                // read LIST body
                                // assign expression to variable PPI
                                var_PPI_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("PPI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PPI);
                                aux_last_type_read_for_PPI = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable L
                                var_L_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("L", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_L);
                                aux_last_type_read_for_L = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable SCH
                                var_SCH_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("SCH", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SCH);
                                aux_last_type_read_for_SCH = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable BND
                                var_BND_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("BND", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BND);
                                aux_last_type_read_for_BND = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable APE
                                var_APE_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("APE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APE);
                                aux_last_type_read_for_APE = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable APT
                                var_APT_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("APT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APT);
                                aux_last_type_read_for_APT = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            // evaluate if-elif-else clause
                            {
                              bool cpp_found_match = false;
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  std::streampos cpp_old_streampos = cont.tellg();
                                  {
                                    // variable declarations
                                    EndfFloatCpp& glob_var_AJ_0d_double_Scalar = var_AJ_0d_double_Scalar;
                                    EndfFloatCpp var_AJ_0d_double_Scalar = glob_var_AJ_0d_double_Scalar;
                                    bool& glob_aux_AJ_read = aux_AJ_read;
                                    bool aux_AJ_read = glob_aux_AJ_read;
                                    vartype aux_last_type_read_for_AJ = UNKNOWN;
                                    EndfFloatCpp& glob_var_PJ_0d_double_Scalar = var_PJ_0d_double_Scalar;
                                    EndfFloatCpp var_PJ_0d_double_Scalar = glob_var_PJ_0d_double_Scalar;
                                    bool& glob_aux_PJ_read = aux_PJ_read;
                                    bool aux_PJ_read = glob_aux_PJ_read;
                                    vartype aux_last_type_read_for_PJ = UNKNOWN;
                                    int& glob_var_KBK_0d_int_Scalar = var_KBK_0d_int_Scalar;
                                    int var_KBK_0d_int_Scalar = glob_var_KBK_0d_int_Scalar;
                                    bool& glob_aux_KBK_read = aux_KBK_read;
                                    bool aux_KBK_read = glob_aux_KBK_read;
                                    vartype aux_last_type_read_for_KBK = UNKNOWN;
                                    int& glob_var_KPS_0d_int_Scalar = var_KPS_0d_int_Scalar;
                                    int var_KPS_0d_int_Scalar = glob_var_KPS_0d_int_Scalar;
                                    bool& glob_aux_KPS_read = aux_KPS_read;
                                    bool aux_KPS_read = glob_aux_KPS_read;
                                    vartype aux_last_type_read_for_KPS = UNKNOWN;
                                    int& glob_cpp_int_val = cpp_int_val;
                                    int cpp_int_val = glob_cpp_int_val;
                                    bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                                    bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                                    vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                    int& glob_var_NCH_0d_int_Scalar = var_NCH_0d_int_Scalar;
                                    int var_NCH_0d_int_Scalar = glob_var_NCH_0d_int_Scalar;
                                    bool& glob_aux_NCH_read = aux_NCH_read;
                                    bool aux_NCH_read = glob_aux_NCH_read;
                                    vartype aux_last_type_read_for_NCH = UNKNOWN;
                                    NestedVector<EndfFloatCpp>& glob_var_PPI_1d_double_NestedVector = var_PPI_1d_double_NestedVector;
                                    NestedVector<EndfFloatCpp> var_PPI_1d_double_NestedVector = glob_var_PPI_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_PPI = UNKNOWN;
                                    NestedVector<EndfFloatCpp>& glob_var_L_1d_double_NestedVector = var_L_1d_double_NestedVector;
                                    NestedVector<EndfFloatCpp> var_L_1d_double_NestedVector = glob_var_L_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_L = UNKNOWN;
                                    NestedVector<EndfFloatCpp>& glob_var_SCH_1d_double_NestedVector = var_SCH_1d_double_NestedVector;
                                    NestedVector<EndfFloatCpp> var_SCH_1d_double_NestedVector = glob_var_SCH_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_SCH = UNKNOWN;
                                    NestedVector<EndfFloatCpp>& glob_var_BND_1d_double_NestedVector = var_BND_1d_double_NestedVector;
                                    NestedVector<EndfFloatCpp> var_BND_1d_double_NestedVector = glob_var_BND_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_BND = UNKNOWN;
                                    NestedVector<EndfFloatCpp>& glob_var_APE_1d_double_NestedVector = var_APE_1d_double_NestedVector;
                                    NestedVector<EndfFloatCpp> var_APE_1d_double_NestedVector = glob_var_APE_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_APE = UNKNOWN;
                                    NestedVector<EndfFloatCpp>& glob_var_APT_1d_double_NestedVector = var_APT_1d_double_NestedVector;
                                    NestedVector<EndfFloatCpp> var_APT_1d_double_NestedVector = glob_var_APT_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_APT = UNKNOWN;
                                    int& glob_var_NRS_0d_int_Scalar = var_NRS_0d_int_Scalar;
                                    int var_NRS_0d_int_Scalar = glob_var_NRS_0d_int_Scalar;
                                    bool& glob_aux_NRS_read = aux_NRS_read;
                                    bool aux_NRS_read = glob_aux_NRS_read;
                                    vartype aux_last_type_read_for_NRS = UNKNOWN;
                                    try {
                                      cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*NX) , NX / \n { ER , { GAM } { m = 1 to NCH } , \n { 0.0 } { p = 1 to num_zeros } } { n = 1 to NRS } ] LIST";
                                      cpp_line = cpp_read_raw_line(cont);
                                      // read LIST record
                                      // assign expression to variable NRS
                                      var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                                      aux_NRS_read = true;
                                      validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                      aux_last_type_read_for_NRS = SCALAR_INT;
                                      if ((! (aux_NCH_read == true))) {
                                        throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NCH because the modulo operator is not supported.");
                                      } else {
                                      }
                                      if ((! (aux_NRS_read == true))) {
                                        throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NRS because the modulo operator is not supported.");
                                      } else {
                                      }
                                      if ((! (aux_NCH_read == true))) {
                                        throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NCH because the modulo operator is not supported.");
                                      } else {
                                      }
                                      if ((! (aux_NRS_read == true))) {
                                        throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NRS because the modulo operator is not supported.");
                                      } else {
                                      }
                                    } catch (const std::out_of_range& e) {
                                      // // accept failure in lookahead
                                    }
                                    if ((((((((aux_NRS_read == true)) && ((var_NRS_0d_int_Scalar)>(0)))))))) {
                                      cpp_found_match = true;
                                    }
                                    cont.seekg(cpp_old_streampos);
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*((((1+NCH)+((5-NCH)%6))*NRS)/6)) , ((((1+NCH)+((5-NCH)%6))*NRS)/6) / \n { ER , { GAM } { m = 1 to NCH } , \n { 0.0 } { p = 1 to num_zeros } } { n = 1 to NRS } ] LIST";
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST record
                                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    // assign expression to variable NRS
                                    var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                                    aux_NRS_read = true;
                                    validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                    aux_last_type_read_for_NRS = SCALAR_INT;
                                    if ((! (aux_NCH_read == true))) {
                                      throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NCH because the modulo operator is not supported.");
                                    } else {
                                      cpp_validate_field((6*((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRS_0d_int_Scalar)/6)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(6*((((1+NCH)+((5-NCH)%6))*NRS)/6))",
                                        cpp_template, cpp_line, parse_opts);
                                    }
                                    if ((! (aux_NRS_read == true))) {
                                      throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NRS because the modulo operator is not supported.");
                                    } else {
                                      cpp_validate_field((6*((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRS_0d_int_Scalar)/6)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(6*((((1+NCH)+((5-NCH)%6))*NRS)/6))",
                                        cpp_template, cpp_line, parse_opts);
                                    }
                                    if ((! (aux_NCH_read == true))) {
                                      throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NCH because the modulo operator is not supported.");
                                    } else {
                                      cpp_validate_field(((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRS_0d_int_Scalar)/6), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "((((1+NCH)+((5-NCH)%6))*NRS)/6)",
                                        cpp_template, cpp_line, parse_opts);
                                    }
                                    if ((! (aux_NRS_read == true))) {
                                      throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NRS because the modulo operator is not supported.");
                                    } else {
                                      cpp_validate_field(((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRS_0d_int_Scalar)/6), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "((((1+NCH)+((5-NCH)%6))*NRS)/6)",
                                        cpp_template, cpp_line, parse_opts);
                                    }
                                    {
                                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      // read LIST body
                                      var_GAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRS_0d_int_Scalar, false, false);

                                      for (int var_n_0d_int_Scalar = 1;
                                         var_n_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                        bool aux_n_read = true;
                                        // read LIST body
                                        // assign expression to variable ER
                                        var_ER_1d_double_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                        validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                                        aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                                        cpp_i++;
                                        cpp_j++;
                                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                          cpp_j = 0;
                                        }

                                        for (int var_m_0d_int_Scalar = 1;
                                           var_m_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                          bool aux_m_read = true;
                                          // read LIST body
                                          // assign expression to variable GAM
                                          var_GAM_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                          validate_vartype_consistency("GAM", MATRIX2D_DOUBLE, aux_last_type_read_for_GAM);
                                          aux_last_type_read_for_GAM = MATRIX2D_DOUBLE;
                                          cpp_i++;
                                          cpp_j++;
                                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                            cpp_j = 0;
                                          }
                                        }

                                        for (int var_p_0d_int_Scalar = 1;
                                           var_p_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_p_0d_int_Scalar++) {
                                          bool aux_p_read = true;
                                          // read LIST body
                                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_i++;
                                          cpp_j++;
                                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                            cpp_j = 0;
                                          }
                                        }
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                  }
                                }
                              }
                              if (! cpp_found_match) {
                                if (! cpp_found_match) {
                                  // if statement evaluation with lookahead
                                  {
                                    std::streampos cpp_old_streampos = cont.tellg();
                                    {
                                      // variable declarations
                                      EndfFloatCpp& glob_var_AJ_0d_double_Scalar = var_AJ_0d_double_Scalar;
                                      EndfFloatCpp var_AJ_0d_double_Scalar = glob_var_AJ_0d_double_Scalar;
                                      bool& glob_aux_AJ_read = aux_AJ_read;
                                      bool aux_AJ_read = glob_aux_AJ_read;
                                      vartype aux_last_type_read_for_AJ = UNKNOWN;
                                      EndfFloatCpp& glob_var_PJ_0d_double_Scalar = var_PJ_0d_double_Scalar;
                                      EndfFloatCpp var_PJ_0d_double_Scalar = glob_var_PJ_0d_double_Scalar;
                                      bool& glob_aux_PJ_read = aux_PJ_read;
                                      bool aux_PJ_read = glob_aux_PJ_read;
                                      vartype aux_last_type_read_for_PJ = UNKNOWN;
                                      int& glob_var_KBK_0d_int_Scalar = var_KBK_0d_int_Scalar;
                                      int var_KBK_0d_int_Scalar = glob_var_KBK_0d_int_Scalar;
                                      bool& glob_aux_KBK_read = aux_KBK_read;
                                      bool aux_KBK_read = glob_aux_KBK_read;
                                      vartype aux_last_type_read_for_KBK = UNKNOWN;
                                      int& glob_var_KPS_0d_int_Scalar = var_KPS_0d_int_Scalar;
                                      int var_KPS_0d_int_Scalar = glob_var_KPS_0d_int_Scalar;
                                      bool& glob_aux_KPS_read = aux_KPS_read;
                                      bool aux_KPS_read = glob_aux_KPS_read;
                                      vartype aux_last_type_read_for_KPS = UNKNOWN;
                                      int& glob_cpp_int_val = cpp_int_val;
                                      int cpp_int_val = glob_cpp_int_val;
                                      bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                                      bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                      int& glob_var_NCH_0d_int_Scalar = var_NCH_0d_int_Scalar;
                                      int var_NCH_0d_int_Scalar = glob_var_NCH_0d_int_Scalar;
                                      bool& glob_aux_NCH_read = aux_NCH_read;
                                      bool aux_NCH_read = glob_aux_NCH_read;
                                      vartype aux_last_type_read_for_NCH = UNKNOWN;
                                      NestedVector<EndfFloatCpp>& glob_var_PPI_1d_double_NestedVector = var_PPI_1d_double_NestedVector;
                                      NestedVector<EndfFloatCpp> var_PPI_1d_double_NestedVector = glob_var_PPI_1d_double_NestedVector;
                                      vartype aux_last_type_read_for_PPI = UNKNOWN;
                                      NestedVector<EndfFloatCpp>& glob_var_L_1d_double_NestedVector = var_L_1d_double_NestedVector;
                                      NestedVector<EndfFloatCpp> var_L_1d_double_NestedVector = glob_var_L_1d_double_NestedVector;
                                      vartype aux_last_type_read_for_L = UNKNOWN;
                                      NestedVector<EndfFloatCpp>& glob_var_SCH_1d_double_NestedVector = var_SCH_1d_double_NestedVector;
                                      NestedVector<EndfFloatCpp> var_SCH_1d_double_NestedVector = glob_var_SCH_1d_double_NestedVector;
                                      vartype aux_last_type_read_for_SCH = UNKNOWN;
                                      NestedVector<EndfFloatCpp>& glob_var_BND_1d_double_NestedVector = var_BND_1d_double_NestedVector;
                                      NestedVector<EndfFloatCpp> var_BND_1d_double_NestedVector = glob_var_BND_1d_double_NestedVector;
                                      vartype aux_last_type_read_for_BND = UNKNOWN;
                                      NestedVector<EndfFloatCpp>& glob_var_APE_1d_double_NestedVector = var_APE_1d_double_NestedVector;
                                      NestedVector<EndfFloatCpp> var_APE_1d_double_NestedVector = glob_var_APE_1d_double_NestedVector;
                                      vartype aux_last_type_read_for_APE = UNKNOWN;
                                      NestedVector<EndfFloatCpp>& glob_var_APT_1d_double_NestedVector = var_APT_1d_double_NestedVector;
                                      NestedVector<EndfFloatCpp> var_APT_1d_double_NestedVector = glob_var_APT_1d_double_NestedVector;
                                      vartype aux_last_type_read_for_APT = UNKNOWN;
                                      int& glob_var_NRS_0d_int_Scalar = var_NRS_0d_int_Scalar;
                                      int var_NRS_0d_int_Scalar = glob_var_NRS_0d_int_Scalar;
                                      bool& glob_aux_NRS_read = aux_NRS_read;
                                      bool aux_NRS_read = glob_aux_NRS_read;
                                      vartype aux_last_type_read_for_NRS = UNKNOWN;
                                      int& glob_var_NX_0d_int_Scalar = var_NX_0d_int_Scalar;
                                      int var_NX_0d_int_Scalar = glob_var_NX_0d_int_Scalar;
                                      bool& glob_aux_NX_read = aux_NX_read;
                                      bool aux_NX_read = glob_aux_NX_read;
                                      vartype aux_last_type_read_for_NX = UNKNOWN;
                                      try {
                                        cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*NX) , NX / \n { 0.0 } { m = 1 to 6 } ] LIST";
                                        cpp_line = cpp_read_raw_line(cont);
                                        // read LIST record
                                        // assign expression to variable NRS
                                        var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                                        aux_NRS_read = true;
                                        validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                        aux_last_type_read_for_NRS = SCALAR_INT;
                                        // assign expression to variable cpp_int_val
                                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                        aux_cpp_int_val_read = true;
                                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                        // assign expression to variable NX
                                        var_NX_0d_int_Scalar = (cpp_int_val/6);
                                        aux_NX_read = true;
                                        validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                        aux_last_type_read_for_NX = SCALAR_INT;
                                        if ((! (aux_NX_read == true))) {
                                          // assign expression to variable NX
                                          var_NX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                                          aux_NX_read = true;
                                          validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                          aux_last_type_read_for_NX = SCALAR_INT;
                                        } else {
                                        }
                                      } catch (const std::out_of_range& e) {
                                        // // accept failure in lookahead
                                      }
                                      if (((((((((aux_NRS_read == true)) && ((var_NRS_0d_int_Scalar)==(0)))))&&((((aux_NX_read == true)) && ((var_NX_0d_int_Scalar)==(1)))))))) {
                                        cpp_found_match = true;
                                      }
                                      cont.seekg(cpp_old_streampos);
                                    }
                                    if (cpp_found_match) {
                                      cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*NX) , NX / \n { 0.0 } { m = 1 to 6 } ] LIST";
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      // read LIST record
                                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                        cpp_template, cpp_line, parse_opts);
                                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                        cpp_template, cpp_line, parse_opts);
                                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                        cpp_template, cpp_line, parse_opts);
                                      // assign expression to variable NRS
                                      var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                                      aux_NRS_read = true;
                                      validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                      aux_last_type_read_for_NRS = SCALAR_INT;
                                      // assign expression to variable cpp_int_val
                                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      aux_cpp_int_val_read = true;
                                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                      // assign expression to variable NX
                                      var_NX_0d_int_Scalar = (cpp_int_val/6);
                                      aux_NX_read = true;
                                      validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                      aux_last_type_read_for_NX = SCALAR_INT;
                                      if ((! (aux_NX_read == true))) {
                                        // assign expression to variable NX
                                        var_NX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                                        aux_NX_read = true;
                                        validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                        aux_last_type_read_for_NX = SCALAR_INT;
                                      } else {
                                        cpp_validate_field(var_NX_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NX",
                                          cpp_template, cpp_line, parse_opts);
                                      }
                                      {
                                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                        int cpp_i = 0;
                                        int cpp_j = 0;
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        // read LIST body

                                        for (int var_m_0d_int_Scalar = 1;
                                           var_m_0d_int_Scalar <= 6; var_m_0d_int_Scalar++) {
                                          bool aux_m_read = true;
                                          // read LIST body
                                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_i++;
                                          cpp_j++;
                                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                            cpp_j = 0;
                                          }
                                        }
                                        if (cpp_i != cpp_npl) {
                                          throw std::runtime_error("not exactly NPL elements consumed");
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            // evaluate if-elif-else clause
                            {
                              bool cpp_found_match = false;
                              if (! cpp_found_match) {
                                if ((((((((aux_KBK_read == true)) && ((var_KBK_0d_int_Scalar)>(0)))))))) {
                                  // if statement evaluation
                                  cpp_found_match = true;

                                  for (int var_n_0d_int_Scalar = 1;
                                     var_n_0d_int_Scalar <= var_KBK_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                    bool aux_n_read = true;
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , LCH , LBK , 0 , 0 ] CONT";
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read CONT record
                                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    // assign expression to variable LCH
                                    var_LCH_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                                    aux_LCH_read = true;
                                    validate_vartype_consistency("LCH", SCALAR_INT, aux_last_type_read_for_LCH);
                                    aux_last_type_read_for_LCH = SCALAR_INT;
                                    // assign expression to variable LBK
                                    var_LBK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                                    aux_LBK_read = true;
                                    validate_vartype_consistency("LBK", SCALAR_INT, aux_last_type_read_for_LBK);
                                    aux_last_type_read_for_LBK = SCALAR_INT;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    // evaluate if-elif-else clause
                                    {
                                      bool cpp_found_match = false;
                                      if (! cpp_found_match) {
                                        if ((((((((aux_LBK_read == true)) && ((var_LBK_0d_int_Scalar)==(1)))))))) {
                                          // if statement evaluation
                                          cpp_found_match = true;
                                          cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , LCH , LBK , 0 , 0 ] CONT";
                                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                          // read CONT record
                                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                            cpp_template, cpp_line, parse_opts);
                                          if ((! (aux_LCH_read == true))) {
                                            // assign expression to variable LCH
                                            var_LCH_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                                            aux_LCH_read = true;
                                            validate_vartype_consistency("LCH", SCALAR_INT, aux_last_type_read_for_LCH);
                                            aux_last_type_read_for_LCH = SCALAR_INT;
                                          } else {
                                            cpp_validate_field(var_LCH_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "LCH",
                                              cpp_template, cpp_line, parse_opts);
                                          }
                                          if ((! (aux_LBK_read == true))) {
                                            // assign expression to variable LBK
                                            var_LBK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                                            aux_LBK_read = true;
                                            validate_vartype_consistency("LBK", SCALAR_INT, aux_last_type_read_for_LBK);
                                            aux_last_type_read_for_LBK = SCALAR_INT;
                                          } else {
                                            cpp_validate_field(var_LBK_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  true, false, false, "LBK",
                                              cpp_template, cpp_line, parse_opts);
                                          }
                                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / E / RBR ] TAB1 ( real_part [ n ] )";
                                          // read TAB1 record
                                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                            cpp_template, cpp_line, parse_opts);
                                          {
                                            py::dict cpp_parent_dict = cpp_current_dict;
                                            cpp_current_dict = cpp_index_shifter_store.setdefault("real_part", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
                                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                                            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                            cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                                            // variable declarations
                                            std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                                            bool aux_E_read = false;
                                            vartype aux_last_type_read_for_E = UNKNOWN;
                                            std::vector<EndfFloatCpp> var_RBR_0d_floatvec_Scalar;
                                            bool aux_RBR_read = false;
                                            vartype aux_last_type_read_for_RBR = UNKNOWN;
                                            std::vector<int> var_INT_0d_intvec_Scalar;
                                            bool aux_INT_read = false;
                                            vartype aux_last_type_read_for_INT = UNKNOWN;
                                            std::vector<int> var_NBT_0d_intvec_Scalar;
                                            bool aux_NBT_read = false;
                                            vartype aux_last_type_read_for_NBT = UNKNOWN;
                                            {
                                              Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                                              // assign expression to variable E
                                              var_E_0d_floatvec_Scalar = tab_body.X;
                                              aux_E_read = true;
                                              validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                                              aux_last_type_read_for_E = SCALAR_FLOATVEC;
                                              // assign expression to variable RBR
                                              var_RBR_0d_floatvec_Scalar = tab_body.Y;
                                              aux_RBR_read = true;
                                              validate_vartype_consistency("RBR", SCALAR_FLOATVEC, aux_last_type_read_for_RBR);
                                              aux_last_type_read_for_RBR = SCALAR_FLOATVEC;
                                              // assign expression to variable INT
                                              var_INT_0d_intvec_Scalar = tab_body.INT;
                                              aux_INT_read = true;
                                              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                              aux_last_type_read_for_INT = SCALAR_INTVEC;
                                              // assign expression to variable NBT
                                              var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                              aux_NBT_read = true;
                                              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                              aux_last_type_read_for_NBT = SCALAR_INTVEC;
                                            }
                                            // store data in Python dictionary
                                            if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                                              cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                                            }
                                            if (((aux_last_type_read_for_RBR == SCALAR_FLOATVEC) && (aux_RBR_read == true))) {
                                              cpp_current_dict["RBR"] = var_RBR_0d_floatvec_Scalar;
                                            }
                                            if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                                              cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                                            }
                                            if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                                              cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                                            }
                                            cpp_current_dict = cpp_parent_dict;
                                          }
                                          cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / E / RBI ] TAB1 ( imag_part [ n ] )";
                                          // read TAB1 record
                                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                            cpp_template, cpp_line, parse_opts);
                                          {
                                            py::dict cpp_parent_dict = cpp_current_dict;
                                            cpp_current_dict = cpp_index_shifter_store.setdefault("imag_part", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
                                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                                            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                            cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                                            // variable declarations
                                            std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                                            bool aux_E_read = false;
                                            vartype aux_last_type_read_for_E = UNKNOWN;
                                            std::vector<EndfFloatCpp> var_RBI_0d_floatvec_Scalar;
                                            bool aux_RBI_read = false;
                                            vartype aux_last_type_read_for_RBI = UNKNOWN;
                                            std::vector<int> var_INT_0d_intvec_Scalar;
                                            bool aux_INT_read = false;
                                            vartype aux_last_type_read_for_INT = UNKNOWN;
                                            std::vector<int> var_NBT_0d_intvec_Scalar;
                                            bool aux_NBT_read = false;
                                            vartype aux_last_type_read_for_NBT = UNKNOWN;
                                            {
                                              Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                                              // assign expression to variable E
                                              var_E_0d_floatvec_Scalar = tab_body.X;
                                              aux_E_read = true;
                                              validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                                              aux_last_type_read_for_E = SCALAR_FLOATVEC;
                                              // assign expression to variable RBI
                                              var_RBI_0d_floatvec_Scalar = tab_body.Y;
                                              aux_RBI_read = true;
                                              validate_vartype_consistency("RBI", SCALAR_FLOATVEC, aux_last_type_read_for_RBI);
                                              aux_last_type_read_for_RBI = SCALAR_FLOATVEC;
                                              // assign expression to variable INT
                                              var_INT_0d_intvec_Scalar = tab_body.INT;
                                              aux_INT_read = true;
                                              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                              aux_last_type_read_for_INT = SCALAR_INTVEC;
                                              // assign expression to variable NBT
                                              var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                              aux_NBT_read = true;
                                              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                              aux_last_type_read_for_NBT = SCALAR_INTVEC;
                                            }
                                            // store data in Python dictionary
                                            if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                                              cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                                            }
                                            if (((aux_last_type_read_for_RBI == SCALAR_FLOATVEC) && (aux_RBI_read == true))) {
                                              cpp_current_dict["RBI"] = var_RBI_0d_floatvec_Scalar;
                                            }
                                            if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                                              cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                                            }
                                            if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                                              cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                                            }
                                            cpp_current_dict = cpp_parent_dict;
                                          }
                                        }
                                      }
                                      if (! cpp_found_match) {
                                        if (! cpp_found_match) {
                                          if ((((((((aux_LBK_read == true)) && ((var_LBK_0d_int_Scalar)==(2)))))))) {
                                            // if statement evaluation
                                            cpp_found_match = true;
                                            cpp_template = "[ MAT , 2 , 151 / ED , EU , 0 , 0 , 5 , 0 / R0 , R1 , R2 , S0 , S1 ] LIST";
                                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                            // read LIST record
                                            // assign expression to variable ED
                                            var_ED_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                            aux_ED_read = true;
                                            validate_vartype_consistency("ED", SCALAR_DOUBLE, aux_last_type_read_for_ED);
                                            aux_last_type_read_for_ED = SCALAR_DOUBLE;
                                            // assign expression to variable EU
                                            var_EU_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                            aux_EU_read = true;
                                            validate_vartype_consistency("EU", SCALAR_DOUBLE, aux_last_type_read_for_EU);
                                            aux_last_type_read_for_EU = SCALAR_DOUBLE;
                                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                              cpp_template, cpp_line, parse_opts);
                                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                              cpp_template, cpp_line, parse_opts);
                                            cpp_validate_field(5, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "5",
                                              cpp_template, cpp_line, parse_opts);
                                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                              cpp_template, cpp_line, parse_opts);
                                            {
                                              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                              int cpp_i = 0;
                                              int cpp_j = 0;
                                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                              // read LIST body
                                              // assign expression to variable R0
                                              var_R0_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                              aux_R0_read = true;
                                              validate_vartype_consistency("R0", SCALAR_DOUBLE, aux_last_type_read_for_R0);
                                              aux_last_type_read_for_R0 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                                cpp_j = 0;
                                              }
                                              // assign expression to variable R1
                                              var_R1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                              aux_R1_read = true;
                                              validate_vartype_consistency("R1", SCALAR_DOUBLE, aux_last_type_read_for_R1);
                                              aux_last_type_read_for_R1 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                                cpp_j = 0;
                                              }
                                              // assign expression to variable R2
                                              var_R2_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                              aux_R2_read = true;
                                              validate_vartype_consistency("R2", SCALAR_DOUBLE, aux_last_type_read_for_R2);
                                              aux_last_type_read_for_R2 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                                cpp_j = 0;
                                              }
                                              // assign expression to variable S0
                                              var_S0_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                              aux_S0_read = true;
                                              validate_vartype_consistency("S0", SCALAR_DOUBLE, aux_last_type_read_for_S0);
                                              aux_last_type_read_for_S0 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                                cpp_j = 0;
                                              }
                                              // assign expression to variable S1
                                              var_S1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                              aux_S1_read = true;
                                              validate_vartype_consistency("S1", SCALAR_DOUBLE, aux_last_type_read_for_S1);
                                              aux_last_type_read_for_S1 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                                cpp_j = 0;
                                              }
                                              if (cpp_i != cpp_npl) {
                                                throw std::runtime_error("not exactly NPL elements consumed");
                                              }
                                            }
                                          }
                                        }
                                      }
                                      if (! cpp_found_match) {
                                        if (! cpp_found_match) {
                                          if ((((((((aux_LBK_read == true)) && ((var_LBK_0d_int_Scalar)==(3)))))))) {
                                            // if statement evaluation
                                            cpp_found_match = true;
                                            cpp_template = "[ MAT , 2 , 151 / ED , EU , 0 , 0 , 3 , 0 / R0 , S0 , GA ] LIST";
                                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                            // read LIST record
                                            // assign expression to variable ED
                                            var_ED_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                            aux_ED_read = true;
                                            validate_vartype_consistency("ED", SCALAR_DOUBLE, aux_last_type_read_for_ED);
                                            aux_last_type_read_for_ED = SCALAR_DOUBLE;
                                            // assign expression to variable EU
                                            var_EU_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                            aux_EU_read = true;
                                            validate_vartype_consistency("EU", SCALAR_DOUBLE, aux_last_type_read_for_EU);
                                            aux_last_type_read_for_EU = SCALAR_DOUBLE;
                                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                              cpp_template, cpp_line, parse_opts);
                                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                              cpp_template, cpp_line, parse_opts);
                                            cpp_validate_field(3, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "3",
                                              cpp_template, cpp_line, parse_opts);
                                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                              cpp_template, cpp_line, parse_opts);
                                            {
                                              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                              int cpp_i = 0;
                                              int cpp_j = 0;
                                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                              // read LIST body
                                              // assign expression to variable R0
                                              var_R0_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                              aux_R0_read = true;
                                              validate_vartype_consistency("R0", SCALAR_DOUBLE, aux_last_type_read_for_R0);
                                              aux_last_type_read_for_R0 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                                cpp_j = 0;
                                              }
                                              // assign expression to variable S0
                                              var_S0_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                              aux_S0_read = true;
                                              validate_vartype_consistency("S0", SCALAR_DOUBLE, aux_last_type_read_for_S0);
                                              aux_last_type_read_for_S0 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                                cpp_j = 0;
                                              }
                                              // assign expression to variable GA
                                              var_GA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                              aux_GA_read = true;
                                              validate_vartype_consistency("GA", SCALAR_DOUBLE, aux_last_type_read_for_GA);
                                              aux_last_type_read_for_GA = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                                cpp_j = 0;
                                              }
                                              if (cpp_i != cpp_npl) {
                                                throw std::runtime_error("not exactly NPL elements consumed");
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            // evaluate if-elif-else clause
                            {
                              bool cpp_found_match = false;
                              if (! cpp_found_match) {
                                if ((((((((aux_KPS_read == true)) && ((var_KPS_0d_int_Scalar)>(0)))))))) {
                                  // if statement evaluation
                                  cpp_found_match = true;

                                  for (int var_n_0d_int_Scalar = 1;
                                     var_n_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                    bool aux_n_read = true;
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , LPS , 1 / \n 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ] LIST";
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST record
                                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    // assign expression to variable LPS
                                    var_LPS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_LPS_read = true;
                                    validate_vartype_consistency("LPS", SCALAR_INT, aux_last_type_read_for_LPS);
                                    aux_last_type_read_for_LPS = SCALAR_INT;
                                    cpp_validate_field(1, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "1",
                                      cpp_template, cpp_line, parse_opts);
                                    {
                                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      // read LIST body
                                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                        cpp_template, cpp_line, parse_opts);
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                        cpp_template, cpp_line, parse_opts);
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                        cpp_template, cpp_line, parse_opts);
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                        cpp_template, cpp_line, parse_opts);
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                        cpp_template, cpp_line, parse_opts);
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                        cpp_template, cpp_line, parse_opts);
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                    // evaluate if-elif-else clause
                                    {
                                      bool cpp_found_match = false;
                                      if (! cpp_found_match) {
                                        if ((((((((aux_LPS_read == true)) && ((var_LPS_0d_int_Scalar)==(1)))))))) {
                                          // if statement evaluation
                                          cpp_found_match = true;
                                          cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / E / PSR ] TAB1 ( real_part [ n ] )";
                                          // read TAB1 record
                                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                            cpp_template, cpp_line, parse_opts);
                                          {
                                            py::dict cpp_parent_dict = cpp_current_dict;
                                            cpp_current_dict = cpp_index_shifter_store.setdefault("real_part", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
                                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                                            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                            cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                                            // variable declarations
                                            std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                                            bool aux_E_read = false;
                                            vartype aux_last_type_read_for_E = UNKNOWN;
                                            std::vector<EndfFloatCpp> var_PSR_0d_floatvec_Scalar;
                                            bool aux_PSR_read = false;
                                            vartype aux_last_type_read_for_PSR = UNKNOWN;
                                            std::vector<int> var_INT_0d_intvec_Scalar;
                                            bool aux_INT_read = false;
                                            vartype aux_last_type_read_for_INT = UNKNOWN;
                                            std::vector<int> var_NBT_0d_intvec_Scalar;
                                            bool aux_NBT_read = false;
                                            vartype aux_last_type_read_for_NBT = UNKNOWN;
                                            {
                                              Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                                              // assign expression to variable E
                                              var_E_0d_floatvec_Scalar = tab_body.X;
                                              aux_E_read = true;
                                              validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                                              aux_last_type_read_for_E = SCALAR_FLOATVEC;
                                              // assign expression to variable PSR
                                              var_PSR_0d_floatvec_Scalar = tab_body.Y;
                                              aux_PSR_read = true;
                                              validate_vartype_consistency("PSR", SCALAR_FLOATVEC, aux_last_type_read_for_PSR);
                                              aux_last_type_read_for_PSR = SCALAR_FLOATVEC;
                                              // assign expression to variable INT
                                              var_INT_0d_intvec_Scalar = tab_body.INT;
                                              aux_INT_read = true;
                                              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                              aux_last_type_read_for_INT = SCALAR_INTVEC;
                                              // assign expression to variable NBT
                                              var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                              aux_NBT_read = true;
                                              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                              aux_last_type_read_for_NBT = SCALAR_INTVEC;
                                            }
                                            // store data in Python dictionary
                                            if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                                              cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                                            }
                                            if (((aux_last_type_read_for_PSR == SCALAR_FLOATVEC) && (aux_PSR_read == true))) {
                                              cpp_current_dict["PSR"] = var_PSR_0d_floatvec_Scalar;
                                            }
                                            if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                                              cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                                            }
                                            if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                                              cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                                            }
                                            cpp_current_dict = cpp_parent_dict;
                                          }
                                          cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / E / PSI ] TAB1 ( imag_part [ n ] )";
                                          // read TAB1 record
                                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                            cpp_template, cpp_line, parse_opts);
                                          {
                                            py::dict cpp_parent_dict = cpp_current_dict;
                                            cpp_current_dict = cpp_index_shifter_store.setdefault("imag_part", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
                                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                                            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                            cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                                            // variable declarations
                                            std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                                            bool aux_E_read = false;
                                            vartype aux_last_type_read_for_E = UNKNOWN;
                                            std::vector<EndfFloatCpp> var_PSI_0d_floatvec_Scalar;
                                            bool aux_PSI_read = false;
                                            vartype aux_last_type_read_for_PSI = UNKNOWN;
                                            std::vector<int> var_INT_0d_intvec_Scalar;
                                            bool aux_INT_read = false;
                                            vartype aux_last_type_read_for_INT = UNKNOWN;
                                            std::vector<int> var_NBT_0d_intvec_Scalar;
                                            bool aux_NBT_read = false;
                                            vartype aux_last_type_read_for_NBT = UNKNOWN;
                                            {
                                              Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                                              // assign expression to variable E
                                              var_E_0d_floatvec_Scalar = tab_body.X;
                                              aux_E_read = true;
                                              validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                                              aux_last_type_read_for_E = SCALAR_FLOATVEC;
                                              // assign expression to variable PSI
                                              var_PSI_0d_floatvec_Scalar = tab_body.Y;
                                              aux_PSI_read = true;
                                              validate_vartype_consistency("PSI", SCALAR_FLOATVEC, aux_last_type_read_for_PSI);
                                              aux_last_type_read_for_PSI = SCALAR_FLOATVEC;
                                              // assign expression to variable INT
                                              var_INT_0d_intvec_Scalar = tab_body.INT;
                                              aux_INT_read = true;
                                              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                              aux_last_type_read_for_INT = SCALAR_INTVEC;
                                              // assign expression to variable NBT
                                              var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                              aux_NBT_read = true;
                                              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                              aux_last_type_read_for_NBT = SCALAR_INTVEC;
                                            }
                                            // store data in Python dictionary
                                            if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                                              cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                                            }
                                            if (((aux_last_type_read_for_PSI == SCALAR_FLOATVEC) && (aux_PSI_read == true))) {
                                              cpp_current_dict["PSI"] = var_PSI_0d_floatvec_Scalar;
                                            }
                                            if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                                              cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                                            }
                                            if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                                              cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                                            }
                                            cpp_current_dict = cpp_parent_dict;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            // store data in Python dictionary
                            if (((aux_last_type_read_for_AJ == SCALAR_DOUBLE) && (aux_AJ_read == true))) {
                              cpp_current_dict["AJ"] = var_AJ_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_PJ == SCALAR_DOUBLE) && (aux_PJ_read == true))) {
                              cpp_current_dict["PJ"] = var_PJ_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_KBK == SCALAR_INT) && (aux_KBK_read == true))) {
                              cpp_current_dict["KBK"] = var_KBK_0d_int_Scalar;
                            }
                            if (((aux_last_type_read_for_KPS == SCALAR_INT) && (aux_KPS_read == true))) {
                              cpp_current_dict["KPS"] = var_KPS_0d_int_Scalar;
                            }
                            if (((aux_last_type_read_for_NCH == SCALAR_INT) && (aux_NCH_read == true))) {
                              cpp_current_dict["NCH"] = var_NCH_0d_int_Scalar;
                            }
                            if ((var_PPI_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["PPI"] = var_PPI_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_L_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["L"] = var_L_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_SCH_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["SCH"] = var_SCH_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_BND_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["BND"] = var_BND_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_APE_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["APE"] = var_APE_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_APT_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["APT"] = var_APT_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if (((aux_last_type_read_for_NRS == SCALAR_INT) && (aux_NRS_read == true))) {
                              cpp_current_dict["NRS"] = var_NRS_0d_int_Scalar;
                            }
                            if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["ER"] = var_ER_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if (var_GAM_2d_double_Matrix2d.did_read()) {
                              cpp_current_dict["GAM"] = var_GAM_2d_double_Matrix2d.to_pyobj(list_mode);
                            }
                            if (((aux_last_type_read_for_NX == SCALAR_INT) && (aux_NX_read == true))) {
                              cpp_current_dict["NX"] = var_NX_0d_int_Scalar;
                            }
                            if (((aux_last_type_read_for_LCH == SCALAR_INT) && (aux_LCH_read == true))) {
                              cpp_current_dict["LCH"] = var_LCH_0d_int_Scalar;
                            }
                            if (((aux_last_type_read_for_LBK == SCALAR_INT) && (aux_LBK_read == true))) {
                              cpp_current_dict["LBK"] = var_LBK_0d_int_Scalar;
                            }
                            if (((aux_last_type_read_for_ED == SCALAR_DOUBLE) && (aux_ED_read == true))) {
                              cpp_current_dict["ED"] = var_ED_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_EU == SCALAR_DOUBLE) && (aux_EU_read == true))) {
                              cpp_current_dict["EU"] = var_EU_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_R0 == SCALAR_DOUBLE) && (aux_R0_read == true))) {
                              cpp_current_dict["R0"] = var_R0_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_R1 == SCALAR_DOUBLE) && (aux_R1_read == true))) {
                              cpp_current_dict["R1"] = var_R1_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_R2 == SCALAR_DOUBLE) && (aux_R2_read == true))) {
                              cpp_current_dict["R2"] = var_R2_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_S0 == SCALAR_DOUBLE) && (aux_S0_read == true))) {
                              cpp_current_dict["S0"] = var_S0_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_S1 == SCALAR_DOUBLE) && (aux_S1_read == true))) {
                              cpp_current_dict["S1"] = var_S1_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_GA == SCALAR_DOUBLE) && (aux_GA_read == true))) {
                              cpp_current_dict["GA"] = var_GA_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_LPS == SCALAR_INT) && (aux_LPS_read == true))) {
                              cpp_current_dict["LPS"] = var_LPS_0d_int_Scalar;
                            }
                            cpp_current_dict = cpp_parent_dict;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                if ((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(2)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  // evaluate if-elif-else clause
                  {
                    bool cpp_found_match = false;
                    if (! cpp_found_match) {
                      if (((((((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(0)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                              // read TAB1 record
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              {
                                Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                                // assign expression to variable Eint
                                var_Eint_0d_floatvec_Scalar = tab_body.X;
                                aux_Eint_read = true;
                                validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                                aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                                if ((! (aux_AP_read == true))) {
                                  // assign expression to variable AP
                                  var_AP_0d_floatvec_Scalar = tab_body.Y;
                                  aux_AP_read = true;
                                  validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                  aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                                } else {
                                  if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                    cpp_validate_field(var_AP_0d_double_Scalar, tab_body.Y,  true, false, false, "AP",
                                      cpp_template, cpp_line, parse_opts);
                                  } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                    cpp_validate_field(var_AP_0d_floatvec_Scalar, tab_body.Y,  true, false, false, "AP",
                                      cpp_template, cpp_line, parse_opts);
                                  }
                                }
                                // assign expression to variable INT
                                var_INT_0d_intvec_Scalar = tab_body.INT;
                                aux_INT_read = true;
                                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                aux_last_type_read_for_INT = SCALAR_INTVEC;
                                // assign expression to variable NBT
                                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                aux_NBT_read = true;
                                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                aux_last_type_read_for_NBT = SCALAR_INTVEC;
                              }
                            }
                          }
                        }
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , LSSF , 0 , NLS , 0 ] CONT";
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read CONT record
                              if ((! (aux_SPI_read == true))) {
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              } else {
                                cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                  cpp_template, cpp_line, parse_opts);
                              }
                              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable LSSF
                              var_LSSF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                              aux_LSSF_read = true;
                              validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                              aux_last_type_read_for_LSSF = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              if ((! (aux_NLS_read == true))) {
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } else {
                                cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                  cpp_template, cpp_line, parse_opts);
                              }
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                            }
                          }
                          if (! cpp_found_match) {
                            cpp_template = "[ MAT , 2 , 151 / SPI , AP , LSSF , 0 , NLS , 0 ] CONT";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read CONT record
                            if ((! (aux_SPI_read == true))) {
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                            } else {
                              cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                cpp_template, cpp_line, parse_opts);
                            }
                            if ((! (aux_AP_read == true))) {
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                            } else {
                              if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                cpp_validate_field(var_AP_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                  cpp_template, cpp_line, parse_opts);
                              } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                cpp_validate_field(var_AP_0d_floatvec_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                  cpp_template, cpp_line, parse_opts);
                              }
                            }
                            // assign expression to variable LSSF
                            var_LSSF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_LSSF_read = true;
                            validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                            aux_last_type_read_for_LSSF = SCALAR_INT;
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            if ((! (aux_NLS_read == true))) {
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                cpp_template, cpp_line, parse_opts);
                            }
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                          }
                        }

                        for (int var_p_0d_int_Scalar = 1;
                           var_p_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                          bool aux_p_read = true;
                          // open section l_group
                          {
                            py::dict cpp_parent_dict = cpp_current_dict;
                            cpp_current_dict = cpp_index_shifter_store.setdefault("l_group", std::vector<int>({var_p_0d_int_Scalar}), py::dict());
                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                            // variable declarations
                            EndfFloatCpp var_AWRI_0d_double_Scalar;
                            bool aux_AWRI_read = false;
                            vartype aux_last_type_read_for_AWRI = UNKNOWN;
                            int var_L_0d_int_Scalar;
                            bool aux_L_read = false;
                            vartype aux_last_type_read_for_L = UNKNOWN;
                            int cpp_int_val;
                            bool aux_cpp_int_val_read = false;
                            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                            int var_NJS_0d_int_Scalar;
                            bool aux_NJS_read = false;
                            vartype aux_last_type_read_for_NJS = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_D_1d_double_NestedVector;
                            vartype aux_last_type_read_for_D = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                            vartype aux_last_type_read_for_AJ = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_AMUN_1d_double_NestedVector;
                            vartype aux_last_type_read_for_AMUN = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_GN0_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GN0 = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GG = UNKNOWN;
                            cpp_template = "[ MAT , 2 , 151 / AWRI , 0.0 , L , 0 , (6*NJS) , NJS / \n { D , AJ , AMUN , GN0 , GG , 0.0 } { m = 1 to NJS } ] LIST";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST record
                            // assign expression to variable AWRI
                            var_AWRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                            aux_AWRI_read = true;
                            validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                            aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                              cpp_template, cpp_line, parse_opts);
                            // assign expression to variable L
                            var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_L_read = true;
                            validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                            aux_last_type_read_for_L = SCALAR_INT;
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NJS
                            var_NJS_0d_int_Scalar = (cpp_int_val/6);
                            aux_NJS_read = true;
                            validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                            aux_last_type_read_for_NJS = SCALAR_INT;
                            if ((! (aux_NJS_read == true))) {
                              // assign expression to variable NJS
                              var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              aux_NJS_read = true;
                              validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                              aux_last_type_read_for_NJS = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NJS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NJS",
                                cpp_template, cpp_line, parse_opts);
                            }
                            {
                              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read LIST body

                              for (int var_m_0d_int_Scalar = 1;
                                 var_m_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                bool aux_m_read = true;
                                // read LIST body
                                // assign expression to variable D
                                var_D_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("D", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_D);
                                aux_last_type_read_for_D = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable AJ
                                var_AJ_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                                aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable AMUN
                                var_AMUN_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("AMUN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AMUN);
                                aux_last_type_read_for_AMUN = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable GN0
                                var_GN0_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("GN0", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN0);
                                aux_last_type_read_for_GN0 = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable GG
                                var_GG_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                                aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                  cpp_template, cpp_line, parse_opts);
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            // store data in Python dictionary
                            if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                              cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                              cpp_current_dict["L"] = var_L_0d_int_Scalar;
                            }
                            if (((aux_last_type_read_for_NJS == SCALAR_INT) && (aux_NJS_read == true))) {
                              cpp_current_dict["NJS"] = var_NJS_0d_int_Scalar;
                            }
                            if ((var_D_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["D"] = var_D_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["AJ"] = var_AJ_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_AMUN_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["AMUN"] = var_AMUN_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_GN0_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["GN0"] = var_GN0_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["GG"] = var_GG_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            cpp_current_dict = cpp_parent_dict;
                          }
                        }
                      }
                    }
                    if (! cpp_found_match) {
                      if (! cpp_found_match) {
                        if (((((((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 2 , 151 / SPI , AP , LSSF , 0 , NE , NLS / \n { ES } { p = 1 to NE } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          if ((! (aux_SPI_read == true))) {
                            // assign expression to variable SPI
                            var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                            aux_SPI_read = true;
                            validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                            aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                          } else {
                            cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                              cpp_template, cpp_line, parse_opts);
                          }
                          if ((! (aux_AP_read == true))) {
                            // assign expression to variable AP
                            var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                            aux_AP_read = true;
                            validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                            aux_last_type_read_for_AP = SCALAR_DOUBLE;
                          } else {
                            if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                              cpp_validate_field(var_AP_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                cpp_template, cpp_line, parse_opts);
                            } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                              cpp_validate_field(var_AP_0d_floatvec_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                cpp_template, cpp_line, parse_opts);
                            }
                          }
                          // assign expression to variable LSSF
                          var_LSSF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LSSF_read = true;
                          validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                          aux_last_type_read_for_LSSF = SCALAR_INT;
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NLS_read == true))) {
                            // assign expression to variable NLS
                            var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NLS_read = true;
                            validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                            aux_last_type_read_for_NLS = SCALAR_INT;
                          } else {
                            cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NLS",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_p_0d_int_Scalar = 1;
                               var_p_0d_int_Scalar <= var_NE_0d_int_Scalar; var_p_0d_int_Scalar++) {
                              bool aux_p_read = true;
                              // read LIST body
                              // assign expression to variable ES
                              var_ES_1d_double_NestedVector.set(var_p_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                              aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }

                          for (int var_p_0d_int_Scalar = 1;
                             var_p_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                            bool aux_p_read = true;
                            // open section j_group
                            {
                              py::dict cpp_parent_dict = cpp_current_dict;
                              cpp_current_dict = cpp_index_shifter_store.setdefault("j_group", std::vector<int>({var_p_0d_int_Scalar}), py::dict());
                              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                              // variable declarations
                              EndfFloatCpp var_AWRI_0d_double_Scalar;
                              bool aux_AWRI_read = false;
                              vartype aux_last_type_read_for_AWRI = UNKNOWN;
                              int var_L_0d_int_Scalar;
                              bool aux_L_read = false;
                              vartype aux_last_type_read_for_L = UNKNOWN;
                              int var_NJS_0d_int_Scalar;
                              bool aux_NJS_read = false;
                              vartype aux_last_type_read_for_NJS = UNKNOWN;
                              cpp_template = "[ MAT , 2 , 151 / AWRI , 0.0 , L , 0 , NJS , 0 ] CONT";
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read CONT record
                              // assign expression to variable AWRI
                              var_AWRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                              aux_AWRI_read = true;
                              validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                              aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable L
                              var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                              aux_L_read = true;
                              validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                              aux_last_type_read_for_L = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable NJS
                              var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_NJS_read = true;
                              validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                              aux_last_type_read_for_NJS = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // open section subsec
                                {
                                  py::dict cpp_parent_dict = cpp_current_dict;
                                  cpp_current_dict = cpp_index_shifter_store.setdefault("subsec", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
                                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                                  // variable declarations
                                  int var_L_0d_int_Scalar;
                                  bool aux_L_read = false;
                                  vartype aux_last_type_read_for_L = UNKNOWN;
                                  int var_MUF_0d_int_Scalar;
                                  bool aux_MUF_read = false;
                                  vartype aux_last_type_read_for_MUF = UNKNOWN;
                                  int cpp_int_val;
                                  bool aux_cpp_int_val_read = false;
                                  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                  int var_NE_0d_int_Scalar;
                                  bool aux_NE_read = false;
                                  vartype aux_last_type_read_for_NE = UNKNOWN;
                                  EndfFloatCpp var_D_0d_double_Scalar;
                                  bool aux_D_read = false;
                                  vartype aux_last_type_read_for_D = UNKNOWN;
                                  EndfFloatCpp var_AJ_0d_double_Scalar;
                                  bool aux_AJ_read = false;
                                  vartype aux_last_type_read_for_AJ = UNKNOWN;
                                  EndfFloatCpp var_AMUN_0d_double_Scalar;
                                  bool aux_AMUN_read = false;
                                  vartype aux_last_type_read_for_AMUN = UNKNOWN;
                                  EndfFloatCpp var_GN0_0d_double_Scalar;
                                  bool aux_GN0_read = false;
                                  vartype aux_last_type_read_for_GN0 = UNKNOWN;
                                  EndfFloatCpp var_GG_0d_double_Scalar;
                                  bool aux_GG_read = false;
                                  vartype aux_last_type_read_for_GG = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GF = UNKNOWN;
                                  cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , L , MUF , (NE+6) , 0 / \n D , AJ , AMUN , GN0 , GG , 0.0 , \n { GF } { m = 1 to NE } ] LIST";
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  // read LIST record
                                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                    cpp_template, cpp_line, parse_opts);
                                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                    cpp_template, cpp_line, parse_opts);
                                  if ((! (aux_L_read == true))) {
                                    // assign expression to variable L
                                    var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                                    aux_L_read = true;
                                    validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                                    aux_last_type_read_for_L = SCALAR_INT;
                                  } else {
                                    cpp_validate_field(var_L_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "L",
                                      cpp_template, cpp_line, parse_opts);
                                  }
                                  // assign expression to variable MUF
                                  var_MUF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                                  aux_MUF_read = true;
                                  validate_vartype_consistency("MUF", SCALAR_INT, aux_last_type_read_for_MUF);
                                  aux_last_type_read_for_MUF = SCALAR_INT;
                                  if ((! (aux_NE_read == true))) {
                                    // assign expression to variable cpp_int_val
                                    cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_cpp_int_val_read = true;
                                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                    // assign expression to variable NE
                                    var_NE_0d_int_Scalar = (cpp_int_val+(-6));
                                    aux_NE_read = true;
                                    validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                                    aux_last_type_read_for_NE = SCALAR_INT;
                                  } else {
                                    cpp_validate_field((var_NE_0d_int_Scalar+6), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(NE+6)",
                                      cpp_template, cpp_line, parse_opts);
                                  }
                                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                    cpp_template, cpp_line, parse_opts);
                                  {
                                    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    int cpp_i = 0;
                                    int cpp_j = 0;
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST body
                                    // assign expression to variable D
                                    var_D_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_D_read = true;
                                    validate_vartype_consistency("D", SCALAR_DOUBLE, aux_last_type_read_for_D);
                                    aux_last_type_read_for_D = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable AJ
                                    var_AJ_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_AJ_read = true;
                                    validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                                    aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable AMUN
                                    var_AMUN_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_AMUN_read = true;
                                    validate_vartype_consistency("AMUN", SCALAR_DOUBLE, aux_last_type_read_for_AMUN);
                                    aux_last_type_read_for_AMUN = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable GN0
                                    var_GN0_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_GN0_read = true;
                                    validate_vartype_consistency("GN0", SCALAR_DOUBLE, aux_last_type_read_for_GN0);
                                    aux_last_type_read_for_GN0 = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable GG
                                    var_GG_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_GG_read = true;
                                    validate_vartype_consistency("GG", SCALAR_DOUBLE, aux_last_type_read_for_GG);
                                    aux_last_type_read_for_GG = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }

                                    for (int var_m_0d_int_Scalar = 1;
                                       var_m_0d_int_Scalar <= var_NE_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                      bool aux_m_read = true;
                                      // read LIST body
                                      // assign expression to variable GF
                                      var_GF_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                                      aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                    }
                                    if (cpp_i != cpp_npl) {
                                      throw std::runtime_error("not exactly NPL elements consumed");
                                    }
                                  }
                                  // store data in Python dictionary
                                  if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                                    cpp_current_dict["L"] = var_L_0d_int_Scalar;
                                  }
                                  if (((aux_last_type_read_for_MUF == SCALAR_INT) && (aux_MUF_read == true))) {
                                    cpp_current_dict["MUF"] = var_MUF_0d_int_Scalar;
                                  }
                                  if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
                                    cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
                                  }
                                  if (((aux_last_type_read_for_D == SCALAR_DOUBLE) && (aux_D_read == true))) {
                                    cpp_current_dict["D"] = var_D_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_AJ == SCALAR_DOUBLE) && (aux_AJ_read == true))) {
                                    cpp_current_dict["AJ"] = var_AJ_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_AMUN == SCALAR_DOUBLE) && (aux_AMUN_read == true))) {
                                    cpp_current_dict["AMUN"] = var_AMUN_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_GN0 == SCALAR_DOUBLE) && (aux_GN0_read == true))) {
                                    cpp_current_dict["GN0"] = var_GN0_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_GG == SCALAR_DOUBLE) && (aux_GG_read == true))) {
                                    cpp_current_dict["GG"] = var_GG_0d_double_Scalar;
                                  }
                                  if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
                                    cpp_current_dict["GF"] = var_GF_1d_double_NestedVector.to_pyobj(list_mode);
                                  }
                                  cpp_current_dict = cpp_parent_dict;
                                }
                              }
                              // store data in Python dictionary
                              if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                                cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                              }
                              if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                                cpp_current_dict["L"] = var_L_0d_int_Scalar;
                              }
                              if (((aux_last_type_read_for_NJS == SCALAR_INT) && (aux_NJS_read == true))) {
                                cpp_current_dict["NJS"] = var_NJS_0d_int_Scalar;
                              }
                              cpp_current_dict = cpp_parent_dict;
                            }
                          }
                        }
                      }
                    }
                    if (! cpp_found_match) {
                      if (! cpp_found_match) {
                        if ((((((((((((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(0))))))||(((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(1)))))))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          // evaluate if-elif-else clause
                          {
                            bool cpp_found_match = false;
                            if (! cpp_found_match) {
                              if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                                // if statement evaluation
                                cpp_found_match = true;
                                cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                                // read TAB1 record
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                  cpp_template, cpp_line, parse_opts);
                                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                  cpp_template, cpp_line, parse_opts);
                                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                  cpp_template, cpp_line, parse_opts);
                                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                  cpp_template, cpp_line, parse_opts);
                                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                                {
                                  Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                                  // assign expression to variable Eint
                                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                                  aux_Eint_read = true;
                                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                                  if ((! (aux_AP_read == true))) {
                                    // assign expression to variable AP
                                    var_AP_0d_floatvec_Scalar = tab_body.Y;
                                    aux_AP_read = true;
                                    validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                    aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                                  } else {
                                    if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                      cpp_validate_field(var_AP_0d_double_Scalar, tab_body.Y,  true, false, false, "AP",
                                        cpp_template, cpp_line, parse_opts);
                                    } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                      cpp_validate_field(var_AP_0d_floatvec_Scalar, tab_body.Y,  true, false, false, "AP",
                                        cpp_template, cpp_line, parse_opts);
                                    }
                                  }
                                  // assign expression to variable INT
                                  var_INT_0d_intvec_Scalar = tab_body.INT;
                                  aux_INT_read = true;
                                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                                  // assign expression to variable NBT
                                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                  aux_NBT_read = true;
                                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                                }
                              }
                            }
                          }
                          // evaluate if-elif-else clause
                          {
                            bool cpp_found_match = false;
                            if (! cpp_found_match) {
                              if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                                // if statement evaluation
                                cpp_found_match = true;
                                cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , LSSF , 0 , NLS , 0 ] CONT";
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                // read CONT record
                                if ((! (aux_SPI_read == true))) {
                                  // assign expression to variable SPI
                                  var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                  aux_SPI_read = true;
                                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                                } else {
                                  cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                    cpp_template, cpp_line, parse_opts);
                                }
                                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                  cpp_template, cpp_line, parse_opts);
                                // assign expression to variable LSSF
                                var_LSSF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                                aux_LSSF_read = true;
                                validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                                aux_last_type_read_for_LSSF = SCALAR_INT;
                                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                  cpp_template, cpp_line, parse_opts);
                                if ((! (aux_NLS_read == true))) {
                                  // assign expression to variable NLS
                                  var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                  aux_NLS_read = true;
                                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                  aux_last_type_read_for_NLS = SCALAR_INT;
                                } else {
                                  cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                    cpp_template, cpp_line, parse_opts);
                                }
                                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                  cpp_template, cpp_line, parse_opts);
                              }
                            }
                            if (! cpp_found_match) {
                              cpp_template = "[ MAT , 2 , 151 / SPI , AP , LSSF , 0 , NLS , 0 ] CONT";
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read CONT record
                              if ((! (aux_SPI_read == true))) {
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              } else {
                                cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                  cpp_template, cpp_line, parse_opts);
                              }
                              if ((! (aux_AP_read == true))) {
                                // assign expression to variable AP
                                var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                aux_AP_read = true;
                                validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                                aux_last_type_read_for_AP = SCALAR_DOUBLE;
                              } else {
                                if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                  cpp_validate_field(var_AP_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                    cpp_template, cpp_line, parse_opts);
                                } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                  cpp_validate_field(var_AP_0d_floatvec_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                    cpp_template, cpp_line, parse_opts);
                                }
                              }
                              // assign expression to variable LSSF
                              var_LSSF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                              aux_LSSF_read = true;
                              validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                              aux_last_type_read_for_LSSF = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              if ((! (aux_NLS_read == true))) {
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } else {
                                cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                  cpp_template, cpp_line, parse_opts);
                              }
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                            }
                          }

                          for (int var_p_0d_int_Scalar = 1;
                             var_p_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                            bool aux_p_read = true;
                            // open section l_group
                            {
                              py::dict cpp_parent_dict = cpp_current_dict;
                              cpp_current_dict = cpp_index_shifter_store.setdefault("l_group", std::vector<int>({var_p_0d_int_Scalar}), py::dict());
                              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                              // variable declarations
                              EndfFloatCpp var_AWRI_0d_double_Scalar;
                              bool aux_AWRI_read = false;
                              vartype aux_last_type_read_for_AWRI = UNKNOWN;
                              int var_L_0d_int_Scalar;
                              bool aux_L_read = false;
                              vartype aux_last_type_read_for_L = UNKNOWN;
                              int var_NJS_0d_int_Scalar;
                              bool aux_NJS_read = false;
                              vartype aux_last_type_read_for_NJS = UNKNOWN;
                              cpp_template = "[ MAT , 2 , 151 / AWRI , 0.0 , L , 0 , NJS , 0 ] CONT";
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read CONT record
                              // assign expression to variable AWRI
                              var_AWRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                              aux_AWRI_read = true;
                              validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                              aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable L
                              var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                              aux_L_read = true;
                              validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                              aux_last_type_read_for_L = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable NJS
                              var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_NJS_read = true;
                              validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                              aux_last_type_read_for_NJS = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // open section subsec
                                {
                                  py::dict cpp_parent_dict = cpp_current_dict;
                                  cpp_current_dict = cpp_index_shifter_store.setdefault("subsec", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
                                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                                  // variable declarations
                                  EndfFloatCpp var_AJ_0d_double_Scalar;
                                  bool aux_AJ_read = false;
                                  vartype aux_last_type_read_for_AJ = UNKNOWN;
                                  int var_INT_0d_int_Scalar;
                                  bool aux_INT_read = false;
                                  vartype aux_last_type_read_for_INT = UNKNOWN;
                                  int cpp_int_val;
                                  bool aux_cpp_int_val_read = false;
                                  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                  int var_NE_0d_int_Scalar;
                                  bool aux_NE_read = false;
                                  vartype aux_last_type_read_for_NE = UNKNOWN;
                                  EndfFloatCpp var_AMUX_0d_double_Scalar;
                                  bool aux_AMUX_read = false;
                                  vartype aux_last_type_read_for_AMUX = UNKNOWN;
                                  EndfFloatCpp var_AMUN_0d_double_Scalar;
                                  bool aux_AMUN_read = false;
                                  vartype aux_last_type_read_for_AMUN = UNKNOWN;
                                  EndfFloatCpp var_AMUG_0d_double_Scalar;
                                  bool aux_AMUG_read = false;
                                  vartype aux_last_type_read_for_AMUG = UNKNOWN;
                                  EndfFloatCpp var_AMUF_0d_double_Scalar;
                                  bool aux_AMUF_read = false;
                                  vartype aux_last_type_read_for_AMUF = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_ES_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_ES = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_D_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_D = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_GX_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GX = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_GN0_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GN0 = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GG = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GF = UNKNOWN;
                                  cpp_template = "[ MAT , 2 , 151 / AJ , 0.0 , INT , 0 , ((6*NE)+6) , NE / \n 0.0 , 0.0 , AMUX , AMUN , AMUG , AMUF , \n { ES , D , GX , GN0 , GG , GF } { m = 1 to NE } ] LIST";
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  // read LIST record
                                  // assign expression to variable AJ
                                  var_AJ_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                  aux_AJ_read = true;
                                  validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                                  aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                    cpp_template, cpp_line, parse_opts);
                                  if ((! (aux_INT_read == true))) {
                                    // assign expression to variable INT
                                    var_INT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                                    aux_INT_read = true;
                                    validate_vartype_consistency("INT", SCALAR_INT, aux_last_type_read_for_INT);
                                    aux_last_type_read_for_INT = SCALAR_INT;
                                  } else {
                                    cpp_validate_field(var_INT_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "INT",
                                      cpp_template, cpp_line, parse_opts);
                                  }
                                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                    cpp_template, cpp_line, parse_opts);
                                  // assign expression to variable cpp_int_val
                                  cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                  aux_cpp_int_val_read = true;
                                  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                  // assign expression to variable NE
                                  var_NE_0d_int_Scalar = ((cpp_int_val+(-6))/6);
                                  aux_NE_read = true;
                                  validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                                  aux_last_type_read_for_NE = SCALAR_INT;
                                  if ((! (aux_NE_read == true))) {
                                    // assign expression to variable NE
                                    var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                                    aux_NE_read = true;
                                    validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                                    aux_last_type_read_for_NE = SCALAR_INT;
                                  } else {
                                    cpp_validate_field(var_NE_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NE",
                                      cpp_template, cpp_line, parse_opts);
                                  }
                                  {
                                    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    int cpp_i = 0;
                                    int cpp_j = 0;
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST body
                                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable AMUX
                                    var_AMUX_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_AMUX_read = true;
                                    validate_vartype_consistency("AMUX", SCALAR_DOUBLE, aux_last_type_read_for_AMUX);
                                    aux_last_type_read_for_AMUX = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable AMUN
                                    var_AMUN_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_AMUN_read = true;
                                    validate_vartype_consistency("AMUN", SCALAR_DOUBLE, aux_last_type_read_for_AMUN);
                                    aux_last_type_read_for_AMUN = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable AMUG
                                    var_AMUG_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_AMUG_read = true;
                                    validate_vartype_consistency("AMUG", SCALAR_DOUBLE, aux_last_type_read_for_AMUG);
                                    aux_last_type_read_for_AMUG = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable AMUF
                                    var_AMUF_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_AMUF_read = true;
                                    validate_vartype_consistency("AMUF", SCALAR_DOUBLE, aux_last_type_read_for_AMUF);
                                    aux_last_type_read_for_AMUF = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }

                                    for (int var_m_0d_int_Scalar = 1;
                                       var_m_0d_int_Scalar <= var_NE_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                      bool aux_m_read = true;
                                      // read LIST body
                                      // assign expression to variable ES
                                      var_ES_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                                      aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable D
                                      var_D_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("D", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_D);
                                      aux_last_type_read_for_D = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable GX
                                      var_GX_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("GX", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GX);
                                      aux_last_type_read_for_GX = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable GN0
                                      var_GN0_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("GN0", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN0);
                                      aux_last_type_read_for_GN0 = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable GG
                                      var_GG_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                                      aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable GF
                                      var_GF_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                                      aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                    }
                                    if (cpp_i != cpp_npl) {
                                      throw std::runtime_error("not exactly NPL elements consumed");
                                    }
                                  }
                                  // store data in Python dictionary
                                  if (((aux_last_type_read_for_AJ == SCALAR_DOUBLE) && (aux_AJ_read == true))) {
                                    cpp_current_dict["AJ"] = var_AJ_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_INT == SCALAR_INT) && (aux_INT_read == true))) {
                                    cpp_current_dict["INT"] = var_INT_0d_int_Scalar;
                                  }
                                  if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
                                    cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
                                  }
                                  if (((aux_last_type_read_for_AMUX == SCALAR_DOUBLE) && (aux_AMUX_read == true))) {
                                    cpp_current_dict["AMUX"] = var_AMUX_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_AMUN == SCALAR_DOUBLE) && (aux_AMUN_read == true))) {
                                    cpp_current_dict["AMUN"] = var_AMUN_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_AMUG == SCALAR_DOUBLE) && (aux_AMUG_read == true))) {
                                    cpp_current_dict["AMUG"] = var_AMUG_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_AMUF == SCALAR_DOUBLE) && (aux_AMUF_read == true))) {
                                    cpp_current_dict["AMUF"] = var_AMUF_0d_double_Scalar;
                                  }
                                  if ((var_ES_1d_double_NestedVector.get_last_index() != -1)) {
                                    cpp_current_dict["ES"] = var_ES_1d_double_NestedVector.to_pyobj(list_mode);
                                  }
                                  if ((var_D_1d_double_NestedVector.get_last_index() != -1)) {
                                    cpp_current_dict["D"] = var_D_1d_double_NestedVector.to_pyobj(list_mode);
                                  }
                                  if ((var_GX_1d_double_NestedVector.get_last_index() != -1)) {
                                    cpp_current_dict["GX"] = var_GX_1d_double_NestedVector.to_pyobj(list_mode);
                                  }
                                  if ((var_GN0_1d_double_NestedVector.get_last_index() != -1)) {
                                    cpp_current_dict["GN0"] = var_GN0_1d_double_NestedVector.to_pyobj(list_mode);
                                  }
                                  if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                                    cpp_current_dict["GG"] = var_GG_1d_double_NestedVector.to_pyobj(list_mode);
                                  }
                                  if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
                                    cpp_current_dict["GF"] = var_GF_1d_double_NestedVector.to_pyobj(list_mode);
                                  }
                                  cpp_current_dict = cpp_parent_dict;
                                }
                              }
                              // store data in Python dictionary
                              if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                                cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                              }
                              if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                                cpp_current_dict["L"] = var_L_0d_int_Scalar;
                              }
                              if (((aux_last_type_read_for_NJS == SCALAR_INT) && (aux_NJS_read == true))) {
                                cpp_current_dict["NJS"] = var_NJS_0d_int_Scalar;
                              }
                              cpp_current_dict = cpp_parent_dict;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_EL == SCALAR_DOUBLE) && (aux_EL_read == true))) {
            cpp_current_dict["EL"] = var_EL_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_EH == SCALAR_DOUBLE) && (aux_EH_read == true))) {
            cpp_current_dict["EH"] = var_EH_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_LRU == SCALAR_INT) && (aux_LRU_read == true))) {
            cpp_current_dict["LRU"] = var_LRU_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_LRF == SCALAR_INT) && (aux_LRF_read == true))) {
            cpp_current_dict["LRF"] = var_LRF_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NRO == SCALAR_INT) && (aux_NRO_read == true))) {
            cpp_current_dict["NRO"] = var_NRO_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NAPS == SCALAR_INT) && (aux_NAPS_read == true))) {
            cpp_current_dict["NAPS"] = var_NAPS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_SPI == SCALAR_DOUBLE) && (aux_SPI_read == true))) {
            cpp_current_dict["SPI"] = var_SPI_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_AP == SCALAR_DOUBLE) && (aux_AP_read == true))) {
            cpp_current_dict["AP"] = var_AP_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC) && (aux_AP_read == true))) {
            cpp_current_dict["AP"] = var_AP_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_NLS == SCALAR_INT) && (aux_NLS_read == true))) {
            cpp_current_dict["NLS"] = var_NLS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
            cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
            cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
          }
          if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
            cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
          }
          if (((aux_last_type_read_for_LAD == SCALAR_INT) && (aux_LAD_read == true))) {
            cpp_current_dict["LAD"] = var_LAD_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NLSC == SCALAR_INT) && (aux_NLSC_read == true))) {
            cpp_current_dict["NLSC"] = var_NLSC_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_IFG == SCALAR_INT) && (aux_IFG_read == true))) {
            cpp_current_dict["IFG"] = var_IFG_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_KRM == SCALAR_INT) && (aux_KRM_read == true))) {
            cpp_current_dict["KRM"] = var_KRM_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NJS == SCALAR_INT) && (aux_NJS_read == true))) {
            cpp_current_dict["NJS"] = var_NJS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_KRL == SCALAR_INT) && (aux_KRL_read == true))) {
            cpp_current_dict["KRL"] = var_KRL_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NPP == SCALAR_INT) && (aux_NPP_read == true))) {
            cpp_current_dict["NPP"] = var_NPP_0d_int_Scalar;
          }
          if ((var_MA_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["MA"] = var_MA_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_MB_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["MB"] = var_MB_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_ZA_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["ZA"] = var_ZA_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_ZB_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["ZB"] = var_ZB_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_IA_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["IA"] = var_IA_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_IB_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["IB"] = var_IB_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_Q_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["Q"] = var_Q_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_PNT_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["PNT"] = var_PNT_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_SHF_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["SHF"] = var_SHF_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_MT_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["MT"] = var_MT_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_PA_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["PA"] = var_PA_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_PB_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["PB"] = var_PB_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if (((aux_last_type_read_for_LSSF == SCALAR_INT) && (aux_LSSF_read == true))) {
            cpp_current_dict["LSSF"] = var_LSSF_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
            cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
          }
          if ((var_ES_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["ES"] = var_ES_1d_double_NestedVector.to_pyobj(list_mode);
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_ZAI == SCALAR_DOUBLE) && (aux_ZAI_read == true))) {
        cpp_current_dict["ZAI"] = var_ZAI_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_ABN == SCALAR_DOUBLE) && (aux_ABN_read == true))) {
        cpp_current_dict["ABN"] = var_ABN_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_LFW == SCALAR_INT) && (aux_LFW_read == true))) {
        cpp_current_dict["LFW"] = var_LFW_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NER == SCALAR_INT) && (aux_NER_read == true))) {
        cpp_current_dict["NER"] = var_NER_0d_int_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NIS == SCALAR_INT) && (aux_NIS_read == true))) {
    cpp_current_dict["NIS"] = var_NIS_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: b060c9a10c5a2def7c0e13f02c35f9ae
// MD5 hash of the following function definition: 5c08f2da69b167ea4301a08835c33478
py::dict parse_mf3_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  EndfFloatCpp var_QM_0d_double_Scalar;
  bool aux_QM_read = false;
  vartype aux_last_type_read_for_QM = UNKNOWN;
  EndfFloatCpp var_QI_0d_double_Scalar;
  bool aux_QI_read = false;
  vartype aux_last_type_read_for_QI = UNKNOWN;
  int var_LR_0d_int_Scalar;
  bool aux_LR_read = false;
  vartype aux_last_type_read_for_LR = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 3;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 3;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 3 , MT / ZA , AWR , 0 , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_template = "[ MAT , 3 , MT / QM , QI , 0 , LR , NR , NP / E / xs ] TAB1 ( xstable )";
  // read TAB1 record
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // assign expression to variable QM
  var_QM_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_QM_read = true;
  validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
  aux_last_type_read_for_QM = SCALAR_DOUBLE;
  // assign expression to variable QI
  var_QI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_QI_read = true;
  validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
  aux_last_type_read_for_QI = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LR
  var_LR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LR_read = true;
  validate_vartype_consistency("LR", SCALAR_INT, aux_last_type_read_for_LR);
  aux_last_type_read_for_LR = SCALAR_INT;
  {
    py::dict cpp_parent_dict = cpp_current_dict;
    cpp_current_dict = cpp_index_shifter_store.setdefault("xstable", std::vector<int>({}), py::dict());
    IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
    cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
    // variable declarations
    std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
    bool aux_E_read = false;
    vartype aux_last_type_read_for_E = UNKNOWN;
    std::vector<EndfFloatCpp> var_xs_0d_floatvec_Scalar;
    bool aux_xs_read = false;
    vartype aux_last_type_read_for_xs = UNKNOWN;
    std::vector<int> var_INT_0d_intvec_Scalar;
    bool aux_INT_read = false;
    vartype aux_last_type_read_for_INT = UNKNOWN;
    std::vector<int> var_NBT_0d_intvec_Scalar;
    bool aux_NBT_read = false;
    vartype aux_last_type_read_for_NBT = UNKNOWN;
    {
      Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
      // assign expression to variable E
      var_E_0d_floatvec_Scalar = tab_body.X;
      aux_E_read = true;
      validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
      aux_last_type_read_for_E = SCALAR_FLOATVEC;
      // assign expression to variable xs
      var_xs_0d_floatvec_Scalar = tab_body.Y;
      aux_xs_read = true;
      validate_vartype_consistency("xs", SCALAR_FLOATVEC, aux_last_type_read_for_xs);
      aux_last_type_read_for_xs = SCALAR_FLOATVEC;
      // assign expression to variable INT
      var_INT_0d_intvec_Scalar = tab_body.INT;
      aux_INT_read = true;
      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
      aux_last_type_read_for_INT = SCALAR_INTVEC;
      // assign expression to variable NBT
      var_NBT_0d_intvec_Scalar = tab_body.NBT;
      aux_NBT_read = true;
      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
      aux_last_type_read_for_NBT = SCALAR_INTVEC;
    }
    // store data in Python dictionary
    if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
      cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
    }
    if (((aux_last_type_read_for_xs == SCALAR_FLOATVEC) && (aux_xs_read == true))) {
      cpp_current_dict["xs"] = var_xs_0d_floatvec_Scalar;
    }
    if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
      cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
    }
    if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
      cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
    }
    cpp_current_dict = cpp_parent_dict;
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_QM == SCALAR_DOUBLE) && (aux_QM_read == true))) {
    cpp_current_dict["QM"] = var_QM_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_QI == SCALAR_DOUBLE) && (aux_QI_read == true))) {
    cpp_current_dict["QI"] = var_QI_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LR == SCALAR_INT) && (aux_LR_read == true))) {
    cpp_current_dict["LR"] = var_LR_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: c4d60855b8643a410283ef0c47845391
// MD5 hash of the following function definition: 1e1b2804ee4d416e41f562ce2d78a3ca
py::dict parse_mf4_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LTT_0d_int_Scalar;
  bool aux_LTT_read = false;
  vartype aux_last_type_read_for_LTT = UNKNOWN;
  int var_LI_0d_int_Scalar;
  bool aux_LI_read = false;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_LCT_0d_int_Scalar;
  bool aux_LCT_read = false;
  vartype aux_last_type_read_for_LCT = UNKNOWN;
  int var_NM_0d_int_Scalar;
  bool aux_NM_read = false;
  vartype aux_last_type_read_for_NM = UNKNOWN;
  int var_NE_0d_int_Scalar;
  bool aux_NE_read = false;
  vartype aux_last_type_read_for_NE = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  EndfFloatCpp var_T_0d_double_Scalar;
  bool aux_T_read = false;
  vartype aux_last_type_read_for_T = UNKNOWN;
  NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  int var_LT_0d_int_Scalar;
  bool aux_LT_read = false;
  vartype aux_last_type_read_for_LT = UNKNOWN;
  NestedVector<int> var_NL_1d_int_NestedVector;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_a_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_a_2d_idx0;
  vartype aux_last_type_read_for_a = UNKNOWN;
  int var_NE1_0d_int_Scalar;
  bool aux_NE1_read = false;
  vartype aux_last_type_read_for_NE1 = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_al_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_al_2d_idx0;
  vartype aux_last_type_read_for_al = UNKNOWN;
  int var_NE2_0d_int_Scalar;
  bool aux_NE2_read = false;
  vartype aux_last_type_read_for_NE2 = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 4;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 4;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 4 , MT / ZA , AWR , 0 , LTT , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LTT
  var_LTT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LTT_read = true;
  validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
  aux_last_type_read_for_LTT = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        std::streampos cpp_old_streampos = cont.tellg();
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LTT_0d_int_Scalar = var_LTT_0d_int_Scalar;
          int var_LTT_0d_int_Scalar = glob_var_LTT_0d_int_Scalar;
          bool& glob_aux_LTT_read = aux_LTT_read;
          bool aux_LTT_read = glob_aux_LTT_read;
          vartype aux_last_type_read_for_LTT = UNKNOWN;
          int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
          int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
          bool& glob_aux_LI_read = aux_LI_read;
          bool aux_LI_read = glob_aux_LI_read;
          vartype aux_last_type_read_for_LI = UNKNOWN;
          int& glob_var_LCT_0d_int_Scalar = var_LCT_0d_int_Scalar;
          int var_LCT_0d_int_Scalar = glob_var_LCT_0d_int_Scalar;
          bool& glob_aux_LCT_read = aux_LCT_read;
          bool aux_LCT_read = glob_aux_LCT_read;
          vartype aux_last_type_read_for_LCT = UNKNOWN;
          int& glob_var_NM_0d_int_Scalar = var_NM_0d_int_Scalar;
          int var_NM_0d_int_Scalar = glob_var_NM_0d_int_Scalar;
          bool& glob_aux_NM_read = aux_NM_read;
          bool aux_NM_read = glob_aux_NM_read;
          vartype aux_last_type_read_for_NM = UNKNOWN;
          try {
            cpp_template = "[ MAT , 4 , MT / 0.0 , AWR , LI , LCT , 0 , NM ] CONT";
            cpp_line = cpp_read_raw_line(cont);
            // read CONT record
            if ((! (aux_AWR_read == true))) {
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            } else {
            }
            // assign expression to variable LI
            var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            // assign expression to variable LCT
            var_LCT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LCT_read = true;
            validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
            aux_last_type_read_for_LCT = SCALAR_INT;
            // assign expression to variable NM
            var_NM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NM_read = true;
            validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
            aux_last_type_read_for_NM = SCALAR_INT;
          } catch (const std::out_of_range& e) {
            // // accept failure in lookahead
          }
          if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(3)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
            cpp_found_match = true;
          }
          cont.seekg(cpp_old_streampos);
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 4 , MT / 0.0 , AWR , LI , LCT , 0 , NM ] CONT";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          if ((! (aux_AWR_read == true))) {
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          } else {
            cpp_validate_field(var_AWR_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AWR",
              cpp_template, cpp_line, parse_opts);
          }
          // assign expression to variable LI
          var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          // assign expression to variable LCT
          var_LCT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_LCT_read = true;
          validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
          aux_last_type_read_for_LCT = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NM
          var_NM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NM_read = true;
          validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
          aux_last_type_read_for_NM = SCALAR_INT;
        }
      }
    }
    if (! cpp_found_match) {
      cpp_template = "[ MAT , 4 , MT / 0.0 , AWR , LI , LCT , 0 , 0 ] CONT";
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read CONT record
      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
        cpp_template, cpp_line, parse_opts);
      if ((! (aux_AWR_read == true))) {
        // assign expression to variable AWR
        var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
        aux_AWR_read = true;
        validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
        aux_last_type_read_for_AWR = SCALAR_DOUBLE;
      } else {
        cpp_validate_field(var_AWR_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AWR",
          cpp_template, cpp_line, parse_opts);
      }
      // assign expression to variable LI
      var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
      aux_LI_read = true;
      validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
      aux_last_type_read_for_LI = SCALAR_INT;
      // assign expression to variable LCT
      var_LCT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LCT_read = true;
      validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
      aux_last_type_read_for_LCT = SCALAR_INT;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
    }
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(1)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
        // read TAB2 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        // assign expression to variable NE
        var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
        aux_NE_read = true;
        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
        aux_last_type_read_for_NE = SCALAR_INT;
        cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        {
          Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }

        for (int var_i_0d_int_Scalar = 1;
           var_i_0d_int_Scalar <= var_NE_0d_int_Scalar; var_i_0d_int_Scalar++) {
          bool aux_i_read = true;
          cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NL , 0 / { a } { l = 1 to NL } ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          // assign expression to variable T
          var_T_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_T_read = true;
          validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
          aux_last_type_read_for_T = SCALAR_DOUBLE;
          // assign expression to variable E
          var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
          validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
          aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
          // assign expression to variable LT
          var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LT_read = true;
          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
          aux_last_type_read_for_LT = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NL
          var_NL_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
          validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
          aux_last_type_read_for_NL = NESTEDVECTOR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body
            ptr_a_2d_idx0 = var_a_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

            for (int var_l_0d_int_Scalar = 1;
               var_l_0d_int_Scalar <= var_NL_1d_int_NestedVector[var_i_0d_int_Scalar]; var_l_0d_int_Scalar++) {
              bool aux_l_read = true;
              // read LIST body
              // assign expression to variable a
              ptr_a_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("a", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_a);
              aux_last_type_read_for_a = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(2)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2 ( energy_table )";
          // read TAB2 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NE
          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NE_read = true;
          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
          aux_last_type_read_for_NE = SCALAR_INT;
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.setdefault("energy_table", std::vector<int>({}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            // variable declarations
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
              cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
            }
            if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
              cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
            }
            cpp_current_dict = cpp_parent_dict;
          }

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_NE_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NR , NP / mu / f ] TAB1 ( angtable [ i ] )";
            // read TAB1 record
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // assign expression to variable T
            var_T_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_T_read = true;
            validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
            aux_last_type_read_for_T = SCALAR_DOUBLE;
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            // assign expression to variable LT
            var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LT_read = true;
            validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
            aux_last_type_read_for_LT = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.setdefault("angtable", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              // variable declarations
              std::vector<EndfFloatCpp> var_mu_0d_floatvec_Scalar;
              bool aux_mu_read = false;
              vartype aux_last_type_read_for_mu = UNKNOWN;
              std::vector<EndfFloatCpp> var_f_0d_floatvec_Scalar;
              bool aux_f_read = false;
              vartype aux_last_type_read_for_f = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                // assign expression to variable mu
                var_mu_0d_floatvec_Scalar = tab_body.X;
                aux_mu_read = true;
                validate_vartype_consistency("mu", SCALAR_FLOATVEC, aux_last_type_read_for_mu);
                aux_last_type_read_for_mu = SCALAR_FLOATVEC;
                // assign expression to variable f
                var_f_0d_floatvec_Scalar = tab_body.Y;
                aux_f_read = true;
                validate_vartype_consistency("f", SCALAR_FLOATVEC, aux_last_type_read_for_f);
                aux_last_type_read_for_f = SCALAR_FLOATVEC;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              // store data in Python dictionary
              if (((aux_last_type_read_for_mu == SCALAR_FLOATVEC) && (aux_mu_read == true))) {
                cpp_current_dict["mu"] = var_mu_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_f == SCALAR_FLOATVEC) && (aux_f_read == true))) {
                cpp_current_dict["f"] = var_f_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
              }
              if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(3)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE1 / Eint ] TAB2 ( leg_int )";
          // read TAB2 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NE1
          var_NE1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NE1_read = true;
          validate_vartype_consistency("NE1", SCALAR_INT, aux_last_type_read_for_NE1);
          aux_last_type_read_for_NE1 = SCALAR_INT;
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.setdefault("leg_int", std::vector<int>({}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            // variable declarations
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
              cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
            }
            if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
              cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
            }
            cpp_current_dict = cpp_parent_dict;
          }

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_NE1_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NL , 0 / \n { al } { j = 1 to NL } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            // assign expression to variable T
            var_T_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_T_read = true;
            validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
            aux_last_type_read_for_T = SCALAR_DOUBLE;
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            // assign expression to variable LT
            var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LT_read = true;
            validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
            aux_last_type_read_for_LT = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable NL
            var_NL_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
            validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
            aux_last_type_read_for_NL = NESTEDVECTOR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body
              ptr_al_2d_idx0 = var_al_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NL_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                // read LIST body
                // assign expression to variable al
                ptr_al_2d_idx0->set(var_j_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("al", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_al);
                aux_last_type_read_for_al = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
          }
          cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE2 / Eint ] TAB2 ( ang_int )";
          // read TAB2 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NE2
          var_NE2_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NE2_read = true;
          validate_vartype_consistency("NE2", SCALAR_INT, aux_last_type_read_for_NE2);
          aux_last_type_read_for_NE2 = SCALAR_INT;
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.setdefault("ang_int", std::vector<int>({}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            // variable declarations
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
              cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
            }
            if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
              cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
            }
            cpp_current_dict = cpp_parent_dict;
          }

          for (int var_i_0d_int_Scalar = var_NE1_0d_int_Scalar;
             var_i_0d_int_Scalar <= ((var_NE1_0d_int_Scalar+var_NE2_0d_int_Scalar)-1); var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NR , NP / mu / f ] TAB1 ( angtable [ i ] )";
            // read TAB1 record
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            if ((! (aux_T_read == true))) {
              // assign expression to variable T
              var_T_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
              aux_T_read = true;
              validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
              aux_last_type_read_for_T = SCALAR_DOUBLE;
            } else {
              cpp_validate_field(var_T_0d_double_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "T",
                cpp_template, cpp_line, parse_opts);
            }
            if ((! var_E_1d_double_NestedVector.contains(var_i_0d_int_Scalar))) {
              // assign expression to variable E
              var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            } else {
              cpp_validate_field(var_E_1d_double_NestedVector[var_i_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "E",
                cpp_template, cpp_line, parse_opts);
            }
            if ((! (aux_LT_read == true))) {
              // assign expression to variable LT
              var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LT_read = true;
              validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
              aux_last_type_read_for_LT = SCALAR_INT;
            } else {
              cpp_validate_field(var_LT_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "LT",
                cpp_template, cpp_line, parse_opts);
            }
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.setdefault("angtable", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              // variable declarations
              std::vector<EndfFloatCpp> var_mu_0d_floatvec_Scalar;
              bool aux_mu_read = false;
              vartype aux_last_type_read_for_mu = UNKNOWN;
              std::vector<EndfFloatCpp> var_f_0d_floatvec_Scalar;
              bool aux_f_read = false;
              vartype aux_last_type_read_for_f = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                // assign expression to variable mu
                var_mu_0d_floatvec_Scalar = tab_body.X;
                aux_mu_read = true;
                validate_vartype_consistency("mu", SCALAR_FLOATVEC, aux_last_type_read_for_mu);
                aux_last_type_read_for_mu = SCALAR_FLOATVEC;
                // assign expression to variable f
                var_f_0d_floatvec_Scalar = tab_body.Y;
                aux_f_read = true;
                validate_vartype_consistency("f", SCALAR_FLOATVEC, aux_last_type_read_for_f);
                aux_last_type_read_for_f = SCALAR_FLOATVEC;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              // store data in Python dictionary
              if (((aux_last_type_read_for_mu == SCALAR_FLOATVEC) && (aux_mu_read == true))) {
                cpp_current_dict["mu"] = var_mu_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_f == SCALAR_FLOATVEC) && (aux_f_read == true))) {
                cpp_current_dict["f"] = var_f_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
              }
              if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LTT == SCALAR_INT) && (aux_LTT_read == true))) {
    cpp_current_dict["LTT"] = var_LTT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LI == SCALAR_INT) && (aux_LI_read == true))) {
    cpp_current_dict["LI"] = var_LI_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LCT == SCALAR_INT) && (aux_LCT_read == true))) {
    cpp_current_dict["LCT"] = var_LCT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NM == SCALAR_INT) && (aux_NM_read == true))) {
    cpp_current_dict["NM"] = var_NM_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
    cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_T == SCALAR_DOUBLE) && (aux_T_read == true))) {
    cpp_current_dict["T"] = var_T_0d_double_Scalar;
  }
  if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_LT == SCALAR_INT) && (aux_LT_read == true))) {
    cpp_current_dict["LT"] = var_LT_0d_int_Scalar;
  }
  if ((var_NL_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["NL"] = var_NL_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_a_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["a"] = var_a_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_NE1 == SCALAR_INT) && (aux_NE1_read == true))) {
    cpp_current_dict["NE1"] = var_NE1_0d_int_Scalar;
  }
  if ((var_al_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["al"] = var_al_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_NE2 == SCALAR_INT) && (aux_NE2_read == true))) {
    cpp_current_dict["NE2"] = var_NE2_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: ad114a6eab38d3e40a863ae76da18ca0
// MD5 hash of the following function definition: 0d02060a4da4cbffa9e4de7bb70130b6
py::dict parse_mf5_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 5;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 5;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 5 , MT / ZA , AWR , 0 , 0 , NK , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section contribution
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.setdefault("contribution", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      int var_LF_0d_int_Scalar;
      bool aux_LF_read = false;
      vartype aux_last_type_read_for_LF = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      EndfFloatCpp var_U_0d_double_Scalar;
      bool aux_U_read = false;
      vartype aux_last_type_read_for_U = UNKNOWN;
      std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
      bool aux_p_read = false;
      vartype aux_last_type_read_for_p = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      EndfFloatCpp var_EFL_0d_double_Scalar;
      bool aux_EFL_read = false;
      vartype aux_last_type_read_for_EFL = UNKNOWN;
      EndfFloatCpp var_EFH_0d_double_Scalar;
      bool aux_EFH_read = false;
      vartype aux_last_type_read_for_EFH = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            std::streampos cpp_old_streampos = cont.tellg();
            {
              // variable declarations
              int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
              int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
              bool& glob_aux_LF_read = aux_LF_read;
              bool aux_LF_read = glob_aux_LF_read;
              vartype aux_last_type_read_for_LF = UNKNOWN;
              try {
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_line = cpp_read_raw_line(cont);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
              } catch (const std::out_of_range& e) {
                // // accept failure in lookahead
              }
              if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(1)))))))) {
                cpp_found_match = true;
              }
              cont.seekg(cpp_old_streampos);
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
              // read TAB1 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable LF
              var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LF_read = true;
              validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
              aux_last_type_read_for_LF = SCALAR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.setdefault("p_table", std::vector<int>({}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                // variable declarations
                std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                bool aux_E_read = false;
                vartype aux_last_type_read_for_E = UNKNOWN;
                std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
                bool aux_p_read = false;
                vartype aux_last_type_read_for_p = UNKNOWN;
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                  // assign expression to variable E
                  var_E_0d_floatvec_Scalar = tab_body.X;
                  aux_E_read = true;
                  validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                  cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                }
                if (((aux_last_type_read_for_p == SCALAR_FLOATVEC) && (aux_p_read == true))) {
                  cpp_current_dict["p"] = var_p_0d_floatvec_Scalar;
                }
                if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                  cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                }
                if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                  cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                }
                cpp_current_dict = cpp_parent_dict;
              }
              cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E ] TAB2 ( E_interp )";
              // read TAB2 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.setdefault("E_interp", std::vector<int>({}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                // variable declarations
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                  cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                }
                if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                  cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                }
                cpp_current_dict = cpp_parent_dict;
              }

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NE_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                cpp_template = "[ MAT , 5 , MT / 0.0 , E , 0 , 0 , NR , NF / Eout / g ] TAB1 ( spectrum [ l ] )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.setdefault("spectrum", std::vector<int>({var_l_0d_int_Scalar}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_Eout_0d_floatvec_Scalar;
                  bool aux_Eout_read = false;
                  vartype aux_last_type_read_for_Eout = UNKNOWN;
                  std::vector<EndfFloatCpp> var_g_0d_floatvec_Scalar;
                  bool aux_g_read = false;
                  vartype aux_last_type_read_for_g = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable Eout
                    var_Eout_0d_floatvec_Scalar = tab_body.X;
                    aux_Eout_read = true;
                    validate_vartype_consistency("Eout", SCALAR_FLOATVEC, aux_last_type_read_for_Eout);
                    aux_last_type_read_for_Eout = SCALAR_FLOATVEC;
                    // assign expression to variable g
                    var_g_0d_floatvec_Scalar = tab_body.Y;
                    aux_g_read = true;
                    validate_vartype_consistency("g", SCALAR_FLOATVEC, aux_last_type_read_for_g);
                    aux_last_type_read_for_g = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_Eout == SCALAR_FLOATVEC) && (aux_Eout_read == true))) {
                    cpp_current_dict["Eout"] = var_Eout_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_g == SCALAR_FLOATVEC) && (aux_g_read == true))) {
                    cpp_current_dict["g"] = var_g_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              std::streampos cpp_old_streampos = cont.tellg();
              {
                // variable declarations
                EndfFloatCpp& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                EndfFloatCpp var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                try {
                  cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                  // read TAB1 record
                  cpp_line = cpp_read_raw_line(cont);
                  // assign expression to variable U
                  var_U_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                  aux_U_read = true;
                  validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                  aux_last_type_read_for_U = SCALAR_DOUBLE;
                  // assign expression to variable LF
                  var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                  aux_LF_read = true;
                  validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                  aux_last_type_read_for_LF = SCALAR_INT;
                } catch (const std::out_of_range& e) {
                  // // accept failure in lookahead
                }
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(5)))))))) {
                  cpp_found_match = true;
                }
                cont.seekg(cpp_old_streampos);
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.setdefault("p_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_p == SCALAR_FLOATVEC) && (aux_p_read == true))) {
                    cpp_current_dict["p"] = var_p_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E / theta ] TAB1 ( theta_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.setdefault("theta_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_theta_0d_floatvec_Scalar;
                  bool aux_theta_read = false;
                  vartype aux_last_type_read_for_theta = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable theta
                    var_theta_0d_floatvec_Scalar = tab_body.Y;
                    aux_theta_read = true;
                    validate_vartype_consistency("theta", SCALAR_FLOATVEC, aux_last_type_read_for_theta);
                    aux_last_type_read_for_theta = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_theta == SCALAR_FLOATVEC) && (aux_theta_read == true))) {
                    cpp_current_dict["theta"] = var_theta_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NF / x / g ] TAB1 ( g_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.setdefault("g_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_x_0d_floatvec_Scalar;
                  bool aux_x_read = false;
                  vartype aux_last_type_read_for_x = UNKNOWN;
                  std::vector<EndfFloatCpp> var_g_0d_floatvec_Scalar;
                  bool aux_g_read = false;
                  vartype aux_last_type_read_for_g = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable x
                    var_x_0d_floatvec_Scalar = tab_body.X;
                    aux_x_read = true;
                    validate_vartype_consistency("x", SCALAR_FLOATVEC, aux_last_type_read_for_x);
                    aux_last_type_read_for_x = SCALAR_FLOATVEC;
                    // assign expression to variable g
                    var_g_0d_floatvec_Scalar = tab_body.Y;
                    aux_g_read = true;
                    validate_vartype_consistency("g", SCALAR_FLOATVEC, aux_last_type_read_for_g);
                    aux_last_type_read_for_g = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_x == SCALAR_FLOATVEC) && (aux_x_read == true))) {
                    cpp_current_dict["x"] = var_x_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_g == SCALAR_FLOATVEC) && (aux_g_read == true))) {
                    cpp_current_dict["g"] = var_g_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              std::streampos cpp_old_streampos = cont.tellg();
              {
                // variable declarations
                EndfFloatCpp& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                EndfFloatCpp var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                try {
                  cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                  // read TAB1 record
                  cpp_line = cpp_read_raw_line(cont);
                  // assign expression to variable U
                  var_U_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                  aux_U_read = true;
                  validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                  aux_last_type_read_for_U = SCALAR_DOUBLE;
                  // assign expression to variable LF
                  var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                  aux_LF_read = true;
                  validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                  aux_last_type_read_for_LF = SCALAR_INT;
                } catch (const std::out_of_range& e) {
                  // // accept failure in lookahead
                }
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(7)))))))) {
                  cpp_found_match = true;
                }
                cont.seekg(cpp_old_streampos);
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.setdefault("p_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_p == SCALAR_FLOATVEC) && (aux_p_read == true))) {
                    cpp_current_dict["p"] = var_p_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E / theta ] TAB1 ( theta_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.setdefault("theta_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_theta_0d_floatvec_Scalar;
                  bool aux_theta_read = false;
                  vartype aux_last_type_read_for_theta = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable theta
                    var_theta_0d_floatvec_Scalar = tab_body.Y;
                    aux_theta_read = true;
                    validate_vartype_consistency("theta", SCALAR_FLOATVEC, aux_last_type_read_for_theta);
                    aux_last_type_read_for_theta = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_theta == SCALAR_FLOATVEC) && (aux_theta_read == true))) {
                    cpp_current_dict["theta"] = var_theta_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              std::streampos cpp_old_streampos = cont.tellg();
              {
                // variable declarations
                EndfFloatCpp& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                EndfFloatCpp var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                try {
                  cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                  // read TAB1 record
                  cpp_line = cpp_read_raw_line(cont);
                  // assign expression to variable U
                  var_U_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                  aux_U_read = true;
                  validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                  aux_last_type_read_for_U = SCALAR_DOUBLE;
                  // assign expression to variable LF
                  var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                  aux_LF_read = true;
                  validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                  aux_last_type_read_for_LF = SCALAR_INT;
                } catch (const std::out_of_range& e) {
                  // // accept failure in lookahead
                }
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(9)))))))) {
                  cpp_found_match = true;
                }
                cont.seekg(cpp_old_streampos);
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.setdefault("p_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_p == SCALAR_FLOATVEC) && (aux_p_read == true))) {
                    cpp_current_dict["p"] = var_p_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E / theta ] TAB1 ( theta_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.setdefault("theta_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_theta_0d_floatvec_Scalar;
                  bool aux_theta_read = false;
                  vartype aux_last_type_read_for_theta = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable theta
                    var_theta_0d_floatvec_Scalar = tab_body.Y;
                    aux_theta_read = true;
                    validate_vartype_consistency("theta", SCALAR_FLOATVEC, aux_last_type_read_for_theta);
                    aux_last_type_read_for_theta = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_theta == SCALAR_FLOATVEC) && (aux_theta_read == true))) {
                    cpp_current_dict["theta"] = var_theta_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              std::streampos cpp_old_streampos = cont.tellg();
              {
                // variable declarations
                EndfFloatCpp& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                EndfFloatCpp var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                try {
                  cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1";
                  // read TAB1 record
                  cpp_line = cpp_read_raw_line(cont);
                  // assign expression to variable U
                  var_U_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                  aux_U_read = true;
                  validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                  aux_last_type_read_for_U = SCALAR_DOUBLE;
                  // assign expression to variable LF
                  var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                  aux_LF_read = true;
                  validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                  aux_last_type_read_for_LF = SCALAR_INT;
                } catch (const std::out_of_range& e) {
                  // // accept failure in lookahead
                }
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(11)))))))) {
                  cpp_found_match = true;
                }
                cont.seekg(cpp_old_streampos);
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                {
                  Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                  // assign expression to variable E
                  var_E_0d_floatvec_Scalar = tab_body.X;
                  aux_E_read = true;
                  validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                throw std::runtime_error("Encountered STOP instruction in recipe: LF=11 case not implemented in ENDF recipe MF5");
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              std::streampos cpp_old_streampos = cont.tellg();
              {
                // variable declarations
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                try {
                  cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                  // read TAB1 record
                  cpp_line = cpp_read_raw_line(cont);
                  // assign expression to variable LF
                  var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                  aux_LF_read = true;
                  validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                  aux_last_type_read_for_LF = SCALAR_INT;
                } catch (const std::out_of_range& e) {
                  // // accept failure in lookahead
                }
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(12)))))))) {
                  cpp_found_match = true;
                }
                cont.seekg(cpp_old_streampos);
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.setdefault("p_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_p == SCALAR_FLOATVEC) && (aux_p_read == true))) {
                    cpp_current_dict["p"] = var_p_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / EFL , EFH , 0 , 0 , NR , NE / E / TM ] TAB1 ( Tm_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // assign expression to variable EFL
                var_EFL_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                aux_EFL_read = true;
                validate_vartype_consistency("EFL", SCALAR_DOUBLE, aux_last_type_read_for_EFL);
                aux_last_type_read_for_EFL = SCALAR_DOUBLE;
                // assign expression to variable EFH
                var_EFH_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                aux_EFH_read = true;
                validate_vartype_consistency("EFH", SCALAR_DOUBLE, aux_last_type_read_for_EFH);
                aux_last_type_read_for_EFH = SCALAR_DOUBLE;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.setdefault("Tm_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_TM_0d_floatvec_Scalar;
                  bool aux_TM_read = false;
                  vartype aux_last_type_read_for_TM = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable TM
                    var_TM_0d_floatvec_Scalar = tab_body.Y;
                    aux_TM_read = true;
                    validate_vartype_consistency("TM", SCALAR_FLOATVEC, aux_last_type_read_for_TM);
                    aux_last_type_read_for_TM = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_TM == SCALAR_FLOATVEC) && (aux_TM_read == true))) {
                    cpp_current_dict["TM"] = var_TM_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_LF == SCALAR_INT) && (aux_LF_read == true))) {
        cpp_current_dict["LF"] = var_LF_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
        cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
      }
      if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
      }
      if (((aux_last_type_read_for_U == SCALAR_DOUBLE) && (aux_U_read == true))) {
        cpp_current_dict["U"] = var_U_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
        cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_p == SCALAR_FLOATVEC) && (aux_p_read == true))) {
        cpp_current_dict["p"] = var_p_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_EFL == SCALAR_DOUBLE) && (aux_EFL_read == true))) {
        cpp_current_dict["EFL"] = var_EFL_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_EFH == SCALAR_DOUBLE) && (aux_EFH_read == true))) {
        cpp_current_dict["EFH"] = var_EFH_0d_double_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NK == SCALAR_INT) && (aux_NK_read == true))) {
    cpp_current_dict["NK"] = var_NK_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: ca82cdd58bd8081afe9c01f911284492
// MD5 hash of the following function definition: 76216815963fd9736688e602d8125974
py::dict parse_mf6_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_JP_0d_int_Scalar;
  bool aux_JP_read = false;
  vartype aux_last_type_read_for_JP = UNKNOWN;
  int var_LCT_0d_int_Scalar;
  bool aux_LCT_read = false;
  vartype aux_last_type_read_for_LCT = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 6;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 6;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 6 , MT / ZA , AWR , JP , LCT , NK , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable JP
  var_JP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_JP_read = true;
  validate_vartype_consistency("JP", SCALAR_INT, aux_last_type_read_for_JP);
  aux_last_type_read_for_JP = SCALAR_INT;
  // assign expression to variable LCT
  var_LCT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LCT_read = true;
  validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
  aux_last_type_read_for_LCT = SCALAR_INT;
  // assign expression to variable NK
  var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NK_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.setdefault("subsection", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_ZAP_0d_double_Scalar;
      bool aux_ZAP_read = false;
      vartype aux_last_type_read_for_ZAP = UNKNOWN;
      EndfFloatCpp var_AWP_0d_double_Scalar;
      bool aux_AWP_read = false;
      vartype aux_last_type_read_for_AWP = UNKNOWN;
      int var_LIP_0d_int_Scalar;
      bool aux_LIP_read = false;
      vartype aux_last_type_read_for_LIP = UNKNOWN;
      int var_LAW_0d_int_Scalar;
      bool aux_LAW_read = false;
      vartype aux_last_type_read_for_LAW = UNKNOWN;
      int var_LANG_0d_int_Scalar;
      bool aux_LANG_read = false;
      vartype aux_last_type_read_for_LANG = UNKNOWN;
      int var_LEP_0d_int_Scalar;
      bool aux_LEP_read = false;
      vartype aux_last_type_read_for_LEP = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      NestedVector<int> var_ND_1d_int_NestedVector;
      vartype aux_last_type_read_for_ND = UNKNOWN;
      NestedVector<int> var_NA_1d_int_NestedVector;
      vartype aux_last_type_read_for_NA = UNKNOWN;
      int cpp_int_val;
      bool aux_cpp_int_val_read = false;
      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
      NestedVector<int> var_NEP_1d_int_NestedVector;
      vartype aux_last_type_read_for_NEP = UNKNOWN;
      NestedVector<NestedVector<EndfFloatCpp>> var_Ep_2d_double_NestedVector;
      NestedVector<EndfFloatCpp>* ptr_Ep_2d_idx0;
      vartype aux_last_type_read_for_Ep = UNKNOWN;
      NestedVector<NestedVector<NestedVector<EndfFloatCpp>>> var_b_3d_double_NestedVector;
      NestedVector<EndfFloatCpp>* ptr_b_3d_idx1;
      NestedVector<NestedVector<EndfFloatCpp>>* ptr_b_3d_idx0;
      vartype aux_last_type_read_for_b = UNKNOWN;
      NestedVector<int> var_NLW_1d_int_NestedVector;
      vartype aux_last_type_read_for_NLW = UNKNOWN;
      NestedVector<int> var_NL_1d_int_NestedVector;
      vartype aux_last_type_read_for_NL = UNKNOWN;
      NestedVector<NestedVector<EndfFloatCpp>> var_A_2d_double_NestedVector;
      NestedVector<EndfFloatCpp>* ptr_A_2d_idx0;
      vartype aux_last_type_read_for_A = UNKNOWN;
      EndfFloatCpp var_SPI_0d_double_Scalar;
      bool aux_SPI_read = false;
      vartype aux_last_type_read_for_SPI = UNKNOWN;
      int var_LIDP_0d_int_Scalar;
      bool aux_LIDP_read = false;
      vartype aux_last_type_read_for_LIDP = UNKNOWN;
      NestedVector<int> var_LTP_1d_int_NestedVector;
      vartype aux_last_type_read_for_LTP = UNKNOWN;
      NestedVector<int> var_NW_1d_int_NestedVector;
      vartype aux_last_type_read_for_NW = UNKNOWN;
      EndfFloatCpp var_APSX_0d_double_Scalar;
      bool aux_APSX_read = false;
      vartype aux_last_type_read_for_APSX = UNKNOWN;
      int var_NPSX_0d_int_Scalar;
      bool aux_NPSX_read = false;
      vartype aux_last_type_read_for_NPSX = UNKNOWN;
      NestedVector<int> var_NMU_1d_int_NestedVector;
      vartype aux_last_type_read_for_NMU = UNKNOWN;
      NestedVector<NestedVector<EndfFloatCpp>> var_mu_2d_double_NestedVector;
      NestedVector<EndfFloatCpp>* ptr_mu_2d_idx0;
      vartype aux_last_type_read_for_mu = UNKNOWN;
      cpp_template = "[ MAT , 6 , MT / ZAP , AWP , LIP , LAW , NR , NP / Eint / yi ] TAB1 ( yields )";
      // read TAB1 record
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // assign expression to variable ZAP
      var_ZAP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
      aux_ZAP_read = true;
      validate_vartype_consistency("ZAP", SCALAR_DOUBLE, aux_last_type_read_for_ZAP);
      aux_last_type_read_for_ZAP = SCALAR_DOUBLE;
      // assign expression to variable AWP
      var_AWP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
      aux_AWP_read = true;
      validate_vartype_consistency("AWP", SCALAR_DOUBLE, aux_last_type_read_for_AWP);
      aux_last_type_read_for_AWP = SCALAR_DOUBLE;
      // assign expression to variable LIP
      var_LIP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
      aux_LIP_read = true;
      validate_vartype_consistency("LIP", SCALAR_INT, aux_last_type_read_for_LIP);
      aux_last_type_read_for_LIP = SCALAR_INT;
      // assign expression to variable LAW
      var_LAW_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LAW_read = true;
      validate_vartype_consistency("LAW", SCALAR_INT, aux_last_type_read_for_LAW);
      aux_last_type_read_for_LAW = SCALAR_INT;
      {
        py::dict cpp_parent_dict = cpp_current_dict;
        cpp_current_dict = cpp_index_shifter_store.setdefault("yields", std::vector<int>({}), py::dict());
        IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
        cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
        // variable declarations
        std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
        bool aux_Eint_read = false;
        vartype aux_last_type_read_for_Eint = UNKNOWN;
        std::vector<EndfFloatCpp> var_yi_0d_floatvec_Scalar;
        bool aux_yi_read = false;
        vartype aux_last_type_read_for_yi = UNKNOWN;
        std::vector<int> var_INT_0d_intvec_Scalar;
        bool aux_INT_read = false;
        vartype aux_last_type_read_for_INT = UNKNOWN;
        std::vector<int> var_NBT_0d_intvec_Scalar;
        bool aux_NBT_read = false;
        vartype aux_last_type_read_for_NBT = UNKNOWN;
        {
          Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
          // assign expression to variable Eint
          var_Eint_0d_floatvec_Scalar = tab_body.X;
          aux_Eint_read = true;
          validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
          aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
          // assign expression to variable yi
          var_yi_0d_floatvec_Scalar = tab_body.Y;
          aux_yi_read = true;
          validate_vartype_consistency("yi", SCALAR_FLOATVEC, aux_last_type_read_for_yi);
          aux_last_type_read_for_yi = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
        // store data in Python dictionary
        if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
          cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
        }
        if (((aux_last_type_read_for_yi == SCALAR_FLOATVEC) && (aux_yi_read == true))) {
          cpp_current_dict["yi"] = var_yi_0d_floatvec_Scalar;
        }
        if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
          cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
        }
        if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
          cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
        }
        cpp_current_dict = cpp_parent_dict;
      }
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(1)))))))) {
            // if statement evaluation
            cpp_found_match = true;
            cpp_template = "[ MAT , 6 , MT / 0.0 , 0.0 , LANG , LEP , NR , NE / Eint ] TAB2";
            // read TAB2 record
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable LANG
            var_LANG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LANG_read = true;
            validate_vartype_consistency("LANG", SCALAR_INT, aux_last_type_read_for_LANG);
            aux_last_type_read_for_LANG = SCALAR_INT;
            // assign expression to variable LEP
            var_LEP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LEP_read = true;
            validate_vartype_consistency("LEP", SCALAR_INT, aux_last_type_read_for_LEP);
            aux_last_type_read_for_LEP = SCALAR_INT;
            // assign expression to variable NE
            var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NE_read = true;
            validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
            aux_last_type_read_for_NE = SCALAR_INT;
            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            {
              Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }

            for (int var_j_0d_int_Scalar = 1;
               var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
              bool aux_j_read = true;
              cpp_template = "[ MAT , 6 , MT / 0.0 , E , ND , NA , NW , NEP / \n { Ep , { b } { m = 0 to NA } } { k = 1 to NEP } ] LIST";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST record
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable E
              var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
              // assign expression to variable ND
              var_ND_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
              validate_vartype_consistency("ND", NESTEDVECTOR_INT, aux_last_type_read_for_ND);
              aux_last_type_read_for_ND = NESTEDVECTOR_INT;
              // assign expression to variable NA
              var_NA_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
              validate_vartype_consistency("NA", NESTEDVECTOR_INT, aux_last_type_read_for_NA);
              aux_last_type_read_for_NA = NESTEDVECTOR_INT;
              // assign expression to variable cpp_int_val
              cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NEP
              var_NEP_1d_int_NestedVector.set(var_j_0d_int_Scalar, (cpp_int_val/(var_NA_1d_int_NestedVector[var_j_0d_int_Scalar]+2)));
              validate_vartype_consistency("NEP", NESTEDVECTOR_INT, aux_last_type_read_for_NEP);
              aux_last_type_read_for_NEP = NESTEDVECTOR_INT;
              if ((! var_NEP_1d_int_NestedVector.contains(var_j_0d_int_Scalar))) {
                // assign expression to variable NEP
                var_NEP_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                validate_vartype_consistency("NEP", NESTEDVECTOR_INT, aux_last_type_read_for_NEP);
                aux_last_type_read_for_NEP = NESTEDVECTOR_INT;
              } else {
                cpp_validate_field(var_NEP_1d_int_NestedVector[var_j_0d_int_Scalar], cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NEP",
                  cpp_template, cpp_line, parse_opts);
              }
              {
                int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST body
                ptr_Ep_2d_idx0 = var_Ep_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);
                ptr_b_3d_idx0 = var_b_3d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                for (int var_k_0d_int_Scalar = 1;
                   var_k_0d_int_Scalar <= var_NEP_1d_int_NestedVector[var_j_0d_int_Scalar]; var_k_0d_int_Scalar++) {
                  bool aux_k_read = true;
                  // read LIST body
                  // assign expression to variable Ep
                  ptr_Ep_2d_idx0->set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                  validate_vartype_consistency("Ep", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ep);
                  aux_last_type_read_for_Ep = NESTEDVECTOR_DOUBLE;
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  ptr_b_3d_idx1 = ptr_b_3d_idx0->prepare(var_k_0d_int_Scalar);

                  for (int var_m_0d_int_Scalar = 0;
                     var_m_0d_int_Scalar <= var_NA_1d_int_NestedVector[var_j_0d_int_Scalar]; var_m_0d_int_Scalar++) {
                    bool aux_m_read = true;
                    // read LIST body
                    // assign expression to variable b
                    ptr_b_3d_idx1->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                    validate_vartype_consistency("b", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_b);
                    aux_last_type_read_for_b = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      cpp_j = 0;
                    }
                  }
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(2)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
              // read TAB2 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              {
                Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                cpp_template = "[ MAT , 6 , MT / 0.0 , E , LANG , 0 , NLW , NL / { A } { l = 1 to NLW } ] LIST";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST record
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                // assign expression to variable LANG
                var_LANG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                aux_LANG_read = true;
                validate_vartype_consistency("LANG", SCALAR_INT, aux_last_type_read_for_LANG);
                aux_last_type_read_for_LANG = SCALAR_INT;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable NLW
                var_NLW_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
                validate_vartype_consistency("NLW", NESTEDVECTOR_INT, aux_last_type_read_for_NLW);
                aux_last_type_read_for_NLW = NESTEDVECTOR_INT;
                // assign expression to variable NL
                var_NL_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = NESTEDVECTOR_INT;
                {
                  int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST body
                  ptr_A_2d_idx0 = var_A_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                  for (int var_l_0d_int_Scalar = 1;
                     var_l_0d_int_Scalar <= var_NLW_1d_int_NestedVector[var_j_0d_int_Scalar]; var_l_0d_int_Scalar++) {
                    bool aux_l_read = true;
                    // read LIST body
                    // assign expression to variable A
                    ptr_A_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                    validate_vartype_consistency("A", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_A);
                    aux_last_type_read_for_A = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      cpp_j = 0;
                    }
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(5)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / SPI , 0.0 , LIDP , 0 , NR , NE / Eint ] TAB2";
              // read TAB2 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // assign expression to variable SPI
              var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
              aux_SPI_read = true;
              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable LIDP
              var_LIDP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LIDP_read = true;
              validate_vartype_consistency("LIDP", SCALAR_INT, aux_last_type_read_for_LIDP);
              aux_last_type_read_for_LIDP = SCALAR_INT;
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              {
                Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                cpp_template = "[ MAT , 6 , MT / 0.0 , E , LTP , 0 , NW , NL / \n { A } { k = 1 to NW } ] LIST";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST record
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                // assign expression to variable LTP
                var_LTP_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
                validate_vartype_consistency("LTP", NESTEDVECTOR_INT, aux_last_type_read_for_LTP);
                aux_last_type_read_for_LTP = NESTEDVECTOR_INT;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable NW
                var_NW_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
                validate_vartype_consistency("NW", NESTEDVECTOR_INT, aux_last_type_read_for_NW);
                aux_last_type_read_for_NW = NESTEDVECTOR_INT;
                // assign expression to variable NL
                var_NL_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = NESTEDVECTOR_INT;
                {
                  int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST body
                  ptr_A_2d_idx0 = var_A_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                  for (int var_k_0d_int_Scalar = 1;
                     var_k_0d_int_Scalar <= var_NW_1d_int_NestedVector[var_j_0d_int_Scalar]; var_k_0d_int_Scalar++) {
                    bool aux_k_read = true;
                    // read LIST body
                    // assign expression to variable A
                    ptr_A_2d_idx0->set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                    validate_vartype_consistency("A", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_A);
                    aux_last_type_read_for_A = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      cpp_j = 0;
                    }
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(6)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / APSX , 0.0 , 0 , 0 , 0 , NPSX ] CONT";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read CONT record
              // assign expression to variable APSX
              var_APSX_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
              aux_APSX_read = true;
              validate_vartype_consistency("APSX", SCALAR_DOUBLE, aux_last_type_read_for_APSX);
              aux_last_type_read_for_APSX = SCALAR_DOUBLE;
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NPSX
              var_NPSX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NPSX_read = true;
              validate_vartype_consistency("NPSX", SCALAR_INT, aux_last_type_read_for_NPSX);
              aux_last_type_read_for_NPSX = SCALAR_INT;
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(7)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E ] TAB2 ( E_interpol )";
              // read TAB2 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.setdefault("E_interpol", std::vector<int>({}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                // variable declarations
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                  cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                }
                if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                  cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                }
                cpp_current_dict = cpp_parent_dict;
              }

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                cpp_template = "[ MAT , 6 , MT / 0.0 , E , 0 , 0 , NRM , NMU / mu ] TAB2 ( mu_interpol [ j ] )";
                // read TAB2 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable NMU
                var_NMU_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                validate_vartype_consistency("NMU", NESTEDVECTOR_INT, aux_last_type_read_for_NMU);
                aux_last_type_read_for_NMU = NESTEDVECTOR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.setdefault("mu_interpol", std::vector<int>({var_j_0d_int_Scalar}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  // variable declarations
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }

                for (int var_k_0d_int_Scalar = 1;
                   var_k_0d_int_Scalar <= var_NMU_1d_int_NestedVector[var_j_0d_int_Scalar]; var_k_0d_int_Scalar++) {
                  bool aux_k_read = true;
                  cpp_template = "[ MAT , 6 , MT / 0.0 , mu , 0 , 0 , NRP , NEP / Ep / f ] TAB1 ( table [ j , k ] )";
                  // read TAB1 record
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable mu
                  ptr_mu_2d_idx0 = var_mu_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);
                  ptr_mu_2d_idx0->set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
                  validate_vartype_consistency("mu", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_mu);
                  aux_last_type_read_for_mu = NESTEDVECTOR_DOUBLE;
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  {
                    py::dict cpp_parent_dict = cpp_current_dict;
                    cpp_current_dict = cpp_index_shifter_store.setdefault("table", std::vector<int>({var_j_0d_int_Scalar, var_k_0d_int_Scalar}), py::dict());
                    IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                    cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    // variable declarations
                    std::vector<EndfFloatCpp> var_Ep_0d_floatvec_Scalar;
                    bool aux_Ep_read = false;
                    vartype aux_last_type_read_for_Ep = UNKNOWN;
                    std::vector<EndfFloatCpp> var_f_0d_floatvec_Scalar;
                    bool aux_f_read = false;
                    vartype aux_last_type_read_for_f = UNKNOWN;
                    std::vector<int> var_INT_0d_intvec_Scalar;
                    bool aux_INT_read = false;
                    vartype aux_last_type_read_for_INT = UNKNOWN;
                    std::vector<int> var_NBT_0d_intvec_Scalar;
                    bool aux_NBT_read = false;
                    vartype aux_last_type_read_for_NBT = UNKNOWN;
                    {
                      Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                      // assign expression to variable Ep
                      var_Ep_0d_floatvec_Scalar = tab_body.X;
                      aux_Ep_read = true;
                      validate_vartype_consistency("Ep", SCALAR_FLOATVEC, aux_last_type_read_for_Ep);
                      aux_last_type_read_for_Ep = SCALAR_FLOATVEC;
                      // assign expression to variable f
                      var_f_0d_floatvec_Scalar = tab_body.Y;
                      aux_f_read = true;
                      validate_vartype_consistency("f", SCALAR_FLOATVEC, aux_last_type_read_for_f);
                      aux_last_type_read_for_f = SCALAR_FLOATVEC;
                      // assign expression to variable INT
                      var_INT_0d_intvec_Scalar = tab_body.INT;
                      aux_INT_read = true;
                      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                      aux_last_type_read_for_INT = SCALAR_INTVEC;
                      // assign expression to variable NBT
                      var_NBT_0d_intvec_Scalar = tab_body.NBT;
                      aux_NBT_read = true;
                      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                      aux_last_type_read_for_NBT = SCALAR_INTVEC;
                    }
                    // store data in Python dictionary
                    if (((aux_last_type_read_for_Ep == SCALAR_FLOATVEC) && (aux_Ep_read == true))) {
                      cpp_current_dict["Ep"] = var_Ep_0d_floatvec_Scalar;
                    }
                    if (((aux_last_type_read_for_f == SCALAR_FLOATVEC) && (aux_f_read == true))) {
                      cpp_current_dict["f"] = var_f_0d_floatvec_Scalar;
                    }
                    if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                      cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                    }
                    if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                      cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                    }
                    cpp_current_dict = cpp_parent_dict;
                  }
                }
              }
            }
          }
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_ZAP == SCALAR_DOUBLE) && (aux_ZAP_read == true))) {
        cpp_current_dict["ZAP"] = var_ZAP_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_AWP == SCALAR_DOUBLE) && (aux_AWP_read == true))) {
        cpp_current_dict["AWP"] = var_AWP_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_LIP == SCALAR_INT) && (aux_LIP_read == true))) {
        cpp_current_dict["LIP"] = var_LIP_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LAW == SCALAR_INT) && (aux_LAW_read == true))) {
        cpp_current_dict["LAW"] = var_LAW_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LANG == SCALAR_INT) && (aux_LANG_read == true))) {
        cpp_current_dict["LANG"] = var_LANG_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LEP == SCALAR_INT) && (aux_LEP_read == true))) {
        cpp_current_dict["LEP"] = var_LEP_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
        cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
      }
      if ((var_ND_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["ND"] = var_ND_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_NA_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["NA"] = var_NA_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_NEP_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["NEP"] = var_NEP_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_Ep_2d_double_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["Ep"] = var_Ep_2d_double_NestedVector.to_pyobj(list_mode);
      }
      if ((var_b_3d_double_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["b"] = var_b_3d_double_NestedVector.to_pyobj(list_mode);
      }
      if ((var_NLW_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["NLW"] = var_NLW_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_NL_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["NL"] = var_NL_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_A_2d_double_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["A"] = var_A_2d_double_NestedVector.to_pyobj(list_mode);
      }
      if (((aux_last_type_read_for_SPI == SCALAR_DOUBLE) && (aux_SPI_read == true))) {
        cpp_current_dict["SPI"] = var_SPI_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_LIDP == SCALAR_INT) && (aux_LIDP_read == true))) {
        cpp_current_dict["LIDP"] = var_LIDP_0d_int_Scalar;
      }
      if ((var_LTP_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["LTP"] = var_LTP_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_NW_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["NW"] = var_NW_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if (((aux_last_type_read_for_APSX == SCALAR_DOUBLE) && (aux_APSX_read == true))) {
        cpp_current_dict["APSX"] = var_APSX_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_NPSX == SCALAR_INT) && (aux_NPSX_read == true))) {
        cpp_current_dict["NPSX"] = var_NPSX_0d_int_Scalar;
      }
      if ((var_NMU_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["NMU"] = var_NMU_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_mu_2d_double_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["mu"] = var_mu_2d_double_NestedVector.to_pyobj(list_mode);
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_JP == SCALAR_INT) && (aux_JP_read == true))) {
    cpp_current_dict["JP"] = var_JP_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LCT == SCALAR_INT) && (aux_LCT_read == true))) {
    cpp_current_dict["LCT"] = var_LCT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NK == SCALAR_INT) && (aux_NK_read == true))) {
    cpp_current_dict["NK"] = var_NK_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: bd9c9da4de018928918c4acb82f32a0a
// MD5 hash of the following function definition: 0a556ea42763dec5d400c11efe32566c
py::dict parse_mf7mt2_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LTHR_0d_int_Scalar;
  bool aux_LTHR_read = false;
  vartype aux_last_type_read_for_LTHR = UNKNOWN;
  EndfFloatCpp var_T0_0d_double_Scalar;
  bool aux_T0_read = false;
  vartype aux_last_type_read_for_T0 = UNKNOWN;
  int var_LT_0d_int_Scalar;
  bool aux_LT_read = false;
  vartype aux_last_type_read_for_LT = UNKNOWN;
  NestedVector<EndfFloatCpp> var_T_1d_double_NestedVector;
  vartype aux_last_type_read_for_T = UNKNOWN;
  int var_LI_0d_int_Scalar;
  bool aux_LI_read = false;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_NP_0d_int_Scalar;
  bool aux_NP_read = false;
  vartype aux_last_type_read_for_NP = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_S_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_S_2d_idx0;
  vartype aux_last_type_read_for_S = UNKNOWN;
  EndfFloatCpp var_SB_0d_double_Scalar;
  bool aux_SB_read = false;
  vartype aux_last_type_read_for_SB = UNKNOWN;
  std::vector<EndfFloatCpp> var_Tint_0d_floatvec_Scalar;
  bool aux_Tint_read = false;
  vartype aux_last_type_read_for_Tint = UNKNOWN;
  std::vector<EndfFloatCpp> var_Wp_0d_floatvec_Scalar;
  bool aux_Wp_read = false;
  vartype aux_last_type_read_for_Wp = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 7;
  int mt = 2;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 7;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 2;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 7 , 2 / ZA , AWR , LTHR , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LTHR
  var_LTHR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LTHR_read = true;
  validate_vartype_consistency("LTHR", SCALAR_INT, aux_last_type_read_for_LTHR);
  aux_last_type_read_for_LTHR = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_LTHR_read == true)) && ((var_LTHR_0d_int_Scalar)==(1)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 2 / T0 , 0.0 , LT , 0 , NR , NP / Eint / S ] TAB1 ( S_T0_table )";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        // assign expression to variable T0
        var_T0_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
        aux_T0_read = true;
        validate_vartype_consistency("T0", SCALAR_DOUBLE, aux_last_type_read_for_T0);
        aux_last_type_read_for_T0 = SCALAR_DOUBLE;
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        // assign expression to variable LT
        var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
        aux_LT_read = true;
        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
        aux_last_type_read_for_LT = SCALAR_INT;
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.setdefault("S_T0_table", std::vector<int>({}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          // variable declarations
          std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
          bool aux_Eint_read = false;
          vartype aux_last_type_read_for_Eint = UNKNOWN;
          std::vector<EndfFloatCpp> var_S_0d_floatvec_Scalar;
          bool aux_S_read = false;
          vartype aux_last_type_read_for_S = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Eint
            var_Eint_0d_floatvec_Scalar = tab_body.X;
            aux_Eint_read = true;
            validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
            aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
            // assign expression to variable S
            var_S_0d_floatvec_Scalar = tab_body.Y;
            aux_S_read = true;
            validate_vartype_consistency("S", SCALAR_FLOATVEC, aux_last_type_read_for_S);
            aux_last_type_read_for_S = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
            cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_S == SCALAR_FLOATVEC) && (aux_S_read == true))) {
            cpp_current_dict["S"] = var_S_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
            cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
          }
          if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
            cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
          }
          cpp_current_dict = cpp_parent_dict;
        }

        for (int var_i_0d_int_Scalar = 1;
           var_i_0d_int_Scalar <= var_LT_0d_int_Scalar; var_i_0d_int_Scalar++) {
          bool aux_i_read = true;
          cpp_template = "[ MAT , 7 , 2 / T , 0.0 , LI , 0 , NP , 0 / \n { S } { q = 1 to NP } ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          // assign expression to variable T
          var_T_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts));
          validate_vartype_consistency("T", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_T);
          aux_last_type_read_for_T = NESTEDVECTOR_DOUBLE;
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable LI
          var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NP
          var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NP_read = true;
          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
          aux_last_type_read_for_NP = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body

            for (int var_q_0d_int_Scalar = 1;
               var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
              bool aux_q_read = true;
              // read LIST body
              // assign expression to variable S
              ptr_S_2d_idx0 = var_S_2d_double_NestedVector.prepare(var_q_0d_int_Scalar);
              ptr_S_2d_idx0->set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("S", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_S);
              aux_last_type_read_for_S = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LTHR_read == true)) && ((var_LTHR_0d_int_Scalar)==(2)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 7 , 2 / SB , 0.0 , 0 , 0 , NR , NP / Tint / Wp ] TAB1";
          // read TAB1 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // assign expression to variable SB
          var_SB_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_SB_read = true;
          validate_vartype_consistency("SB", SCALAR_DOUBLE, aux_last_type_read_for_SB);
          aux_last_type_read_for_SB = SCALAR_DOUBLE;
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          {
            Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Wp
            var_Wp_0d_floatvec_Scalar = tab_body.Y;
            aux_Wp_read = true;
            validate_vartype_consistency("Wp", SCALAR_FLOATVEC, aux_last_type_read_for_Wp);
            aux_last_type_read_for_Wp = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LTHR_read == true)) && ((var_LTHR_0d_int_Scalar)==(3)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 7 , 2 / T0 , 0.0 , LT , 0 , NR , NP / Eint / S ] TAB1 ( S_T0_table )";
          // read TAB1 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // assign expression to variable T0
          var_T0_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_T0_read = true;
          validate_vartype_consistency("T0", SCALAR_DOUBLE, aux_last_type_read_for_T0);
          aux_last_type_read_for_T0 = SCALAR_DOUBLE;
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable LT
          var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LT_read = true;
          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
          aux_last_type_read_for_LT = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.setdefault("S_T0_table", std::vector<int>({}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            // variable declarations
            std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
            bool aux_Eint_read = false;
            vartype aux_last_type_read_for_Eint = UNKNOWN;
            std::vector<EndfFloatCpp> var_S_0d_floatvec_Scalar;
            bool aux_S_read = false;
            vartype aux_last_type_read_for_S = UNKNOWN;
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
              // assign expression to variable Eint
              var_Eint_0d_floatvec_Scalar = tab_body.X;
              aux_Eint_read = true;
              validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
              aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
              // assign expression to variable S
              var_S_0d_floatvec_Scalar = tab_body.Y;
              aux_S_read = true;
              validate_vartype_consistency("S", SCALAR_FLOATVEC, aux_last_type_read_for_S);
              aux_last_type_read_for_S = SCALAR_FLOATVEC;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
              cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
            }
            if (((aux_last_type_read_for_S == SCALAR_FLOATVEC) && (aux_S_read == true))) {
              cpp_current_dict["S"] = var_S_0d_floatvec_Scalar;
            }
            if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
              cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
            }
            if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
              cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
            }
            cpp_current_dict = cpp_parent_dict;
          }

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_LT_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 7 , 2 / T , 0.0 , LI , 0 , NP , 0 / \n { S } { q = 1 to NP } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            // assign expression to variable T
            var_T_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts));
            validate_vartype_consistency("T", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_T);
            aux_last_type_read_for_T = NESTEDVECTOR_DOUBLE;
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable LI
            var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable NP
            var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NP_read = true;
            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
            aux_last_type_read_for_NP = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body

              for (int var_q_0d_int_Scalar = 1;
                 var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
                bool aux_q_read = true;
                // read LIST body
                // assign expression to variable S
                ptr_S_2d_idx0 = var_S_2d_double_NestedVector.prepare(var_q_0d_int_Scalar);
                ptr_S_2d_idx0->set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("S", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_S);
                aux_last_type_read_for_S = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
          }
          cpp_template = "[ MAT , 7 , 2 / SB , 0.0 , 0 , 0 , NR , NP / Tint / Wp ] TAB1";
          // read TAB1 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // assign expression to variable SB
          var_SB_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_SB_read = true;
          validate_vartype_consistency("SB", SCALAR_DOUBLE, aux_last_type_read_for_SB);
          aux_last_type_read_for_SB = SCALAR_DOUBLE;
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          {
            Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Wp
            var_Wp_0d_floatvec_Scalar = tab_body.Y;
            aux_Wp_read = true;
            validate_vartype_consistency("Wp", SCALAR_FLOATVEC, aux_last_type_read_for_Wp);
            aux_last_type_read_for_Wp = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LTHR == SCALAR_INT) && (aux_LTHR_read == true))) {
    cpp_current_dict["LTHR"] = var_LTHR_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_T0 == SCALAR_DOUBLE) && (aux_T0_read == true))) {
    cpp_current_dict["T0"] = var_T0_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LT == SCALAR_INT) && (aux_LT_read == true))) {
    cpp_current_dict["LT"] = var_LT_0d_int_Scalar;
  }
  if ((var_T_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["T"] = var_T_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_LI == SCALAR_INT) && (aux_LI_read == true))) {
    cpp_current_dict["LI"] = var_LI_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NP == SCALAR_INT) && (aux_NP_read == true))) {
    cpp_current_dict["NP"] = var_NP_0d_int_Scalar;
  }
  if ((var_S_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["S"] = var_S_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_SB == SCALAR_DOUBLE) && (aux_SB_read == true))) {
    cpp_current_dict["SB"] = var_SB_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_Tint == SCALAR_FLOATVEC) && (aux_Tint_read == true))) {
    cpp_current_dict["Tint"] = var_Tint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_Wp == SCALAR_FLOATVEC) && (aux_Wp_read == true))) {
    cpp_current_dict["Wp"] = var_Wp_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: a3934a161c54e232c57d90823e77ee29
// MD5 hash of the following function definition: 6fb24b7b1dbd1fcb28e452cbbb2ec91c
py::dict parse_mf7mt4_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LAT_0d_int_Scalar;
  bool aux_LAT_read = false;
  vartype aux_last_type_read_for_LAT = UNKNOWN;
  int var_LASYM_0d_int_Scalar;
  bool aux_LASYM_read = false;
  vartype aux_last_type_read_for_LASYM = UNKNOWN;
  int var_LLN_0d_int_Scalar;
  bool aux_LLN_read = false;
  vartype aux_last_type_read_for_LLN = UNKNOWN;
  int var_NI_0d_int_Scalar;
  bool aux_NI_read = false;
  vartype aux_last_type_read_for_NI = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  NestedVector<EndfFloatCpp> var_B_1d_double_NestedVector;
  vartype aux_last_type_read_for_B = UNKNOWN;
  int var_NB_0d_int_Scalar;
  bool aux_NB_read = false;
  vartype aux_last_type_read_for_NB = UNKNOWN;
  EndfFloatCpp var_T0_0d_double_Scalar;
  bool aux_T0_read = false;
  vartype aux_last_type_read_for_T0 = UNKNOWN;
  NestedVector<EndfFloatCpp> var_beta_1d_double_NestedVector;
  vartype aux_last_type_read_for_beta = UNKNOWN;
  NestedVector<int> var_LT_1d_int_NestedVector;
  vartype aux_last_type_read_for_LT = UNKNOWN;
  NestedVector<EndfFloatCpp> var_T_1d_double_NestedVector;
  vartype aux_last_type_read_for_T = UNKNOWN;
  NestedVector<int> var_LI_1d_int_NestedVector;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_NP_0d_int_Scalar;
  bool aux_NP_read = false;
  vartype aux_last_type_read_for_NP = UNKNOWN;
  NestedVector<NestedVector<NestedVector<EndfFloatCpp>>> var_S_3d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_S_3d_idx1;
  NestedVector<NestedVector<EndfFloatCpp>>* ptr_S_3d_idx0;
  vartype aux_last_type_read_for_S = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 7;
  int mt = 4;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 7;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 4;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 7 , 4 / ZA , AWR , 0 , LAT , LASYM , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LAT
  var_LAT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LAT_read = true;
  validate_vartype_consistency("LAT", SCALAR_INT, aux_last_type_read_for_LAT);
  aux_last_type_read_for_LAT = SCALAR_INT;
  // assign expression to variable LASYM
  var_LASYM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_LASYM_read = true;
  validate_vartype_consistency("LASYM", SCALAR_INT, aux_last_type_read_for_LASYM);
  aux_last_type_read_for_LASYM = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , LLN , 0 , NI , NS / { B } { n = 1 to NI } ] LIST";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read LIST record
  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LLN
  var_LLN_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LLN_read = true;
  validate_vartype_consistency("LLN", SCALAR_INT, aux_last_type_read_for_LLN);
  aux_last_type_read_for_LLN = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NI
  var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NI_read = true;
  validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
  aux_last_type_read_for_NI = SCALAR_INT;
  // assign expression to variable NS
  var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  {
    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST body

    for (int var_n_0d_int_Scalar = 1;
       var_n_0d_int_Scalar <= var_NI_0d_int_Scalar; var_n_0d_int_Scalar++) {
      bool aux_n_read = true;
      // read LIST body
      // assign expression to variable B
      var_B_1d_double_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("B", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_B);
      aux_last_type_read_for_B = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }
  cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NB / beta_int ] TAB2 ( beta_interp )";
  // read TAB2 record
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NB
  var_NB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NB_read = true;
  validate_vartype_consistency("NB", SCALAR_INT, aux_last_type_read_for_NB);
  aux_last_type_read_for_NB = SCALAR_INT;
  {
    py::dict cpp_parent_dict = cpp_current_dict;
    cpp_current_dict = cpp_index_shifter_store.setdefault("beta_interp", std::vector<int>({}), py::dict());
    IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
    cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    // variable declarations
    std::vector<int> var_INT_0d_intvec_Scalar;
    bool aux_INT_read = false;
    vartype aux_last_type_read_for_INT = UNKNOWN;
    std::vector<int> var_NBT_0d_intvec_Scalar;
    bool aux_NBT_read = false;
    vartype aux_last_type_read_for_NBT = UNKNOWN;
    {
      Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
      // assign expression to variable INT
      var_INT_0d_intvec_Scalar = tab_body.INT;
      aux_INT_read = true;
      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
      aux_last_type_read_for_INT = SCALAR_INTVEC;
      // assign expression to variable NBT
      var_NBT_0d_intvec_Scalar = tab_body.NBT;
      aux_NBT_read = true;
      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
      aux_last_type_read_for_NBT = SCALAR_INTVEC;
    }
    // store data in Python dictionary
    if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
      cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
    }
    if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
      cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
    }
    cpp_current_dict = cpp_parent_dict;
  }

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NB_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 7 , 4 / T0 , beta , LT , 0 , NR , NP / alpha / S ] TAB1 ( S_table [ i ] )";
    // read TAB1 record
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // assign expression to variable T0
    var_T0_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
    aux_T0_read = true;
    validate_vartype_consistency("T0", SCALAR_DOUBLE, aux_last_type_read_for_T0);
    aux_last_type_read_for_T0 = SCALAR_DOUBLE;
    // assign expression to variable beta
    var_beta_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
    validate_vartype_consistency("beta", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_beta);
    aux_last_type_read_for_beta = NESTEDVECTOR_DOUBLE;
    // assign expression to variable LT
    var_LT_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
    validate_vartype_consistency("LT", NESTEDVECTOR_INT, aux_last_type_read_for_LT);
    aux_last_type_read_for_LT = NESTEDVECTOR_INT;
    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
      cpp_template, cpp_line, parse_opts);
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.setdefault("S_table", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
      // variable declarations
      std::vector<EndfFloatCpp> var_alpha_0d_floatvec_Scalar;
      bool aux_alpha_read = false;
      vartype aux_last_type_read_for_alpha = UNKNOWN;
      std::vector<EndfFloatCpp> var_S_0d_floatvec_Scalar;
      bool aux_S_read = false;
      vartype aux_last_type_read_for_S = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      {
        Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
        // assign expression to variable alpha
        var_alpha_0d_floatvec_Scalar = tab_body.X;
        aux_alpha_read = true;
        validate_vartype_consistency("alpha", SCALAR_FLOATVEC, aux_last_type_read_for_alpha);
        aux_last_type_read_for_alpha = SCALAR_FLOATVEC;
        // assign expression to variable S
        var_S_0d_floatvec_Scalar = tab_body.Y;
        aux_S_read = true;
        validate_vartype_consistency("S", SCALAR_FLOATVEC, aux_last_type_read_for_S);
        aux_last_type_read_for_S = SCALAR_FLOATVEC;
        // assign expression to variable INT
        var_INT_0d_intvec_Scalar = tab_body.INT;
        aux_INT_read = true;
        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
        aux_last_type_read_for_INT = SCALAR_INTVEC;
        // assign expression to variable NBT
        var_NBT_0d_intvec_Scalar = tab_body.NBT;
        aux_NBT_read = true;
        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
        aux_last_type_read_for_NBT = SCALAR_INTVEC;
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_alpha == SCALAR_FLOATVEC) && (aux_alpha_read == true))) {
        cpp_current_dict["alpha"] = var_alpha_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_S == SCALAR_FLOATVEC) && (aux_S_read == true))) {
        cpp_current_dict["S"] = var_S_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }

    for (int var_j_0d_int_Scalar = 1;
       var_j_0d_int_Scalar <= var_LT_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
      bool aux_j_read = true;
      cpp_template = "[ MAT , 7 , 4 / T , beta , LI , 0 , NP , 0 / { S } { q = 1 to NP } ] LIST";
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read LIST record
      // assign expression to variable T
      var_T_1d_double_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts));
      validate_vartype_consistency("T", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_T);
      aux_last_type_read_for_T = NESTEDVECTOR_DOUBLE;
      if ((! var_beta_1d_double_NestedVector.contains(var_i_0d_int_Scalar))) {
        // assign expression to variable beta
        var_beta_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
        validate_vartype_consistency("beta", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_beta);
        aux_last_type_read_for_beta = NESTEDVECTOR_DOUBLE;
      } else {
        cpp_validate_field(var_beta_1d_double_NestedVector[var_i_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "beta",
          cpp_template, cpp_line, parse_opts);
      }
      // assign expression to variable LI
      var_LI_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
      validate_vartype_consistency("LI", NESTEDVECTOR_INT, aux_last_type_read_for_LI);
      aux_last_type_read_for_LI = NESTEDVECTOR_INT;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
      // assign expression to variable NP
      var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      aux_NP_read = true;
      validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
      aux_last_type_read_for_NP = SCALAR_INT;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
      {
        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        int cpp_i = 0;
        int cpp_j = 0;
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        // read LIST body

        for (int var_q_0d_int_Scalar = 1;
           var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
          bool aux_q_read = true;
          // read LIST body
          // assign expression to variable S
          ptr_S_3d_idx0 = var_S_3d_double_NestedVector.prepare(var_q_0d_int_Scalar);
          ptr_S_3d_idx1 = ptr_S_3d_idx0->prepare(var_i_0d_int_Scalar);
          ptr_S_3d_idx1->set(var_j_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("S", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_S);
          aux_last_type_read_for_S = NESTEDVECTOR_DOUBLE;
          cpp_i++;
          cpp_j++;
          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            cpp_j = 0;
          }
        }
        if (cpp_i != cpp_npl) {
          throw std::runtime_error("not exactly NPL elements consumed");
        }
      }
    }
  }
  cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff0 ] TAB1 ( teff0_table )";
  // read TAB1 record
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  {
    py::dict cpp_parent_dict = cpp_current_dict;
    cpp_current_dict = cpp_index_shifter_store.setdefault("teff0_table", std::vector<int>({}), py::dict());
    IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
    cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
    // variable declarations
    std::vector<EndfFloatCpp> var_Tint_0d_floatvec_Scalar;
    bool aux_Tint_read = false;
    vartype aux_last_type_read_for_Tint = UNKNOWN;
    std::vector<EndfFloatCpp> var_Teff0_0d_floatvec_Scalar;
    bool aux_Teff0_read = false;
    vartype aux_last_type_read_for_Teff0 = UNKNOWN;
    std::vector<int> var_INT_0d_intvec_Scalar;
    bool aux_INT_read = false;
    vartype aux_last_type_read_for_INT = UNKNOWN;
    std::vector<int> var_NBT_0d_intvec_Scalar;
    bool aux_NBT_read = false;
    vartype aux_last_type_read_for_NBT = UNKNOWN;
    {
      Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
      // assign expression to variable Tint
      var_Tint_0d_floatvec_Scalar = tab_body.X;
      aux_Tint_read = true;
      validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
      aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
      // assign expression to variable Teff0
      var_Teff0_0d_floatvec_Scalar = tab_body.Y;
      aux_Teff0_read = true;
      validate_vartype_consistency("Teff0", SCALAR_FLOATVEC, aux_last_type_read_for_Teff0);
      aux_last_type_read_for_Teff0 = SCALAR_FLOATVEC;
      // assign expression to variable INT
      var_INT_0d_intvec_Scalar = tab_body.INT;
      aux_INT_read = true;
      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
      aux_last_type_read_for_INT = SCALAR_INTVEC;
      // assign expression to variable NBT
      var_NBT_0d_intvec_Scalar = tab_body.NBT;
      aux_NBT_read = true;
      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
      aux_last_type_read_for_NBT = SCALAR_INTVEC;
    }
    // store data in Python dictionary
    if (((aux_last_type_read_for_Tint == SCALAR_FLOATVEC) && (aux_Tint_read == true))) {
      cpp_current_dict["Tint"] = var_Tint_0d_floatvec_Scalar;
    }
    if (((aux_last_type_read_for_Teff0 == SCALAR_FLOATVEC) && (aux_Teff0_read == true))) {
      cpp_current_dict["Teff0"] = var_Teff0_0d_floatvec_Scalar;
    }
    if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
      cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
    }
    if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
      cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
    }
    cpp_current_dict = cpp_parent_dict;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_NI_read == true)) && ((var_NI_0d_int_Scalar)>=(7)))))&&(((var_B_1d_double_NestedVector.contains(7)) && ((var_B_1d_double_NestedVector[7])==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff1 ] TAB1 ( teff1_table )";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.setdefault("teff1_table", std::vector<int>({}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          // variable declarations
          std::vector<EndfFloatCpp> var_Tint_0d_floatvec_Scalar;
          bool aux_Tint_read = false;
          vartype aux_last_type_read_for_Tint = UNKNOWN;
          std::vector<EndfFloatCpp> var_Teff1_0d_floatvec_Scalar;
          bool aux_Teff1_read = false;
          vartype aux_last_type_read_for_Teff1 = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Teff1
            var_Teff1_0d_floatvec_Scalar = tab_body.Y;
            aux_Teff1_read = true;
            validate_vartype_consistency("Teff1", SCALAR_FLOATVEC, aux_last_type_read_for_Teff1);
            aux_last_type_read_for_Teff1 = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_Tint == SCALAR_FLOATVEC) && (aux_Tint_read == true))) {
            cpp_current_dict["Tint"] = var_Tint_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_Teff1 == SCALAR_FLOATVEC) && (aux_Teff1_read == true))) {
            cpp_current_dict["Teff1"] = var_Teff1_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
            cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
          }
          if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
            cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
    }
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_NI_read == true)) && ((var_NI_0d_int_Scalar)>=(13)))))&&(((var_B_1d_double_NestedVector.contains(13)) && ((var_B_1d_double_NestedVector[13])==(0.0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff2 ] TAB1 ( teff2_table )";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.setdefault("teff2_table", std::vector<int>({}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          // variable declarations
          std::vector<EndfFloatCpp> var_Tint_0d_floatvec_Scalar;
          bool aux_Tint_read = false;
          vartype aux_last_type_read_for_Tint = UNKNOWN;
          std::vector<EndfFloatCpp> var_Teff2_0d_floatvec_Scalar;
          bool aux_Teff2_read = false;
          vartype aux_last_type_read_for_Teff2 = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Teff2
            var_Teff2_0d_floatvec_Scalar = tab_body.Y;
            aux_Teff2_read = true;
            validate_vartype_consistency("Teff2", SCALAR_FLOATVEC, aux_last_type_read_for_Teff2);
            aux_last_type_read_for_Teff2 = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_Tint == SCALAR_FLOATVEC) && (aux_Tint_read == true))) {
            cpp_current_dict["Tint"] = var_Tint_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_Teff2 == SCALAR_FLOATVEC) && (aux_Teff2_read == true))) {
            cpp_current_dict["Teff2"] = var_Teff2_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
            cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
          }
          if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
            cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
    }
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_NI_read == true)) && ((var_NI_0d_int_Scalar)>=(19)))))&&(((var_B_1d_double_NestedVector.contains(19)) && ((var_B_1d_double_NestedVector[19])==(0.0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff3 ] TAB1 ( teff3_table )";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.setdefault("teff3_table", std::vector<int>({}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          // variable declarations
          std::vector<EndfFloatCpp> var_Tint_0d_floatvec_Scalar;
          bool aux_Tint_read = false;
          vartype aux_last_type_read_for_Tint = UNKNOWN;
          std::vector<EndfFloatCpp> var_Teff3_0d_floatvec_Scalar;
          bool aux_Teff3_read = false;
          vartype aux_last_type_read_for_Teff3 = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Teff3
            var_Teff3_0d_floatvec_Scalar = tab_body.Y;
            aux_Teff3_read = true;
            validate_vartype_consistency("Teff3", SCALAR_FLOATVEC, aux_last_type_read_for_Teff3);
            aux_last_type_read_for_Teff3 = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_Tint == SCALAR_FLOATVEC) && (aux_Tint_read == true))) {
            cpp_current_dict["Tint"] = var_Tint_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_Teff3 == SCALAR_FLOATVEC) && (aux_Teff3_read == true))) {
            cpp_current_dict["Teff3"] = var_Teff3_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
            cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
          }
          if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
            cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LAT == SCALAR_INT) && (aux_LAT_read == true))) {
    cpp_current_dict["LAT"] = var_LAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LASYM == SCALAR_INT) && (aux_LASYM_read == true))) {
    cpp_current_dict["LASYM"] = var_LASYM_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LLN == SCALAR_INT) && (aux_LLN_read == true))) {
    cpp_current_dict["LLN"] = var_LLN_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NI == SCALAR_INT) && (aux_NI_read == true))) {
    cpp_current_dict["NI"] = var_NI_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NS == SCALAR_INT) && (aux_NS_read == true))) {
    cpp_current_dict["NS"] = var_NS_0d_int_Scalar;
  }
  if ((var_B_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["B"] = var_B_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_NB == SCALAR_INT) && (aux_NB_read == true))) {
    cpp_current_dict["NB"] = var_NB_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_T0 == SCALAR_DOUBLE) && (aux_T0_read == true))) {
    cpp_current_dict["T0"] = var_T0_0d_double_Scalar;
  }
  if ((var_beta_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["beta"] = var_beta_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_LT_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["LT"] = var_LT_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_T_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["T"] = var_T_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_LI_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["LI"] = var_LI_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_NP == SCALAR_INT) && (aux_NP_read == true))) {
    cpp_current_dict["NP"] = var_NP_0d_int_Scalar;
  }
  if ((var_S_3d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["S"] = var_S_3d_double_NestedVector.to_pyobj(list_mode);
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 0468c7052e96f983d6f680ae2b54c677
// MD5 hash of the following function definition: 28211a3f6ec90d9a4202a66b8b69094f
py::dict parse_mf7mt451_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NA_0d_int_Scalar;
  bool aux_NA_read = false;
  vartype aux_last_type_read_for_NA = UNKNOWN;
  int var_NAS_0d_int_Scalar;
  bool aux_NAS_read = false;
  vartype aux_last_type_read_for_NAS = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<int> var_NI_1d_int_NestedVector;
  vartype aux_last_type_read_for_NI = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_ZAI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_ZAI_2d_idx0;
  vartype aux_last_type_read_for_ZAI = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_LISI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_LISI_2d_idx0;
  vartype aux_last_type_read_for_LISI = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_AFI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_AFI_2d_idx0;
  vartype aux_last_type_read_for_AFI = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_AWRI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_AWRI_2d_idx0;
  vartype aux_last_type_read_for_AWRI = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_SFI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_SFI_2d_idx0;
  vartype aux_last_type_read_for_SFI = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 7;
  int mt = 451;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 7;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 451;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 7 , 451 / ZA , AWR , NA , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable NA
  var_NA_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_NA_read = true;
  validate_vartype_consistency("NA", SCALAR_INT, aux_last_type_read_for_NA);
  aux_last_type_read_for_NA = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NA_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 7 , 451 / 0 , 0 , NAS , 0 , (6*NI) , NI / \n { ZAI , LISI , AFI , AWRI , SFI , 0 } { j = 1 to NI } ] LIST";
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST record
    cpp_validate_field(0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0",
      cpp_template, cpp_line, parse_opts);
    cpp_validate_field(0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0",
      cpp_template, cpp_line, parse_opts);
    // assign expression to variable NAS
    var_NAS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
    aux_NAS_read = true;
    validate_vartype_consistency("NAS", SCALAR_INT, aux_last_type_read_for_NAS);
    aux_last_type_read_for_NAS = SCALAR_INT;
    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
      cpp_template, cpp_line, parse_opts);
    // assign expression to variable cpp_int_val
    cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    aux_cpp_int_val_read = true;
    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
    // assign expression to variable NI
    var_NI_1d_int_NestedVector.set(var_i_0d_int_Scalar, (cpp_int_val/6));
    validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
    aux_last_type_read_for_NI = NESTEDVECTOR_INT;
    if ((! var_NI_1d_int_NestedVector.contains(var_i_0d_int_Scalar))) {
      // assign expression to variable NI
      var_NI_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
      validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
      aux_last_type_read_for_NI = NESTEDVECTOR_INT;
    } else {
      cpp_validate_field(var_NI_1d_int_NestedVector[var_i_0d_int_Scalar], cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NI",
        cpp_template, cpp_line, parse_opts);
    }
    {
      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      int cpp_i = 0;
      int cpp_j = 0;
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read LIST body
      ptr_ZAI_2d_idx0 = var_ZAI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_LISI_2d_idx0 = var_LISI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_AFI_2d_idx0 = var_AFI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_AWRI_2d_idx0 = var_AWRI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_SFI_2d_idx0 = var_SFI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

      for (int var_j_0d_int_Scalar = 1;
         var_j_0d_int_Scalar <= var_NI_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
        bool aux_j_read = true;
        // read LIST body
        // assign expression to variable ZAI
        ptr_ZAI_2d_idx0->set(var_j_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
        validate_vartype_consistency("ZAI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAI);
        aux_last_type_read_for_ZAI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        // assign expression to variable LISI
        ptr_LISI_2d_idx0->set(var_j_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
        validate_vartype_consistency("LISI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_LISI);
        aux_last_type_read_for_LISI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        // assign expression to variable AFI
        ptr_AFI_2d_idx0->set(var_j_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
        validate_vartype_consistency("AFI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AFI);
        aux_last_type_read_for_AFI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        // assign expression to variable AWRI
        ptr_AWRI_2d_idx0->set(var_j_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
        validate_vartype_consistency("AWRI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AWRI);
        aux_last_type_read_for_AWRI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        // assign expression to variable SFI
        ptr_SFI_2d_idx0->set(var_j_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
        validate_vartype_consistency("SFI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SFI);
        aux_last_type_read_for_SFI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        cpp_validate_field(0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
      }
      if (cpp_i != cpp_npl) {
        throw std::runtime_error("not exactly NPL elements consumed");
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NA == SCALAR_INT) && (aux_NA_read == true))) {
    cpp_current_dict["NA"] = var_NA_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NAS == SCALAR_INT) && (aux_NAS_read == true))) {
    cpp_current_dict["NAS"] = var_NAS_0d_int_Scalar;
  }
  if ((var_NI_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["NI"] = var_NI_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_ZAI_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["ZAI"] = var_ZAI_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_LISI_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["LISI"] = var_LISI_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_AFI_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["AFI"] = var_AFI_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_AWRI_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["AWRI"] = var_AWRI_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_SFI_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["SFI"] = var_SFI_2d_double_NestedVector.to_pyobj(list_mode);
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: e0fff507053b212e2ece7181a9f7fb15
// MD5 hash of the following function definition: 42d55cee97367ed0fe55f9868059e082
py::dict parse_mf8_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_LISO_0d_int_Scalar;
  bool aux_LISO_read = false;
  vartype aux_last_type_read_for_LISO = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  int var_NO_0d_int_Scalar;
  bool aux_NO_read = false;
  vartype aux_last_type_read_for_NO = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 8;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 8 , MT / ZA , AWR , LIS , LISO , NS , NO ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  // assign expression to variable LISO
  var_LISO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LISO_read = true;
  validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
  aux_last_type_read_for_LISO = SCALAR_INT;
  // assign expression to variable NS
  var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  // assign expression to variable NO
  var_NO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NO_read = true;
  validate_vartype_consistency("NO", SCALAR_INT, aux_last_type_read_for_NO);
  aux_last_type_read_for_NO = SCALAR_INT;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_NO_read == true)) && ((var_NO_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;

        for (int var_k_0d_int_Scalar = 1;
           var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
          bool aux_k_read = true;
          // open section subsection
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.setdefault("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            // variable declarations
            EndfFloatCpp var_ZAP_0d_double_Scalar;
            bool aux_ZAP_read = false;
            vartype aux_last_type_read_for_ZAP = UNKNOWN;
            EndfFloatCpp var_ELFS_0d_double_Scalar;
            bool aux_ELFS_read = false;
            vartype aux_last_type_read_for_ELFS = UNKNOWN;
            int var_LMF_0d_int_Scalar;
            bool aux_LMF_read = false;
            vartype aux_last_type_read_for_LMF = UNKNOWN;
            int var_LFS_0d_int_Scalar;
            bool aux_LFS_read = false;
            vartype aux_last_type_read_for_LFS = UNKNOWN;
            int cpp_int_val;
            bool aux_cpp_int_val_read = false;
            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
            int var_ND_0d_int_Scalar;
            bool aux_ND_read = false;
            vartype aux_last_type_read_for_ND = UNKNOWN;
            NestedVector<EndfFloatCpp> var_HL_1d_double_NestedVector;
            vartype aux_last_type_read_for_HL = UNKNOWN;
            NestedVector<EndfFloatCpp> var_RTYP_1d_double_NestedVector;
            vartype aux_last_type_read_for_RTYP = UNKNOWN;
            NestedVector<EndfFloatCpp> var_ZAN_1d_double_NestedVector;
            vartype aux_last_type_read_for_ZAN = UNKNOWN;
            NestedVector<EndfFloatCpp> var_BR_1d_double_NestedVector;
            vartype aux_last_type_read_for_BR = UNKNOWN;
            NestedVector<EndfFloatCpp> var_END_1d_double_NestedVector;
            vartype aux_last_type_read_for_END = UNKNOWN;
            NestedVector<EndfFloatCpp> var_CT_1d_double_NestedVector;
            vartype aux_last_type_read_for_CT = UNKNOWN;
            cpp_template = "[ MAT , 8 , MT / ZAP , ELFS , LMF , LFS , (6*ND) , 0 / \n { HL , RTYP , ZAN , BR , END , CT } { l = 1 to ND } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            // assign expression to variable ZAP
            var_ZAP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_ZAP_read = true;
            validate_vartype_consistency("ZAP", SCALAR_DOUBLE, aux_last_type_read_for_ZAP);
            aux_last_type_read_for_ZAP = SCALAR_DOUBLE;
            // assign expression to variable ELFS
            var_ELFS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_ELFS_read = true;
            validate_vartype_consistency("ELFS", SCALAR_DOUBLE, aux_last_type_read_for_ELFS);
            aux_last_type_read_for_ELFS = SCALAR_DOUBLE;
            // assign expression to variable LMF
            var_LMF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LMF_read = true;
            validate_vartype_consistency("LMF", SCALAR_INT, aux_last_type_read_for_LMF);
            aux_last_type_read_for_LMF = SCALAR_INT;
            // assign expression to variable LFS
            var_LFS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LFS_read = true;
            validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
            aux_last_type_read_for_LFS = SCALAR_INT;
            // assign expression to variable cpp_int_val
            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_cpp_int_val_read = true;
            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
            // assign expression to variable ND
            var_ND_0d_int_Scalar = (cpp_int_val/6);
            aux_ND_read = true;
            validate_vartype_consistency("ND", SCALAR_INT, aux_last_type_read_for_ND);
            aux_last_type_read_for_ND = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_ND_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                // read LIST body
                // assign expression to variable HL
                var_HL_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("HL", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_HL);
                aux_last_type_read_for_HL = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable RTYP
                var_RTYP_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("RTYP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_RTYP);
                aux_last_type_read_for_RTYP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable ZAN
                var_ZAN_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("ZAN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAN);
                aux_last_type_read_for_ZAN = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable BR
                var_BR_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("BR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BR);
                aux_last_type_read_for_BR = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable END
                var_END_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("END", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_END);
                aux_last_type_read_for_END = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable CT
                var_CT_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("CT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_CT);
                aux_last_type_read_for_CT = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_ZAP == SCALAR_DOUBLE) && (aux_ZAP_read == true))) {
              cpp_current_dict["ZAP"] = var_ZAP_0d_double_Scalar;
            }
            if (((aux_last_type_read_for_ELFS == SCALAR_DOUBLE) && (aux_ELFS_read == true))) {
              cpp_current_dict["ELFS"] = var_ELFS_0d_double_Scalar;
            }
            if (((aux_last_type_read_for_LMF == SCALAR_INT) && (aux_LMF_read == true))) {
              cpp_current_dict["LMF"] = var_LMF_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_LFS == SCALAR_INT) && (aux_LFS_read == true))) {
              cpp_current_dict["LFS"] = var_LFS_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_ND == SCALAR_INT) && (aux_ND_read == true))) {
              cpp_current_dict["ND"] = var_ND_0d_int_Scalar;
            }
            if ((var_HL_1d_double_NestedVector.get_last_index() != -1)) {
              cpp_current_dict["HL"] = var_HL_1d_double_NestedVector.to_pyobj(list_mode);
            }
            if ((var_RTYP_1d_double_NestedVector.get_last_index() != -1)) {
              cpp_current_dict["RTYP"] = var_RTYP_1d_double_NestedVector.to_pyobj(list_mode);
            }
            if ((var_ZAN_1d_double_NestedVector.get_last_index() != -1)) {
              cpp_current_dict["ZAN"] = var_ZAN_1d_double_NestedVector.to_pyobj(list_mode);
            }
            if ((var_BR_1d_double_NestedVector.get_last_index() != -1)) {
              cpp_current_dict["BR"] = var_BR_1d_double_NestedVector.to_pyobj(list_mode);
            }
            if ((var_END_1d_double_NestedVector.get_last_index() != -1)) {
              cpp_current_dict["END"] = var_END_1d_double_NestedVector.to_pyobj(list_mode);
            }
            if ((var_CT_1d_double_NestedVector.get_last_index() != -1)) {
              cpp_current_dict["CT"] = var_CT_1d_double_NestedVector.to_pyobj(list_mode);
            }
            cpp_current_dict = cpp_parent_dict;
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_NO_read == true)) && ((var_NO_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // open section subsection
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.setdefault("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              // variable declarations
              EndfFloatCpp var_ZAP_0d_double_Scalar;
              bool aux_ZAP_read = false;
              vartype aux_last_type_read_for_ZAP = UNKNOWN;
              EndfFloatCpp var_ELFS_0d_double_Scalar;
              bool aux_ELFS_read = false;
              vartype aux_last_type_read_for_ELFS = UNKNOWN;
              int var_LMF_0d_int_Scalar;
              bool aux_LMF_read = false;
              vartype aux_last_type_read_for_LMF = UNKNOWN;
              int var_LFS_0d_int_Scalar;
              bool aux_LFS_read = false;
              vartype aux_last_type_read_for_LFS = UNKNOWN;
              cpp_template = "[ MAT , 8 , MT / ZAP , ELFS , LMF , LFS , 0 , 0 ] CONT";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read CONT record
              // assign expression to variable ZAP
              var_ZAP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
              aux_ZAP_read = true;
              validate_vartype_consistency("ZAP", SCALAR_DOUBLE, aux_last_type_read_for_ZAP);
              aux_last_type_read_for_ZAP = SCALAR_DOUBLE;
              // assign expression to variable ELFS
              var_ELFS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
              aux_ELFS_read = true;
              validate_vartype_consistency("ELFS", SCALAR_DOUBLE, aux_last_type_read_for_ELFS);
              aux_last_type_read_for_ELFS = SCALAR_DOUBLE;
              // assign expression to variable LMF
              var_LMF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LMF_read = true;
              validate_vartype_consistency("LMF", SCALAR_INT, aux_last_type_read_for_LMF);
              aux_last_type_read_for_LMF = SCALAR_INT;
              // assign expression to variable LFS
              var_LFS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LFS_read = true;
              validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
              aux_last_type_read_for_LFS = SCALAR_INT;
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // store data in Python dictionary
              if (((aux_last_type_read_for_ZAP == SCALAR_DOUBLE) && (aux_ZAP_read == true))) {
                cpp_current_dict["ZAP"] = var_ZAP_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_ELFS == SCALAR_DOUBLE) && (aux_ELFS_read == true))) {
                cpp_current_dict["ELFS"] = var_ELFS_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_LMF == SCALAR_INT) && (aux_LMF_read == true))) {
                cpp_current_dict["LMF"] = var_LMF_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_LFS == SCALAR_INT) && (aux_LFS_read == true))) {
                cpp_current_dict["LFS"] = var_LFS_0d_int_Scalar;
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LIS == SCALAR_INT) && (aux_LIS_read == true))) {
    cpp_current_dict["LIS"] = var_LIS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LISO == SCALAR_INT) && (aux_LISO_read == true))) {
    cpp_current_dict["LISO"] = var_LISO_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NS == SCALAR_INT) && (aux_NS_read == true))) {
    cpp_current_dict["NS"] = var_NS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NO == SCALAR_INT) && (aux_NO_read == true))) {
    cpp_current_dict["NO"] = var_NO_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 2c946085e67d919e399440582cef277e
// MD5 hash of the following function definition: a27303afc12b29e90d6dc1ce3b8dc9d7
py::dict parse_mf8mt454_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_LE_0d_int_Scalar;
  bool aux_LE_read = false;
  vartype aux_last_type_read_for_LE = UNKNOWN;
  NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<int> var_NN_1d_int_NestedVector;
  vartype aux_last_type_read_for_NN = UNKNOWN;
  NestedVector<int> var_NFP_1d_int_NestedVector;
  vartype aux_last_type_read_for_NFP = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_ZAFP_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_ZAFP_2d_idx0;
  vartype aux_last_type_read_for_ZAFP = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_FPS_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_FPS_2d_idx0;
  vartype aux_last_type_read_for_FPS = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_YI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_YI_2d_idx0;
  vartype aux_last_type_read_for_YI = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_DYI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_DYI_2d_idx0;
  vartype aux_last_type_read_for_DYI = UNKNOWN;
  NestedVector<int> var_I_1d_int_NestedVector;
  vartype aux_last_type_read_for_I = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 8;
  int mt = 454;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 454;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 8 , MT / ZA , AWR , (LE+1) , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable cpp_int_val
  cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_cpp_int_val_read = true;
  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
  // assign expression to variable LE
  var_LE_0d_int_Scalar = (cpp_int_val+(-1));
  aux_LE_read = true;
  validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
  aux_last_type_read_for_LE = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_template = "[ MAT , 8 , MT / E , 0.0 , LE , 0 , NN , NFP / \n { ZAFP , FPS , YI , DYI } { m = 1 to NFP } ] LIST";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read LIST record
  // assign expression to variable E
  var_E_1d_double_NestedVector.set(0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts));
  validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
  aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  if ((! (aux_LE_read == true))) {
    // assign expression to variable LE
    var_LE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
    aux_LE_read = true;
    validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
    aux_last_type_read_for_LE = SCALAR_INT;
  } else {
    cpp_validate_field(var_LE_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "LE",
      cpp_template, cpp_line, parse_opts);
  }
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NN
  var_NN_1d_int_NestedVector.set(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
  validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
  aux_last_type_read_for_NN = NESTEDVECTOR_INT;
  // assign expression to variable NFP
  var_NFP_1d_int_NestedVector.set(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
  validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
  aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
  {
    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST body
    ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(0);
    ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(0);
    ptr_YI_2d_idx0 = var_YI_2d_double_NestedVector.prepare(0);
    ptr_DYI_2d_idx0 = var_DYI_2d_double_NestedVector.prepare(0);

    for (int var_m_0d_int_Scalar = 1;
       var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[0]; var_m_0d_int_Scalar++) {
      bool aux_m_read = true;
      // read LIST body
      // assign expression to variable ZAFP
      ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
      aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
      // assign expression to variable FPS
      ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
      aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
      // assign expression to variable YI
      ptr_YI_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("YI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YI);
      aux_last_type_read_for_YI = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
      // assign expression to variable DYI
      ptr_DYI_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("DYI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYI);
      aux_last_type_read_for_DYI = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_LE_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    cpp_template = "[ MAT , 8 , MT / E , 0.0 , I , 0 , NN , NFP / \n { ZAFP , FPS , YI , DYI } { m = 1 to NFP } ] LIST";
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST record
    if ((! var_E_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable E
      var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts));
      validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
      aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
    } else {
      cpp_validate_field(var_E_1d_double_NestedVector[var_k_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "E",
        cpp_template, cpp_line, parse_opts);
    }
    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
      cpp_template, cpp_line, parse_opts);
    // assign expression to variable I
    var_I_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
    validate_vartype_consistency("I", NESTEDVECTOR_INT, aux_last_type_read_for_I);
    aux_last_type_read_for_I = NESTEDVECTOR_INT;
    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
      cpp_template, cpp_line, parse_opts);
    if ((! var_NN_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NN
      var_NN_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
      validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
      aux_last_type_read_for_NN = NESTEDVECTOR_INT;
    } else {
      cpp_validate_field(var_NN_1d_int_NestedVector[var_k_0d_int_Scalar], cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NN",
        cpp_template, cpp_line, parse_opts);
    }
    if ((! var_NFP_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NFP
      var_NFP_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
      validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
      aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
    } else {
      cpp_validate_field(var_NFP_1d_int_NestedVector[var_k_0d_int_Scalar], cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NFP",
        cpp_template, cpp_line, parse_opts);
    }
    {
      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      int cpp_i = 0;
      int cpp_j = 0;
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read LIST body
      ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_YI_2d_idx0 = var_YI_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_DYI_2d_idx0 = var_DYI_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

      for (int var_m_0d_int_Scalar = 1;
         var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[var_k_0d_int_Scalar]; var_m_0d_int_Scalar++) {
        bool aux_m_read = true;
        // read LIST body
        if ((! (var_ZAFP_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_ZAFP_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable ZAFP
          ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
          aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_ZAFP_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "ZAFP",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        if ((! (var_FPS_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_FPS_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable FPS
          ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
          aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_FPS_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "FPS",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        if ((! (var_YI_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_YI_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable YI
          ptr_YI_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("YI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YI);
          aux_last_type_read_for_YI = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_YI_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "YI",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        if ((! (var_DYI_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_DYI_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable DYI
          ptr_DYI_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("DYI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYI);
          aux_last_type_read_for_DYI = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_DYI_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "DYI",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
      }
      if (cpp_i != cpp_npl) {
        throw std::runtime_error("not exactly NPL elements consumed");
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LE == SCALAR_INT) && (aux_LE_read == true))) {
    cpp_current_dict["LE"] = var_LE_0d_int_Scalar;
  }
  if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_NN_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["NN"] = var_NN_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_NFP_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["NFP"] = var_NFP_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_ZAFP_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["ZAFP"] = var_ZAFP_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_FPS_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["FPS"] = var_FPS_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_YI_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["YI"] = var_YI_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_DYI_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["DYI"] = var_DYI_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_I_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["I"] = var_I_1d_int_NestedVector.to_pyobj(list_mode);
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 938fd3d870f297fe0f3b2ca86b863542
// MD5 hash of the following function definition: f6cd857e87d010dd5a9a45be13faedef
py::dict parse_mf8mt457_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_LISO_0d_int_Scalar;
  bool aux_LISO_read = false;
  vartype aux_last_type_read_for_LISO = UNKNOWN;
  int var_NST_0d_int_Scalar;
  bool aux_NST_read = false;
  vartype aux_last_type_read_for_NST = UNKNOWN;
  int var_NSP_0d_int_Scalar;
  bool aux_NSP_read = false;
  vartype aux_last_type_read_for_NSP = UNKNOWN;
  EndfFloatCpp var_Thalf_0d_double_Scalar;
  bool aux_Thalf_read = false;
  vartype aux_last_type_read_for_Thalf = UNKNOWN;
  EndfFloatCpp var_dThalf_0d_double_Scalar;
  bool aux_dThalf_read = false;
  vartype aux_last_type_read_for_dThalf = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  NestedVector<EndfFloatCpp> var_Ebar_x_1d_double_NestedVector;
  vartype aux_last_type_read_for_Ebar_x = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dEbar_x_1d_double_NestedVector;
  vartype aux_last_type_read_for_dEbar_x = UNKNOWN;
  EndfFloatCpp var_SPI_0d_double_Scalar;
  bool aux_SPI_read = false;
  vartype aux_last_type_read_for_SPI = UNKNOWN;
  EndfFloatCpp var_PAR_0d_double_Scalar;
  bool aux_PAR_read = false;
  vartype aux_last_type_read_for_PAR = UNKNOWN;
  int var_NDK_0d_int_Scalar;
  bool aux_NDK_read = false;
  vartype aux_last_type_read_for_NDK = UNKNOWN;
  NestedVector<EndfFloatCpp> var_RTYP_1d_double_NestedVector;
  vartype aux_last_type_read_for_RTYP = UNKNOWN;
  NestedVector<EndfFloatCpp> var_RFS_1d_double_NestedVector;
  vartype aux_last_type_read_for_RFS = UNKNOWN;
  NestedVector<EndfFloatCpp> var_Q_1d_double_NestedVector;
  vartype aux_last_type_read_for_Q = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dQ_1d_double_NestedVector;
  vartype aux_last_type_read_for_dQ = UNKNOWN;
  NestedVector<EndfFloatCpp> var_BR_1d_double_NestedVector;
  vartype aux_last_type_read_for_BR = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dBR_1d_double_NestedVector;
  vartype aux_last_type_read_for_dBR = UNKNOWN;
  int var_JENDL_LIST_NPL_0d_int_Scalar;
  bool aux_JENDL_LIST_NPL_read = false;
  vartype aux_last_type_read_for_JENDL_LIST_NPL = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 8;
  int mt = 457;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 457;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        std::streampos cpp_old_streampos = cont.tellg();
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LIS_0d_int_Scalar = var_LIS_0d_int_Scalar;
          int var_LIS_0d_int_Scalar = glob_var_LIS_0d_int_Scalar;
          bool& glob_aux_LIS_read = aux_LIS_read;
          bool aux_LIS_read = glob_aux_LIS_read;
          vartype aux_last_type_read_for_LIS = UNKNOWN;
          int& glob_var_LISO_0d_int_Scalar = var_LISO_0d_int_Scalar;
          int var_LISO_0d_int_Scalar = glob_var_LISO_0d_int_Scalar;
          bool& glob_aux_LISO_read = aux_LISO_read;
          bool aux_LISO_read = glob_aux_LISO_read;
          vartype aux_last_type_read_for_LISO = UNKNOWN;
          int& glob_var_NST_0d_int_Scalar = var_NST_0d_int_Scalar;
          int var_NST_0d_int_Scalar = glob_var_NST_0d_int_Scalar;
          bool& glob_aux_NST_read = aux_NST_read;
          bool aux_NST_read = glob_aux_NST_read;
          vartype aux_last_type_read_for_NST = UNKNOWN;
          int& glob_var_NSP_0d_int_Scalar = var_NSP_0d_int_Scalar;
          int var_NSP_0d_int_Scalar = glob_var_NSP_0d_int_Scalar;
          bool& glob_aux_NSP_read = aux_NSP_read;
          bool aux_NSP_read = glob_aux_NSP_read;
          vartype aux_last_type_read_for_NSP = UNKNOWN;
          try {
            cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , NSP ] HEAD";
            cpp_line = cpp_read_raw_line(cont);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LIS
            var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LIS_read = true;
            validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
            aux_last_type_read_for_LIS = SCALAR_INT;
            // assign expression to variable LISO
            var_LISO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LISO_read = true;
            validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
            aux_last_type_read_for_LISO = SCALAR_INT;
            // assign expression to variable NST
            var_NST_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NST_read = true;
            validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
            aux_last_type_read_for_NST = SCALAR_INT;
            // assign expression to variable NSP
            var_NSP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NSP_read = true;
            validate_vartype_consistency("NSP", SCALAR_INT, aux_last_type_read_for_NSP);
            aux_last_type_read_for_NSP = SCALAR_INT;
          } catch (const std::out_of_range& e) {
            // // accept failure in lookahead
          }
          if ((((((((aux_NST_read == true)) && ((var_NST_0d_int_Scalar)==(0)))))))) {
            cpp_found_match = true;
          }
          cont.seekg(cpp_old_streampos);
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , NSP ] HEAD";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LIS
          var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LIS_read = true;
          validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
          aux_last_type_read_for_LIS = SCALAR_INT;
          // assign expression to variable LISO
          var_LISO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_LISO_read = true;
          validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
          aux_last_type_read_for_LISO = SCALAR_INT;
          // assign expression to variable NST
          var_NST_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NST_read = true;
          validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
          aux_last_type_read_for_NST = SCALAR_INT;
          // assign expression to variable NSP
          var_NSP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NSP_read = true;
          validate_vartype_consistency("NSP", SCALAR_INT, aux_last_type_read_for_NSP);
          aux_last_type_read_for_NSP = SCALAR_INT;
          cpp_template = "[ MAT , 8 , 457 / Thalf , dThalf , 0 , 0 , (2*NC) , 0 / \n { Ebar_x , dEbar_x } { k = 1 to NC } ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          // assign expression to variable Thalf
          var_Thalf_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_Thalf_read = true;
          validate_vartype_consistency("Thalf", SCALAR_DOUBLE, aux_last_type_read_for_Thalf);
          aux_last_type_read_for_Thalf = SCALAR_DOUBLE;
          // assign expression to variable dThalf
          var_dThalf_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
          aux_dThalf_read = true;
          validate_vartype_consistency("dThalf", SCALAR_DOUBLE, aux_last_type_read_for_dThalf);
          aux_last_type_read_for_dThalf = SCALAR_DOUBLE;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable cpp_int_val
          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_cpp_int_val_read = true;
          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
          // assign expression to variable NC
          var_NC_0d_int_Scalar = (cpp_int_val/2);
          aux_NC_read = true;
          validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
          aux_last_type_read_for_NC = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NC_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              // assign expression to variable Ebar_x
              var_Ebar_x_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("Ebar_x", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ebar_x);
              aux_last_type_read_for_Ebar_x = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dEbar_x
              var_dEbar_x_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("dEbar_x", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dEbar_x);
              aux_last_type_read_for_dEbar_x = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , (6*NDK) , NDK / \n { RTYP , RFS , Q , dQ , BR , dBR } { k = 1 to NDK } ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          // assign expression to variable SPI
          var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_SPI_read = true;
          validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
          aux_last_type_read_for_SPI = SCALAR_DOUBLE;
          // assign expression to variable PAR
          var_PAR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
          aux_PAR_read = true;
          validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
          aux_last_type_read_for_PAR = SCALAR_DOUBLE;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable cpp_int_val
          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_cpp_int_val_read = true;
          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
          // assign expression to variable NDK
          var_NDK_0d_int_Scalar = (cpp_int_val/6);
          aux_NDK_read = true;
          validate_vartype_consistency("NDK", SCALAR_INT, aux_last_type_read_for_NDK);
          aux_last_type_read_for_NDK = SCALAR_INT;
          if ((! (aux_NDK_read == true))) {
            // assign expression to variable NDK
            var_NDK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NDK_read = true;
            validate_vartype_consistency("NDK", SCALAR_INT, aux_last_type_read_for_NDK);
            aux_last_type_read_for_NDK = SCALAR_INT;
          } else {
            cpp_validate_field(var_NDK_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NDK",
              cpp_template, cpp_line, parse_opts);
          }
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NDK_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              // assign expression to variable RTYP
              var_RTYP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("RTYP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_RTYP);
              aux_last_type_read_for_RTYP = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable RFS
              var_RFS_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("RFS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_RFS);
              aux_last_type_read_for_RFS = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable Q
              var_Q_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("Q", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Q);
              aux_last_type_read_for_Q = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dQ
              var_dQ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("dQ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dQ);
              aux_last_type_read_for_dQ = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable BR
              var_BR_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("BR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BR);
              aux_last_type_read_for_BR = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dBR
              var_dBR_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("dBR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dBR);
              aux_last_type_read_for_dBR = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NSP_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // open section spectrum
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.setdefault("spectrum", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              // variable declarations
              EndfFloatCpp var_STYP_0d_double_Scalar;
              bool aux_STYP_read = false;
              vartype aux_last_type_read_for_STYP = UNKNOWN;
              int var_LCON_0d_int_Scalar;
              bool aux_LCON_read = false;
              vartype aux_last_type_read_for_LCON = UNKNOWN;
              int var_LCOV_0d_int_Scalar;
              bool aux_LCOV_read = false;
              vartype aux_last_type_read_for_LCOV = UNKNOWN;
              int var_NER_0d_int_Scalar;
              bool aux_NER_read = false;
              vartype aux_last_type_read_for_NER = UNKNOWN;
              EndfFloatCpp var_FD_0d_double_Scalar;
              bool aux_FD_read = false;
              vartype aux_last_type_read_for_FD = UNKNOWN;
              EndfFloatCpp var_dFD_0d_double_Scalar;
              bool aux_dFD_read = false;
              vartype aux_last_type_read_for_dFD = UNKNOWN;
              EndfFloatCpp var_ERAV_0d_double_Scalar;
              bool aux_ERAV_read = false;
              vartype aux_last_type_read_for_ERAV = UNKNOWN;
              EndfFloatCpp var_dERAV_0d_double_Scalar;
              bool aux_dERAV_read = false;
              vartype aux_last_type_read_for_dERAV = UNKNOWN;
              EndfFloatCpp var_FC_0d_double_Scalar;
              bool aux_FC_read = false;
              vartype aux_last_type_read_for_FC = UNKNOWN;
              EndfFloatCpp var_dFC_0d_double_Scalar;
              bool aux_dFC_read = false;
              vartype aux_last_type_read_for_dFC = UNKNOWN;
              cpp_template = "[ MAT , 8 , 457 / 0.0 , STYP , LCON , LCOV , 6 , NER / \n FD , dFD , ERAV , dERAV , FC , dFC ] LIST";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST record
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable STYP
              var_STYP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
              aux_STYP_read = true;
              validate_vartype_consistency("STYP", SCALAR_DOUBLE, aux_last_type_read_for_STYP);
              aux_last_type_read_for_STYP = SCALAR_DOUBLE;
              // assign expression to variable LCON
              var_LCON_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LCON_read = true;
              validate_vartype_consistency("LCON", SCALAR_INT, aux_last_type_read_for_LCON);
              aux_last_type_read_for_LCON = SCALAR_INT;
              // assign expression to variable LCOV
              var_LCOV_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LCOV_read = true;
              validate_vartype_consistency("LCOV", SCALAR_INT, aux_last_type_read_for_LCOV);
              aux_last_type_read_for_LCOV = SCALAR_INT;
              cpp_validate_field(6, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "6",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NER
              var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NER_read = true;
              validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
              aux_last_type_read_for_NER = SCALAR_INT;
              {
                int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST body
                // assign expression to variable FD
                var_FD_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                aux_FD_read = true;
                validate_vartype_consistency("FD", SCALAR_DOUBLE, aux_last_type_read_for_FD);
                aux_last_type_read_for_FD = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dFD
                var_dFD_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                aux_dFD_read = true;
                validate_vartype_consistency("dFD", SCALAR_DOUBLE, aux_last_type_read_for_dFD);
                aux_last_type_read_for_dFD = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable ERAV
                var_ERAV_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                aux_ERAV_read = true;
                validate_vartype_consistency("ERAV", SCALAR_DOUBLE, aux_last_type_read_for_ERAV);
                aux_last_type_read_for_ERAV = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dERAV
                var_dERAV_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                aux_dERAV_read = true;
                validate_vartype_consistency("dERAV", SCALAR_DOUBLE, aux_last_type_read_for_dERAV);
                aux_last_type_read_for_dERAV = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable FC
                var_FC_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                aux_FC_read = true;
                validate_vartype_consistency("FC", SCALAR_DOUBLE, aux_last_type_read_for_FC);
                aux_last_type_read_for_FC = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dFC
                var_dFC_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                aux_dFC_read = true;
                validate_vartype_consistency("dFC", SCALAR_DOUBLE, aux_last_type_read_for_dFC);
                aux_last_type_read_for_dFC = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if ((((((((aux_LCON_read == true)) && ((var_LCON_0d_int_Scalar)!=(1)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section discrete
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      cpp_current_dict = cpp_index_shifter_store.setdefault("discrete", std::vector<int>({}), py::dict());
                      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                      // variable declarations

                      for (int var_i_0d_int_Scalar = 1;
                         var_i_0d_int_Scalar <= var_NER_0d_int_Scalar; var_i_0d_int_Scalar++) {
                        bool aux_i_read = true;
                        // open section energysec
                        {
                          py::dict cpp_parent_dict = cpp_current_dict;
                          cpp_current_dict = cpp_index_shifter_store.setdefault("energysec", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
                          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                          // variable declarations
                          EndfFloatCpp var_ER_0d_double_Scalar;
                          bool aux_ER_read = false;
                          vartype aux_last_type_read_for_ER = UNKNOWN;
                          EndfFloatCpp var_dER_0d_double_Scalar;
                          bool aux_dER_read = false;
                          vartype aux_last_type_read_for_dER = UNKNOWN;
                          int var_NT_0d_int_Scalar;
                          bool aux_NT_read = false;
                          vartype aux_last_type_read_for_NT = UNKNOWN;
                          EndfFloatCpp var_RTYP_0d_double_Scalar;
                          bool aux_RTYP_read = false;
                          vartype aux_last_type_read_for_RTYP = UNKNOWN;
                          EndfFloatCpp var_TYPE_0d_double_Scalar;
                          bool aux_TYPE_read = false;
                          vartype aux_last_type_read_for_TYPE = UNKNOWN;
                          EndfFloatCpp var_RI_0d_double_Scalar;
                          bool aux_RI_read = false;
                          vartype aux_last_type_read_for_RI = UNKNOWN;
                          EndfFloatCpp var_dRI_0d_double_Scalar;
                          bool aux_dRI_read = false;
                          vartype aux_last_type_read_for_dRI = UNKNOWN;
                          EndfFloatCpp var_RIS_0d_double_Scalar;
                          bool aux_RIS_read = false;
                          vartype aux_last_type_read_for_RIS = UNKNOWN;
                          EndfFloatCpp var_dRIS_0d_double_Scalar;
                          bool aux_dRIS_read = false;
                          vartype aux_last_type_read_for_dRIS = UNKNOWN;
                          EndfFloatCpp var_RICC_0d_double_Scalar;
                          bool aux_RICC_read = false;
                          vartype aux_last_type_read_for_RICC = UNKNOWN;
                          EndfFloatCpp var_dRICC_0d_double_Scalar;
                          bool aux_dRICC_read = false;
                          vartype aux_last_type_read_for_dRICC = UNKNOWN;
                          EndfFloatCpp var_RICK_0d_double_Scalar;
                          bool aux_RICK_read = false;
                          vartype aux_last_type_read_for_RICK = UNKNOWN;
                          EndfFloatCpp var_dRICK_0d_double_Scalar;
                          bool aux_dRICK_read = false;
                          vartype aux_last_type_read_for_dRICK = UNKNOWN;
                          EndfFloatCpp var_RICL_0d_double_Scalar;
                          bool aux_RICL_read = false;
                          vartype aux_last_type_read_for_RICL = UNKNOWN;
                          EndfFloatCpp var_dRICL_0d_double_Scalar;
                          bool aux_dRICL_read = false;
                          vartype aux_last_type_read_for_dRICL = UNKNOWN;
                          // evaluate if-elif-else clause
                          {
                            bool cpp_found_match = false;
                            if (! cpp_found_match) {
                              // if statement evaluation with lookahead
                              {
                                std::streampos cpp_old_streampos = cont.tellg();
                                {
                                  // variable declarations
                                  EndfFloatCpp& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                  EndfFloatCpp var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                  bool& glob_aux_ER_read = aux_ER_read;
                                  bool aux_ER_read = glob_aux_ER_read;
                                  vartype aux_last_type_read_for_ER = UNKNOWN;
                                  EndfFloatCpp& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                  EndfFloatCpp var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                  bool& glob_aux_dER_read = aux_dER_read;
                                  bool aux_dER_read = glob_aux_dER_read;
                                  vartype aux_last_type_read_for_dER = UNKNOWN;
                                  int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                  int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                  bool& glob_aux_NT_read = aux_NT_read;
                                  bool aux_NT_read = glob_aux_NT_read;
                                  vartype aux_last_type_read_for_NT = UNKNOWN;
                                  try {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI ] LIST";
                                    cpp_line = cpp_read_raw_line(cont);
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                  } catch (const std::out_of_range& e) {
                                    // // accept failure in lookahead
                                  }
                                  if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(4)))))))) {
                                    cpp_found_match = true;
                                  }
                                  cont.seekg(cpp_old_streampos);
                                }
                                if (cpp_found_match) {
                                  cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI ] LIST";
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  // read LIST record
                                  // assign expression to variable ER
                                  var_ER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                  aux_ER_read = true;
                                  validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                  aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                  // assign expression to variable dER
                                  var_dER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                  aux_dER_read = true;
                                  validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                  aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                    cpp_template, cpp_line, parse_opts);
                                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                    cpp_template, cpp_line, parse_opts);
                                  // assign expression to variable NT
                                  var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                  aux_NT_read = true;
                                  validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                  aux_last_type_read_for_NT = SCALAR_INT;
                                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                    cpp_template, cpp_line, parse_opts);
                                  {
                                    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    int cpp_i = 0;
                                    int cpp_j = 0;
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST body
                                    // assign expression to variable RTYP
                                    var_RTYP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_RTYP_read = true;
                                    validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                    aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable TYPE
                                    var_TYPE_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_TYPE_read = true;
                                    validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                    aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable RI
                                    var_RI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_RI_read = true;
                                    validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                    aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable dRI
                                    var_dRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_dRI_read = true;
                                    validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                    aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    if (cpp_i != cpp_npl) {
                                      throw std::runtime_error("not exactly NPL elements consumed");
                                    }
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  std::streampos cpp_old_streampos = cont.tellg();
                                  {
                                    // variable declarations
                                    EndfFloatCpp& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    EndfFloatCpp var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    EndfFloatCpp& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    EndfFloatCpp var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    try {
                                      cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS ] LIST";
                                      cpp_line = cpp_read_raw_line(cont);
                                      // read LIST record
                                      // assign expression to variable ER
                                      var_ER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                      aux_ER_read = true;
                                      validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                      aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                      // assign expression to variable dER
                                      var_dER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                      aux_dER_read = true;
                                      validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                      aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                      // assign expression to variable NT
                                      var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      aux_NT_read = true;
                                      validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                      aux_last_type_read_for_NT = SCALAR_INT;
                                    } catch (const std::out_of_range& e) {
                                      // // accept failure in lookahead
                                    }
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(6)))))))) {
                                      cpp_found_match = true;
                                    }
                                    cont.seekg(cpp_old_streampos);
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS ] LIST";
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    {
                                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      // read LIST body
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  std::streampos cpp_old_streampos = cont.tellg();
                                  {
                                    // variable declarations
                                    EndfFloatCpp& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    EndfFloatCpp var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    EndfFloatCpp& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    EndfFloatCpp var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    try {
                                      cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC ] LIST";
                                      cpp_line = cpp_read_raw_line(cont);
                                      // read LIST record
                                      // assign expression to variable ER
                                      var_ER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                      aux_ER_read = true;
                                      validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                      aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                      // assign expression to variable dER
                                      var_dER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                      aux_dER_read = true;
                                      validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                      aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                      // assign expression to variable NT
                                      var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      aux_NT_read = true;
                                      validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                      aux_last_type_read_for_NT = SCALAR_INT;
                                    } catch (const std::out_of_range& e) {
                                      // // accept failure in lookahead
                                    }
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(8)))))))) {
                                      cpp_found_match = true;
                                    }
                                    cont.seekg(cpp_old_streampos);
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC ] LIST";
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    {
                                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      // read LIST body
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RICC
                                      var_RICC_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RICC_read = true;
                                      validate_vartype_consistency("RICC", SCALAR_DOUBLE, aux_last_type_read_for_RICC);
                                      aux_last_type_read_for_RICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRICC
                                      var_dRICC_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRICC_read = true;
                                      validate_vartype_consistency("dRICC", SCALAR_DOUBLE, aux_last_type_read_for_dRICC);
                                      aux_last_type_read_for_dRICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  std::streampos cpp_old_streampos = cont.tellg();
                                  {
                                    // variable declarations
                                    EndfFloatCpp& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    EndfFloatCpp var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    EndfFloatCpp& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    EndfFloatCpp var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    try {
                                      cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK ] LIST";
                                      cpp_line = cpp_read_raw_line(cont);
                                      // read LIST record
                                      // assign expression to variable ER
                                      var_ER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                      aux_ER_read = true;
                                      validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                      aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                      // assign expression to variable dER
                                      var_dER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                      aux_dER_read = true;
                                      validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                      aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                      // assign expression to variable NT
                                      var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      aux_NT_read = true;
                                      validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                      aux_last_type_read_for_NT = SCALAR_INT;
                                    } catch (const std::out_of_range& e) {
                                      // // accept failure in lookahead
                                    }
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(10)))))))) {
                                      cpp_found_match = true;
                                    }
                                    cont.seekg(cpp_old_streampos);
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK ] LIST";
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    {
                                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      // read LIST body
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RICC
                                      var_RICC_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RICC_read = true;
                                      validate_vartype_consistency("RICC", SCALAR_DOUBLE, aux_last_type_read_for_RICC);
                                      aux_last_type_read_for_RICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRICC
                                      var_dRICC_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRICC_read = true;
                                      validate_vartype_consistency("dRICC", SCALAR_DOUBLE, aux_last_type_read_for_dRICC);
                                      aux_last_type_read_for_dRICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RICK
                                      var_RICK_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RICK_read = true;
                                      validate_vartype_consistency("RICK", SCALAR_DOUBLE, aux_last_type_read_for_RICK);
                                      aux_last_type_read_for_RICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRICK
                                      var_dRICK_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRICK_read = true;
                                      validate_vartype_consistency("dRICK", SCALAR_DOUBLE, aux_last_type_read_for_dRICK);
                                      aux_last_type_read_for_dRICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  std::streampos cpp_old_streampos = cont.tellg();
                                  {
                                    // variable declarations
                                    EndfFloatCpp& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    EndfFloatCpp var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    EndfFloatCpp& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    EndfFloatCpp var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    try {
                                      cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK , RICL , dRICL ] LIST";
                                      cpp_line = cpp_read_raw_line(cont);
                                      // read LIST record
                                      // assign expression to variable ER
                                      var_ER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                      aux_ER_read = true;
                                      validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                      aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                      // assign expression to variable dER
                                      var_dER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                      aux_dER_read = true;
                                      validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                      aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                      // assign expression to variable NT
                                      var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      aux_NT_read = true;
                                      validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                      aux_last_type_read_for_NT = SCALAR_INT;
                                    } catch (const std::out_of_range& e) {
                                      // // accept failure in lookahead
                                    }
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(12)))))))) {
                                      cpp_found_match = true;
                                    }
                                    cont.seekg(cpp_old_streampos);
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK , RICL , dRICL ] LIST";
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    {
                                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      // read LIST body
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RICC
                                      var_RICC_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RICC_read = true;
                                      validate_vartype_consistency("RICC", SCALAR_DOUBLE, aux_last_type_read_for_RICC);
                                      aux_last_type_read_for_RICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRICC
                                      var_dRICC_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRICC_read = true;
                                      validate_vartype_consistency("dRICC", SCALAR_DOUBLE, aux_last_type_read_for_dRICC);
                                      aux_last_type_read_for_dRICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RICK
                                      var_RICK_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RICK_read = true;
                                      validate_vartype_consistency("RICK", SCALAR_DOUBLE, aux_last_type_read_for_RICK);
                                      aux_last_type_read_for_RICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRICK
                                      var_dRICK_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRICK_read = true;
                                      validate_vartype_consistency("dRICK", SCALAR_DOUBLE, aux_last_type_read_for_dRICK);
                                      aux_last_type_read_for_dRICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RICL
                                      var_RICL_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RICL_read = true;
                                      validate_vartype_consistency("RICL", SCALAR_DOUBLE, aux_last_type_read_for_RICL);
                                      aux_last_type_read_for_RICL = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRICL
                                      var_dRICL_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRICL_read = true;
                                      validate_vartype_consistency("dRICL", SCALAR_DOUBLE, aux_last_type_read_for_dRICL);
                                      aux_last_type_read_for_dRICL = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          // store data in Python dictionary
                          if (((aux_last_type_read_for_ER == SCALAR_DOUBLE) && (aux_ER_read == true))) {
                            cpp_current_dict["ER"] = var_ER_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_dER == SCALAR_DOUBLE) && (aux_dER_read == true))) {
                            cpp_current_dict["dER"] = var_dER_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_NT == SCALAR_INT) && (aux_NT_read == true))) {
                            cpp_current_dict["NT"] = var_NT_0d_int_Scalar;
                          }
                          if (((aux_last_type_read_for_RTYP == SCALAR_DOUBLE) && (aux_RTYP_read == true))) {
                            cpp_current_dict["RTYP"] = var_RTYP_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_TYPE == SCALAR_DOUBLE) && (aux_TYPE_read == true))) {
                            cpp_current_dict["TYPE"] = var_TYPE_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_RI == SCALAR_DOUBLE) && (aux_RI_read == true))) {
                            cpp_current_dict["RI"] = var_RI_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_dRI == SCALAR_DOUBLE) && (aux_dRI_read == true))) {
                            cpp_current_dict["dRI"] = var_dRI_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_RIS == SCALAR_DOUBLE) && (aux_RIS_read == true))) {
                            cpp_current_dict["RIS"] = var_RIS_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_dRIS == SCALAR_DOUBLE) && (aux_dRIS_read == true))) {
                            cpp_current_dict["dRIS"] = var_dRIS_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_RICC == SCALAR_DOUBLE) && (aux_RICC_read == true))) {
                            cpp_current_dict["RICC"] = var_RICC_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_dRICC == SCALAR_DOUBLE) && (aux_dRICC_read == true))) {
                            cpp_current_dict["dRICC"] = var_dRICC_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_RICK == SCALAR_DOUBLE) && (aux_RICK_read == true))) {
                            cpp_current_dict["RICK"] = var_RICK_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_dRICK == SCALAR_DOUBLE) && (aux_dRICK_read == true))) {
                            cpp_current_dict["dRICK"] = var_dRICK_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_RICL == SCALAR_DOUBLE) && (aux_RICL_read == true))) {
                            cpp_current_dict["RICL"] = var_RICL_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_dRICL == SCALAR_DOUBLE) && (aux_dRICL_read == true))) {
                            cpp_current_dict["dRICL"] = var_dRICL_0d_double_Scalar;
                          }
                          cpp_current_dict = cpp_parent_dict;
                        }
                      }
                      // store data in Python dictionary
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if ((((((((aux_LCON_read == true)) && ((var_LCON_0d_int_Scalar)!=(0)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section continuous
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      cpp_current_dict = cpp_index_shifter_store.setdefault("continuous", std::vector<int>({}), py::dict());
                      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                      // variable declarations
                      EndfFloatCpp var_RTYP_0d_double_Scalar;
                      bool aux_RTYP_read = false;
                      vartype aux_last_type_read_for_RTYP = UNKNOWN;
                      std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
                      bool aux_Eint_read = false;
                      vartype aux_last_type_read_for_Eint = UNKNOWN;
                      std::vector<EndfFloatCpp> var_RP_0d_floatvec_Scalar;
                      bool aux_RP_read = false;
                      vartype aux_last_type_read_for_RP = UNKNOWN;
                      std::vector<int> var_INT_0d_intvec_Scalar;
                      bool aux_INT_read = false;
                      vartype aux_last_type_read_for_INT = UNKNOWN;
                      std::vector<int> var_NBT_0d_intvec_Scalar;
                      bool aux_NBT_read = false;
                      vartype aux_last_type_read_for_NBT = UNKNOWN;
                      cpp_template = "[ MAT , 8 , 457 / RTYP , 0.0 , 0 , 0 , NR , NP / Eint / RP ] TAB1";
                      // read TAB1 record
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // assign expression to variable RTYP
                      var_RTYP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                      aux_RTYP_read = true;
                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      {
                        Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                        // assign expression to variable Eint
                        var_Eint_0d_floatvec_Scalar = tab_body.X;
                        aux_Eint_read = true;
                        validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                        aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                        // assign expression to variable RP
                        var_RP_0d_floatvec_Scalar = tab_body.Y;
                        aux_RP_read = true;
                        validate_vartype_consistency("RP", SCALAR_FLOATVEC, aux_last_type_read_for_RP);
                        aux_last_type_read_for_RP = SCALAR_FLOATVEC;
                        // assign expression to variable INT
                        var_INT_0d_intvec_Scalar = tab_body.INT;
                        aux_INT_read = true;
                        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                        aux_last_type_read_for_INT = SCALAR_INTVEC;
                        // assign expression to variable NBT
                        var_NBT_0d_intvec_Scalar = tab_body.NBT;
                        aux_NBT_read = true;
                        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                        aux_last_type_read_for_NBT = SCALAR_INTVEC;
                      }
                      // store data in Python dictionary
                      if (((aux_last_type_read_for_RTYP == SCALAR_DOUBLE) && (aux_RTYP_read == true))) {
                        cpp_current_dict["RTYP"] = var_RTYP_0d_double_Scalar;
                      }
                      if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
                        cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
                      }
                      if (((aux_last_type_read_for_RP == SCALAR_FLOATVEC) && (aux_RP_read == true))) {
                        cpp_current_dict["RP"] = var_RP_0d_floatvec_Scalar;
                      }
                      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                      }
                      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                      }
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if ((((((((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(0)))))&&((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(2)))))&&((((aux_LCON_read == true)) && ((var_LCON_0d_int_Scalar)!=(0)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section continuous
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      cpp_current_dict = cpp_index_shifter_store.setdefault("continuous", std::vector<int>({}), py::dict());
                      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                      // variable declarations
                      int cpp_int_val;
                      bool aux_cpp_int_val_read = false;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int var_NPP_0d_int_Scalar;
                      bool aux_NPP_read = false;
                      vartype aux_last_type_read_for_NPP = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
                      vartype aux_last_type_read_for_E = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_F_1d_double_NestedVector;
                      vartype aux_last_type_read_for_F = UNKNOWN;
                      cpp_template = "[ MAT , 8 , 457 / 0.0 , 0.0 , 0 , 2 , (2*NPP) , NPP / { E , F } { m = 1 to NPP } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(2, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "2",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NPP
                      var_NPP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NPP_read = true;
                      validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                      aux_last_type_read_for_NPP = SCALAR_INT;
                      if ((! (aux_NPP_read == true))) {
                        // assign expression to variable NPP
                        var_NPP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NPP_read = true;
                        validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                        aux_last_type_read_for_NPP = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NPP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NPP",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NPP_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // read LIST body
                          // assign expression to variable E
                          var_E_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                          aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable F
                          var_F_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                          aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      // store data in Python dictionary
                      if (((aux_last_type_read_for_NPP == SCALAR_INT) && (aux_NPP_read == true))) {
                        cpp_current_dict["NPP"] = var_NPP_0d_int_Scalar;
                      }
                      if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_F_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["F"] = var_F_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if (((((((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(0)))))&&((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(1)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section discrete
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      cpp_current_dict = cpp_index_shifter_store.setdefault("discrete", std::vector<int>({}), py::dict());
                      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                      // variable declarations
                      // open section cov
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        cpp_current_dict = cpp_index_shifter_store.setdefault("cov", std::vector<int>({}), py::dict());
                        IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                        // variable declarations
                        int var_LS_0d_int_Scalar;
                        bool aux_LS_read = false;
                        vartype aux_last_type_read_for_LS = UNKNOWN;
                        int var_NE_0d_int_Scalar;
                        bool aux_NE_read = false;
                        vartype aux_last_type_read_for_NE = UNKNOWN;
                        int var_NERP_0d_int_Scalar;
                        bool aux_NERP_read = false;
                        vartype aux_last_type_read_for_NERP = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
                        vartype aux_last_type_read_for_E = UNKNOWN;
                        Matrix2d<EndfFloatCpp> var_F_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_F = UNKNOWN;
                        cpp_template = "[ MAT , 8 , 457 / 0.0 , 0.0 , LS , 5 , NE , NERP / \n { E } { m = 1 to NERP } , { { F } { n = m to (NERP-2) } } { m = 1 to (NERP-2) } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        cpp_validate_field(5, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "5",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        // assign expression to variable NERP
                        var_NERP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NERP_read = true;
                        validate_vartype_consistency("NERP", SCALAR_INT, aux_last_type_read_for_NERP);
                        aux_last_type_read_for_NERP = SCALAR_INT;
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= var_NERP_0d_int_Scalar; var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NERP_0d_int_Scalar-2), 1, (var_NERP_0d_int_Scalar-2), true, false);

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= (var_NERP_0d_int_Scalar-2); var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body

                            for (int var_n_0d_int_Scalar = var_m_0d_int_Scalar;
                               var_n_0d_int_Scalar <= (var_NERP_0d_int_Scalar-2); var_n_0d_int_Scalar++) {
                              bool aux_n_read = true;
                              // read LIST body
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        // store data in Python dictionary
                        if (((aux_last_type_read_for_LS == SCALAR_INT) && (aux_LS_read == true))) {
                          cpp_current_dict["LS"] = var_LS_0d_int_Scalar;
                        }
                        if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
                          cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
                        }
                        if (((aux_last_type_read_for_NERP == SCALAR_INT) && (aux_NERP_read == true))) {
                          cpp_current_dict["NERP"] = var_NERP_0d_int_Scalar;
                        }
                        if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if (var_F_2d_double_Matrix2d.did_read()) {
                          cpp_current_dict["F"] = var_F_2d_double_Matrix2d.to_pyobj(list_mode);
                        }
                        cpp_current_dict = cpp_parent_dict;
                      }
                      // store data in Python dictionary
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
              // store data in Python dictionary
              if (((aux_last_type_read_for_STYP == SCALAR_DOUBLE) && (aux_STYP_read == true))) {
                cpp_current_dict["STYP"] = var_STYP_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_LCON == SCALAR_INT) && (aux_LCON_read == true))) {
                cpp_current_dict["LCON"] = var_LCON_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_LCOV == SCALAR_INT) && (aux_LCOV_read == true))) {
                cpp_current_dict["LCOV"] = var_LCOV_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_NER == SCALAR_INT) && (aux_NER_read == true))) {
                cpp_current_dict["NER"] = var_NER_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_FD == SCALAR_DOUBLE) && (aux_FD_read == true))) {
                cpp_current_dict["FD"] = var_FD_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_dFD == SCALAR_DOUBLE) && (aux_dFD_read == true))) {
                cpp_current_dict["dFD"] = var_dFD_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_ERAV == SCALAR_DOUBLE) && (aux_ERAV_read == true))) {
                cpp_current_dict["ERAV"] = var_ERAV_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_dERAV == SCALAR_DOUBLE) && (aux_dERAV_read == true))) {
                cpp_current_dict["dERAV"] = var_dERAV_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_FC == SCALAR_DOUBLE) && (aux_FC_read == true))) {
                cpp_current_dict["FC"] = var_FC_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_dFC == SCALAR_DOUBLE) && (aux_dFC_read == true))) {
                cpp_current_dict["dFC"] = var_dFC_0d_double_Scalar;
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LIS_0d_int_Scalar = var_LIS_0d_int_Scalar;
            int var_LIS_0d_int_Scalar = glob_var_LIS_0d_int_Scalar;
            bool& glob_aux_LIS_read = aux_LIS_read;
            bool aux_LIS_read = glob_aux_LIS_read;
            vartype aux_last_type_read_for_LIS = UNKNOWN;
            int& glob_var_LISO_0d_int_Scalar = var_LISO_0d_int_Scalar;
            int var_LISO_0d_int_Scalar = glob_var_LISO_0d_int_Scalar;
            bool& glob_aux_LISO_read = aux_LISO_read;
            bool aux_LISO_read = glob_aux_LISO_read;
            vartype aux_last_type_read_for_LISO = UNKNOWN;
            int& glob_var_NST_0d_int_Scalar = var_NST_0d_int_Scalar;
            int var_NST_0d_int_Scalar = glob_var_NST_0d_int_Scalar;
            bool& glob_aux_NST_read = aux_NST_read;
            bool aux_NST_read = glob_aux_NST_read;
            vartype aux_last_type_read_for_NST = UNKNOWN;
            try {
              cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , 0 ] HEAD";
              cpp_line = cpp_read_raw_line(cont);
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LIS
              var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LIS_read = true;
              validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
              aux_last_type_read_for_LIS = SCALAR_INT;
              // assign expression to variable LISO
              var_LISO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LISO_read = true;
              validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
              aux_last_type_read_for_LISO = SCALAR_INT;
              // assign expression to variable NST
              var_NST_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_NST_read = true;
              validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
              aux_last_type_read_for_NST = SCALAR_INT;
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if ((((((((aux_NST_read == true)) && ((var_NST_0d_int_Scalar)==(1)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , 0 ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LIS
            var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LIS_read = true;
            validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
            aux_last_type_read_for_LIS = SCALAR_INT;
            // assign expression to variable LISO
            var_LISO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LISO_read = true;
            validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
            aux_last_type_read_for_LISO = SCALAR_INT;
            // assign expression to variable NST
            var_NST_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NST_read = true;
            validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
            aux_last_type_read_for_NST = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_template = "[ MAT , 8 , 457 / 0.0 , 0.0 , 0 , 0 , 6 , 0 / \n 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(6, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "6",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            // evaluate if-elif-else clause
            {
              bool cpp_found_match = false;
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
                    int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
                    bool& glob_aux_MAT_read = aux_MAT_read;
                    bool aux_MAT_read = glob_aux_MAT_read;
                    vartype aux_last_type_read_for_MAT = UNKNOWN;
                    int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
                    int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
                    bool& glob_aux_MF_read = aux_MF_read;
                    bool aux_MF_read = glob_aux_MF_read;
                    vartype aux_last_type_read_for_MF = UNKNOWN;
                    int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
                    int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
                    bool& glob_aux_MT_read = aux_MT_read;
                    bool aux_MT_read = glob_aux_MT_read;
                    vartype aux_last_type_read_for_MT = UNKNOWN;
                    EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
                    EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
                    bool& glob_aux_ZA_read = aux_ZA_read;
                    bool aux_ZA_read = glob_aux_ZA_read;
                    vartype aux_last_type_read_for_ZA = UNKNOWN;
                    EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
                    EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
                    bool& glob_aux_AWR_read = aux_AWR_read;
                    bool aux_AWR_read = glob_aux_AWR_read;
                    vartype aux_last_type_read_for_AWR = UNKNOWN;
                    int& glob_var_LIS_0d_int_Scalar = var_LIS_0d_int_Scalar;
                    int var_LIS_0d_int_Scalar = glob_var_LIS_0d_int_Scalar;
                    bool& glob_aux_LIS_read = aux_LIS_read;
                    bool aux_LIS_read = glob_aux_LIS_read;
                    vartype aux_last_type_read_for_LIS = UNKNOWN;
                    int& glob_var_LISO_0d_int_Scalar = var_LISO_0d_int_Scalar;
                    int var_LISO_0d_int_Scalar = glob_var_LISO_0d_int_Scalar;
                    bool& glob_aux_LISO_read = aux_LISO_read;
                    bool aux_LISO_read = glob_aux_LISO_read;
                    vartype aux_last_type_read_for_LISO = UNKNOWN;
                    int& glob_var_NST_0d_int_Scalar = var_NST_0d_int_Scalar;
                    int var_NST_0d_int_Scalar = glob_var_NST_0d_int_Scalar;
                    bool& glob_aux_NST_read = aux_NST_read;
                    bool aux_NST_read = glob_aux_NST_read;
                    vartype aux_last_type_read_for_NST = UNKNOWN;
                    EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    EndfFloatCpp& glob_var_PAR_0d_double_Scalar = var_PAR_0d_double_Scalar;
                    EndfFloatCpp var_PAR_0d_double_Scalar = glob_var_PAR_0d_double_Scalar;
                    bool& glob_aux_PAR_read = aux_PAR_read;
                    bool aux_PAR_read = glob_aux_PAR_read;
                    vartype aux_last_type_read_for_PAR = UNKNOWN;
                    int& glob_var_JENDL_LIST_NPL_0d_int_Scalar = var_JENDL_LIST_NPL_0d_int_Scalar;
                    int var_JENDL_LIST_NPL_0d_int_Scalar = glob_var_JENDL_LIST_NPL_0d_int_Scalar;
                    bool& glob_aux_JENDL_LIST_NPL_read = aux_JENDL_LIST_NPL_read;
                    bool aux_JENDL_LIST_NPL_read = glob_aux_JENDL_LIST_NPL_read;
                    vartype aux_last_type_read_for_JENDL_LIST_NPL = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , JENDL_LIST_NPL , 0 / \n { 0.0 } { k = 1 to JENDL_LIST_NPL } ] LIST";
                      cpp_line = cpp_read_raw_line(cont);
                      // read LIST record
                      // assign expression to variable SPI
                      var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                      aux_SPI_read = true;
                      validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                      aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                      // assign expression to variable PAR
                      var_PAR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                      aux_PAR_read = true;
                      validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
                      aux_last_type_read_for_PAR = SCALAR_DOUBLE;
                      // assign expression to variable JENDL_LIST_NPL
                      var_JENDL_LIST_NPL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_JENDL_LIST_NPL_read = true;
                      validate_vartype_consistency("JENDL_LIST_NPL", SCALAR_INT, aux_last_type_read_for_JENDL_LIST_NPL);
                      aux_last_type_read_for_JENDL_LIST_NPL = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((aux_JENDL_LIST_NPL_read == true)) && ((var_JENDL_LIST_NPL_0d_int_Scalar)!=(6)))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , JENDL_LIST_NPL , 0 / \n { 0.0 } { k = 1 to JENDL_LIST_NPL } ] LIST";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable PAR
                    var_PAR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                    aux_PAR_read = true;
                    validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
                    aux_last_type_read_for_PAR = SCALAR_DOUBLE;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable JENDL_LIST_NPL
                    var_JENDL_LIST_NPL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_JENDL_LIST_NPL_read = true;
                    validate_vartype_consistency("JENDL_LIST_NPL", SCALAR_INT, aux_last_type_read_for_JENDL_LIST_NPL);
                    aux_last_type_read_for_JENDL_LIST_NPL = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    {
                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_JENDL_LIST_NPL_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                  }
                }
              }
              if (! cpp_found_match) {
                cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , 6 , 0 / \n 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ] LIST";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST record
                // assign expression to variable SPI
                var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                aux_SPI_read = true;
                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                // assign expression to variable PAR
                var_PAR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                aux_PAR_read = true;
                validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
                aux_last_type_read_for_PAR = SCALAR_DOUBLE;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(6, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "6",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST body
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LIS == SCALAR_INT) && (aux_LIS_read == true))) {
    cpp_current_dict["LIS"] = var_LIS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LISO == SCALAR_INT) && (aux_LISO_read == true))) {
    cpp_current_dict["LISO"] = var_LISO_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NST == SCALAR_INT) && (aux_NST_read == true))) {
    cpp_current_dict["NST"] = var_NST_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NSP == SCALAR_INT) && (aux_NSP_read == true))) {
    cpp_current_dict["NSP"] = var_NSP_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_Thalf == SCALAR_DOUBLE) && (aux_Thalf_read == true))) {
    cpp_current_dict["Thalf"] = var_Thalf_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dThalf == SCALAR_DOUBLE) && (aux_dThalf_read == true))) {
    cpp_current_dict["dThalf"] = var_dThalf_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
    cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
  }
  if ((var_Ebar_x_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["Ebar_x"] = var_Ebar_x_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_dEbar_x_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["dEbar_x"] = var_dEbar_x_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_SPI == SCALAR_DOUBLE) && (aux_SPI_read == true))) {
    cpp_current_dict["SPI"] = var_SPI_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_PAR == SCALAR_DOUBLE) && (aux_PAR_read == true))) {
    cpp_current_dict["PAR"] = var_PAR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NDK == SCALAR_INT) && (aux_NDK_read == true))) {
    cpp_current_dict["NDK"] = var_NDK_0d_int_Scalar;
  }
  if ((var_RTYP_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["RTYP"] = var_RTYP_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_RFS_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["RFS"] = var_RFS_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_Q_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["Q"] = var_Q_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_dQ_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["dQ"] = var_dQ_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_BR_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["BR"] = var_BR_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_dBR_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["dBR"] = var_dBR_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_JENDL_LIST_NPL == SCALAR_INT) && (aux_JENDL_LIST_NPL_read == true))) {
    cpp_current_dict["JENDL_LIST_NPL"] = var_JENDL_LIST_NPL_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 9b44a8a45cec90ea92aa701b596f413f
// MD5 hash of the following function definition: 0a2a907a67fb165c07f9d3f66e34f67d
py::dict parse_mf8mt459_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_LE_0d_int_Scalar;
  bool aux_LE_read = false;
  vartype aux_last_type_read_for_LE = UNKNOWN;
  NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<int> var_NN_1d_int_NestedVector;
  vartype aux_last_type_read_for_NN = UNKNOWN;
  NestedVector<int> var_NFP_1d_int_NestedVector;
  vartype aux_last_type_read_for_NFP = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_ZAFP_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_ZAFP_2d_idx0;
  vartype aux_last_type_read_for_ZAFP = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_FPS_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_FPS_2d_idx0;
  vartype aux_last_type_read_for_FPS = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_YC_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_YC_2d_idx0;
  vartype aux_last_type_read_for_YC = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_DYC_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_DYC_2d_idx0;
  vartype aux_last_type_read_for_DYC = UNKNOWN;
  NestedVector<int> var_I_1d_int_NestedVector;
  vartype aux_last_type_read_for_I = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 8;
  int mt = 459;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 459;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 8 , MT / ZA , AWR , (LE+1) , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable cpp_int_val
  cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_cpp_int_val_read = true;
  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
  // assign expression to variable LE
  var_LE_0d_int_Scalar = (cpp_int_val+(-1));
  aux_LE_read = true;
  validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
  aux_last_type_read_for_LE = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_template = "[ MAT , 8 , MT / E , 0.0 , LE , 0 , NN , NFP / \n { ZAFP , FPS , YC , DYC } { m = 1 to NFP } ] LIST";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read LIST record
  // assign expression to variable E
  var_E_1d_double_NestedVector.set(0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts));
  validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
  aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  if ((! (aux_LE_read == true))) {
    // assign expression to variable LE
    var_LE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
    aux_LE_read = true;
    validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
    aux_last_type_read_for_LE = SCALAR_INT;
  } else {
    cpp_validate_field(var_LE_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "LE",
      cpp_template, cpp_line, parse_opts);
  }
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NN
  var_NN_1d_int_NestedVector.set(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
  validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
  aux_last_type_read_for_NN = NESTEDVECTOR_INT;
  // assign expression to variable NFP
  var_NFP_1d_int_NestedVector.set(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
  validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
  aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
  {
    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST body
    ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(0);
    ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(0);
    ptr_YC_2d_idx0 = var_YC_2d_double_NestedVector.prepare(0);
    ptr_DYC_2d_idx0 = var_DYC_2d_double_NestedVector.prepare(0);

    for (int var_m_0d_int_Scalar = 1;
       var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[0]; var_m_0d_int_Scalar++) {
      bool aux_m_read = true;
      // read LIST body
      // assign expression to variable ZAFP
      ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
      aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
      // assign expression to variable FPS
      ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
      aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
      // assign expression to variable YC
      ptr_YC_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("YC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YC);
      aux_last_type_read_for_YC = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
      // assign expression to variable DYC
      ptr_DYC_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("DYC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYC);
      aux_last_type_read_for_DYC = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_LE_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    cpp_template = "[ MAT , 8 , MT / E , 0.0 , I , 0 , NN , NFP / \n { ZAFP , FPS , YC , DYC } { m = 1 to NFP } ] LIST";
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST record
    if ((! var_E_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable E
      var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts));
      validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
      aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
    } else {
      cpp_validate_field(var_E_1d_double_NestedVector[var_k_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "E",
        cpp_template, cpp_line, parse_opts);
    }
    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
      cpp_template, cpp_line, parse_opts);
    // assign expression to variable I
    var_I_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
    validate_vartype_consistency("I", NESTEDVECTOR_INT, aux_last_type_read_for_I);
    aux_last_type_read_for_I = NESTEDVECTOR_INT;
    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
      cpp_template, cpp_line, parse_opts);
    if ((! var_NN_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NN
      var_NN_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
      validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
      aux_last_type_read_for_NN = NESTEDVECTOR_INT;
    } else {
      cpp_validate_field(var_NN_1d_int_NestedVector[var_k_0d_int_Scalar], cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NN",
        cpp_template, cpp_line, parse_opts);
    }
    if ((! var_NFP_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NFP
      var_NFP_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
      validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
      aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
    } else {
      cpp_validate_field(var_NFP_1d_int_NestedVector[var_k_0d_int_Scalar], cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NFP",
        cpp_template, cpp_line, parse_opts);
    }
    {
      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      int cpp_i = 0;
      int cpp_j = 0;
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read LIST body
      ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_YC_2d_idx0 = var_YC_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_DYC_2d_idx0 = var_DYC_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

      for (int var_m_0d_int_Scalar = 1;
         var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[var_k_0d_int_Scalar]; var_m_0d_int_Scalar++) {
        bool aux_m_read = true;
        // read LIST body
        if ((! (var_ZAFP_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_ZAFP_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable ZAFP
          ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
          aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_ZAFP_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "ZAFP",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        if ((! (var_FPS_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_FPS_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable FPS
          ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
          aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_FPS_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "FPS",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        if ((! (var_YC_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_YC_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable YC
          ptr_YC_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("YC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YC);
          aux_last_type_read_for_YC = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_YC_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "YC",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        if ((! (var_DYC_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_DYC_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable DYC
          ptr_DYC_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("DYC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYC);
          aux_last_type_read_for_DYC = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_DYC_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "DYC",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
      }
      if (cpp_i != cpp_npl) {
        throw std::runtime_error("not exactly NPL elements consumed");
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LE == SCALAR_INT) && (aux_LE_read == true))) {
    cpp_current_dict["LE"] = var_LE_0d_int_Scalar;
  }
  if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_NN_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["NN"] = var_NN_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_NFP_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["NFP"] = var_NFP_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_ZAFP_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["ZAFP"] = var_ZAFP_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_FPS_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["FPS"] = var_FPS_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_YC_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["YC"] = var_YC_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_DYC_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["DYC"] = var_DYC_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_I_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["I"] = var_I_1d_int_NestedVector.to_pyobj(list_mode);
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 1db3e473b7f130d4f0683e6401196b22
// MD5 hash of the following function definition: e1e30ddeaf1ed30e9117d112ce067d5f
py::dict parse_mf9_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 9;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 9;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 9 , MT / ZA , AWR , LIS , 0 , NS , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.setdefault("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_QM_0d_double_Scalar;
      bool aux_QM_read = false;
      vartype aux_last_type_read_for_QM = UNKNOWN;
      EndfFloatCpp var_QI_0d_double_Scalar;
      bool aux_QI_read = false;
      vartype aux_last_type_read_for_QI = UNKNOWN;
      int var_IZAP_0d_int_Scalar;
      bool aux_IZAP_read = false;
      vartype aux_last_type_read_for_IZAP = UNKNOWN;
      int var_LFS_0d_int_Scalar;
      bool aux_LFS_read = false;
      vartype aux_last_type_read_for_LFS = UNKNOWN;
      std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      vartype aux_last_type_read_for_E = UNKNOWN;
      std::vector<EndfFloatCpp> var_Y_0d_floatvec_Scalar;
      bool aux_Y_read = false;
      vartype aux_last_type_read_for_Y = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      cpp_template = "[ MAT , 9 , MT / QM , QI , IZAP , LFS , NR , NP / E / Y ] TAB1";
      // read TAB1 record
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // assign expression to variable QM
      var_QM_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
      aux_QM_read = true;
      validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
      aux_last_type_read_for_QM = SCALAR_DOUBLE;
      // assign expression to variable QI
      var_QI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
      aux_QI_read = true;
      validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
      aux_last_type_read_for_QI = SCALAR_DOUBLE;
      // assign expression to variable IZAP
      var_IZAP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
      aux_IZAP_read = true;
      validate_vartype_consistency("IZAP", SCALAR_INT, aux_last_type_read_for_IZAP);
      aux_last_type_read_for_IZAP = SCALAR_INT;
      // assign expression to variable LFS
      var_LFS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LFS_read = true;
      validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
      aux_last_type_read_for_LFS = SCALAR_INT;
      cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
      {
        Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
        // assign expression to variable E
        var_E_0d_floatvec_Scalar = tab_body.X;
        aux_E_read = true;
        validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
        aux_last_type_read_for_E = SCALAR_FLOATVEC;
        // assign expression to variable Y
        var_Y_0d_floatvec_Scalar = tab_body.Y;
        aux_Y_read = true;
        validate_vartype_consistency("Y", SCALAR_FLOATVEC, aux_last_type_read_for_Y);
        aux_last_type_read_for_Y = SCALAR_FLOATVEC;
        // assign expression to variable INT
        var_INT_0d_intvec_Scalar = tab_body.INT;
        aux_INT_read = true;
        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
        aux_last_type_read_for_INT = SCALAR_INTVEC;
        // assign expression to variable NBT
        var_NBT_0d_intvec_Scalar = tab_body.NBT;
        aux_NBT_read = true;
        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
        aux_last_type_read_for_NBT = SCALAR_INTVEC;
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_QM == SCALAR_DOUBLE) && (aux_QM_read == true))) {
        cpp_current_dict["QM"] = var_QM_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_QI == SCALAR_DOUBLE) && (aux_QI_read == true))) {
        cpp_current_dict["QI"] = var_QI_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_IZAP == SCALAR_INT) && (aux_IZAP_read == true))) {
        cpp_current_dict["IZAP"] = var_IZAP_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LFS == SCALAR_INT) && (aux_LFS_read == true))) {
        cpp_current_dict["LFS"] = var_LFS_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
        cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_Y == SCALAR_FLOATVEC) && (aux_Y_read == true))) {
        cpp_current_dict["Y"] = var_Y_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LIS == SCALAR_INT) && (aux_LIS_read == true))) {
    cpp_current_dict["LIS"] = var_LIS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NS == SCALAR_INT) && (aux_NS_read == true))) {
    cpp_current_dict["NS"] = var_NS_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: b5ce883fcd2a78e1dee22fd8e5f23c84
// MD5 hash of the following function definition: 0c8c1cb081a7281d0d50af5239cfa190
py::dict parse_mf10_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 10;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 10;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 10 , MT / ZA , AWR , LIS , 0 , NS , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.setdefault("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_QM_0d_double_Scalar;
      bool aux_QM_read = false;
      vartype aux_last_type_read_for_QM = UNKNOWN;
      EndfFloatCpp var_QI_0d_double_Scalar;
      bool aux_QI_read = false;
      vartype aux_last_type_read_for_QI = UNKNOWN;
      int var_IZAP_0d_int_Scalar;
      bool aux_IZAP_read = false;
      vartype aux_last_type_read_for_IZAP = UNKNOWN;
      int var_LFS_0d_int_Scalar;
      bool aux_LFS_read = false;
      vartype aux_last_type_read_for_LFS = UNKNOWN;
      std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      vartype aux_last_type_read_for_E = UNKNOWN;
      std::vector<EndfFloatCpp> var_sigma_0d_floatvec_Scalar;
      bool aux_sigma_read = false;
      vartype aux_last_type_read_for_sigma = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      cpp_template = "[ MAT , 10 , MT / QM , QI , IZAP , LFS , NR , NP / E / sigma ] TAB1";
      // read TAB1 record
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // assign expression to variable QM
      var_QM_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
      aux_QM_read = true;
      validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
      aux_last_type_read_for_QM = SCALAR_DOUBLE;
      // assign expression to variable QI
      var_QI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
      aux_QI_read = true;
      validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
      aux_last_type_read_for_QI = SCALAR_DOUBLE;
      // assign expression to variable IZAP
      var_IZAP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
      aux_IZAP_read = true;
      validate_vartype_consistency("IZAP", SCALAR_INT, aux_last_type_read_for_IZAP);
      aux_last_type_read_for_IZAP = SCALAR_INT;
      // assign expression to variable LFS
      var_LFS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LFS_read = true;
      validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
      aux_last_type_read_for_LFS = SCALAR_INT;
      cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
      {
        Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
        // assign expression to variable E
        var_E_0d_floatvec_Scalar = tab_body.X;
        aux_E_read = true;
        validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
        aux_last_type_read_for_E = SCALAR_FLOATVEC;
        // assign expression to variable sigma
        var_sigma_0d_floatvec_Scalar = tab_body.Y;
        aux_sigma_read = true;
        validate_vartype_consistency("sigma", SCALAR_FLOATVEC, aux_last_type_read_for_sigma);
        aux_last_type_read_for_sigma = SCALAR_FLOATVEC;
        // assign expression to variable INT
        var_INT_0d_intvec_Scalar = tab_body.INT;
        aux_INT_read = true;
        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
        aux_last_type_read_for_INT = SCALAR_INTVEC;
        // assign expression to variable NBT
        var_NBT_0d_intvec_Scalar = tab_body.NBT;
        aux_NBT_read = true;
        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
        aux_last_type_read_for_NBT = SCALAR_INTVEC;
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_QM == SCALAR_DOUBLE) && (aux_QM_read == true))) {
        cpp_current_dict["QM"] = var_QM_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_QI == SCALAR_DOUBLE) && (aux_QI_read == true))) {
        cpp_current_dict["QI"] = var_QI_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_IZAP == SCALAR_INT) && (aux_IZAP_read == true))) {
        cpp_current_dict["IZAP"] = var_IZAP_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LFS == SCALAR_INT) && (aux_LFS_read == true))) {
        cpp_current_dict["LFS"] = var_LFS_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
        cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_sigma == SCALAR_FLOATVEC) && (aux_sigma_read == true))) {
        cpp_current_dict["sigma"] = var_sigma_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LIS == SCALAR_INT) && (aux_LIS_read == true))) {
    cpp_current_dict["LIS"] = var_LIS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NS == SCALAR_INT) && (aux_NS_read == true))) {
    cpp_current_dict["NS"] = var_NS_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: e54487563cbd4b212af001ef1d061333
// MD5 hash of the following function definition: a3f4c024399a24abedc61d1d83dd54cf
py::dict parse_mf12_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LO_0d_int_Scalar;
  bool aux_LO_read = false;
  vartype aux_last_type_read_for_LO = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<EndfFloatCpp> var_Y_0d_floatvec_Scalar;
  bool aux_Y_read = false;
  vartype aux_last_type_read_for_Y = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  NestedVector<EndfFloatCpp> var_Eg_1d_double_NestedVector;
  vartype aux_last_type_read_for_Eg = UNKNOWN;
  NestedVector<EndfFloatCpp> var_ES_1d_double_NestedVector;
  vartype aux_last_type_read_for_ES = UNKNOWN;
  NestedVector<int> var_LP_1d_int_NestedVector;
  vartype aux_last_type_read_for_LP = UNKNOWN;
  NestedVector<int> var_LF_1d_int_NestedVector;
  vartype aux_last_type_read_for_LF = UNKNOWN;
  int var_LG_0d_int_Scalar;
  bool aux_LG_read = false;
  vartype aux_last_type_read_for_LG = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  EndfFloatCpp var_ES_NS_0d_double_Scalar;
  bool aux_ES_NS_read = false;
  vartype aux_last_type_read_for_ES_NS = UNKNOWN;
  int var_LP_0d_int_Scalar;
  bool aux_LP_read = false;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_NT_0d_int_Scalar;
  bool aux_NT_read = false;
  vartype aux_last_type_read_for_NT = UNKNOWN;
  NestedVector<EndfFloatCpp> var_TP_1d_double_NestedVector;
  vartype aux_last_type_read_for_TP = UNKNOWN;
  NestedVector<EndfFloatCpp> var_GP_1d_double_NestedVector;
  vartype aux_last_type_read_for_GP = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 12;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 12;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        std::streampos cpp_old_streampos = cont.tellg();
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
          int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
          bool& glob_aux_LO_read = aux_LO_read;
          bool aux_LO_read = glob_aux_LO_read;
          vartype aux_last_type_read_for_LO = UNKNOWN;
          int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
          int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
          bool& glob_aux_NK_read = aux_NK_read;
          bool aux_NK_read = glob_aux_NK_read;
          vartype aux_last_type_read_for_NK = UNKNOWN;
          try {
            cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , 0 , NK , 0 ] HEAD";
            cpp_line = cpp_read_raw_line(cont);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LO
            var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            // assign expression to variable NK
            var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
          } catch (const std::out_of_range& e) {
            // // accept failure in lookahead
          }
          if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(1)))))))) {
            cpp_found_match = true;
          }
          cont.seekg(cpp_old_streampos);
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , 0 , NK , 0 ] HEAD";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LO
          var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LO_read = true;
          validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
          aux_last_type_read_for_LO = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NK
          var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NK_read = true;
          validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
          aux_last_type_read_for_NK = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((aux_NK_read == true)) && ((var_NK_0d_int_Scalar)>(1)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                cpp_template = "[ MAT , 12 , MT / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / Y ] TAB1";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                {
                  Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                  // assign expression to variable Y
                  var_Y_0d_floatvec_Scalar = tab_body.Y;
                  aux_Y_read = true;
                  validate_vartype_consistency("Y", SCALAR_FLOATVEC, aux_last_type_read_for_Y);
                  aux_last_type_read_for_Y = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
              }
            }
          }

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            cpp_template = "[ MAT , 12 , MT / Eg , ES , LP , LF , NR , NP / Eint / y ] TAB1 ( table [ k ] )";
            // read TAB1 record
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // assign expression to variable Eg
            var_Eg_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts));
            validate_vartype_consistency("Eg", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Eg);
            aux_last_type_read_for_Eg = NESTEDVECTOR_DOUBLE;
            // assign expression to variable ES
            var_ES_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
            validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
            aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
            // assign expression to variable LP
            var_LP_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
            validate_vartype_consistency("LP", NESTEDVECTOR_INT, aux_last_type_read_for_LP);
            aux_last_type_read_for_LP = NESTEDVECTOR_INT;
            // assign expression to variable LF
            var_LF_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
            validate_vartype_consistency("LF", NESTEDVECTOR_INT, aux_last_type_read_for_LF);
            aux_last_type_read_for_LF = NESTEDVECTOR_INT;
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.setdefault("table", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              // variable declarations
              std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
              bool aux_Eint_read = false;
              vartype aux_last_type_read_for_Eint = UNKNOWN;
              std::vector<EndfFloatCpp> var_y_0d_floatvec_Scalar;
              bool aux_y_read = false;
              vartype aux_last_type_read_for_y = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                if ((! (aux_Eint_read == true))) {
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                } else {
                  cpp_validate_field(var_Eint_0d_floatvec_Scalar, tab_body.X,  true, false, false, "Eint",
                    cpp_template, cpp_line, parse_opts);
                }
                // assign expression to variable y
                var_y_0d_floatvec_Scalar = tab_body.Y;
                aux_y_read = true;
                validate_vartype_consistency("y", SCALAR_FLOATVEC, aux_last_type_read_for_y);
                aux_last_type_read_for_y = SCALAR_FLOATVEC;
                if ((! (aux_INT_read == true))) {
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                } else {
                  cpp_validate_field(var_INT_0d_intvec_Scalar, tab_body.INT,  true, false, false, "INT",
                    cpp_template, cpp_line, parse_opts);
                }
                if ((! (aux_NBT_read == true))) {
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                } else {
                  cpp_validate_field(var_NBT_0d_intvec_Scalar, tab_body.NBT,  true, false, false, "NBT",
                    cpp_template, cpp_line, parse_opts);
                }
              }
              // store data in Python dictionary
              if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
                cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_y == SCALAR_FLOATVEC) && (aux_y_read == true))) {
                cpp_current_dict["y"] = var_y_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
              }
              if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
            int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
            bool& glob_aux_LO_read = aux_LO_read;
            bool aux_LO_read = glob_aux_LO_read;
            vartype aux_last_type_read_for_LO = UNKNOWN;
            int& glob_var_LG_0d_int_Scalar = var_LG_0d_int_Scalar;
            int var_LG_0d_int_Scalar = glob_var_LG_0d_int_Scalar;
            bool& glob_aux_LG_read = aux_LG_read;
            bool aux_LG_read = glob_aux_LG_read;
            vartype aux_last_type_read_for_LG = UNKNOWN;
            int& glob_var_NS_0d_int_Scalar = var_NS_0d_int_Scalar;
            int var_NS_0d_int_Scalar = glob_var_NS_0d_int_Scalar;
            bool& glob_aux_NS_read = aux_NS_read;
            bool aux_NS_read = glob_aux_NS_read;
            vartype aux_last_type_read_for_NS = UNKNOWN;
            try {
              cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , LG , NS , 0 ] HEAD";
              cpp_line = cpp_read_raw_line(cont);
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LO
              var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LO_read = true;
              validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
              aux_last_type_read_for_LO = SCALAR_INT;
              // assign expression to variable LG
              var_LG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LG_read = true;
              validate_vartype_consistency("LG", SCALAR_INT, aux_last_type_read_for_LG);
              aux_last_type_read_for_LG = SCALAR_INT;
              // assign expression to variable NS
              var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_NS_read = true;
              validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
              aux_last_type_read_for_NS = SCALAR_INT;
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(2)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , LG , NS , 0 ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LO
            var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            // assign expression to variable LG
            var_LG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LG_read = true;
            validate_vartype_consistency("LG", SCALAR_INT, aux_last_type_read_for_LG);
            aux_last_type_read_for_LG = SCALAR_INT;
            // assign expression to variable NS
            var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NS_read = true;
            validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
            aux_last_type_read_for_NS = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // evaluate if-elif-else clause
            {
              bool cpp_found_match = false;
              if (! cpp_found_match) {
                if ((((((((aux_LG_read == true)) && ((var_LG_0d_int_Scalar)==(1)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  cpp_template = "[ MAT , 12 , MT / ES_NS , 0.0 , LP , 0 , (2*NT) , NT / \n { ES , TP } { i = 1 to NT } ] LIST";
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST record
                  // assign expression to variable ES_NS
                  var_ES_NS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                  aux_ES_NS_read = true;
                  validate_vartype_consistency("ES_NS", SCALAR_DOUBLE, aux_last_type_read_for_ES_NS);
                  aux_last_type_read_for_ES_NS = SCALAR_DOUBLE;
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable LP
                  var_LP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                  aux_LP_read = true;
                  validate_vartype_consistency("LP", SCALAR_INT, aux_last_type_read_for_LP);
                  aux_last_type_read_for_LP = SCALAR_INT;
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable cpp_int_val
                  cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  aux_cpp_int_val_read = true;
                  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                  // assign expression to variable NT
                  var_NT_0d_int_Scalar = (cpp_int_val/2);
                  aux_NT_read = true;
                  validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                  aux_last_type_read_for_NT = SCALAR_INT;
                  if ((! (aux_NT_read == true))) {
                    // assign expression to variable NT
                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_NT_read = true;
                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                    aux_last_type_read_for_NT = SCALAR_INT;
                  } else {
                    cpp_validate_field(var_NT_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NT",
                      cpp_template, cpp_line, parse_opts);
                  }
                  {
                    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    int cpp_i = 0;
                    int cpp_j = 0;
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST body

                    for (int var_i_0d_int_Scalar = 1;
                       var_i_0d_int_Scalar <= var_NT_0d_int_Scalar; var_i_0d_int_Scalar++) {
                      bool aux_i_read = true;
                      // read LIST body
                      // assign expression to variable ES
                      var_ES_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                      validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                      aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                      cpp_i++;
                      cpp_j++;
                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        cpp_j = 0;
                      }
                      // assign expression to variable TP
                      var_TP_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                      validate_vartype_consistency("TP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_TP);
                      aux_last_type_read_for_TP = NESTEDVECTOR_DOUBLE;
                      cpp_i++;
                      cpp_j++;
                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        cpp_j = 0;
                      }
                    }
                    if (cpp_i != cpp_npl) {
                      throw std::runtime_error("not exactly NPL elements consumed");
                    }
                  }
                }
              }
              if (! cpp_found_match) {
                if (! cpp_found_match) {
                  if ((((((((aux_LG_read == true)) && ((var_LG_0d_int_Scalar)==(2)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    cpp_template = "[ MAT , 12 , MT / ES_NS , 0.0 , LP , 0 , ((LG+1)*NT) , NT / \n { ES , TP , GP } { i = 1 to NT } ] LIST";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST record
                    // assign expression to variable ES_NS
                    var_ES_NS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                    aux_ES_NS_read = true;
                    validate_vartype_consistency("ES_NS", SCALAR_DOUBLE, aux_last_type_read_for_ES_NS);
                    aux_last_type_read_for_ES_NS = SCALAR_DOUBLE;
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable LP
                    var_LP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_LP_read = true;
                    validate_vartype_consistency("LP", SCALAR_INT, aux_last_type_read_for_LP);
                    aux_last_type_read_for_LP = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable cpp_int_val
                    cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_cpp_int_val_read = true;
                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                    // assign expression to variable NT
                    var_NT_0d_int_Scalar = (cpp_int_val/(var_LG_0d_int_Scalar+1));
                    aux_NT_read = true;
                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                    aux_last_type_read_for_NT = SCALAR_INT;
                    if ((! (aux_NT_read == true))) {
                      // assign expression to variable NT
                      var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_NT_read = true;
                      validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                      aux_last_type_read_for_NT = SCALAR_INT;
                    } else {
                      cpp_validate_field(var_NT_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NT",
                        cpp_template, cpp_line, parse_opts);
                    }
                    {
                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST body

                      for (int var_i_0d_int_Scalar = 1;
                         var_i_0d_int_Scalar <= var_NT_0d_int_Scalar; var_i_0d_int_Scalar++) {
                        bool aux_i_read = true;
                        // read LIST body
                        // assign expression to variable ES
                        var_ES_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                        aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable TP
                        var_TP_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("TP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_TP);
                        aux_last_type_read_for_TP = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GP
                        var_GP_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GP);
                        aux_last_type_read_for_GP = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LO == SCALAR_INT) && (aux_LO_read == true))) {
    cpp_current_dict["LO"] = var_LO_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NK == SCALAR_INT) && (aux_NK_read == true))) {
    cpp_current_dict["NK"] = var_NK_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
    cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_Y == SCALAR_FLOATVEC) && (aux_Y_read == true))) {
    cpp_current_dict["Y"] = var_Y_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  if ((var_Eg_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["Eg"] = var_Eg_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_ES_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["ES"] = var_ES_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_LP_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["LP"] = var_LP_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_LF_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["LF"] = var_LF_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if (((aux_last_type_read_for_LG == SCALAR_INT) && (aux_LG_read == true))) {
    cpp_current_dict["LG"] = var_LG_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NS == SCALAR_INT) && (aux_NS_read == true))) {
    cpp_current_dict["NS"] = var_NS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ES_NS == SCALAR_DOUBLE) && (aux_ES_NS_read == true))) {
    cpp_current_dict["ES_NS"] = var_ES_NS_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LP == SCALAR_INT) && (aux_LP_read == true))) {
    cpp_current_dict["LP"] = var_LP_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NT == SCALAR_INT) && (aux_NT_read == true))) {
    cpp_current_dict["NT"] = var_NT_0d_int_Scalar;
  }
  if ((var_TP_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["TP"] = var_TP_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_GP_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["GP"] = var_GP_1d_double_NestedVector.to_pyobj(list_mode);
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 0244722dd783f7feb5112a1d869b898f
// MD5 hash of the following function definition: 72ce63a503bf62f19299a1dabb47d8e8
py::dict parse_mf13_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
  bool aux_E_read = false;
  vartype aux_last_type_read_for_E = UNKNOWN;
  std::vector<EndfFloatCpp> var_sigma_tot_0d_floatvec_Scalar;
  bool aux_sigma_tot_read = false;
  vartype aux_last_type_read_for_sigma_tot = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 13;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 13;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 13 , MT / ZA , AWR , 0 , 0 , NK , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_NK_read == true)) && ((var_NK_0d_int_Scalar)>(1)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 13 , MT / 0.0 , 0.0 , 0 , 0 , NR , NP / E / sigma_tot ] TAB1";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
        {
          Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
          // assign expression to variable E
          var_E_0d_floatvec_Scalar = tab_body.X;
          aux_E_read = true;
          validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
          aux_last_type_read_for_E = SCALAR_FLOATVEC;
          // assign expression to variable sigma_tot
          var_sigma_tot_0d_floatvec_Scalar = tab_body.Y;
          aux_sigma_tot_read = true;
          validate_vartype_consistency("sigma_tot", SCALAR_FLOATVEC, aux_last_type_read_for_sigma_tot);
          aux_last_type_read_for_sigma_tot = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
      }
    }
  }

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.setdefault("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_EG_0d_double_Scalar;
      bool aux_EG_read = false;
      vartype aux_last_type_read_for_EG = UNKNOWN;
      EndfFloatCpp var_ES_0d_double_Scalar;
      bool aux_ES_read = false;
      vartype aux_last_type_read_for_ES = UNKNOWN;
      int var_LP_0d_int_Scalar;
      bool aux_LP_read = false;
      vartype aux_last_type_read_for_LP = UNKNOWN;
      int var_LF_0d_int_Scalar;
      bool aux_LF_read = false;
      vartype aux_last_type_read_for_LF = UNKNOWN;
      std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      vartype aux_last_type_read_for_E = UNKNOWN;
      std::vector<EndfFloatCpp> var_sigma_0d_floatvec_Scalar;
      bool aux_sigma_read = false;
      vartype aux_last_type_read_for_sigma = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      cpp_template = "[ MAT , 13 , MT / EG , ES , LP , LF , NR , NP / E / sigma ] TAB1";
      // read TAB1 record
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // assign expression to variable EG
      var_EG_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
      aux_EG_read = true;
      validate_vartype_consistency("EG", SCALAR_DOUBLE, aux_last_type_read_for_EG);
      aux_last_type_read_for_EG = SCALAR_DOUBLE;
      // assign expression to variable ES
      var_ES_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
      aux_ES_read = true;
      validate_vartype_consistency("ES", SCALAR_DOUBLE, aux_last_type_read_for_ES);
      aux_last_type_read_for_ES = SCALAR_DOUBLE;
      // assign expression to variable LP
      var_LP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
      aux_LP_read = true;
      validate_vartype_consistency("LP", SCALAR_INT, aux_last_type_read_for_LP);
      aux_last_type_read_for_LP = SCALAR_INT;
      // assign expression to variable LF
      var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LF_read = true;
      validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
      aux_last_type_read_for_LF = SCALAR_INT;
      cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
      {
        Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
        if ((! (aux_E_read == true))) {
          // assign expression to variable E
          var_E_0d_floatvec_Scalar = tab_body.X;
          aux_E_read = true;
          validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
          aux_last_type_read_for_E = SCALAR_FLOATVEC;
        } else {
          cpp_validate_field(var_E_0d_floatvec_Scalar, tab_body.X,  true, false, false, "E",
            cpp_template, cpp_line, parse_opts);
        }
        // assign expression to variable sigma
        var_sigma_0d_floatvec_Scalar = tab_body.Y;
        aux_sigma_read = true;
        validate_vartype_consistency("sigma", SCALAR_FLOATVEC, aux_last_type_read_for_sigma);
        aux_last_type_read_for_sigma = SCALAR_FLOATVEC;
        if ((! (aux_INT_read == true))) {
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
        } else {
          cpp_validate_field(var_INT_0d_intvec_Scalar, tab_body.INT,  true, false, false, "INT",
            cpp_template, cpp_line, parse_opts);
        }
        if ((! (aux_NBT_read == true))) {
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        } else {
          cpp_validate_field(var_NBT_0d_intvec_Scalar, tab_body.NBT,  true, false, false, "NBT",
            cpp_template, cpp_line, parse_opts);
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_EG == SCALAR_DOUBLE) && (aux_EG_read == true))) {
        cpp_current_dict["EG"] = var_EG_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_ES == SCALAR_DOUBLE) && (aux_ES_read == true))) {
        cpp_current_dict["ES"] = var_ES_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_LP == SCALAR_INT) && (aux_LP_read == true))) {
        cpp_current_dict["LP"] = var_LP_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LF == SCALAR_INT) && (aux_LF_read == true))) {
        cpp_current_dict["LF"] = var_LF_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
        cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_sigma == SCALAR_FLOATVEC) && (aux_sigma_read == true))) {
        cpp_current_dict["sigma"] = var_sigma_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NK == SCALAR_INT) && (aux_NK_read == true))) {
    cpp_current_dict["NK"] = var_NK_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_sigma_tot == SCALAR_FLOATVEC) && (aux_sigma_tot_read == true))) {
    cpp_current_dict["sigma_tot"] = var_sigma_tot_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: cbb953767d4afb465ff9cee335ea03ef
// MD5 hash of the following function definition: 154d6ceee64ea28cf6a0bd0cb73549b0
py::dict parse_mf14_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LI_0d_int_Scalar;
  bool aux_LI_read = false;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  int var_LTT_0d_int_Scalar;
  bool aux_LTT_read = false;
  vartype aux_last_type_read_for_LTT = UNKNOWN;
  int var_NI_0d_int_Scalar;
  bool aux_NI_read = false;
  vartype aux_last_type_read_for_NI = UNKNOWN;
  NestedVector<EndfFloatCpp> var_EG_1d_double_NestedVector;
  vartype aux_last_type_read_for_EG = UNKNOWN;
  NestedVector<EndfFloatCpp> var_ES_1d_double_NestedVector;
  vartype aux_last_type_read_for_ES = UNKNOWN;
  NestedVector<int> var_NE_1d_int_NestedVector;
  vartype aux_last_type_read_for_NE = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_E_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_E_2d_idx0;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<NestedVector<int>> var_NL_2d_int_NestedVector;
  NestedVector<int>* ptr_NL_2d_idx0;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  NestedVector<NestedVector<NestedVector<EndfFloatCpp>>> var_a_3d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_a_3d_idx1;
  NestedVector<NestedVector<EndfFloatCpp>>* ptr_a_3d_idx0;
  vartype aux_last_type_read_for_a = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 14;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 14;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        std::streampos cpp_old_streampos = cont.tellg();
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
          int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
          bool& glob_aux_LI_read = aux_LI_read;
          bool aux_LI_read = glob_aux_LI_read;
          vartype aux_last_type_read_for_LI = UNKNOWN;
          int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
          int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
          bool& glob_aux_NK_read = aux_NK_read;
          bool aux_NK_read = glob_aux_NK_read;
          vartype aux_last_type_read_for_NK = UNKNOWN;
          try {
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , 0 , NK , 0 ] HEAD";
            cpp_line = cpp_read_raw_line(cont);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LI
            var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            // assign expression to variable NK
            var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
          } catch (const std::out_of_range& e) {
            // // accept failure in lookahead
          }
          if ((((((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(1)))))))) {
            cpp_found_match = true;
          }
          cont.seekg(cpp_old_streampos);
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , 0 , NK , 0 ] HEAD";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LI
          var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NK
          var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NK_read = true;
          validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
          aux_last_type_read_for_NK = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
            int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
            bool& glob_aux_LI_read = aux_LI_read;
            bool aux_LI_read = glob_aux_LI_read;
            vartype aux_last_type_read_for_LI = UNKNOWN;
            int& glob_var_LTT_0d_int_Scalar = var_LTT_0d_int_Scalar;
            int var_LTT_0d_int_Scalar = glob_var_LTT_0d_int_Scalar;
            bool& glob_aux_LTT_read = aux_LTT_read;
            bool aux_LTT_read = glob_aux_LTT_read;
            vartype aux_last_type_read_for_LTT = UNKNOWN;
            int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
            int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
            bool& glob_aux_NK_read = aux_NK_read;
            bool aux_NK_read = glob_aux_NK_read;
            vartype aux_last_type_read_for_NK = UNKNOWN;
            int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
            int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
            bool& glob_aux_NI_read = aux_NI_read;
            bool aux_NI_read = glob_aux_NI_read;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            try {
              cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
              cpp_line = cpp_read_raw_line(cont);
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LI
              var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LI_read = true;
              validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
              aux_last_type_read_for_LI = SCALAR_INT;
              // assign expression to variable LTT
              var_LTT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LTT_read = true;
              validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
              aux_last_type_read_for_LTT = SCALAR_INT;
              // assign expression to variable NK
              var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_NK_read = true;
              validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
              aux_last_type_read_for_NK = SCALAR_INT;
              // assign expression to variable NI
              var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NI_read = true;
              validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
              aux_last_type_read_for_NI = SCALAR_INT;
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if (((((((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))&&((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(1)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LI
            var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            // assign expression to variable LTT
            var_LTT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LTT_read = true;
            validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
            aux_last_type_read_for_LTT = SCALAR_INT;
            // assign expression to variable NK
            var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
            // assign expression to variable NI
            var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NI_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              cpp_template = "[ MAT , 14 , MT / EG , ES , 0 , 0 , 0 , 0 ] CONT";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read CONT record
              // assign expression to variable EG
              var_EG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts));
              validate_vartype_consistency("EG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EG);
              aux_last_type_read_for_EG = NESTEDVECTOR_DOUBLE;
              // assign expression to variable ES
              var_ES_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
              validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
              aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
            }

            for (int var_k_0d_int_Scalar = (var_NI_0d_int_Scalar+1);
               var_k_0d_int_Scalar <= (var_NI_0d_int_Scalar+(var_NK_0d_int_Scalar-var_NI_0d_int_Scalar)); var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              cpp_template = "[ MAT , 14 , MT / EG , ES , 0 , 0 , NR , NE / E ] TAB2 ( E_interpol [ k ] )";
              // read TAB2 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              if ((! var_EG_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
                // assign expression to variable EG
                var_EG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts));
                validate_vartype_consistency("EG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EG);
                aux_last_type_read_for_EG = NESTEDVECTOR_DOUBLE;
              } else {
                cpp_validate_field(var_EG_1d_double_NestedVector[var_k_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "EG",
                  cpp_template, cpp_line, parse_opts);
              }
              if ((! var_ES_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
                // assign expression to variable ES
                var_ES_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
              } else {
                cpp_validate_field(var_ES_1d_double_NestedVector[var_k_0d_int_Scalar], cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "ES",
                  cpp_template, cpp_line, parse_opts);
              }
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NE
              var_NE_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
              validate_vartype_consistency("NE", NESTEDVECTOR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = NESTEDVECTOR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.setdefault("E_interpol", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                // variable declarations
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                  cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                }
                if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                  cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                }
                cpp_current_dict = cpp_parent_dict;
              }
              ptr_E_2d_idx0 = var_E_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
              ptr_a_3d_idx0 = var_a_3d_double_NestedVector.prepare(var_k_0d_int_Scalar);

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NE_1d_int_NestedVector[var_k_0d_int_Scalar]; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                cpp_template = "[ MAT , 14 , MT / 0.0 , E , 0 , 0 , NL , 0 / \n { a } { m = 1 to NL } ] LIST";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST record
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable E
                ptr_E_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable NL
                ptr_NL_2d_idx0 = var_NL_2d_int_NestedVector.prepare(var_k_0d_int_Scalar);
                ptr_NL_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
                validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = NESTEDVECTOR_INT;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST body
                  ptr_a_3d_idx1 = ptr_a_3d_idx0->prepare(var_l_0d_int_Scalar);

                  for (int var_m_0d_int_Scalar = 1;
                     var_m_0d_int_Scalar <= var_NL_2d_int_NestedVector[var_k_0d_int_Scalar][var_l_0d_int_Scalar]; var_m_0d_int_Scalar++) {
                    bool aux_m_read = true;
                    // read LIST body
                    // assign expression to variable a
                    ptr_a_3d_idx1->set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                    validate_vartype_consistency("a", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_a);
                    aux_last_type_read_for_a = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      cpp_j = 0;
                    }
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
              }
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
            int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
            bool& glob_aux_LI_read = aux_LI_read;
            bool aux_LI_read = glob_aux_LI_read;
            vartype aux_last_type_read_for_LI = UNKNOWN;
            int& glob_var_LTT_0d_int_Scalar = var_LTT_0d_int_Scalar;
            int var_LTT_0d_int_Scalar = glob_var_LTT_0d_int_Scalar;
            bool& glob_aux_LTT_read = aux_LTT_read;
            bool aux_LTT_read = glob_aux_LTT_read;
            vartype aux_last_type_read_for_LTT = UNKNOWN;
            int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
            int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
            bool& glob_aux_NK_read = aux_NK_read;
            bool aux_NK_read = glob_aux_NK_read;
            vartype aux_last_type_read_for_NK = UNKNOWN;
            int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
            int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
            bool& glob_aux_NI_read = aux_NI_read;
            bool aux_NI_read = glob_aux_NI_read;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            try {
              cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
              cpp_line = cpp_read_raw_line(cont);
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LI
              var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LI_read = true;
              validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
              aux_last_type_read_for_LI = SCALAR_INT;
              // assign expression to variable LTT
              var_LTT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LTT_read = true;
              validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
              aux_last_type_read_for_LTT = SCALAR_INT;
              // assign expression to variable NK
              var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_NK_read = true;
              validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
              aux_last_type_read_for_NK = SCALAR_INT;
              // assign expression to variable NI
              var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NI_read = true;
              validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
              aux_last_type_read_for_NI = SCALAR_INT;
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if (((((((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))&&((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(2)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LI
            var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            // assign expression to variable LTT
            var_LTT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LTT_read = true;
            validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
            aux_last_type_read_for_LTT = SCALAR_INT;
            // assign expression to variable NK
            var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
            // assign expression to variable NI
            var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
            throw std::runtime_error("Encountered STOP instruction in recipe: Case LI=0, LTT=2 not implemented in ENDF recipe for MF14");
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LI == SCALAR_INT) && (aux_LI_read == true))) {
    cpp_current_dict["LI"] = var_LI_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NK == SCALAR_INT) && (aux_NK_read == true))) {
    cpp_current_dict["NK"] = var_NK_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LTT == SCALAR_INT) && (aux_LTT_read == true))) {
    cpp_current_dict["LTT"] = var_LTT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NI == SCALAR_INT) && (aux_NI_read == true))) {
    cpp_current_dict["NI"] = var_NI_0d_int_Scalar;
  }
  if ((var_EG_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["EG"] = var_EG_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_ES_1d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["ES"] = var_ES_1d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_NE_1d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["NE"] = var_NE_1d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_E_2d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["E"] = var_E_2d_double_NestedVector.to_pyobj(list_mode);
  }
  if ((var_NL_2d_int_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["NL"] = var_NL_2d_int_NestedVector.to_pyobj(list_mode);
  }
  if ((var_a_3d_double_NestedVector.get_last_index() != -1)) {
    cpp_current_dict["a"] = var_a_3d_double_NestedVector.to_pyobj(list_mode);
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: d686a05ea85d12021bed42716983796f
// MD5 hash of the following function definition: d5edc980b83a5b7d67d80a69ed2b13f2
py::dict parse_mf15_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 15;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 15;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 15 , MT / ZA , AWR , 0 , 0 , NC , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NC
  var_NC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NC_read = true;
  validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
  aux_last_type_read_for_NC = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_j_0d_int_Scalar = 1;
     var_j_0d_int_Scalar <= var_NC_0d_int_Scalar; var_j_0d_int_Scalar++) {
    bool aux_j_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.setdefault("subsection", std::vector<int>({var_j_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      int var_LF_0d_int_Scalar;
      bool aux_LF_read = false;
      vartype aux_last_type_read_for_LF = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            std::streampos cpp_old_streampos = cont.tellg();
            {
              // variable declarations
              int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
              int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
              bool& glob_aux_LF_read = aux_LF_read;
              bool aux_LF_read = glob_aux_LF_read;
              vartype aux_last_type_read_for_LF = UNKNOWN;
              try {
                cpp_template = "[ MAT , 15 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / Eint / p ] TAB1 ( rtfm_tab1 )";
                // read TAB1 record
                cpp_line = cpp_read_raw_line(cont);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
              } catch (const std::out_of_range& e) {
                // // accept failure in lookahead
              }
              if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(1)))))))) {
                cpp_found_match = true;
              }
              cont.seekg(cpp_old_streampos);
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 15 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / Eint / p ] TAB1 ( rtfm_tab1 )";
              // read TAB1 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable LF
              var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LF_read = true;
              validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
              aux_last_type_read_for_LF = SCALAR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.setdefault("rtfm_tab1", std::vector<int>({}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                // variable declarations
                std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
                bool aux_Eint_read = false;
                vartype aux_last_type_read_for_Eint = UNKNOWN;
                std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
                bool aux_p_read = false;
                vartype aux_last_type_read_for_p = UNKNOWN;
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
                  cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
                }
                if (((aux_last_type_read_for_p == SCALAR_FLOATVEC) && (aux_p_read == true))) {
                  cpp_current_dict["p"] = var_p_0d_floatvec_Scalar;
                }
                if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                  cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                }
                if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                  cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                }
                cpp_current_dict = cpp_parent_dict;
              }
              cpp_template = "[ MAT , 15 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
              // read TAB2 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              {
                Tab2Body tab_body = read_tab2_body(cont, cpp_nr_val, mat, mf, mt, parse_opts);
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }

              for (int var_k_0d_int_Scalar = 1;
                 var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                bool aux_k_read = true;
                cpp_template = "[ MAT , 15 , MT / 0.0 , E , 0 , 0 , NR , NP / Egamma / g ] TAB1 ( rtfm1_tab [ k ] )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.setdefault("rtfm1_tab", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_Egamma_0d_floatvec_Scalar;
                  bool aux_Egamma_read = false;
                  vartype aux_last_type_read_for_Egamma = UNKNOWN;
                  std::vector<EndfFloatCpp> var_g_0d_floatvec_Scalar;
                  bool aux_g_read = false;
                  vartype aux_last_type_read_for_g = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable Egamma
                    var_Egamma_0d_floatvec_Scalar = tab_body.X;
                    aux_Egamma_read = true;
                    validate_vartype_consistency("Egamma", SCALAR_FLOATVEC, aux_last_type_read_for_Egamma);
                    aux_last_type_read_for_Egamma = SCALAR_FLOATVEC;
                    // assign expression to variable g
                    var_g_0d_floatvec_Scalar = tab_body.Y;
                    aux_g_read = true;
                    validate_vartype_consistency("g", SCALAR_FLOATVEC, aux_last_type_read_for_g);
                    aux_last_type_read_for_g = SCALAR_FLOATVEC;
                    if ((! (aux_INT_read == true))) {
                      // assign expression to variable INT
                      var_INT_0d_intvec_Scalar = tab_body.INT;
                      aux_INT_read = true;
                      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                      aux_last_type_read_for_INT = SCALAR_INTVEC;
                    } else {
                      cpp_validate_field(var_INT_0d_intvec_Scalar, tab_body.INT,  true, false, false, "INT",
                        cpp_template, cpp_line, parse_opts);
                    }
                    if ((! (aux_NBT_read == true))) {
                      // assign expression to variable NBT
                      var_NBT_0d_intvec_Scalar = tab_body.NBT;
                      aux_NBT_read = true;
                      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                      aux_last_type_read_for_NBT = SCALAR_INTVEC;
                    } else {
                      cpp_validate_field(var_NBT_0d_intvec_Scalar, tab_body.NBT,  true, false, false, "NBT",
                        cpp_template, cpp_line, parse_opts);
                    }
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_Egamma == SCALAR_FLOATVEC) && (aux_Egamma_read == true))) {
                    cpp_current_dict["Egamma"] = var_Egamma_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_g == SCALAR_FLOATVEC) && (aux_g_read == true))) {
                    cpp_current_dict["g"] = var_g_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_LF == SCALAR_INT) && (aux_LF_read == true))) {
        cpp_current_dict["LF"] = var_LF_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
        cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
    cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 5557baba7f951e2762c63f317ba874b9
// MD5 hash of the following function definition: 5917ac9aa27324e77397b2fecb83b1f9
py::dict parse_mf23_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  EndfFloatCpp var_EPE_0d_double_Scalar;
  bool aux_EPE_read = false;
  vartype aux_last_type_read_for_EPE = UNKNOWN;
  EndfFloatCpp var_EFL_0d_double_Scalar;
  bool aux_EFL_read = false;
  vartype aux_last_type_read_for_EFL = UNKNOWN;
  std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<EndfFloatCpp> var_sigma_0d_floatvec_Scalar;
  bool aux_sigma_read = false;
  vartype aux_last_type_read_for_sigma = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 23;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 23;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 23 , MT / ZA , AWR , 0 , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_template = "[ MAT , 23 , MT / EPE , EFL , 0 , 0 , NR , NP / Eint / sigma ] TAB1";
  // read TAB1 record
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // assign expression to variable EPE
  var_EPE_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_EPE_read = true;
  validate_vartype_consistency("EPE", SCALAR_DOUBLE, aux_last_type_read_for_EPE);
  aux_last_type_read_for_EPE = SCALAR_DOUBLE;
  // assign expression to variable EFL
  var_EFL_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_EFL_read = true;
  validate_vartype_consistency("EFL", SCALAR_DOUBLE, aux_last_type_read_for_EFL);
  aux_last_type_read_for_EFL = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  {
    Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
    // assign expression to variable Eint
    var_Eint_0d_floatvec_Scalar = tab_body.X;
    aux_Eint_read = true;
    validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
    aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
    // assign expression to variable sigma
    var_sigma_0d_floatvec_Scalar = tab_body.Y;
    aux_sigma_read = true;
    validate_vartype_consistency("sigma", SCALAR_FLOATVEC, aux_last_type_read_for_sigma);
    aux_last_type_read_for_sigma = SCALAR_FLOATVEC;
    // assign expression to variable INT
    var_INT_0d_intvec_Scalar = tab_body.INT;
    aux_INT_read = true;
    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
    aux_last_type_read_for_INT = SCALAR_INTVEC;
    // assign expression to variable NBT
    var_NBT_0d_intvec_Scalar = tab_body.NBT;
    aux_NBT_read = true;
    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
    aux_last_type_read_for_NBT = SCALAR_INTVEC;
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_EPE == SCALAR_DOUBLE) && (aux_EPE_read == true))) {
    cpp_current_dict["EPE"] = var_EPE_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_EFL == SCALAR_DOUBLE) && (aux_EFL_read == true))) {
    cpp_current_dict["EFL"] = var_EFL_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
    cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_sigma == SCALAR_FLOATVEC) && (aux_sigma_read == true))) {
    cpp_current_dict["sigma"] = var_sigma_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 3f70d967823f46b1bb1f3b072c33eced
// MD5 hash of the following function definition: aa2cbda75d8969dc37b3c7214711ed6f
py::dict parse_mf26_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 26;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 26;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  throw std::runtime_error("Encountered STOP instruction in recipe: ENDF recipe for MF26 is not implemented");
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 20ce9f620fd87cc4c048529da1906a0e
// MD5 hash of the following function definition: 68c472e445702dd36be08418f21cfe4d
py::dict parse_mf27_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  EndfFloatCpp var_Z_0d_double_Scalar;
  bool aux_Z_read = false;
  vartype aux_last_type_read_for_Z = UNKNOWN;
  std::vector<EndfFloatCpp> var_xint_0d_floatvec_Scalar;
  bool aux_xint_read = false;
  vartype aux_last_type_read_for_xint = UNKNOWN;
  std::vector<EndfFloatCpp> var_H_0d_floatvec_Scalar;
  bool aux_H_read = false;
  vartype aux_last_type_read_for_H = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 27;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 27;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 27 , MT / ZA , AWR , 0 , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_template = "[ MAT , 27 , MT / 0.0 , Z , 0 , 0 , NR , NP / xint / H ] TAB1";
  // read TAB1 record
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable Z
  var_Z_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_Z_read = true;
  validate_vartype_consistency("Z", SCALAR_DOUBLE, aux_last_type_read_for_Z);
  aux_last_type_read_for_Z = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  {
    Tab1Body tab_body = read_tab1_body(cont, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
    // assign expression to variable xint
    var_xint_0d_floatvec_Scalar = tab_body.X;
    aux_xint_read = true;
    validate_vartype_consistency("xint", SCALAR_FLOATVEC, aux_last_type_read_for_xint);
    aux_last_type_read_for_xint = SCALAR_FLOATVEC;
    // assign expression to variable H
    var_H_0d_floatvec_Scalar = tab_body.Y;
    aux_H_read = true;
    validate_vartype_consistency("H", SCALAR_FLOATVEC, aux_last_type_read_for_H);
    aux_last_type_read_for_H = SCALAR_FLOATVEC;
    // assign expression to variable INT
    var_INT_0d_intvec_Scalar = tab_body.INT;
    aux_INT_read = true;
    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
    aux_last_type_read_for_INT = SCALAR_INTVEC;
    // assign expression to variable NBT
    var_NBT_0d_intvec_Scalar = tab_body.NBT;
    aux_NBT_read = true;
    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
    aux_last_type_read_for_NBT = SCALAR_INTVEC;
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_Z == SCALAR_DOUBLE) && (aux_Z_read == true))) {
    cpp_current_dict["Z"] = var_Z_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_xint == SCALAR_FLOATVEC) && (aux_xint_read == true))) {
    cpp_current_dict["xint"] = var_xint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_H == SCALAR_FLOATVEC) && (aux_H_read == true))) {
    cpp_current_dict["H"] = var_H_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 04f3c92d2aa669d9b265ca0bc15b6e1f
// MD5 hash of the following function definition: 90c6fdbf47d025a42499a9e50ab9625f
py::dict parse_mf28_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 28;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 28;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  throw std::runtime_error("Encountered STOP instruction in recipe: ENDF recipe for MF28 not implemented");
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 485a4917898fb80f8e6522571893a9e5
// MD5 hash of the following function definition: ad923ec849b9239baa617be2e3c5cea5
py::dict parse_mf31_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_MTL_0d_int_Scalar;
  bool aux_MTL_read = false;
  vartype aux_last_type_read_for_MTL = UNKNOWN;
  int var_NL_0d_int_Scalar;
  bool aux_NL_read = false;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 31;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 31;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 31 , MT / ZA , AWR , 0 , MTL , 0 , NL ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable MTL
  var_MTL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_MTL_read = true;
  validate_vartype_consistency("MTL", SCALAR_INT, aux_last_type_read_for_MTL);
  aux_last_type_read_for_MTL = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NL
  var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NL_read = true;
  validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
  aux_last_type_read_for_NL = SCALAR_INT;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_MTL_read == true)) && ((var_MTL_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;

        for (int var_n_0d_int_Scalar = 1;
           var_n_0d_int_Scalar <= var_NL_0d_int_Scalar; var_n_0d_int_Scalar++) {
          bool aux_n_read = true;
          // open section subsection
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.setdefault("subsection", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            // variable declarations
            EndfFloatCpp var_XMF1_0d_double_Scalar;
            bool aux_XMF1_read = false;
            vartype aux_last_type_read_for_XMF1 = UNKNOWN;
            EndfFloatCpp var_XLFS1_0d_double_Scalar;
            bool aux_XLFS1_read = false;
            vartype aux_last_type_read_for_XLFS1 = UNKNOWN;
            int var_MAT1_0d_int_Scalar;
            bool aux_MAT1_read = false;
            vartype aux_last_type_read_for_MAT1 = UNKNOWN;
            int var_MT1_0d_int_Scalar;
            bool aux_MT1_read = false;
            vartype aux_last_type_read_for_MT1 = UNKNOWN;
            int var_NC_0d_int_Scalar;
            bool aux_NC_read = false;
            vartype aux_last_type_read_for_NC = UNKNOWN;
            int var_NI_0d_int_Scalar;
            bool aux_NI_read = false;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            cpp_template = "[ MAT , 31 , MT / XMF1 , XLFS1 , MAT1 , MT1 , NC , NI ] CONT";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable XMF1
            var_XMF1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_XMF1_read = true;
            validate_vartype_consistency("XMF1", SCALAR_DOUBLE, aux_last_type_read_for_XMF1);
            aux_last_type_read_for_XMF1 = SCALAR_DOUBLE;
            // assign expression to variable XLFS1
            var_XLFS1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_XLFS1_read = true;
            validate_vartype_consistency("XLFS1", SCALAR_DOUBLE, aux_last_type_read_for_XLFS1);
            aux_last_type_read_for_XLFS1 = SCALAR_DOUBLE;
            // assign expression to variable MAT1
            var_MAT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_MAT1_read = true;
            validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
            aux_last_type_read_for_MAT1 = SCALAR_INT;
            // assign expression to variable MT1
            var_MT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_MT1_read = true;
            validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
            aux_last_type_read_for_MT1 = SCALAR_INT;
            // assign expression to variable NC
            var_NC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NC_read = true;
            validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
            aux_last_type_read_for_NC = SCALAR_INT;
            // assign expression to variable NI
            var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NC_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section nc_subsection
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.setdefault("nc_subsection", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                // variable declarations
                int var_LTY_0d_int_Scalar;
                bool aux_LTY_read = false;
                vartype aux_last_type_read_for_LTY = UNKNOWN;
                EndfFloatCpp var_E1_0d_double_Scalar;
                bool aux_E1_read = false;
                vartype aux_last_type_read_for_E1 = UNKNOWN;
                EndfFloatCpp var_E2_0d_double_Scalar;
                bool aux_E2_read = false;
                vartype aux_last_type_read_for_E2 = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NCI_0d_int_Scalar;
                bool aux_NCI_read = false;
                vartype aux_last_type_read_for_NCI = UNKNOWN;
                NestedVector<EndfFloatCpp> var_C_1d_double_NestedVector;
                vartype aux_last_type_read_for_C = UNKNOWN;
                NestedVector<EndfFloatCpp> var_XMT_1d_double_NestedVector;
                vartype aux_last_type_read_for_XMT = UNKNOWN;
                int var_MATS_0d_int_Scalar;
                bool aux_MATS_read = false;
                vartype aux_last_type_read_for_MATS = UNKNOWN;
                int var_MTS_0d_int_Scalar;
                bool aux_MTS_read = false;
                vartype aux_last_type_read_for_MTS = UNKNOWN;
                int var_NEI_0d_int_Scalar;
                bool aux_NEI_read = false;
                vartype aux_last_type_read_for_NEI = UNKNOWN;
                EndfFloatCpp var_XMFS_0d_double_Scalar;
                bool aux_XMFS_read = false;
                vartype aux_last_type_read_for_XMFS = UNKNOWN;
                EndfFloatCpp var_XLFSS_0d_double_Scalar;
                bool aux_XLFSS_read = false;
                vartype aux_last_type_read_for_XLFSS = UNKNOWN;
                NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                NestedVector<EndfFloatCpp> var_WE_1d_double_NestedVector;
                vartype aux_last_type_read_for_WE = UNKNOWN;
                cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read CONT record
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LTY
                var_LTY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LTY_read = true;
                validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                aux_last_type_read_for_LTY = SCALAR_INT;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if ((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(0)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      cpp_template = "[ MAT , 31 , MT / E1 , E2 , 0 , 0 , (2*NCI) , NCI / \n { C , XMT } { i = 1 to NCI } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      // assign expression to variable E1
                      var_E1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                      aux_E1_read = true;
                      validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                      aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                      // assign expression to variable E2
                      var_E2_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                      aux_E2_read = true;
                      validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                      aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NCI
                      var_NCI_0d_int_Scalar = (cpp_int_val/2);
                      aux_NCI_read = true;
                      validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                      aux_last_type_read_for_NCI = SCALAR_INT;
                      if ((! (aux_NCI_read == true))) {
                        // assign expression to variable NCI
                        var_NCI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NCI_read = true;
                        validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                        aux_last_type_read_for_NCI = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NCI_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NCI",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_i_0d_int_Scalar = 1;
                           var_i_0d_int_Scalar <= var_NCI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                          bool aux_i_read = true;
                          // read LIST body
                          // assign expression to variable C
                          var_C_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
                          aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable XMT
                          var_XMT_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("XMT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_XMT);
                          aux_last_type_read_for_XMT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if (((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)>=(1)))))&&((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)<=(3)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 31 , MT / E1 , E2 , MATS , MTS , ((2*NEI)+2) , NEI / \n XMFS , XLFSS , { E , WE } { i = 1 to NEI } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        // assign expression to variable E1
                        var_E1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                        aux_E1_read = true;
                        validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                        aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                        // assign expression to variable E2
                        var_E2_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                        aux_E2_read = true;
                        validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                        aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                        // assign expression to variable MATS
                        var_MATS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_MATS_read = true;
                        validate_vartype_consistency("MATS", SCALAR_INT, aux_last_type_read_for_MATS);
                        aux_last_type_read_for_MATS = SCALAR_INT;
                        // assign expression to variable MTS
                        var_MTS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_MTS_read = true;
                        validate_vartype_consistency("MTS", SCALAR_INT, aux_last_type_read_for_MTS);
                        aux_last_type_read_for_MTS = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NEI
                        var_NEI_0d_int_Scalar = ((cpp_int_val+(-2))/2);
                        aux_NEI_read = true;
                        validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                        aux_last_type_read_for_NEI = SCALAR_INT;
                        if ((! (aux_NEI_read == true))) {
                          // assign expression to variable NEI
                          var_NEI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NEI_read = true;
                          validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                          aux_last_type_read_for_NEI = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NEI_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NEI",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body
                          // assign expression to variable XMFS
                          var_XMFS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                          aux_XMFS_read = true;
                          validate_vartype_consistency("XMFS", SCALAR_DOUBLE, aux_last_type_read_for_XMFS);
                          aux_last_type_read_for_XMFS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable XLFSS
                          var_XLFSS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                          aux_XLFSS_read = true;
                          validate_vartype_consistency("XLFSS", SCALAR_DOUBLE, aux_last_type_read_for_XLFSS);
                          aux_last_type_read_for_XLFSS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }

                          for (int var_i_0d_int_Scalar = 1;
                             var_i_0d_int_Scalar <= var_NEI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                            bool aux_i_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable WE
                            var_WE_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("WE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_WE);
                            aux_last_type_read_for_WE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_LTY == SCALAR_INT) && (aux_LTY_read == true))) {
                  cpp_current_dict["LTY"] = var_LTY_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_E1 == SCALAR_DOUBLE) && (aux_E1_read == true))) {
                  cpp_current_dict["E1"] = var_E1_0d_double_Scalar;
                }
                if (((aux_last_type_read_for_E2 == SCALAR_DOUBLE) && (aux_E2_read == true))) {
                  cpp_current_dict["E2"] = var_E2_0d_double_Scalar;
                }
                if (((aux_last_type_read_for_NCI == SCALAR_INT) && (aux_NCI_read == true))) {
                  cpp_current_dict["NCI"] = var_NCI_0d_int_Scalar;
                }
                if ((var_C_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["C"] = var_C_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_XMT_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["XMT"] = var_XMT_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if (((aux_last_type_read_for_MATS == SCALAR_INT) && (aux_MATS_read == true))) {
                  cpp_current_dict["MATS"] = var_MATS_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_MTS == SCALAR_INT) && (aux_MTS_read == true))) {
                  cpp_current_dict["MTS"] = var_MTS_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NEI == SCALAR_INT) && (aux_NEI_read == true))) {
                  cpp_current_dict["NEI"] = var_NEI_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_XMFS == SCALAR_DOUBLE) && (aux_XMFS_read == true))) {
                  cpp_current_dict["XMFS"] = var_XMFS_0d_double_Scalar;
                }
                if (((aux_last_type_read_for_XLFSS == SCALAR_DOUBLE) && (aux_XLFSS_read == true))) {
                  cpp_current_dict["XLFSS"] = var_XLFSS_0d_double_Scalar;
                }
                if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_WE_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["WE"] = var_WE_1d_double_NestedVector.to_pyobj(list_mode);
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NI_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section ni_subsection
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.setdefault("ni_subsection", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                // variable declarations
                int var_LT_0d_int_Scalar;
                bool aux_LT_read = false;
                vartype aux_last_type_read_for_LT = UNKNOWN;
                int var_LB_0d_int_Scalar;
                bool aux_LB_read = false;
                vartype aux_last_type_read_for_LB = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NP_0d_int_Scalar;
                bool aux_NP_read = false;
                vartype aux_last_type_read_for_NP = UNKNOWN;
                NestedVector<EndfFloatCpp> var_Ek_1d_double_NestedVector;
                vartype aux_last_type_read_for_Ek = UNKNOWN;
                NestedVector<EndfFloatCpp> var_Fk_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fk = UNKNOWN;
                NestedVector<EndfFloatCpp> var_El_1d_double_NestedVector;
                vartype aux_last_type_read_for_El = UNKNOWN;
                NestedVector<EndfFloatCpp> var_Fl_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fl = UNKNOWN;
                int var_LS_0d_int_Scalar;
                bool aux_LS_read = false;
                vartype aux_last_type_read_for_LS = UNKNOWN;
                int var_NE_0d_int_Scalar;
                bool aux_NE_read = false;
                vartype aux_last_type_read_for_NE = UNKNOWN;
                NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                Matrix2d<EndfFloatCpp> var_F_2d_double_Matrix2d;
                vartype aux_last_type_read_for_F = UNKNOWN;
                int var_NER_0d_int_Scalar;
                bool aux_NER_read = false;
                vartype aux_last_type_read_for_NER = UNKNOWN;
                int var_NEC_0d_int_Scalar;
                bool aux_NEC_read = false;
                vartype aux_last_type_read_for_NEC = UNKNOWN;
                NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                vartype aux_last_type_read_for_ER = UNKNOWN;
                NestedVector<EndfFloatCpp> var_EC_1d_double_NestedVector;
                vartype aux_last_type_read_for_EC = UNKNOWN;
                NestedVector<EndfFloatCpp> var_F_1d_double_NestedVector;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                        int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                        bool& glob_aux_LT_read = aux_LT_read;
                        bool aux_LT_read = glob_aux_LT_read;
                        vartype aux_last_type_read_for_LT = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_cpp_int_val = cpp_int_val;
                        int cpp_int_val = glob_cpp_int_val;
                        bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                        bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                        int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                        bool& glob_aux_NP_read = aux_NP_read;
                        bool aux_NP_read = glob_aux_NP_read;
                        vartype aux_last_type_read_for_NP = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)>=(0)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)<=(4)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NP",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= (var_NP_0d_int_Scalar-var_LT_0d_int_Scalar); var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable Ek
                            var_Ek_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Ek", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ek);
                            aux_last_type_read_for_Ek = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable Fk
                            var_Fk_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Fk", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fk);
                            aux_last_type_read_for_Fk = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_LT_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable El
                            var_El_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("El", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_El);
                            aux_last_type_read_for_El = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable Fl
                            var_Fl_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Fl", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fl);
                            aux_last_type_read_for_Fl = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                            cpp_line = cpp_read_raw_line(cont);
                            // read LIST record
                            // assign expression to variable LS
                            var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_LS_read = true;
                            validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                            aux_last_type_read_for_LS = SCALAR_INT;
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable NE
                            var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NE_read = true;
                            validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                            aux_last_type_read_for_NE = SCALAR_INT;
                            if ((! (aux_NE_read == true))) {
                              throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE-1))+1) , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                            cpp_validate_field(((var_NE_0d_int_Scalar*(var_NE_0d_int_Scalar-1))+1), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((NE*(NE-1))+1)",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = 1;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                            cpp_line = cpp_read_raw_line(cont);
                            // read LIST record
                            // assign expression to variable LS
                            var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_LS_read = true;
                            validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                            aux_last_type_read_for_LS = SCALAR_INT;
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable NE
                            var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NE_read = true;
                            validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                            aux_last_type_read_for_NE = SCALAR_INT;
                            if ((! (aux_NE_read == true))) {
                              throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE+1))/2) , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                            cpp_validate_field(((var_NE_0d_int_Scalar*(var_NE_0d_int_Scalar+1))/2), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((NE*(NE+1))/2)",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = var_k_0d_int_Scalar;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NER_0d_int_Scalar = var_NER_0d_int_Scalar;
                          int var_NER_0d_int_Scalar = glob_var_NER_0d_int_Scalar;
                          bool& glob_aux_NER_read = aux_NER_read;
                          bool aux_NER_read = glob_aux_NER_read;
                          vartype aux_last_type_read_for_NER = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NEC_0d_int_Scalar = var_NEC_0d_int_Scalar;
                          int var_NEC_0d_int_Scalar = glob_var_NEC_0d_int_Scalar;
                          bool& glob_aux_NEC_read = aux_NEC_read;
                          bool aux_NEC_read = glob_aux_NEC_read;
                          vartype aux_last_type_read_for_NEC = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                            cpp_line = cpp_read_raw_line(cont);
                            // read LIST record
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NEC
                            var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                            aux_NEC_read = true;
                            validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                            aux_last_type_read_for_NEC = SCALAR_INT;
                            if ((! (aux_NER_read == true))) {
                              // assign expression to variable cpp_int_val
                              cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_cpp_int_val_read = true;
                              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                              // assign expression to variable NER
                              var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                              aux_NER_read = true;
                              validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                              aux_last_type_read_for_NER = SCALAR_INT;
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if ((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(6)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , 0 , LB , (1+(NER*NEC)) , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NEC
                          var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                          aux_NEC_read = true;
                          validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                          aux_last_type_read_for_NEC = SCALAR_INT;
                          if ((! (aux_NER_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                          } else {
                            cpp_validate_field((1+(var_NER_0d_int_Scalar*var_NEC_0d_int_Scalar)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(1+(NER*NEC))",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NER_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable ER
                              var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                              aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NEC_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable EC
                              var_EC_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("EC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EC);
                              aux_last_type_read_for_EC = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NER_0d_int_Scalar-1), 1, (var_NEC_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NER_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_l_0d_int_Scalar = 1;
                                 var_l_0d_int_Scalar <= (var_NEC_0d_int_Scalar-1); var_l_0d_int_Scalar++) {
                                bool aux_l_read = true;
                                // read LIST body
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_l_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                          int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                          bool& glob_aux_LT_read = aux_LT_read;
                          bool aux_LT_read = glob_aux_LT_read;
                          vartype aux_last_type_read_for_LT = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                          int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                          bool& glob_aux_NP_read = aux_NP_read;
                          bool aux_NP_read = glob_aux_NP_read;
                          vartype aux_last_type_read_for_NP = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                            cpp_line = cpp_read_raw_line(cont);
                            // read LIST record
                            // assign expression to variable LT
                            var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_LT_read = true;
                            validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                            aux_last_type_read_for_LT = SCALAR_INT;
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = (cpp_int_val/2);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                            if ((! (aux_NP_read == true))) {
                              // assign expression to variable NP
                              var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              aux_NP_read = true;
                              validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                              aux_last_type_read_for_NP = SCALAR_INT;
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if ((((((((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(8))))))||(((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(9)))))))))&&((((aux_LT_read == true)) && ((var_LT_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                            cpp_validate_field(var_NP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NP",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable F
                              var_F_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_LT == SCALAR_INT) && (aux_LT_read == true))) {
                  cpp_current_dict["LT"] = var_LT_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_LB == SCALAR_INT) && (aux_LB_read == true))) {
                  cpp_current_dict["LB"] = var_LB_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NP == SCALAR_INT) && (aux_NP_read == true))) {
                  cpp_current_dict["NP"] = var_NP_0d_int_Scalar;
                }
                if ((var_Ek_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["Ek"] = var_Ek_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_Fk_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["Fk"] = var_Fk_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_El_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["El"] = var_El_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_Fl_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["Fl"] = var_Fl_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if (((aux_last_type_read_for_LS == SCALAR_INT) && (aux_LS_read == true))) {
                  cpp_current_dict["LS"] = var_LS_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
                  cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
                }
                if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if (var_F_2d_double_Matrix2d.did_read()) {
                  cpp_current_dict["F"] = var_F_2d_double_Matrix2d.to_pyobj(list_mode);
                }
                if (((aux_last_type_read_for_NER == SCALAR_INT) && (aux_NER_read == true))) {
                  cpp_current_dict["NER"] = var_NER_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NEC == SCALAR_INT) && (aux_NEC_read == true))) {
                  cpp_current_dict["NEC"] = var_NEC_0d_int_Scalar;
                }
                if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["ER"] = var_ER_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_EC_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["EC"] = var_EC_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_F_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["F"] = var_F_1d_double_NestedVector.to_pyobj(list_mode);
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_XMF1 == SCALAR_DOUBLE) && (aux_XMF1_read == true))) {
              cpp_current_dict["XMF1"] = var_XMF1_0d_double_Scalar;
            }
            if (((aux_last_type_read_for_XLFS1 == SCALAR_DOUBLE) && (aux_XLFS1_read == true))) {
              cpp_current_dict["XLFS1"] = var_XLFS1_0d_double_Scalar;
            }
            if (((aux_last_type_read_for_MAT1 == SCALAR_INT) && (aux_MAT1_read == true))) {
              cpp_current_dict["MAT1"] = var_MAT1_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_MT1 == SCALAR_INT) && (aux_MT1_read == true))) {
              cpp_current_dict["MT1"] = var_MT1_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
              cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_NI == SCALAR_INT) && (aux_NI_read == true))) {
              cpp_current_dict["NI"] = var_NI_0d_int_Scalar;
            }
            cpp_current_dict = cpp_parent_dict;
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_MTL == SCALAR_INT) && (aux_MTL_read == true))) {
    cpp_current_dict["MTL"] = var_MTL_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NL == SCALAR_INT) && (aux_NL_read == true))) {
    cpp_current_dict["NL"] = var_NL_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 89a763d6f809f216a36f99ade3a07a08
// MD5 hash of the following function definition: cb588930f85e79f1ccb87e5d67dad181
py::dict parse_mf32_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NIS_0d_int_Scalar;
  bool aux_NIS_read = false;
  vartype aux_last_type_read_for_NIS = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 32;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 32;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 32 , 151 / ZA , AWR , 0 , 0 , NIS , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NIS
  var_NIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NIS_read = true;
  validate_vartype_consistency("NIS", SCALAR_INT, aux_last_type_read_for_NIS);
  aux_last_type_read_for_NIS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NIS_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    // open section isotope
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.setdefault("isotope", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_ZAI_0d_double_Scalar;
      bool aux_ZAI_read = false;
      vartype aux_last_type_read_for_ZAI = UNKNOWN;
      EndfFloatCpp var_ABN_0d_double_Scalar;
      bool aux_ABN_read = false;
      vartype aux_last_type_read_for_ABN = UNKNOWN;
      int var_LFW_0d_int_Scalar;
      bool aux_LFW_read = false;
      vartype aux_last_type_read_for_LFW = UNKNOWN;
      int var_NER_0d_int_Scalar;
      bool aux_NER_read = false;
      vartype aux_last_type_read_for_NER = UNKNOWN;
      cpp_template = "[ MAT , 32 , 151 / ZAI , ABN , 0 , LFW , NER , 0 ] CONT";
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read CONT record
      // assign expression to variable ZAI
      var_ZAI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
      aux_ZAI_read = true;
      validate_vartype_consistency("ZAI", SCALAR_DOUBLE, aux_last_type_read_for_ZAI);
      aux_last_type_read_for_ZAI = SCALAR_DOUBLE;
      // assign expression to variable ABN
      var_ABN_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
      aux_ABN_read = true;
      validate_vartype_consistency("ABN", SCALAR_DOUBLE, aux_last_type_read_for_ABN);
      aux_last_type_read_for_ABN = SCALAR_DOUBLE;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
      // assign expression to variable LFW
      var_LFW_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LFW_read = true;
      validate_vartype_consistency("LFW", SCALAR_INT, aux_last_type_read_for_LFW);
      aux_last_type_read_for_LFW = SCALAR_INT;
      // assign expression to variable NER
      var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      aux_NER_read = true;
      validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
      aux_last_type_read_for_NER = SCALAR_INT;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);

      for (int var_j_0d_int_Scalar = 1;
         var_j_0d_int_Scalar <= var_NER_0d_int_Scalar; var_j_0d_int_Scalar++) {
        bool aux_j_read = true;
        // open section range
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.setdefault("range", std::vector<int>({var_j_0d_int_Scalar}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          // variable declarations
          EndfFloatCpp var_EL_0d_double_Scalar;
          bool aux_EL_read = false;
          vartype aux_last_type_read_for_EL = UNKNOWN;
          EndfFloatCpp var_EH_0d_double_Scalar;
          bool aux_EH_read = false;
          vartype aux_last_type_read_for_EH = UNKNOWN;
          int var_LRU_0d_int_Scalar;
          bool aux_LRU_read = false;
          vartype aux_last_type_read_for_LRU = UNKNOWN;
          int var_LRF_0d_int_Scalar;
          bool aux_LRF_read = false;
          vartype aux_last_type_read_for_LRF = UNKNOWN;
          int var_NRO_0d_int_Scalar;
          bool aux_NRO_read = false;
          vartype aux_last_type_read_for_NRO = UNKNOWN;
          int var_NAPS_0d_int_Scalar;
          bool aux_NAPS_read = false;
          vartype aux_last_type_read_for_NAPS = UNKNOWN;
          int var_NI_0d_int_Scalar;
          bool aux_NI_read = false;
          vartype aux_last_type_read_for_NI = UNKNOWN;
          EndfFloatCpp var_SPI_0d_double_Scalar;
          bool aux_SPI_read = false;
          vartype aux_last_type_read_for_SPI = UNKNOWN;
          EndfFloatCpp var_AP_0d_double_Scalar;
          bool aux_AP_read = false;
          vartype aux_last_type_read_for_AP = UNKNOWN;
          int var_LCOMP_0d_int_Scalar;
          bool aux_LCOMP_read = false;
          vartype aux_last_type_read_for_LCOMP = UNKNOWN;
          int var_NLS_0d_int_Scalar;
          bool aux_NLS_read = false;
          vartype aux_last_type_read_for_NLS = UNKNOWN;
          int var_ISR_0d_int_Scalar;
          bool aux_ISR_read = false;
          vartype aux_last_type_read_for_ISR = UNKNOWN;
          EndfFloatCpp var_DAP_0d_double_Scalar;
          bool aux_DAP_read = false;
          vartype aux_last_type_read_for_DAP = UNKNOWN;
          EndfFloatCpp var_AWRI_0d_double_Scalar;
          bool aux_AWRI_read = false;
          vartype aux_last_type_read_for_AWRI = UNKNOWN;
          int var_NSRS_0d_int_Scalar;
          bool aux_NSRS_read = false;
          vartype aux_last_type_read_for_NSRS = UNKNOWN;
          int var_NLRS_0d_int_Scalar;
          bool aux_NLRS_read = false;
          vartype aux_last_type_read_for_NLRS = UNKNOWN;
          int var_MLS_0d_int_Scalar;
          bool aux_MLS_read = false;
          vartype aux_last_type_read_for_MLS = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DAP_1d_double_NestedVector;
          int var_JCH_0d_int_Scalar;
          bool aux_JCH_read = false;
          vartype aux_last_type_read_for_JCH = UNKNOWN;
          int cpp_int_val;
          bool aux_cpp_int_val_read = false;
          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
          int var_NCH_0d_int_Scalar;
          bool aux_NCH_read = false;
          vartype aux_last_type_read_for_NCH = UNKNOWN;
          Matrix2d<EndfFloatCpp> var_DAP_2d_double_Matrix2d;
          EndfFloatCpp var_QX_0d_double_Scalar;
          bool aux_QX_read = false;
          vartype aux_last_type_read_for_QX = UNKNOWN;
          int var_LRX_0d_int_Scalar;
          bool aux_LRX_read = false;
          vartype aux_last_type_read_for_LRX = UNKNOWN;
          int var_NRSA_0d_int_Scalar;
          bool aux_NRSA_read = false;
          vartype aux_last_type_read_for_NRSA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
          vartype aux_last_type_read_for_ER = UNKNOWN;
          NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
          vartype aux_last_type_read_for_AJ = UNKNOWN;
          NestedVector<EndfFloatCpp> var_GT_1d_double_NestedVector;
          vartype aux_last_type_read_for_GT = UNKNOWN;
          NestedVector<EndfFloatCpp> var_GN_1d_double_NestedVector;
          vartype aux_last_type_read_for_GN = UNKNOWN;
          NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
          vartype aux_last_type_read_for_GG = UNKNOWN;
          NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
          vartype aux_last_type_read_for_GF = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DER_1d_double_NestedVector;
          vartype aux_last_type_read_for_DER = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DGN_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGN = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DGG_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGG = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DGF_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGF = UNKNOWN;
          int var_NDIGIT_0d_int_Scalar;
          bool aux_NDIGIT_read = false;
          vartype aux_last_type_read_for_NDIGIT = UNKNOWN;
          int var_NNN_0d_int_Scalar;
          bool aux_NNN_read = false;
          vartype aux_last_type_read_for_NNN = UNKNOWN;
          int var_NM_0d_int_Scalar;
          bool aux_NM_read = false;
          vartype aux_last_type_read_for_NM = UNKNOWN;
          NestedVector<int> var_II_1d_int_NestedVector;
          vartype aux_last_type_read_for_II = UNKNOWN;
          NestedVector<int> var_JJ_1d_int_NestedVector;
          vartype aux_last_type_read_for_JJ = UNKNOWN;
          NestedVector<std::vector<int>> var_KIJ_1d_intvec_NestedVector;
          vartype aux_last_type_read_for_KIJ = UNKNOWN;
          int var_LAD_0d_int_Scalar;
          bool aux_LAD_read = false;
          vartype aux_last_type_read_for_LAD = UNKNOWN;
          EndfFloatCpp var_APL_0d_double_Scalar;
          bool aux_APL_read = false;
          vartype aux_last_type_read_for_APL = UNKNOWN;
          NestedVector<EndfFloatCpp> var_GFA_1d_double_NestedVector;
          vartype aux_last_type_read_for_GFA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_GFB_1d_double_NestedVector;
          vartype aux_last_type_read_for_GFB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DGFA_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGFA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DGFB_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGFB = UNKNOWN;
          int var_IFG_0d_int_Scalar;
          bool aux_IFG_read = false;
          vartype aux_last_type_read_for_IFG = UNKNOWN;
          int var_NJS_0d_int_Scalar;
          bool aux_NJS_read = false;
          vartype aux_last_type_read_for_NJS = UNKNOWN;
          int var_NJCH_0d_int_Scalar;
          bool aux_NJCH_read = false;
          vartype aux_last_type_read_for_NJCH = UNKNOWN;
          int var_NPP_0d_int_Scalar;
          bool aux_NPP_read = false;
          vartype aux_last_type_read_for_NPP = UNKNOWN;
          int var_NJSX_0d_int_Scalar;
          bool aux_NJSX_read = false;
          vartype aux_last_type_read_for_NJSX = UNKNOWN;
          NestedVector<EndfFloatCpp> var_MA_1d_double_NestedVector;
          vartype aux_last_type_read_for_MA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_MB_1d_double_NestedVector;
          vartype aux_last_type_read_for_MB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_ZA_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_ZB_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_IA_1d_double_NestedVector;
          vartype aux_last_type_read_for_IA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_IB_1d_double_NestedVector;
          vartype aux_last_type_read_for_IB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_Q_1d_double_NestedVector;
          vartype aux_last_type_read_for_Q = UNKNOWN;
          NestedVector<EndfFloatCpp> var_PNT_1d_double_NestedVector;
          vartype aux_last_type_read_for_PNT = UNKNOWN;
          NestedVector<EndfFloatCpp> var_SHF_1d_double_NestedVector;
          vartype aux_last_type_read_for_SHF = UNKNOWN;
          NestedVector<EndfFloatCpp> var_MT_1d_double_NestedVector;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          NestedVector<EndfFloatCpp> var_PA_1d_double_NestedVector;
          vartype aux_last_type_read_for_PA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_PB_1d_double_NestedVector;
          vartype aux_last_type_read_for_PB = UNKNOWN;
          int var_MPAR_0d_int_Scalar;
          bool aux_MPAR_read = false;
          vartype aux_last_type_read_for_MPAR = UNKNOWN;
          int var_NPAR_0d_int_Scalar;
          bool aux_NPAR_read = false;
          vartype aux_last_type_read_for_NPAR = UNKNOWN;
          Matrix2d<EndfFloatCpp> var_RV_2d_double_Matrix2d;
          vartype aux_last_type_read_for_RV = UNKNOWN;
          cpp_template = "[ MAT , 32 , 151 / EL , EH , LRU , LRF , NRO , NAPS ] CONT";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable EL
          var_EL_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_EL_read = true;
          validate_vartype_consistency("EL", SCALAR_DOUBLE, aux_last_type_read_for_EL);
          aux_last_type_read_for_EL = SCALAR_DOUBLE;
          // assign expression to variable EH
          var_EH_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
          aux_EH_read = true;
          validate_vartype_consistency("EH", SCALAR_DOUBLE, aux_last_type_read_for_EH);
          aux_last_type_read_for_EH = SCALAR_DOUBLE;
          // assign expression to variable LRU
          var_LRU_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LRU_read = true;
          validate_vartype_consistency("LRU", SCALAR_INT, aux_last_type_read_for_LRU);
          aux_last_type_read_for_LRU = SCALAR_INT;
          // assign expression to variable LRF
          var_LRF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_LRF_read = true;
          validate_vartype_consistency("LRF", SCALAR_INT, aux_last_type_read_for_LRF);
          aux_last_type_read_for_LRF = SCALAR_INT;
          // assign expression to variable NRO
          var_NRO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NRO_read = true;
          validate_vartype_consistency("NRO", SCALAR_INT, aux_last_type_read_for_NRO);
          aux_last_type_read_for_NRO = SCALAR_INT;
          // assign expression to variable NAPS
          var_NAPS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NAPS_read = true;
          validate_vartype_consistency("NAPS", SCALAR_INT, aux_last_type_read_for_NAPS);
          aux_last_type_read_for_NAPS = SCALAR_INT;
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , 0 , NI ] CONT";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read CONT record
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable NI
                var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                aux_NI_read = true;
                validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
                aux_last_type_read_for_NI = SCALAR_INT;
                throw std::runtime_error("Encountered STOP instruction in recipe: NRO != 0 branch not implemented in ENDF recipe MF32");
              }
            }
          }
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              // if statement evaluation with lookahead
              {
                std::streampos cpp_old_streampos = cont.tellg();
                {
                  // variable declarations
                  EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                  EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                  bool& glob_aux_EL_read = aux_EL_read;
                  bool aux_EL_read = glob_aux_EL_read;
                  vartype aux_last_type_read_for_EL = UNKNOWN;
                  EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                  EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                  bool& glob_aux_EH_read = aux_EH_read;
                  bool aux_EH_read = glob_aux_EH_read;
                  vartype aux_last_type_read_for_EH = UNKNOWN;
                  int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                  int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                  bool& glob_aux_LRU_read = aux_LRU_read;
                  bool aux_LRU_read = glob_aux_LRU_read;
                  vartype aux_last_type_read_for_LRU = UNKNOWN;
                  int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                  int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                  bool& glob_aux_LRF_read = aux_LRF_read;
                  bool aux_LRF_read = glob_aux_LRF_read;
                  vartype aux_last_type_read_for_LRF = UNKNOWN;
                  int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                  int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                  bool& glob_aux_NRO_read = aux_NRO_read;
                  bool aux_NRO_read = glob_aux_NRO_read;
                  vartype aux_last_type_read_for_NRO = UNKNOWN;
                  int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                  int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                  bool& glob_aux_NAPS_read = aux_NAPS_read;
                  bool aux_NAPS_read = glob_aux_NAPS_read;
                  vartype aux_last_type_read_for_NAPS = UNKNOWN;
                  int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                  int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                  bool& glob_aux_NI_read = aux_NI_read;
                  bool aux_NI_read = glob_aux_NI_read;
                  vartype aux_last_type_read_for_NI = UNKNOWN;
                  EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                  EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                  bool& glob_aux_SPI_read = aux_SPI_read;
                  bool aux_SPI_read = glob_aux_SPI_read;
                  vartype aux_last_type_read_for_SPI = UNKNOWN;
                  EndfFloatCpp& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                  EndfFloatCpp var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                  bool& glob_aux_AP_read = aux_AP_read;
                  bool aux_AP_read = glob_aux_AP_read;
                  vartype aux_last_type_read_for_AP = UNKNOWN;
                  int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                  int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                  bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                  bool aux_LCOMP_read = glob_aux_LCOMP_read;
                  vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                  int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                  int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                  bool& glob_aux_NLS_read = aux_NLS_read;
                  bool aux_NLS_read = glob_aux_NLS_read;
                  vartype aux_last_type_read_for_NLS = UNKNOWN;
                  int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                  int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                  bool& glob_aux_ISR_read = aux_ISR_read;
                  bool aux_ISR_read = glob_aux_ISR_read;
                  vartype aux_last_type_read_for_ISR = UNKNOWN;
                  try {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    cpp_line = cpp_read_raw_line(cont);
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                  } catch (const std::out_of_range& e) {
                    // // accept failure in lookahead
                  }
                  if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(0)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&(((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))))))) {
                    cpp_found_match = true;
                  }
                  cont.seekg(cpp_old_streampos);
                }
                if (cpp_found_match) {
                  cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read CONT record
                  // assign expression to variable SPI
                  var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                  aux_SPI_read = true;
                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                  // assign expression to variable AP
                  var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                  aux_AP_read = true;
                  validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                  aux_last_type_read_for_AP = SCALAR_DOUBLE;
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable LCOMP
                  var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                  aux_LCOMP_read = true;
                  validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                  aux_last_type_read_for_LCOMP = SCALAR_INT;
                  // assign expression to variable NLS
                  var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  aux_NLS_read = true;
                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                  aux_last_type_read_for_NLS = SCALAR_INT;
                  // assign expression to variable ISR
                  var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  aux_ISR_read = true;
                  validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                  aux_last_type_read_for_ISR = SCALAR_INT;
                  // evaluate if-elif-else clause
                  {
                    bool cpp_found_match = false;
                    if (! cpp_found_match) {
                      if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)!=(0)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , DAP , 0 , 0 , 0 , 0 ] CONT";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read CONT record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable DAP
                        var_DAP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                        aux_DAP_read = true;
                        validate_vartype_consistency("DAP", SCALAR_DOUBLE, aux_last_type_read_for_DAP);
                        aux_last_type_read_for_DAP = SCALAR_DOUBLE;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                      }
                    }
                  }

                  for (int var_k_0d_int_Scalar = 1;
                     var_k_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                    bool aux_k_read = true;
                    // open section somesec
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      cpp_current_dict = cpp_index_shifter_store.setdefault("somesec", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
                      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                      // variable declarations
                      EndfFloatCpp var_AWRI_0d_double_Scalar;
                      bool aux_AWRI_read = false;
                      vartype aux_last_type_read_for_AWRI = UNKNOWN;
                      int var_L_0d_int_Scalar;
                      bool aux_L_read = false;
                      vartype aux_last_type_read_for_L = UNKNOWN;
                      int cpp_int_val;
                      bool aux_cpp_int_val_read = false;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int var_NRS_0d_int_Scalar;
                      bool aux_NRS_read = false;
                      vartype aux_last_type_read_for_NRS = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                      vartype aux_last_type_read_for_ER = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                      vartype aux_last_type_read_for_AJ = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GT_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GT = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GN_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GN = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GG = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GF = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DE2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DE2 = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DN2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DN2 = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DNDG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DNDG = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DG2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DG2 = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DNDF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DNDF = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DGDF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DGDF = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DF2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DF2 = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DJDN_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJDN = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DJDG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJDG = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DJDF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJDF = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DJ2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJ2 = UNKNOWN;
                      cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , L , 0 , (18*NRS) , NRS / \n { ER , AJ , GT , GN , GG , GF , \n DE2 , DN2 , DNDG , DG2 , DNDF , DGDF , \n DF2 , DJDN , DJDG , DJDF , DJ2 , 0.0 } { m = 1 to NRS } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      // assign expression to variable AWRI
                      var_AWRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                      aux_AWRI_read = true;
                      validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                      aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable L
                      var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                      aux_L_read = true;
                      validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                      aux_last_type_read_for_L = SCALAR_INT;
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NRS
                      var_NRS_0d_int_Scalar = (cpp_int_val/18);
                      aux_NRS_read = true;
                      validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                      aux_last_type_read_for_NRS = SCALAR_INT;
                      if ((! (aux_NRS_read == true))) {
                        // assign expression to variable NRS
                        var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NRS_read = true;
                        validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                        aux_last_type_read_for_NRS = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NRS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NRS",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // read LIST body
                          // assign expression to variable ER
                          var_ER_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                          aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable AJ
                          var_AJ_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                          aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GT
                          var_GT_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                          aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GN
                          var_GN_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                          aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GG
                          var_GG_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                          aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GF
                          var_GF_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                          aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DE2
                          var_DE2_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DE2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DE2);
                          aux_last_type_read_for_DE2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DN2
                          var_DN2_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DN2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DN2);
                          aux_last_type_read_for_DN2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DNDG
                          var_DNDG_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DNDG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DNDG);
                          aux_last_type_read_for_DNDG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DG2
                          var_DG2_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DG2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DG2);
                          aux_last_type_read_for_DG2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DNDF
                          var_DNDF_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DNDF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DNDF);
                          aux_last_type_read_for_DNDF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DGDF
                          var_DGDF_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DGDF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGDF);
                          aux_last_type_read_for_DGDF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DF2
                          var_DF2_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DF2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DF2);
                          aux_last_type_read_for_DF2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DJDN
                          var_DJDN_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DJDN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJDN);
                          aux_last_type_read_for_DJDN = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DJDG
                          var_DJDG_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DJDG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJDG);
                          aux_last_type_read_for_DJDG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DJDF
                          var_DJDF_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DJDF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJDF);
                          aux_last_type_read_for_DJDF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DJ2
                          var_DJ2_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DJ2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJ2);
                          aux_last_type_read_for_DJ2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      // store data in Python dictionary
                      if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                        cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                      }
                      if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                        cpp_current_dict["L"] = var_L_0d_int_Scalar;
                      }
                      if (((aux_last_type_read_for_NRS == SCALAR_INT) && (aux_NRS_read == true))) {
                        cpp_current_dict["NRS"] = var_NRS_0d_int_Scalar;
                      }
                      if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["ER"] = var_ER_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["AJ"] = var_AJ_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_GT_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["GT"] = var_GT_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_GN_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["GN"] = var_GN_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["GG"] = var_GG_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["GF"] = var_GF_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_DE2_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["DE2"] = var_DE2_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_DN2_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["DN2"] = var_DN2_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_DNDG_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["DNDG"] = var_DNDG_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_DG2_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["DG2"] = var_DG2_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_DNDF_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["DNDF"] = var_DNDF_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_DGDF_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["DGDF"] = var_DGDF_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_DF2_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["DF2"] = var_DF2_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_DJDN_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["DJDN"] = var_DJDN_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_DJDG_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["DJDG"] = var_DJDG_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_DJDF_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["DJDF"] = var_DJDF_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_DJ2_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["DJ2"] = var_DJ2_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    EndfFloatCpp& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    EndfFloatCpp var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                    int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                    bool& glob_aux_NLS_read = aux_NLS_read;
                    bool aux_NLS_read = glob_aux_NLS_read;
                    vartype aux_last_type_read_for_NLS = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                      cpp_line = cpp_read_raw_line(cont);
                      // read CONT record
                      // assign expression to variable SPI
                      var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                      aux_SPI_read = true;
                      validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                      aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                      // assign expression to variable AP
                      var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                      aux_AP_read = true;
                      validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                      aux_last_type_read_for_AP = SCALAR_DOUBLE;
                      // assign expression to variable LCOMP
                      var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                      aux_LCOMP_read = true;
                      validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                      aux_last_type_read_for_LCOMP = SCALAR_INT;
                      // assign expression to variable NLS
                      var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_NLS_read = true;
                      validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                      aux_last_type_read_for_NLS = SCALAR_INT;
                      // assign expression to variable ISR
                      var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_ISR_read = true;
                      validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                      aux_last_type_read_for_ISR = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(1)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&(((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , DAP , 0 , 0 , 0 , 0 ] CONT";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read CONT record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable DAP
                          var_DAP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                          aux_DAP_read = true;
                          validate_vartype_consistency("DAP", SCALAR_DOUBLE, aux_last_type_read_for_DAP);
                          aux_last_type_read_for_DAP = SCALAR_DOUBLE;
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , 0 , 0 , NSRS , NLRS ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NSRS
                    var_NSRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NSRS_read = true;
                    validate_vartype_consistency("NSRS", SCALAR_INT, aux_last_type_read_for_NSRS);
                    aux_last_type_read_for_NSRS = SCALAR_INT;
                    // assign expression to variable NLRS
                    var_NLRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_NLRS_read = true;
                    validate_vartype_consistency("NLRS", SCALAR_INT, aux_last_type_read_for_NLRS);
                    aux_last_type_read_for_NLRS = SCALAR_INT;

                    for (int var_p_0d_int_Scalar = 1;
                       var_p_0d_int_Scalar <= var_NSRS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                      bool aux_p_read = true;
                      // open section nsrs_subsec
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        cpp_current_dict = cpp_index_shifter_store.setdefault("nsrs_subsec", std::vector<int>({var_p_0d_int_Scalar}), py::dict());
                        IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                        // variable declarations
                        int var_MPAR_0d_int_Scalar;
                        bool aux_MPAR_read = false;
                        vartype aux_last_type_read_for_MPAR = UNKNOWN;
                        int var_NRB_0d_int_Scalar;
                        bool aux_NRB_read = false;
                        vartype aux_last_type_read_for_NRB = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_ER = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                        vartype aux_last_type_read_for_AJ = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GT_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GT = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GN_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GN = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GG = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GF = UNKNOWN;
                        Matrix2d<EndfFloatCpp> var_V_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_V = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , MPAR , 0 , ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2)) , NRB / \n { ER , AJ , GT , GN , GG , GF } { k = 1 to NRB } , \n { { V } { n = m to (MPAR*NRB) } } { m = 1 to (MPAR*NRB) } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable MPAR
                        var_MPAR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_MPAR_read = true;
                        validate_vartype_consistency("MPAR", SCALAR_INT, aux_last_type_read_for_MPAR);
                        aux_last_type_read_for_MPAR = SCALAR_INT;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable NRB
                        var_NRB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NRB_read = true;
                        validate_vartype_consistency("NRB", SCALAR_INT, aux_last_type_read_for_NRB);
                        aux_last_type_read_for_NRB = SCALAR_INT;
                        if ((! (aux_MPAR_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for MPAR because this variable could not be isolated.");
                        } else {
                          cpp_validate_field(((6*var_NRB_0d_int_Scalar)+(((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)*((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)+1))/2)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))",
                            cpp_template, cpp_line, parse_opts);
                        }
                        if ((! (aux_NRB_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for NRB because this variable could not be isolated.");
                        } else {
                          cpp_validate_field(((6*var_NRB_0d_int_Scalar)+(((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)*((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)+1))/2)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NRB_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable AJ
                            var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                            aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GT
                            var_GT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                            aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GN
                            var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                            aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GG
                            var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                            aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GF
                            var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                            aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          var_V_2d_double_Matrix2d.init(1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), 1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), true, false);

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body

                            for (int var_n_0d_int_Scalar = var_m_0d_int_Scalar;
                               var_n_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_n_0d_int_Scalar++) {
                              bool aux_n_read = true;
                              // read LIST body
                              // assign expression to variable V
                              var_V_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("V", MATRIX2D_DOUBLE, aux_last_type_read_for_V);
                              aux_last_type_read_for_V = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        // store data in Python dictionary
                        if (((aux_last_type_read_for_MPAR == SCALAR_INT) && (aux_MPAR_read == true))) {
                          cpp_current_dict["MPAR"] = var_MPAR_0d_int_Scalar;
                        }
                        if (((aux_last_type_read_for_NRB == SCALAR_INT) && (aux_NRB_read == true))) {
                          cpp_current_dict["NRB"] = var_NRB_0d_int_Scalar;
                        }
                        if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["ER"] = var_ER_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["AJ"] = var_AJ_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_GT_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["GT"] = var_GT_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_GN_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["GN"] = var_GN_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["GG"] = var_GG_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["GF"] = var_GF_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if (var_V_2d_double_Matrix2d.did_read()) {
                          cpp_current_dict["V"] = var_V_2d_double_Matrix2d.to_pyobj(list_mode);
                        }
                        cpp_current_dict = cpp_parent_dict;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    EndfFloatCpp& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    EndfFloatCpp var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                    int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                    bool& glob_aux_NLS_read = aux_NLS_read;
                    bool aux_NLS_read = glob_aux_NLS_read;
                    vartype aux_last_type_read_for_NLS = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                      cpp_line = cpp_read_raw_line(cont);
                      // read CONT record
                      // assign expression to variable SPI
                      var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                      aux_SPI_read = true;
                      validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                      aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                      // assign expression to variable AP
                      var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                      aux_AP_read = true;
                      validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                      aux_last_type_read_for_AP = SCALAR_DOUBLE;
                      // assign expression to variable LCOMP
                      var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                      aux_LCOMP_read = true;
                      validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                      aux_last_type_read_for_LCOMP = SCALAR_INT;
                      // assign expression to variable NLS
                      var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_NLS_read = true;
                      validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                      aux_last_type_read_for_NLS = SCALAR_INT;
                      // assign expression to variable ISR
                      var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_ISR_read = true;
                      validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                      aux_last_type_read_for_ISR = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(1)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(3)))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , MLS , 1 / \n { DAP } { k = 1 to MLS } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable MLS
                          var_MLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_MLS_read = true;
                          validate_vartype_consistency("MLS", SCALAR_INT, aux_last_type_read_for_MLS);
                          aux_last_type_read_for_MLS = SCALAR_INT;
                          cpp_validate_field(1, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "1",
                            cpp_template, cpp_line, parse_opts);
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_MLS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable DAP
                              var_DAP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("DAP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DAP);
                              aux_last_type_read_for_DAP = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , 0 , 0 , NSRS , NLRS ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NSRS
                    var_NSRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NSRS_read = true;
                    validate_vartype_consistency("NSRS", SCALAR_INT, aux_last_type_read_for_NSRS);
                    aux_last_type_read_for_NSRS = SCALAR_INT;
                    // assign expression to variable NLRS
                    var_NLRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_NLRS_read = true;
                    validate_vartype_consistency("NLRS", SCALAR_INT, aux_last_type_read_for_NLRS);
                    aux_last_type_read_for_NLRS = SCALAR_INT;

                    for (int var_p_0d_int_Scalar = 1;
                       var_p_0d_int_Scalar <= var_NSRS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                      bool aux_p_read = true;
                      // open section nsrs_subsec
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        cpp_current_dict = cpp_index_shifter_store.setdefault("nsrs_subsec", std::vector<int>({var_p_0d_int_Scalar}), py::dict());
                        IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                        // variable declarations
                        int var_MPAR_0d_int_Scalar;
                        bool aux_MPAR_read = false;
                        vartype aux_last_type_read_for_MPAR = UNKNOWN;
                        int var_NRB_0d_int_Scalar;
                        bool aux_NRB_read = false;
                        vartype aux_last_type_read_for_NRB = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_ER = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                        vartype aux_last_type_read_for_AJ = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GN_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GN = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GG = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GFA_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GFA = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GFB_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GFB = UNKNOWN;
                        Matrix2d<EndfFloatCpp> var_V_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_V = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , MPAR , 0 , ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2)) , NRB / \n { ER , AJ , GN , GG , GFA , GFB } { k = 1 to NRB } , \n { { V } { n = m to (MPAR*NRB) } } { m = 1 to (MPAR*NRB) } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable MPAR
                        var_MPAR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_MPAR_read = true;
                        validate_vartype_consistency("MPAR", SCALAR_INT, aux_last_type_read_for_MPAR);
                        aux_last_type_read_for_MPAR = SCALAR_INT;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable NRB
                        var_NRB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NRB_read = true;
                        validate_vartype_consistency("NRB", SCALAR_INT, aux_last_type_read_for_NRB);
                        aux_last_type_read_for_NRB = SCALAR_INT;
                        if ((! (aux_MPAR_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for MPAR because this variable could not be isolated.");
                        } else {
                          cpp_validate_field(((6*var_NRB_0d_int_Scalar)+(((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)*((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)+1))/2)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))",
                            cpp_template, cpp_line, parse_opts);
                        }
                        if ((! (aux_NRB_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for NRB because this variable could not be isolated.");
                        } else {
                          cpp_validate_field(((6*var_NRB_0d_int_Scalar)+(((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)*((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)+1))/2)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NRB_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable AJ
                            var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                            aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GN
                            var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                            aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GG
                            var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                            aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GFA
                            var_GFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFA);
                            aux_last_type_read_for_GFA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GFB
                            var_GFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFB);
                            aux_last_type_read_for_GFB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          var_V_2d_double_Matrix2d.init(1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), 1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), true, false);

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body

                            for (int var_n_0d_int_Scalar = var_m_0d_int_Scalar;
                               var_n_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_n_0d_int_Scalar++) {
                              bool aux_n_read = true;
                              // read LIST body
                              // assign expression to variable V
                              var_V_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("V", MATRIX2D_DOUBLE, aux_last_type_read_for_V);
                              aux_last_type_read_for_V = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        // store data in Python dictionary
                        if (((aux_last_type_read_for_MPAR == SCALAR_INT) && (aux_MPAR_read == true))) {
                          cpp_current_dict["MPAR"] = var_MPAR_0d_int_Scalar;
                        }
                        if (((aux_last_type_read_for_NRB == SCALAR_INT) && (aux_NRB_read == true))) {
                          cpp_current_dict["NRB"] = var_NRB_0d_int_Scalar;
                        }
                        if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["ER"] = var_ER_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["AJ"] = var_AJ_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_GN_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["GN"] = var_GN_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["GG"] = var_GG_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_GFA_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["GFA"] = var_GFA_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_GFB_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["GFB"] = var_GFB_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if (var_V_2d_double_Matrix2d.did_read()) {
                          cpp_current_dict["V"] = var_V_2d_double_Matrix2d.to_pyobj(list_mode);
                        }
                        cpp_current_dict = cpp_parent_dict;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , LCOMP , 0 , ISR ] CONT";
                      cpp_line = cpp_read_raw_line(cont);
                      // read CONT record
                      // assign expression to variable LCOMP
                      var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                      aux_LCOMP_read = true;
                      validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                      aux_last_type_read_for_LCOMP = SCALAR_INT;
                      // assign expression to variable ISR
                      var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_ISR_read = true;
                      validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                      aux_last_type_read_for_ISR = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(1)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(7)))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , LCOMP , 0 , ISR ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , JCH , (1+((NCH-1)/6)) / \n { { DAP } { n = 1 to NCH } } { m = 1 to (JCH/NCH) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable JCH
                          var_JCH_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_JCH_read = true;
                          validate_vartype_consistency("JCH", SCALAR_INT, aux_last_type_read_for_JCH);
                          aux_last_type_read_for_JCH = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NCH
                          var_NCH_0d_int_Scalar = ((((((1/6)*(-1))+1)*(-1))+cpp_int_val)/(1/6));
                          aux_NCH_read = true;
                          validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                          aux_last_type_read_for_NCH = SCALAR_INT;
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body
                            var_DAP_2d_double_Matrix2d.init(1, (var_JCH_0d_int_Scalar/var_NCH_0d_int_Scalar), 1, var_NCH_0d_int_Scalar, false, false);

                            for (int var_m_0d_int_Scalar = 1;
                               var_m_0d_int_Scalar <= (var_JCH_0d_int_Scalar/var_NCH_0d_int_Scalar); var_m_0d_int_Scalar++) {
                              bool aux_m_read = true;
                              // read LIST body

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // read LIST body
                                // assign expression to variable DAP
                                var_DAP_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("DAP", MATRIX2D_DOUBLE, aux_last_type_read_for_DAP);
                                aux_last_type_read_for_DAP = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , 0 , 0 , NSRS , 0 ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NSRS
                    var_NSRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NSRS_read = true;
                    validate_vartype_consistency("NSRS", SCALAR_INT, aux_last_type_read_for_NSRS);
                    aux_last_type_read_for_NSRS = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);

                    for (int var_k_0d_int_Scalar = 1;
                       var_k_0d_int_Scalar <= var_NSRS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                      bool aux_k_read = true;
                      // open section nsrs_subsec
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        cpp_current_dict = cpp_index_shifter_store.setdefault("nsrs_subsec", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
                        IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                        // variable declarations
                        int var_NJSX_0d_int_Scalar;
                        bool aux_NJSX_read = false;
                        vartype aux_last_type_read_for_NJSX = UNKNOWN;
                        int var_N_0d_int_Scalar;
                        bool aux_N_read = false;
                        vartype aux_last_type_read_for_N = UNKNOWN;
                        int var_NPARB_0d_int_Scalar;
                        bool aux_NPARB_read = false;
                        vartype aux_last_type_read_for_NPARB = UNKNOWN;
                        Matrix2d<EndfFloatCpp> var_V_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_V = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NJSX , 0 , 0 , 0 ] CONT";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read CONT record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable NJSX
                        var_NJSX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_NJSX_read = true;
                        validate_vartype_consistency("NJSX", SCALAR_INT, aux_last_type_read_for_NJSX);
                        aux_last_type_read_for_NJSX = SCALAR_INT;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NJSX_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // open section J_pi_group
                          {
                            py::dict cpp_parent_dict = cpp_current_dict;
                            cpp_current_dict = cpp_index_shifter_store.setdefault("J_pi_group", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                            // variable declarations
                            int var_NCH_0d_int_Scalar;
                            bool aux_NCH_read = false;
                            vartype aux_last_type_read_for_NCH = UNKNOWN;
                            int var_NRB_0d_int_Scalar;
                            bool aux_NRB_read = false;
                            vartype aux_last_type_read_for_NRB = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                            vartype aux_last_type_read_for_ER = UNKNOWN;
                            Matrix2d<EndfFloatCpp> var_GAM_2d_double_Matrix2d;
                            vartype aux_last_type_read_for_GAM = UNKNOWN;
                            cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NCH , NRB , (6*NX) , NX / \n { ER , { GAM } { q = 1 to NCH } \n { 0.0 } { r = 1 to num_zeros } } { p = 1 to NRB } ] LIST";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST record
                            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                              cpp_template, cpp_line, parse_opts);
                            if ((! (aux_NCH_read == true))) {
                              // assign expression to variable NCH
                              var_NCH_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                              aux_NCH_read = true;
                              validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                              aux_last_type_read_for_NCH = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NCH_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "NCH",
                                cpp_template, cpp_line, parse_opts);
                            }
                            // assign expression to variable NRB
                            var_NRB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                            aux_NRB_read = true;
                            validate_vartype_consistency("NRB", SCALAR_INT, aux_last_type_read_for_NRB);
                            aux_last_type_read_for_NRB = SCALAR_INT;
                            if ((! (aux_NCH_read == true))) {
                              throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRB)/6))==value cannot be solved for NCH because the modulo operator is not supported.");
                            } else {
                              cpp_validate_field((6*((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRB_0d_int_Scalar)/6)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(6*((((1+NCH)+((5-NCH)%6))*NRB)/6))",
                                cpp_template, cpp_line, parse_opts);
                            }
                            if ((! (aux_NRB_read == true))) {
                              throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRB)/6))==value cannot be solved for NRB because the modulo operator is not supported.");
                            } else {
                              cpp_validate_field((6*((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRB_0d_int_Scalar)/6)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(6*((((1+NCH)+((5-NCH)%6))*NRB)/6))",
                                cpp_template, cpp_line, parse_opts);
                            }
                            if ((! (aux_NCH_read == true))) {
                              throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRB)/6)==value cannot be solved for NCH because the modulo operator is not supported.");
                            } else {
                              cpp_validate_field(((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRB_0d_int_Scalar)/6), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "((((1+NCH)+((5-NCH)%6))*NRB)/6)",
                                cpp_template, cpp_line, parse_opts);
                            }
                            if ((! (aux_NRB_read == true))) {
                              throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRB)/6)==value cannot be solved for NRB because the modulo operator is not supported.");
                            } else {
                              cpp_validate_field(((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRB_0d_int_Scalar)/6), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "((((1+NCH)+((5-NCH)%6))*NRB)/6)",
                                cpp_template, cpp_line, parse_opts);
                            }
                            {
                              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read LIST body
                              var_GAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRB_0d_int_Scalar, false, false);

                              for (int var_p_0d_int_Scalar = 1;
                                 var_p_0d_int_Scalar <= var_NRB_0d_int_Scalar; var_p_0d_int_Scalar++) {
                                bool aux_p_read = true;
                                // read LIST body
                                // assign expression to variable ER
                                var_ER_1d_double_NestedVector.set(var_p_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                                aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }

                                for (int var_q_0d_int_Scalar = 1;
                                   var_q_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_q_0d_int_Scalar++) {
                                  bool aux_q_read = true;
                                  // read LIST body
                                  // assign expression to variable GAM
                                  var_GAM_2d_double_Matrix2d(var_q_0d_int_Scalar, var_p_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                  validate_vartype_consistency("GAM", MATRIX2D_DOUBLE, aux_last_type_read_for_GAM);
                                  aux_last_type_read_for_GAM = MATRIX2D_DOUBLE;
                                  cpp_i++;
                                  cpp_j++;
                                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    cpp_j = 0;
                                  }
                                }

                                for (int var_r_0d_int_Scalar = 1;
                                   var_r_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_r_0d_int_Scalar++) {
                                  bool aux_r_read = true;
                                  // read LIST body
                                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                    cpp_template, cpp_line, parse_opts);
                                  cpp_i++;
                                  cpp_j++;
                                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    cpp_j = 0;
                                  }
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            // store data in Python dictionary
                            if (((aux_last_type_read_for_NCH == SCALAR_INT) && (aux_NCH_read == true))) {
                              cpp_current_dict["NCH"] = var_NCH_0d_int_Scalar;
                            }
                            if (((aux_last_type_read_for_NRB == SCALAR_INT) && (aux_NRB_read == true))) {
                              cpp_current_dict["NRB"] = var_NRB_0d_int_Scalar;
                            }
                            if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                              cpp_current_dict["ER"] = var_ER_1d_double_NestedVector.to_pyobj(list_mode);
                            }
                            if (var_GAM_2d_double_Matrix2d.did_read()) {
                              cpp_current_dict["GAM"] = var_GAM_2d_double_Matrix2d.to_pyobj(list_mode);
                            }
                            cpp_current_dict = cpp_parent_dict;
                          }
                        }
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , N , NPARB / \n { { V } { q = p to NPARB } } { p = 1 to NPARB } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable N
                        var_N_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_N_read = true;
                        validate_vartype_consistency("N", SCALAR_INT, aux_last_type_read_for_N);
                        aux_last_type_read_for_N = SCALAR_INT;
                        // assign expression to variable NPARB
                        var_NPARB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NPARB_read = true;
                        validate_vartype_consistency("NPARB", SCALAR_INT, aux_last_type_read_for_NPARB);
                        aux_last_type_read_for_NPARB = SCALAR_INT;
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body
                          var_V_2d_double_Matrix2d.init(1, var_NPARB_0d_int_Scalar, 1, var_NPARB_0d_int_Scalar, true, false);

                          for (int var_p_0d_int_Scalar = 1;
                             var_p_0d_int_Scalar <= var_NPARB_0d_int_Scalar; var_p_0d_int_Scalar++) {
                            bool aux_p_read = true;
                            // read LIST body

                            for (int var_q_0d_int_Scalar = var_p_0d_int_Scalar;
                               var_q_0d_int_Scalar <= var_NPARB_0d_int_Scalar; var_q_0d_int_Scalar++) {
                              bool aux_q_read = true;
                              // read LIST body
                              // assign expression to variable V
                              var_V_2d_double_Matrix2d(var_p_0d_int_Scalar, var_q_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("V", MATRIX2D_DOUBLE, aux_last_type_read_for_V);
                              aux_last_type_read_for_V = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        // store data in Python dictionary
                        if (((aux_last_type_read_for_NJSX == SCALAR_INT) && (aux_NJSX_read == true))) {
                          cpp_current_dict["NJSX"] = var_NJSX_0d_int_Scalar;
                        }
                        if (((aux_last_type_read_for_N == SCALAR_INT) && (aux_N_read == true))) {
                          cpp_current_dict["N"] = var_N_0d_int_Scalar;
                        }
                        if (((aux_last_type_read_for_NPARB == SCALAR_INT) && (aux_NPARB_read == true))) {
                          cpp_current_dict["NPARB"] = var_NPARB_0d_int_Scalar;
                        }
                        if (var_V_2d_double_Matrix2d.did_read()) {
                          cpp_current_dict["V"] = var_V_2d_double_Matrix2d.to_pyobj(list_mode);
                        }
                        cpp_current_dict = cpp_parent_dict;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    EndfFloatCpp& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    EndfFloatCpp var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , 0 , ISR ] CONT";
                      cpp_line = cpp_read_raw_line(cont);
                      // read CONT record
                      // assign expression to variable SPI
                      var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                      aux_SPI_read = true;
                      validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                      aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                      // assign expression to variable AP
                      var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                      aux_AP_read = true;
                      validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                      aux_last_type_read_for_AP = SCALAR_DOUBLE;
                      // assign expression to variable LCOMP
                      var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                      aux_LCOMP_read = true;
                      validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                      aux_last_type_read_for_LCOMP = SCALAR_INT;
                      // assign expression to variable ISR
                      var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_ISR_read = true;
                      validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                      aux_last_type_read_for_ISR = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(2)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&(((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , 0 , ISR ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , DAP , 0 , 0 , 0 , 0 ] CONT";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read CONT record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable DAP
                          var_DAP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                          aux_DAP_read = true;
                          validate_vartype_consistency("DAP", SCALAR_DOUBLE, aux_last_type_read_for_DAP);
                          aux_last_type_read_for_DAP = SCALAR_DOUBLE;
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , QX , 0 , LRX , (12*NRSA) , NRSA / \n { ER , AJ , GT , GN , GG , GF , \n DER , 0.0 , 0.0 , DGN , DGG , DGF } { k = 1 to NRSA } ] LIST";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST record
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    // assign expression to variable QX
                    var_QX_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                    aux_QX_read = true;
                    validate_vartype_consistency("QX", SCALAR_DOUBLE, aux_last_type_read_for_QX);
                    aux_last_type_read_for_QX = SCALAR_DOUBLE;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable LRX
                    var_LRX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LRX_read = true;
                    validate_vartype_consistency("LRX", SCALAR_INT, aux_last_type_read_for_LRX);
                    aux_last_type_read_for_LRX = SCALAR_INT;
                    // assign expression to variable cpp_int_val
                    cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_cpp_int_val_read = true;
                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                    // assign expression to variable NRSA
                    var_NRSA_0d_int_Scalar = (cpp_int_val/12);
                    aux_NRSA_read = true;
                    validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                    aux_last_type_read_for_NRSA = SCALAR_INT;
                    if ((! (aux_NRSA_read == true))) {
                      // assign expression to variable NRSA
                      var_NRSA_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_NRSA_read = true;
                      validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                      aux_last_type_read_for_NRSA = SCALAR_INT;
                    } else {
                      cpp_validate_field(var_NRSA_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NRSA",
                        cpp_template, cpp_line, parse_opts);
                    }
                    {
                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_NRSA_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        // assign expression to variable ER
                        var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                        aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable AJ
                        var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                        aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GT
                        var_GT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                        aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GN
                        var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                        aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GG
                        var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                        aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GF
                        var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                        aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DER
                        var_DER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DER);
                        aux_last_type_read_for_DER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGN
                        var_DGN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGN);
                        aux_last_type_read_for_DGN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGG
                        var_DGG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGG);
                        aux_last_type_read_for_DGG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGF
                        var_DGF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGF);
                        aux_last_type_read_for_DGF = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NDIGIT , NNN , NM , 0 ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NDIGIT
                    var_NDIGIT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_NDIGIT_read = true;
                    validate_vartype_consistency("NDIGIT", SCALAR_INT, aux_last_type_read_for_NDIGIT);
                    aux_last_type_read_for_NDIGIT = SCALAR_INT;
                    // assign expression to variable NNN
                    var_NNN_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_NNN_read = true;
                    validate_vartype_consistency("NNN", SCALAR_INT, aux_last_type_read_for_NNN);
                    aux_last_type_read_for_NNN = SCALAR_INT;
                    // assign expression to variable NM
                    var_NM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NM_read = true;
                    validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
                    aux_last_type_read_for_NM = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);

                    for (int var_k_0d_int_Scalar = 1;
                       var_k_0d_int_Scalar <= var_NM_0d_int_Scalar; var_k_0d_int_Scalar++) {
                      bool aux_k_read = true;
                      {
                        cpp_template = "[ MAT , 32 , 151 / II , JJ , KIJ { NDIGIT } ] INTG";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        int cpp_ndigit = var_NDIGIT_0d_int_Scalar;
                        if ((cpp_ndigit < 2 || cpp_ndigit > 6)) {
                          throw std::runtime_error("invalid NDIGIT (must be between 2 and 6)");
                        }
                        // assign expression to variable II
                        var_II_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_custom_int_field(cpp_line.c_str(), 0, 5));
                        validate_vartype_consistency("II", NESTEDVECTOR_INT, aux_last_type_read_for_II);
                        aux_last_type_read_for_II = NESTEDVECTOR_INT;
                        // assign expression to variable JJ
                        var_JJ_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_custom_int_field(cpp_line.c_str(), 5, 5));
                        validate_vartype_consistency("JJ", NESTEDVECTOR_INT, aux_last_type_read_for_JJ);
                        aux_last_type_read_for_JJ = NESTEDVECTOR_INT;
                        int cpp_step = cpp_ndigit + 1;
                        int cpp_end = 65;
                        int cpp_start;
                        if (cpp_ndigit <= 5) {
                          cpp_start = 11;
                        } else {
                          cpp_start = 10;
                        }
                        std::vector<int> cpp_intvec;
                        int elpos = 0;
                        for (int cpp_i = cpp_start; cpp_i < cpp_end; cpp_i += cpp_step) {
                          cpp_intvec.push_back(cpp_read_custom_int_field(cpp_line.c_str(), cpp_i, cpp_step));
                          elpos++;
                        }
                        // assign expression to variable KIJ
                        var_KIJ_1d_intvec_NestedVector.set(var_k_0d_int_Scalar, cpp_intvec);
                        validate_vartype_consistency("KIJ", NESTEDVECTOR_INTVEC, aux_last_type_read_for_KIJ);
                        aux_last_type_read_for_KIJ = NESTEDVECTOR_INTVEC;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    EndfFloatCpp& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    EndfFloatCpp var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LAD_0d_int_Scalar = var_LAD_0d_int_Scalar;
                    int var_LAD_0d_int_Scalar = glob_var_LAD_0d_int_Scalar;
                    bool& glob_aux_LAD_read = aux_LAD_read;
                    bool aux_LAD_read = glob_aux_LAD_read;
                    vartype aux_last_type_read_for_LAD = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 32 , 151 / SPI , AP , LAD , LCOMP , 0 , ISR ] CONT";
                      cpp_line = cpp_read_raw_line(cont);
                      // read CONT record
                      // assign expression to variable SPI
                      var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                      aux_SPI_read = true;
                      validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                      aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                      // assign expression to variable AP
                      var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                      aux_AP_read = true;
                      validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                      aux_last_type_read_for_AP = SCALAR_DOUBLE;
                      // assign expression to variable LAD
                      var_LAD_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                      aux_LAD_read = true;
                      validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                      aux_last_type_read_for_LAD = SCALAR_INT;
                      // assign expression to variable LCOMP
                      var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                      aux_LCOMP_read = true;
                      validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                      aux_last_type_read_for_LCOMP = SCALAR_INT;
                      // assign expression to variable ISR
                      var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_ISR_read = true;
                      validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                      aux_last_type_read_for_ISR = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(2)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(3)))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , LAD , LCOMP , 0 , ISR ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    // assign expression to variable LAD
                    var_LAD_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_LAD_read = true;
                    validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                    aux_last_type_read_for_LAD = SCALAR_INT;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , MLS , 1 / \n { DAP } { k = 1 to MLS } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable MLS
                          var_MLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_MLS_read = true;
                          validate_vartype_consistency("MLS", SCALAR_INT, aux_last_type_read_for_MLS);
                          aux_last_type_read_for_MLS = SCALAR_INT;
                          cpp_validate_field(1, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "1",
                            cpp_template, cpp_line, parse_opts);
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_MLS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable DAP
                              var_DAP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("DAP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DAP);
                              aux_last_type_read_for_DAP = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , APL , 0 , 0 , (12*NRSA) , NRSA / \n { ER , AJ , GN , GG , GFA , GFB , \n DER , 0.0 , DGN , DGG , DGFA , DGFB } { k = 1 to NRSA } ] LIST";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST record
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    // assign expression to variable APL
                    var_APL_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                    aux_APL_read = true;
                    validate_vartype_consistency("APL", SCALAR_DOUBLE, aux_last_type_read_for_APL);
                    aux_last_type_read_for_APL = SCALAR_DOUBLE;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable cpp_int_val
                    cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_cpp_int_val_read = true;
                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                    // assign expression to variable NRSA
                    var_NRSA_0d_int_Scalar = (cpp_int_val/12);
                    aux_NRSA_read = true;
                    validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                    aux_last_type_read_for_NRSA = SCALAR_INT;
                    if ((! (aux_NRSA_read == true))) {
                      // assign expression to variable NRSA
                      var_NRSA_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_NRSA_read = true;
                      validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                      aux_last_type_read_for_NRSA = SCALAR_INT;
                    } else {
                      cpp_validate_field(var_NRSA_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NRSA",
                        cpp_template, cpp_line, parse_opts);
                    }
                    {
                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_NRSA_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        // assign expression to variable ER
                        var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                        aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable AJ
                        var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                        aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GN
                        var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                        aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GG
                        var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                        aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GFA
                        var_GFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFA);
                        aux_last_type_read_for_GFA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GFB
                        var_GFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFB);
                        aux_last_type_read_for_GFB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DER
                        var_DER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DER);
                        aux_last_type_read_for_DER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGN
                        var_DGN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGN);
                        aux_last_type_read_for_DGN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGG
                        var_DGG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGG);
                        aux_last_type_read_for_DGG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGFA
                        var_DGFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGFA);
                        aux_last_type_read_for_DGFA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGFB
                        var_DGFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGFB);
                        aux_last_type_read_for_DGFB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NDIGIT , NNN , NM , 0 ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NDIGIT
                    var_NDIGIT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_NDIGIT_read = true;
                    validate_vartype_consistency("NDIGIT", SCALAR_INT, aux_last_type_read_for_NDIGIT);
                    aux_last_type_read_for_NDIGIT = SCALAR_INT;
                    // assign expression to variable NNN
                    var_NNN_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_NNN_read = true;
                    validate_vartype_consistency("NNN", SCALAR_INT, aux_last_type_read_for_NNN);
                    aux_last_type_read_for_NNN = SCALAR_INT;
                    // assign expression to variable NM
                    var_NM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NM_read = true;
                    validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
                    aux_last_type_read_for_NM = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);

                    for (int var_k_0d_int_Scalar = 1;
                       var_k_0d_int_Scalar <= var_NM_0d_int_Scalar; var_k_0d_int_Scalar++) {
                      bool aux_k_read = true;
                      {
                        cpp_template = "[ MAT , 32 , 151 / II , JJ , KIJ { NDIGIT } ] INTG";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        int cpp_ndigit = var_NDIGIT_0d_int_Scalar;
                        if ((cpp_ndigit < 2 || cpp_ndigit > 6)) {
                          throw std::runtime_error("invalid NDIGIT (must be between 2 and 6)");
                        }
                        // assign expression to variable II
                        var_II_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_custom_int_field(cpp_line.c_str(), 0, 5));
                        validate_vartype_consistency("II", NESTEDVECTOR_INT, aux_last_type_read_for_II);
                        aux_last_type_read_for_II = NESTEDVECTOR_INT;
                        // assign expression to variable JJ
                        var_JJ_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_custom_int_field(cpp_line.c_str(), 5, 5));
                        validate_vartype_consistency("JJ", NESTEDVECTOR_INT, aux_last_type_read_for_JJ);
                        aux_last_type_read_for_JJ = NESTEDVECTOR_INT;
                        int cpp_step = cpp_ndigit + 1;
                        int cpp_end = 65;
                        int cpp_start;
                        if (cpp_ndigit <= 5) {
                          cpp_start = 11;
                        } else {
                          cpp_start = 10;
                        }
                        std::vector<int> cpp_intvec;
                        int elpos = 0;
                        for (int cpp_i = cpp_start; cpp_i < cpp_end; cpp_i += cpp_step) {
                          cpp_intvec.push_back(cpp_read_custom_int_field(cpp_line.c_str(), cpp_i, cpp_step));
                          elpos++;
                        }
                        // assign expression to variable KIJ
                        var_KIJ_1d_intvec_NestedVector.set(var_k_0d_int_Scalar, cpp_intvec);
                        validate_vartype_consistency("KIJ", NESTEDVECTOR_INTVEC, aux_last_type_read_for_KIJ);
                        aux_last_type_read_for_KIJ = NESTEDVECTOR_INTVEC;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    int& glob_var_IFG_0d_int_Scalar = var_IFG_0d_int_Scalar;
                    int var_IFG_0d_int_Scalar = glob_var_IFG_0d_int_Scalar;
                    bool& glob_aux_IFG_read = aux_IFG_read;
                    bool aux_IFG_read = glob_aux_IFG_read;
                    vartype aux_last_type_read_for_IFG = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_NJS_0d_int_Scalar = var_NJS_0d_int_Scalar;
                    int var_NJS_0d_int_Scalar = glob_var_NJS_0d_int_Scalar;
                    bool& glob_aux_NJS_read = aux_NJS_read;
                    bool aux_NJS_read = glob_aux_NJS_read;
                    vartype aux_last_type_read_for_NJS = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , IFG , LCOMP , NJS , ISR ] CONT";
                      cpp_line = cpp_read_raw_line(cont);
                      // read CONT record
                      // assign expression to variable IFG
                      var_IFG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                      aux_IFG_read = true;
                      validate_vartype_consistency("IFG", SCALAR_INT, aux_last_type_read_for_IFG);
                      aux_last_type_read_for_IFG = SCALAR_INT;
                      // assign expression to variable LCOMP
                      var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                      aux_LCOMP_read = true;
                      validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                      aux_last_type_read_for_LCOMP = SCALAR_INT;
                      // assign expression to variable NJS
                      var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_NJS_read = true;
                      validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                      aux_last_type_read_for_NJS = SCALAR_INT;
                      // assign expression to variable ISR
                      var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_ISR_read = true;
                      validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                      aux_last_type_read_for_ISR = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(2)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(7)))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , IFG , LCOMP , NJS , ISR ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable IFG
                    var_IFG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_IFG_read = true;
                    validate_vartype_consistency("IFG", SCALAR_INT, aux_last_type_read_for_IFG);
                    aux_last_type_read_for_IFG = SCALAR_INT;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NJS
                    var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NJS_read = true;
                    validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                    aux_last_type_read_for_NJS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , NJCH , (1+((NJCH-1)/6)) / \n { { DAP } { n = 1 to (NJCH/NJS) } } { m = 1 to (NJCH/NJS) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable NJCH
                          var_NJCH_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_NJCH_read = true;
                          validate_vartype_consistency("NJCH", SCALAR_INT, aux_last_type_read_for_NJCH);
                          aux_last_type_read_for_NJCH = SCALAR_INT;
                          if ((! (aux_NJCH_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NJCH
                            var_NJCH_0d_int_Scalar = ((((((1/6)*(-1))+1)*(-1))+cpp_int_val)/(1/6));
                            aux_NJCH_read = true;
                            validate_vartype_consistency("NJCH", SCALAR_INT, aux_last_type_read_for_NJCH);
                            aux_last_type_read_for_NJCH = SCALAR_INT;
                          } else {
                            cpp_validate_field((1+((var_NJCH_0d_int_Scalar-1)/6)), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "(1+((NJCH-1)/6))",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body
                            var_DAP_2d_double_Matrix2d.init(1, (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar), 1, (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar), false, false);

                            for (int var_m_0d_int_Scalar = 1;
                               var_m_0d_int_Scalar <= (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar); var_m_0d_int_Scalar++) {
                              bool aux_m_read = true;
                              // read LIST body

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar); var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // read LIST body
                                // assign expression to variable DAP
                                var_DAP_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("DAP", MATRIX2D_DOUBLE, aux_last_type_read_for_DAP);
                                aux_last_type_read_for_DAP = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NPP , NJSX , (12*NPP) , (2*NPP) / \n { MA , MB , ZA , ZB , IA , IB , \n Q , PNT , SHF , MT , PA , PB } { k = 1 to NPP } ] LIST";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST record
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NPP
                    var_NPP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_NPP_read = true;
                    validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                    aux_last_type_read_for_NPP = SCALAR_INT;
                    // assign expression to variable NJSX
                    var_NJSX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_NJSX_read = true;
                    validate_vartype_consistency("NJSX", SCALAR_INT, aux_last_type_read_for_NJSX);
                    aux_last_type_read_for_NJSX = SCALAR_INT;
                    if ((! (aux_NPP_read == true))) {
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NPP
                      var_NPP_0d_int_Scalar = (cpp_int_val/12);
                      aux_NPP_read = true;
                      validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                      aux_last_type_read_for_NPP = SCALAR_INT;
                    } else {
                      cpp_validate_field((12*var_NPP_0d_int_Scalar), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(12*NPP)",
                        cpp_template, cpp_line, parse_opts);
                    }
                    if ((! (aux_NPP_read == true))) {
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NPP
                      var_NPP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NPP_read = true;
                      validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                      aux_last_type_read_for_NPP = SCALAR_INT;
                    } else {
                      cpp_validate_field((2*var_NPP_0d_int_Scalar), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "(2*NPP)",
                        cpp_template, cpp_line, parse_opts);
                    }
                    {
                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_NPP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        // assign expression to variable MA
                        var_MA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("MA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MA);
                        aux_last_type_read_for_MA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable MB
                        var_MB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("MB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MB);
                        aux_last_type_read_for_MB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable ZA
                        var_ZA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("ZA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZA);
                        aux_last_type_read_for_ZA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable ZB
                        var_ZB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("ZB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZB);
                        aux_last_type_read_for_ZB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable IA
                        var_IA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("IA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IA);
                        aux_last_type_read_for_IA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable IB
                        var_IB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("IB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IB);
                        aux_last_type_read_for_IB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable Q
                        var_Q_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("Q", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Q);
                        aux_last_type_read_for_Q = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable PNT
                        var_PNT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("PNT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PNT);
                        aux_last_type_read_for_PNT = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable SHF
                        var_SHF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("SHF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SHF);
                        aux_last_type_read_for_SHF = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable MT
                        var_MT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("MT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MT);
                        aux_last_type_read_for_MT = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable PA
                        var_PA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("PA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PA);
                        aux_last_type_read_for_PA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable PB
                        var_PB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("PB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PB);
                        aux_last_type_read_for_PB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }

                    for (int var_q_0d_int_Scalar = 1;
                       var_q_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_q_0d_int_Scalar++) {
                      bool aux_q_read = true;
                      // open section somesec
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        cpp_current_dict = cpp_index_shifter_store.setdefault("somesec", std::vector<int>({var_q_0d_int_Scalar}), py::dict());
                        IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                        // variable declarations
                        EndfFloatCpp var_AJ_0d_double_Scalar;
                        bool aux_AJ_read = false;
                        vartype aux_last_type_read_for_AJ = UNKNOWN;
                        EndfFloatCpp var_PJ_0d_double_Scalar;
                        bool aux_PJ_read = false;
                        vartype aux_last_type_read_for_PJ = UNKNOWN;
                        int cpp_int_val;
                        bool aux_cpp_int_val_read = false;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int var_NCH_0d_int_Scalar;
                        bool aux_NCH_read = false;
                        vartype aux_last_type_read_for_NCH = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_PPI_1d_double_NestedVector;
                        vartype aux_last_type_read_for_PPI = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_L_1d_double_NestedVector;
                        vartype aux_last_type_read_for_L = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_SCH_1d_double_NestedVector;
                        vartype aux_last_type_read_for_SCH = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_BND_1d_double_NestedVector;
                        vartype aux_last_type_read_for_BND = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_APE_1d_double_NestedVector;
                        vartype aux_last_type_read_for_APE = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_APT_1d_double_NestedVector;
                        vartype aux_last_type_read_for_APT = UNKNOWN;
                        int var_NRSA_0d_int_Scalar;
                        bool aux_NRSA_read = false;
                        vartype aux_last_type_read_for_NRSA = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_ER = UNKNOWN;
                        Matrix2d<EndfFloatCpp> var_GAM_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_GAM = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_DER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_DER = UNKNOWN;
                        Matrix2d<EndfFloatCpp> var_DGAM_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_DGAM = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / AJ , PJ , 0 , 0 , (6*NCH) , NCH / \n { PPI , L , SCH , BND , APE , APT } { k = 1 to NCH } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        // assign expression to variable AJ
                        var_AJ_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                        aux_AJ_read = true;
                        validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                        aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                        // assign expression to variable PJ
                        var_PJ_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                        aux_PJ_read = true;
                        validate_vartype_consistency("PJ", SCALAR_DOUBLE, aux_last_type_read_for_PJ);
                        aux_last_type_read_for_PJ = SCALAR_DOUBLE;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NCH
                        var_NCH_0d_int_Scalar = (cpp_int_val/6);
                        aux_NCH_read = true;
                        validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                        aux_last_type_read_for_NCH = SCALAR_INT;
                        if ((! (aux_NCH_read == true))) {
                          // assign expression to variable NCH
                          var_NCH_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NCH_read = true;
                          validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                          aux_last_type_read_for_NCH = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NCH_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NCH",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable PPI
                            var_PPI_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("PPI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PPI);
                            aux_last_type_read_for_PPI = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable L
                            var_L_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("L", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_L);
                            aux_last_type_read_for_L = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable SCH
                            var_SCH_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("SCH", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SCH);
                            aux_last_type_read_for_SCH = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable BND
                            var_BND_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("BND", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BND);
                            aux_last_type_read_for_BND = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable APE
                            var_APE_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("APE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APE);
                            aux_last_type_read_for_APE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable APT
                            var_APT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("APT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APT);
                            aux_last_type_read_for_APT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , NRSA , (12*NX) , NX / \n { ER , { GAM } { p = 1 to NCH } , { 0.0 } { r = 1 to num_zeros } \n DER , { DGAM } { p = 1 to NCH } , { 0.0 } { r = 1 to num_zeros } \n } { k = 1 to NRSA } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable NRSA
                        var_NRSA_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_NRSA_read = true;
                        validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                        aux_last_type_read_for_NRSA = SCALAR_INT;
                        if ((! (aux_NCH_read == true))) {
                          throw std::runtime_error("The equation (12*((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12))==value cannot be solved for NCH because the modulo operator is not supported.");
                        } else {
                          cpp_validate_field((12*((((2*(var_NCH_0d_int_Scalar+1))+(2*((5-var_NCH_0d_int_Scalar)%6)))*var_NRSA_0d_int_Scalar)/12)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(12*((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12))",
                            cpp_template, cpp_line, parse_opts);
                        }
                        if ((! (aux_NRSA_read == true))) {
                          throw std::runtime_error("The equation (12*((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12))==value cannot be solved for NRSA because the modulo operator is not supported.");
                        } else {
                          cpp_validate_field((12*((((2*(var_NCH_0d_int_Scalar+1))+(2*((5-var_NCH_0d_int_Scalar)%6)))*var_NRSA_0d_int_Scalar)/12)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(12*((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12))",
                            cpp_template, cpp_line, parse_opts);
                        }
                        if ((! (aux_NCH_read == true))) {
                          throw std::runtime_error("The equation ((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12)==value cannot be solved for NCH because the modulo operator is not supported.");
                        } else {
                          cpp_validate_field(((((2*(var_NCH_0d_int_Scalar+1))+(2*((5-var_NCH_0d_int_Scalar)%6)))*var_NRSA_0d_int_Scalar)/12), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12)",
                            cpp_template, cpp_line, parse_opts);
                        }
                        if ((! (aux_NRSA_read == true))) {
                          throw std::runtime_error("The equation ((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12)==value cannot be solved for NRSA because the modulo operator is not supported.");
                        } else {
                          cpp_validate_field(((((2*(var_NCH_0d_int_Scalar+1))+(2*((5-var_NCH_0d_int_Scalar)%6)))*var_NRSA_0d_int_Scalar)/12), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12)",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body
                          var_GAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRSA_0d_int_Scalar, false, false);
                          var_DGAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRSA_0d_int_Scalar, false, false);

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NRSA_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }

                            for (int var_p_0d_int_Scalar = 1;
                               var_p_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_p_0d_int_Scalar++) {
                              bool aux_p_read = true;
                              // read LIST body
                              // assign expression to variable GAM
                              var_GAM_2d_double_Matrix2d(var_p_0d_int_Scalar, var_k_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("GAM", MATRIX2D_DOUBLE, aux_last_type_read_for_GAM);
                              aux_last_type_read_for_GAM = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }

                            for (int var_r_0d_int_Scalar = 1;
                               var_r_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_r_0d_int_Scalar++) {
                              bool aux_r_read = true;
                              // read LIST body
                              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            // assign expression to variable DER
                            var_DER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("DER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DER);
                            aux_last_type_read_for_DER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }

                            for (int var_p_0d_int_Scalar = 1;
                               var_p_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_p_0d_int_Scalar++) {
                              bool aux_p_read = true;
                              // read LIST body
                              // assign expression to variable DGAM
                              var_DGAM_2d_double_Matrix2d(var_p_0d_int_Scalar, var_k_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("DGAM", MATRIX2D_DOUBLE, aux_last_type_read_for_DGAM);
                              aux_last_type_read_for_DGAM = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }

                            for (int var_r_0d_int_Scalar = 1;
                               var_r_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_r_0d_int_Scalar++) {
                              bool aux_r_read = true;
                              // read LIST body
                              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        // store data in Python dictionary
                        if (((aux_last_type_read_for_AJ == SCALAR_DOUBLE) && (aux_AJ_read == true))) {
                          cpp_current_dict["AJ"] = var_AJ_0d_double_Scalar;
                        }
                        if (((aux_last_type_read_for_PJ == SCALAR_DOUBLE) && (aux_PJ_read == true))) {
                          cpp_current_dict["PJ"] = var_PJ_0d_double_Scalar;
                        }
                        if (((aux_last_type_read_for_NCH == SCALAR_INT) && (aux_NCH_read == true))) {
                          cpp_current_dict["NCH"] = var_NCH_0d_int_Scalar;
                        }
                        if ((var_PPI_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["PPI"] = var_PPI_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_L_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["L"] = var_L_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_SCH_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["SCH"] = var_SCH_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_BND_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["BND"] = var_BND_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_APE_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["APE"] = var_APE_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if ((var_APT_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["APT"] = var_APT_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if (((aux_last_type_read_for_NRSA == SCALAR_INT) && (aux_NRSA_read == true))) {
                          cpp_current_dict["NRSA"] = var_NRSA_0d_int_Scalar;
                        }
                        if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["ER"] = var_ER_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if (var_GAM_2d_double_Matrix2d.did_read()) {
                          cpp_current_dict["GAM"] = var_GAM_2d_double_Matrix2d.to_pyobj(list_mode);
                        }
                        if ((var_DER_1d_double_NestedVector.get_last_index() != -1)) {
                          cpp_current_dict["DER"] = var_DER_1d_double_NestedVector.to_pyobj(list_mode);
                        }
                        if (var_DGAM_2d_double_Matrix2d.did_read()) {
                          cpp_current_dict["DGAM"] = var_DGAM_2d_double_Matrix2d.to_pyobj(list_mode);
                        }
                        cpp_current_dict = cpp_parent_dict;
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NDIGIT , NNN , NM , 0 ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NDIGIT
                    var_NDIGIT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_NDIGIT_read = true;
                    validate_vartype_consistency("NDIGIT", SCALAR_INT, aux_last_type_read_for_NDIGIT);
                    aux_last_type_read_for_NDIGIT = SCALAR_INT;
                    // assign expression to variable NNN
                    var_NNN_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_NNN_read = true;
                    validate_vartype_consistency("NNN", SCALAR_INT, aux_last_type_read_for_NNN);
                    aux_last_type_read_for_NNN = SCALAR_INT;
                    // assign expression to variable NM
                    var_NM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NM_read = true;
                    validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
                    aux_last_type_read_for_NM = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);

                    for (int var_q_0d_int_Scalar = 1;
                       var_q_0d_int_Scalar <= var_NM_0d_int_Scalar; var_q_0d_int_Scalar++) {
                      bool aux_q_read = true;
                      {
                        cpp_template = "[ MAT , 32 , 151 / II , JJ , KIJ { NDIGIT } ] INTG";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        int cpp_ndigit = var_NDIGIT_0d_int_Scalar;
                        if ((cpp_ndigit < 2 || cpp_ndigit > 6)) {
                          throw std::runtime_error("invalid NDIGIT (must be between 2 and 6)");
                        }
                        // assign expression to variable II
                        var_II_1d_int_NestedVector.set(var_q_0d_int_Scalar, cpp_read_custom_int_field(cpp_line.c_str(), 0, 5));
                        validate_vartype_consistency("II", NESTEDVECTOR_INT, aux_last_type_read_for_II);
                        aux_last_type_read_for_II = NESTEDVECTOR_INT;
                        // assign expression to variable JJ
                        var_JJ_1d_int_NestedVector.set(var_q_0d_int_Scalar, cpp_read_custom_int_field(cpp_line.c_str(), 5, 5));
                        validate_vartype_consistency("JJ", NESTEDVECTOR_INT, aux_last_type_read_for_JJ);
                        aux_last_type_read_for_JJ = NESTEDVECTOR_INT;
                        int cpp_step = cpp_ndigit + 1;
                        int cpp_end = 65;
                        int cpp_start;
                        if (cpp_ndigit <= 5) {
                          cpp_start = 11;
                        } else {
                          cpp_start = 10;
                        }
                        std::vector<int> cpp_intvec;
                        int elpos = 0;
                        for (int cpp_i = cpp_start; cpp_i < cpp_end; cpp_i += cpp_step) {
                          cpp_intvec.push_back(cpp_read_custom_int_field(cpp_line.c_str(), cpp_i, cpp_step));
                          elpos++;
                        }
                        // assign expression to variable KIJ
                        var_KIJ_1d_intvec_NestedVector.set(var_q_0d_int_Scalar, cpp_intvec);
                        validate_vartype_consistency("KIJ", NESTEDVECTOR_INTVEC, aux_last_type_read_for_KIJ);
                        aux_last_type_read_for_KIJ = NESTEDVECTOR_INTVEC;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                if ((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(2)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read CONT record
                  // assign expression to variable SPI
                  var_SPI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                  aux_SPI_read = true;
                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                  // assign expression to variable AP
                  var_AP_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                  aux_AP_read = true;
                  validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                  aux_last_type_read_for_AP = SCALAR_DOUBLE;
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable NLS
                  var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  aux_NLS_read = true;
                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                  aux_last_type_read_for_NLS = SCALAR_INT;
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);

                  for (int var_q_0d_int_Scalar = 1;
                     var_q_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_q_0d_int_Scalar++) {
                    bool aux_q_read = true;
                    // open section l_group
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      cpp_current_dict = cpp_index_shifter_store.setdefault("l_group", std::vector<int>({var_q_0d_int_Scalar}), py::dict());
                      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                      // variable declarations
                      EndfFloatCpp var_AWRI_0d_double_Scalar;
                      bool aux_AWRI_read = false;
                      vartype aux_last_type_read_for_AWRI = UNKNOWN;
                      int var_L_0d_int_Scalar;
                      bool aux_L_read = false;
                      vartype aux_last_type_read_for_L = UNKNOWN;
                      int cpp_int_val;
                      bool aux_cpp_int_val_read = false;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int var_NJS_0d_int_Scalar;
                      bool aux_NJS_read = false;
                      vartype aux_last_type_read_for_NJS = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_D_1d_double_NestedVector;
                      vartype aux_last_type_read_for_D = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                      vartype aux_last_type_read_for_AJ = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GNO_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GNO = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GG = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GF = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GX_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GX = UNKNOWN;
                      cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , L , 0 , (6*NJS) , NJS / \n { D , AJ , GNO , GG , GF , GX } { k = 1 to NJS } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      // assign expression to variable AWRI
                      var_AWRI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                      aux_AWRI_read = true;
                      validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                      aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable L
                      var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                      aux_L_read = true;
                      validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                      aux_last_type_read_for_L = SCALAR_INT;
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NJS
                      var_NJS_0d_int_Scalar = (cpp_int_val/6);
                      aux_NJS_read = true;
                      validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                      aux_last_type_read_for_NJS = SCALAR_INT;
                      if ((! (aux_NJS_read == true))) {
                        // assign expression to variable NJS
                        var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NJS_read = true;
                        validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                        aux_last_type_read_for_NJS = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NJS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NJS",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_k_0d_int_Scalar = 1;
                           var_k_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                          bool aux_k_read = true;
                          // read LIST body
                          // assign expression to variable D
                          var_D_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("D", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_D);
                          aux_last_type_read_for_D = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable AJ
                          var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                          aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GNO
                          var_GNO_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GNO", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GNO);
                          aux_last_type_read_for_GNO = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GG
                          var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                          aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GF
                          var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                          aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GX
                          var_GX_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GX", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GX);
                          aux_last_type_read_for_GX = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      // store data in Python dictionary
                      if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                        cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                      }
                      if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                        cpp_current_dict["L"] = var_L_0d_int_Scalar;
                      }
                      if (((aux_last_type_read_for_NJS == SCALAR_INT) && (aux_NJS_read == true))) {
                        cpp_current_dict["NJS"] = var_NJS_0d_int_Scalar;
                      }
                      if ((var_D_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["D"] = var_D_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["AJ"] = var_AJ_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_GNO_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["GNO"] = var_GNO_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["GG"] = var_GG_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["GF"] = var_GF_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      if ((var_GX_1d_double_NestedVector.get_last_index() != -1)) {
                        cpp_current_dict["GX"] = var_GX_1d_double_NestedVector.to_pyobj(list_mode);
                      }
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                  cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , MPAR , 0 , ((NPAR*(NPAR+1))/2) , NPAR / \n { { RV } { q = p to NPAR } } { p = 1 to NPAR } ] LIST";
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST record
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable MPAR
                  var_MPAR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                  aux_MPAR_read = true;
                  validate_vartype_consistency("MPAR", SCALAR_INT, aux_last_type_read_for_MPAR);
                  aux_last_type_read_for_MPAR = SCALAR_INT;
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable NPAR
                  var_NPAR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  aux_NPAR_read = true;
                  validate_vartype_consistency("NPAR", SCALAR_INT, aux_last_type_read_for_NPAR);
                  aux_last_type_read_for_NPAR = SCALAR_INT;
                  if ((! (aux_NPAR_read == true))) {
                    throw std::runtime_error("The equation ((NPAR*(NPAR+1))/2)==value cannot be solved for NPAR because this variable could not be isolated.");
                  } else {
                    cpp_validate_field(((var_NPAR_0d_int_Scalar*(var_NPAR_0d_int_Scalar+1))/2), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((NPAR*(NPAR+1))/2)",
                      cpp_template, cpp_line, parse_opts);
                  }
                  {
                    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    int cpp_i = 0;
                    int cpp_j = 0;
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST body
                    var_RV_2d_double_Matrix2d.init(1, var_NPAR_0d_int_Scalar, 1, var_NPAR_0d_int_Scalar, true, false);

                    for (int var_p_0d_int_Scalar = 1;
                       var_p_0d_int_Scalar <= var_NPAR_0d_int_Scalar; var_p_0d_int_Scalar++) {
                      bool aux_p_read = true;
                      // read LIST body

                      for (int var_q_0d_int_Scalar = var_p_0d_int_Scalar;
                         var_q_0d_int_Scalar <= var_NPAR_0d_int_Scalar; var_q_0d_int_Scalar++) {
                        bool aux_q_read = true;
                        // read LIST body
                        // assign expression to variable RV
                        var_RV_2d_double_Matrix2d(var_p_0d_int_Scalar, var_q_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                        validate_vartype_consistency("RV", MATRIX2D_DOUBLE, aux_last_type_read_for_RV);
                        aux_last_type_read_for_RV = MATRIX2D_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                      }
                    }
                    if (cpp_i != cpp_npl) {
                      throw std::runtime_error("not exactly NPL elements consumed");
                    }
                  }
                }
              }
            }
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_EL == SCALAR_DOUBLE) && (aux_EL_read == true))) {
            cpp_current_dict["EL"] = var_EL_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_EH == SCALAR_DOUBLE) && (aux_EH_read == true))) {
            cpp_current_dict["EH"] = var_EH_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_LRU == SCALAR_INT) && (aux_LRU_read == true))) {
            cpp_current_dict["LRU"] = var_LRU_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_LRF == SCALAR_INT) && (aux_LRF_read == true))) {
            cpp_current_dict["LRF"] = var_LRF_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NRO == SCALAR_INT) && (aux_NRO_read == true))) {
            cpp_current_dict["NRO"] = var_NRO_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NAPS == SCALAR_INT) && (aux_NAPS_read == true))) {
            cpp_current_dict["NAPS"] = var_NAPS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NI == SCALAR_INT) && (aux_NI_read == true))) {
            cpp_current_dict["NI"] = var_NI_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_SPI == SCALAR_DOUBLE) && (aux_SPI_read == true))) {
            cpp_current_dict["SPI"] = var_SPI_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_AP == SCALAR_DOUBLE) && (aux_AP_read == true))) {
            cpp_current_dict["AP"] = var_AP_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_LCOMP == SCALAR_INT) && (aux_LCOMP_read == true))) {
            cpp_current_dict["LCOMP"] = var_LCOMP_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NLS == SCALAR_INT) && (aux_NLS_read == true))) {
            cpp_current_dict["NLS"] = var_NLS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_ISR == SCALAR_INT) && (aux_ISR_read == true))) {
            cpp_current_dict["ISR"] = var_ISR_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_DAP == SCALAR_DOUBLE) && (aux_DAP_read == true))) {
            cpp_current_dict["DAP"] = var_DAP_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
            cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_NSRS == SCALAR_INT) && (aux_NSRS_read == true))) {
            cpp_current_dict["NSRS"] = var_NSRS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NLRS == SCALAR_INT) && (aux_NLRS_read == true))) {
            cpp_current_dict["NLRS"] = var_NLRS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_MLS == SCALAR_INT) && (aux_MLS_read == true))) {
            cpp_current_dict["MLS"] = var_MLS_0d_int_Scalar;
          }
          if ((var_DAP_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["DAP"] = var_DAP_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if (((aux_last_type_read_for_JCH == SCALAR_INT) && (aux_JCH_read == true))) {
            cpp_current_dict["JCH"] = var_JCH_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NCH == SCALAR_INT) && (aux_NCH_read == true))) {
            cpp_current_dict["NCH"] = var_NCH_0d_int_Scalar;
          }
          if (var_DAP_2d_double_Matrix2d.did_read()) {
            cpp_current_dict["DAP"] = var_DAP_2d_double_Matrix2d.to_pyobj(list_mode);
          }
          if (((aux_last_type_read_for_QX == SCALAR_DOUBLE) && (aux_QX_read == true))) {
            cpp_current_dict["QX"] = var_QX_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_LRX == SCALAR_INT) && (aux_LRX_read == true))) {
            cpp_current_dict["LRX"] = var_LRX_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NRSA == SCALAR_INT) && (aux_NRSA_read == true))) {
            cpp_current_dict["NRSA"] = var_NRSA_0d_int_Scalar;
          }
          if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["ER"] = var_ER_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["AJ"] = var_AJ_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_GT_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["GT"] = var_GT_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_GN_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["GN"] = var_GN_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["GG"] = var_GG_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["GF"] = var_GF_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_DER_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["DER"] = var_DER_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_DGN_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["DGN"] = var_DGN_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_DGG_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["DGG"] = var_DGG_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_DGF_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["DGF"] = var_DGF_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if (((aux_last_type_read_for_NDIGIT == SCALAR_INT) && (aux_NDIGIT_read == true))) {
            cpp_current_dict["NDIGIT"] = var_NDIGIT_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NNN == SCALAR_INT) && (aux_NNN_read == true))) {
            cpp_current_dict["NNN"] = var_NNN_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NM == SCALAR_INT) && (aux_NM_read == true))) {
            cpp_current_dict["NM"] = var_NM_0d_int_Scalar;
          }
          if ((var_II_1d_int_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["II"] = var_II_1d_int_NestedVector.to_pyobj(list_mode);
          }
          if ((var_JJ_1d_int_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["JJ"] = var_JJ_1d_int_NestedVector.to_pyobj(list_mode);
          }
          if ((var_KIJ_1d_intvec_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["KIJ"] = var_KIJ_1d_intvec_NestedVector.to_pyobj(list_mode);
          }
          if (((aux_last_type_read_for_LAD == SCALAR_INT) && (aux_LAD_read == true))) {
            cpp_current_dict["LAD"] = var_LAD_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_APL == SCALAR_DOUBLE) && (aux_APL_read == true))) {
            cpp_current_dict["APL"] = var_APL_0d_double_Scalar;
          }
          if ((var_GFA_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["GFA"] = var_GFA_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_GFB_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["GFB"] = var_GFB_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_DGFA_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["DGFA"] = var_DGFA_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_DGFB_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["DGFB"] = var_DGFB_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if (((aux_last_type_read_for_IFG == SCALAR_INT) && (aux_IFG_read == true))) {
            cpp_current_dict["IFG"] = var_IFG_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NJS == SCALAR_INT) && (aux_NJS_read == true))) {
            cpp_current_dict["NJS"] = var_NJS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NJCH == SCALAR_INT) && (aux_NJCH_read == true))) {
            cpp_current_dict["NJCH"] = var_NJCH_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NPP == SCALAR_INT) && (aux_NPP_read == true))) {
            cpp_current_dict["NPP"] = var_NPP_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NJSX == SCALAR_INT) && (aux_NJSX_read == true))) {
            cpp_current_dict["NJSX"] = var_NJSX_0d_int_Scalar;
          }
          if ((var_MA_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["MA"] = var_MA_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_MB_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["MB"] = var_MB_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_ZA_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["ZA"] = var_ZA_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_ZB_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["ZB"] = var_ZB_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_IA_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["IA"] = var_IA_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_IB_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["IB"] = var_IB_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_Q_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["Q"] = var_Q_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_PNT_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["PNT"] = var_PNT_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_SHF_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["SHF"] = var_SHF_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_MT_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["MT"] = var_MT_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_PA_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["PA"] = var_PA_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if ((var_PB_1d_double_NestedVector.get_last_index() != -1)) {
            cpp_current_dict["PB"] = var_PB_1d_double_NestedVector.to_pyobj(list_mode);
          }
          if (((aux_last_type_read_for_MPAR == SCALAR_INT) && (aux_MPAR_read == true))) {
            cpp_current_dict["MPAR"] = var_MPAR_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NPAR == SCALAR_INT) && (aux_NPAR_read == true))) {
            cpp_current_dict["NPAR"] = var_NPAR_0d_int_Scalar;
          }
          if (var_RV_2d_double_Matrix2d.did_read()) {
            cpp_current_dict["RV"] = var_RV_2d_double_Matrix2d.to_pyobj(list_mode);
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_ZAI == SCALAR_DOUBLE) && (aux_ZAI_read == true))) {
        cpp_current_dict["ZAI"] = var_ZAI_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_ABN == SCALAR_DOUBLE) && (aux_ABN_read == true))) {
        cpp_current_dict["ABN"] = var_ABN_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_LFW == SCALAR_INT) && (aux_LFW_read == true))) {
        cpp_current_dict["LFW"] = var_LFW_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NER == SCALAR_INT) && (aux_NER_read == true))) {
        cpp_current_dict["NER"] = var_NER_0d_int_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NIS == SCALAR_INT) && (aux_NIS_read == true))) {
    cpp_current_dict["NIS"] = var_NIS_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 284c3ace698a427c06623ccd760dca26
// MD5 hash of the following function definition: 53f1a42a0e0d854b7681496b0834ebf5
py::dict parse_mf33_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_MTL_0d_int_Scalar;
  bool aux_MTL_read = false;
  vartype aux_last_type_read_for_MTL = UNKNOWN;
  int var_NL_0d_int_Scalar;
  bool aux_NL_read = false;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 33;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 33;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 33 , MT / ZA , AWR , 0 , MTL , 0 , NL ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable MTL
  var_MTL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_MTL_read = true;
  validate_vartype_consistency("MTL", SCALAR_INT, aux_last_type_read_for_MTL);
  aux_last_type_read_for_MTL = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NL
  var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NL_read = true;
  validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
  aux_last_type_read_for_NL = SCALAR_INT;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_MTL_read == true)) && ((var_MTL_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;

        for (int var_n_0d_int_Scalar = 1;
           var_n_0d_int_Scalar <= var_NL_0d_int_Scalar; var_n_0d_int_Scalar++) {
          bool aux_n_read = true;
          // open section subsection
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.setdefault("subsection", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            // variable declarations
            EndfFloatCpp var_XMF1_0d_double_Scalar;
            bool aux_XMF1_read = false;
            vartype aux_last_type_read_for_XMF1 = UNKNOWN;
            EndfFloatCpp var_XLFS1_0d_double_Scalar;
            bool aux_XLFS1_read = false;
            vartype aux_last_type_read_for_XLFS1 = UNKNOWN;
            int var_MAT1_0d_int_Scalar;
            bool aux_MAT1_read = false;
            vartype aux_last_type_read_for_MAT1 = UNKNOWN;
            int var_MT1_0d_int_Scalar;
            bool aux_MT1_read = false;
            vartype aux_last_type_read_for_MT1 = UNKNOWN;
            int var_NC_0d_int_Scalar;
            bool aux_NC_read = false;
            vartype aux_last_type_read_for_NC = UNKNOWN;
            int var_NI_0d_int_Scalar;
            bool aux_NI_read = false;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            cpp_template = "[ MAT , 33 , MT / XMF1 , XLFS1 , MAT1 , MT1 , NC , NI ] CONT";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable XMF1
            var_XMF1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
            aux_XMF1_read = true;
            validate_vartype_consistency("XMF1", SCALAR_DOUBLE, aux_last_type_read_for_XMF1);
            aux_last_type_read_for_XMF1 = SCALAR_DOUBLE;
            // assign expression to variable XLFS1
            var_XLFS1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
            aux_XLFS1_read = true;
            validate_vartype_consistency("XLFS1", SCALAR_DOUBLE, aux_last_type_read_for_XLFS1);
            aux_last_type_read_for_XLFS1 = SCALAR_DOUBLE;
            // assign expression to variable MAT1
            var_MAT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_MAT1_read = true;
            validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
            aux_last_type_read_for_MAT1 = SCALAR_INT;
            // assign expression to variable MT1
            var_MT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_MT1_read = true;
            validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
            aux_last_type_read_for_MT1 = SCALAR_INT;
            // assign expression to variable NC
            var_NC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NC_read = true;
            validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
            aux_last_type_read_for_NC = SCALAR_INT;
            // assign expression to variable NI
            var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NC_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section nc_subsection
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.setdefault("nc_subsection", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                // variable declarations
                int var_LTY_0d_int_Scalar;
                bool aux_LTY_read = false;
                vartype aux_last_type_read_for_LTY = UNKNOWN;
                EndfFloatCpp var_E1_0d_double_Scalar;
                bool aux_E1_read = false;
                vartype aux_last_type_read_for_E1 = UNKNOWN;
                EndfFloatCpp var_E2_0d_double_Scalar;
                bool aux_E2_read = false;
                vartype aux_last_type_read_for_E2 = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NCI_0d_int_Scalar;
                bool aux_NCI_read = false;
                vartype aux_last_type_read_for_NCI = UNKNOWN;
                NestedVector<EndfFloatCpp> var_C_1d_double_NestedVector;
                vartype aux_last_type_read_for_C = UNKNOWN;
                NestedVector<EndfFloatCpp> var_XMT_1d_double_NestedVector;
                vartype aux_last_type_read_for_XMT = UNKNOWN;
                int var_MATS_0d_int_Scalar;
                bool aux_MATS_read = false;
                vartype aux_last_type_read_for_MATS = UNKNOWN;
                int var_MTS_0d_int_Scalar;
                bool aux_MTS_read = false;
                vartype aux_last_type_read_for_MTS = UNKNOWN;
                int var_NEI_0d_int_Scalar;
                bool aux_NEI_read = false;
                vartype aux_last_type_read_for_NEI = UNKNOWN;
                EndfFloatCpp var_XMFS_0d_double_Scalar;
                bool aux_XMFS_read = false;
                vartype aux_last_type_read_for_XMFS = UNKNOWN;
                EndfFloatCpp var_XLFSS_0d_double_Scalar;
                bool aux_XLFSS_read = false;
                vartype aux_last_type_read_for_XLFSS = UNKNOWN;
                NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                NestedVector<EndfFloatCpp> var_WE_1d_double_NestedVector;
                vartype aux_last_type_read_for_WE = UNKNOWN;
                cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read CONT record
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LTY
                var_LTY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LTY_read = true;
                validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                aux_last_type_read_for_LTY = SCALAR_INT;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if ((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(0)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      cpp_template = "[ MAT , 33 , MT / E1 , E2 , 0 , 0 , (2*NCI) , NCI / \n { C , XMT } { i = 1 to NCI } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      // assign expression to variable E1
                      var_E1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                      aux_E1_read = true;
                      validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                      aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                      // assign expression to variable E2
                      var_E2_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                      aux_E2_read = true;
                      validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                      aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NCI
                      var_NCI_0d_int_Scalar = (cpp_int_val/2);
                      aux_NCI_read = true;
                      validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                      aux_last_type_read_for_NCI = SCALAR_INT;
                      if ((! (aux_NCI_read == true))) {
                        // assign expression to variable NCI
                        var_NCI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NCI_read = true;
                        validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                        aux_last_type_read_for_NCI = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NCI_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NCI",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_i_0d_int_Scalar = 1;
                           var_i_0d_int_Scalar <= var_NCI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                          bool aux_i_read = true;
                          // read LIST body
                          // assign expression to variable C
                          var_C_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
                          aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable XMT
                          var_XMT_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("XMT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_XMT);
                          aux_last_type_read_for_XMT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if (((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)>=(1)))))&&((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)<=(3)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 33 , MT / E1 , E2 , MATS , MTS , ((2*NEI)+2) , NEI / \n XMFS , XLFSS , { E , WE } { i = 1 to NEI } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        // assign expression to variable E1
                        var_E1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                        aux_E1_read = true;
                        validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                        aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                        // assign expression to variable E2
                        var_E2_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                        aux_E2_read = true;
                        validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                        aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                        // assign expression to variable MATS
                        var_MATS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_MATS_read = true;
                        validate_vartype_consistency("MATS", SCALAR_INT, aux_last_type_read_for_MATS);
                        aux_last_type_read_for_MATS = SCALAR_INT;
                        // assign expression to variable MTS
                        var_MTS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_MTS_read = true;
                        validate_vartype_consistency("MTS", SCALAR_INT, aux_last_type_read_for_MTS);
                        aux_last_type_read_for_MTS = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NEI
                        var_NEI_0d_int_Scalar = ((cpp_int_val+(-2))/2);
                        aux_NEI_read = true;
                        validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                        aux_last_type_read_for_NEI = SCALAR_INT;
                        if ((! (aux_NEI_read == true))) {
                          // assign expression to variable NEI
                          var_NEI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NEI_read = true;
                          validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                          aux_last_type_read_for_NEI = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NEI_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NEI",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body
                          // assign expression to variable XMFS
                          var_XMFS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                          aux_XMFS_read = true;
                          validate_vartype_consistency("XMFS", SCALAR_DOUBLE, aux_last_type_read_for_XMFS);
                          aux_last_type_read_for_XMFS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable XLFSS
                          var_XLFSS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                          aux_XLFSS_read = true;
                          validate_vartype_consistency("XLFSS", SCALAR_DOUBLE, aux_last_type_read_for_XLFSS);
                          aux_last_type_read_for_XLFSS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }

                          for (int var_i_0d_int_Scalar = 1;
                             var_i_0d_int_Scalar <= var_NEI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                            bool aux_i_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable WE
                            var_WE_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("WE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_WE);
                            aux_last_type_read_for_WE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_LTY == SCALAR_INT) && (aux_LTY_read == true))) {
                  cpp_current_dict["LTY"] = var_LTY_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_E1 == SCALAR_DOUBLE) && (aux_E1_read == true))) {
                  cpp_current_dict["E1"] = var_E1_0d_double_Scalar;
                }
                if (((aux_last_type_read_for_E2 == SCALAR_DOUBLE) && (aux_E2_read == true))) {
                  cpp_current_dict["E2"] = var_E2_0d_double_Scalar;
                }
                if (((aux_last_type_read_for_NCI == SCALAR_INT) && (aux_NCI_read == true))) {
                  cpp_current_dict["NCI"] = var_NCI_0d_int_Scalar;
                }
                if ((var_C_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["C"] = var_C_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_XMT_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["XMT"] = var_XMT_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if (((aux_last_type_read_for_MATS == SCALAR_INT) && (aux_MATS_read == true))) {
                  cpp_current_dict["MATS"] = var_MATS_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_MTS == SCALAR_INT) && (aux_MTS_read == true))) {
                  cpp_current_dict["MTS"] = var_MTS_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NEI == SCALAR_INT) && (aux_NEI_read == true))) {
                  cpp_current_dict["NEI"] = var_NEI_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_XMFS == SCALAR_DOUBLE) && (aux_XMFS_read == true))) {
                  cpp_current_dict["XMFS"] = var_XMFS_0d_double_Scalar;
                }
                if (((aux_last_type_read_for_XLFSS == SCALAR_DOUBLE) && (aux_XLFSS_read == true))) {
                  cpp_current_dict["XLFSS"] = var_XLFSS_0d_double_Scalar;
                }
                if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_WE_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["WE"] = var_WE_1d_double_NestedVector.to_pyobj(list_mode);
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NI_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section ni_subsection
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.setdefault("ni_subsection", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                // variable declarations
                int var_LT_0d_int_Scalar;
                bool aux_LT_read = false;
                vartype aux_last_type_read_for_LT = UNKNOWN;
                int var_LB_0d_int_Scalar;
                bool aux_LB_read = false;
                vartype aux_last_type_read_for_LB = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NP_0d_int_Scalar;
                bool aux_NP_read = false;
                vartype aux_last_type_read_for_NP = UNKNOWN;
                NestedVector<EndfFloatCpp> var_Ek_1d_double_NestedVector;
                vartype aux_last_type_read_for_Ek = UNKNOWN;
                NestedVector<EndfFloatCpp> var_Fk_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fk = UNKNOWN;
                NestedVector<EndfFloatCpp> var_El_1d_double_NestedVector;
                vartype aux_last_type_read_for_El = UNKNOWN;
                NestedVector<EndfFloatCpp> var_Fl_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fl = UNKNOWN;
                int var_LS_0d_int_Scalar;
                bool aux_LS_read = false;
                vartype aux_last_type_read_for_LS = UNKNOWN;
                int var_NE_0d_int_Scalar;
                bool aux_NE_read = false;
                vartype aux_last_type_read_for_NE = UNKNOWN;
                NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                Matrix2d<EndfFloatCpp> var_F_2d_double_Matrix2d;
                vartype aux_last_type_read_for_F = UNKNOWN;
                int var_NER_0d_int_Scalar;
                bool aux_NER_read = false;
                vartype aux_last_type_read_for_NER = UNKNOWN;
                int var_NEC_0d_int_Scalar;
                bool aux_NEC_read = false;
                vartype aux_last_type_read_for_NEC = UNKNOWN;
                NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                vartype aux_last_type_read_for_ER = UNKNOWN;
                NestedVector<EndfFloatCpp> var_EC_1d_double_NestedVector;
                vartype aux_last_type_read_for_EC = UNKNOWN;
                NestedVector<EndfFloatCpp> var_F_1d_double_NestedVector;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                        int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                        bool& glob_aux_LT_read = aux_LT_read;
                        bool aux_LT_read = glob_aux_LT_read;
                        vartype aux_last_type_read_for_LT = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_cpp_int_val = cpp_int_val;
                        int cpp_int_val = glob_cpp_int_val;
                        bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                        bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                        int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                        bool& glob_aux_NP_read = aux_NP_read;
                        bool aux_NP_read = glob_aux_NP_read;
                        vartype aux_last_type_read_for_NP = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)>=(0)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)<=(4)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NP",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= (var_NP_0d_int_Scalar-var_LT_0d_int_Scalar); var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable Ek
                            var_Ek_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Ek", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ek);
                            aux_last_type_read_for_Ek = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable Fk
                            var_Fk_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Fk", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fk);
                            aux_last_type_read_for_Fk = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_LT_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable El
                            var_El_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("El", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_El);
                            aux_last_type_read_for_El = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable Fl
                            var_Fl_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Fl", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fl);
                            aux_last_type_read_for_Fl = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                            cpp_line = cpp_read_raw_line(cont);
                            // read LIST record
                            // assign expression to variable LS
                            var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_LS_read = true;
                            validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                            aux_last_type_read_for_LS = SCALAR_INT;
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable NE
                            var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NE_read = true;
                            validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                            aux_last_type_read_for_NE = SCALAR_INT;
                            if ((! (aux_NE_read == true))) {
                              throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE-1))+1) , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                            cpp_validate_field(((var_NE_0d_int_Scalar*(var_NE_0d_int_Scalar-1))+1), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((NE*(NE-1))+1)",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = 1;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                            cpp_line = cpp_read_raw_line(cont);
                            // read LIST record
                            // assign expression to variable LS
                            var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_LS_read = true;
                            validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                            aux_last_type_read_for_LS = SCALAR_INT;
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable NE
                            var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NE_read = true;
                            validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                            aux_last_type_read_for_NE = SCALAR_INT;
                            if ((! (aux_NE_read == true))) {
                              throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE+1))/2) , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                            cpp_validate_field(((var_NE_0d_int_Scalar*(var_NE_0d_int_Scalar+1))/2), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((NE*(NE+1))/2)",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = var_k_0d_int_Scalar;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NER_0d_int_Scalar = var_NER_0d_int_Scalar;
                          int var_NER_0d_int_Scalar = glob_var_NER_0d_int_Scalar;
                          bool& glob_aux_NER_read = aux_NER_read;
                          bool aux_NER_read = glob_aux_NER_read;
                          vartype aux_last_type_read_for_NER = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NEC_0d_int_Scalar = var_NEC_0d_int_Scalar;
                          int var_NEC_0d_int_Scalar = glob_var_NEC_0d_int_Scalar;
                          bool& glob_aux_NEC_read = aux_NEC_read;
                          bool aux_NEC_read = glob_aux_NEC_read;
                          vartype aux_last_type_read_for_NEC = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                            cpp_line = cpp_read_raw_line(cont);
                            // read LIST record
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NEC
                            var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                            aux_NEC_read = true;
                            validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                            aux_last_type_read_for_NEC = SCALAR_INT;
                            if ((! (aux_NER_read == true))) {
                              // assign expression to variable cpp_int_val
                              cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_cpp_int_val_read = true;
                              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                              // assign expression to variable NER
                              var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                              aux_NER_read = true;
                              validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                              aux_last_type_read_for_NER = SCALAR_INT;
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if ((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(6)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , 0 , LB , (1+(NER*NEC)) , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NEC
                          var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                          aux_NEC_read = true;
                          validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                          aux_last_type_read_for_NEC = SCALAR_INT;
                          if ((! (aux_NER_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                          } else {
                            cpp_validate_field((1+(var_NER_0d_int_Scalar*var_NEC_0d_int_Scalar)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(1+(NER*NEC))",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NER_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable ER
                              var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                              aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NEC_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable EC
                              var_EC_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("EC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EC);
                              aux_last_type_read_for_EC = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NER_0d_int_Scalar-1), 1, (var_NEC_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NER_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_l_0d_int_Scalar = 1;
                                 var_l_0d_int_Scalar <= (var_NEC_0d_int_Scalar-1); var_l_0d_int_Scalar++) {
                                bool aux_l_read = true;
                                // read LIST body
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_l_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                          int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                          bool& glob_aux_LT_read = aux_LT_read;
                          bool aux_LT_read = glob_aux_LT_read;
                          vartype aux_last_type_read_for_LT = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                          int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                          bool& glob_aux_NP_read = aux_NP_read;
                          bool aux_NP_read = glob_aux_NP_read;
                          vartype aux_last_type_read_for_NP = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                            cpp_line = cpp_read_raw_line(cont);
                            // read LIST record
                            // assign expression to variable LT
                            var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_LT_read = true;
                            validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                            aux_last_type_read_for_LT = SCALAR_INT;
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = (cpp_int_val/2);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                            if ((! (aux_NP_read == true))) {
                              // assign expression to variable NP
                              var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              aux_NP_read = true;
                              validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                              aux_last_type_read_for_NP = SCALAR_INT;
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if ((((((((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(8))))))||(((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(9)))))))))&&((((aux_LT_read == true)) && ((var_LT_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                            cpp_validate_field(var_NP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NP",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable F
                              var_F_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_LT == SCALAR_INT) && (aux_LT_read == true))) {
                  cpp_current_dict["LT"] = var_LT_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_LB == SCALAR_INT) && (aux_LB_read == true))) {
                  cpp_current_dict["LB"] = var_LB_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NP == SCALAR_INT) && (aux_NP_read == true))) {
                  cpp_current_dict["NP"] = var_NP_0d_int_Scalar;
                }
                if ((var_Ek_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["Ek"] = var_Ek_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_Fk_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["Fk"] = var_Fk_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_El_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["El"] = var_El_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_Fl_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["Fl"] = var_Fl_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if (((aux_last_type_read_for_LS == SCALAR_INT) && (aux_LS_read == true))) {
                  cpp_current_dict["LS"] = var_LS_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
                  cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
                }
                if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if (var_F_2d_double_Matrix2d.did_read()) {
                  cpp_current_dict["F"] = var_F_2d_double_Matrix2d.to_pyobj(list_mode);
                }
                if (((aux_last_type_read_for_NER == SCALAR_INT) && (aux_NER_read == true))) {
                  cpp_current_dict["NER"] = var_NER_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NEC == SCALAR_INT) && (aux_NEC_read == true))) {
                  cpp_current_dict["NEC"] = var_NEC_0d_int_Scalar;
                }
                if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["ER"] = var_ER_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_EC_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["EC"] = var_EC_1d_double_NestedVector.to_pyobj(list_mode);
                }
                if ((var_F_1d_double_NestedVector.get_last_index() != -1)) {
                  cpp_current_dict["F"] = var_F_1d_double_NestedVector.to_pyobj(list_mode);
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_XMF1 == SCALAR_DOUBLE) && (aux_XMF1_read == true))) {
              cpp_current_dict["XMF1"] = var_XMF1_0d_double_Scalar;
            }
            if (((aux_last_type_read_for_XLFS1 == SCALAR_DOUBLE) && (aux_XLFS1_read == true))) {
              cpp_current_dict["XLFS1"] = var_XLFS1_0d_double_Scalar;
            }
            if (((aux_last_type_read_for_MAT1 == SCALAR_INT) && (aux_MAT1_read == true))) {
              cpp_current_dict["MAT1"] = var_MAT1_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_MT1 == SCALAR_INT) && (aux_MT1_read == true))) {
              cpp_current_dict["MT1"] = var_MT1_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
              cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_NI == SCALAR_INT) && (aux_NI_read == true))) {
              cpp_current_dict["NI"] = var_NI_0d_int_Scalar;
            }
            cpp_current_dict = cpp_parent_dict;
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_MTL == SCALAR_INT) && (aux_MTL_read == true))) {
    cpp_current_dict["MTL"] = var_MTL_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NL == SCALAR_INT) && (aux_NL_read == true))) {
    cpp_current_dict["NL"] = var_NL_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 8421256b750ec19b722b38ddb32ece21
// MD5 hash of the following function definition: b0a0a194936faf9a3fa9bf9cfd3fadae
py::dict parse_mf34_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LTT_0d_int_Scalar;
  bool aux_LTT_read = false;
  vartype aux_last_type_read_for_LTT = UNKNOWN;
  int var_NMT1_0d_int_Scalar;
  bool aux_NMT1_read = false;
  vartype aux_last_type_read_for_NMT1 = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 34;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 34;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 34 , MT / ZA , AWR , 0 , LTT , 0 , NMT1 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LTT
  var_LTT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LTT_read = true;
  validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
  aux_last_type_read_for_LTT = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NMT1
  var_NMT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NMT1_read = true;
  validate_vartype_consistency("NMT1", SCALAR_INT, aux_last_type_read_for_NMT1);
  aux_last_type_read_for_NMT1 = SCALAR_INT;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NMT1_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.setdefault("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      int var_MAT1_0d_int_Scalar;
      bool aux_MAT1_read = false;
      vartype aux_last_type_read_for_MAT1 = UNKNOWN;
      int var_MT1_0d_int_Scalar;
      bool aux_MT1_read = false;
      vartype aux_last_type_read_for_MT1 = UNKNOWN;
      int var_NL_0d_int_Scalar;
      bool aux_NL_read = false;
      vartype aux_last_type_read_for_NL = UNKNOWN;
      NestedVector<int> var_L_1d_int_NestedVector;
      vartype aux_last_type_read_for_L = UNKNOWN;
      NestedVector<int> var_L1_1d_int_NestedVector;
      vartype aux_last_type_read_for_L1 = UNKNOWN;
      int var_LCT_0d_int_Scalar;
      bool aux_LCT_read = false;
      vartype aux_last_type_read_for_LCT = UNKNOWN;
      NestedVector<int> var_NI_1d_int_NestedVector;
      vartype aux_last_type_read_for_NI = UNKNOWN;
      NestedVector<NestedVector<int>> var_LS_2d_int_NestedVector;
      NestedVector<int>* ptr_LS_2d_idx0;
      vartype aux_last_type_read_for_LS = UNKNOWN;
      NestedVector<NestedVector<int>> var_LB_2d_int_NestedVector;
      NestedVector<int>* ptr_LB_2d_idx0;
      vartype aux_last_type_read_for_LB = UNKNOWN;
      NestedVector<NestedVector<int>> var_NT_2d_int_NestedVector;
      NestedVector<int>* ptr_NT_2d_idx0;
      vartype aux_last_type_read_for_NT = UNKNOWN;
      NestedVector<NestedVector<int>> var_NE_2d_int_NestedVector;
      NestedVector<int>* ptr_NE_2d_idx0;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      NestedVector<NestedVector<NestedVector<EndfFloatCpp>>> var_Data_3d_double_NestedVector;
      NestedVector<EndfFloatCpp>* ptr_Data_3d_idx1;
      NestedVector<NestedVector<EndfFloatCpp>>* ptr_Data_3d_idx0;
      vartype aux_last_type_read_for_Data = UNKNOWN;
      int var_NL1_0d_int_Scalar;
      bool aux_NL1_read = false;
      vartype aux_last_type_read_for_NL1 = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            std::streampos cpp_old_streampos = cont.tellg();
            {
              // variable declarations
              int& glob_var_MAT1_0d_int_Scalar = var_MAT1_0d_int_Scalar;
              int var_MAT1_0d_int_Scalar = glob_var_MAT1_0d_int_Scalar;
              bool& glob_aux_MAT1_read = aux_MAT1_read;
              bool aux_MAT1_read = glob_aux_MAT1_read;
              vartype aux_last_type_read_for_MAT1 = UNKNOWN;
              int& glob_var_MT1_0d_int_Scalar = var_MT1_0d_int_Scalar;
              int var_MT1_0d_int_Scalar = glob_var_MT1_0d_int_Scalar;
              bool& glob_aux_MT1_read = aux_MT1_read;
              bool aux_MT1_read = glob_aux_MT1_read;
              vartype aux_last_type_read_for_MT1 = UNKNOWN;
              int& glob_var_NL_0d_int_Scalar = var_NL_0d_int_Scalar;
              int var_NL_0d_int_Scalar = glob_var_NL_0d_int_Scalar;
              bool& glob_aux_NL_read = aux_NL_read;
              bool aux_NL_read = glob_aux_NL_read;
              vartype aux_last_type_read_for_NL = UNKNOWN;
              try {
                cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , MAT1 , MT1 , NL , NL ] CONT";
                cpp_line = cpp_read_raw_line(cont);
                // read CONT record
                // assign expression to variable MAT1
                var_MAT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                aux_MAT1_read = true;
                validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
                aux_last_type_read_for_MAT1 = SCALAR_INT;
                // assign expression to variable MT1
                var_MT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_MT1_read = true;
                validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
                aux_last_type_read_for_MT1 = SCALAR_INT;
                // assign expression to variable NL
                var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                aux_NL_read = true;
                validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = SCALAR_INT;
                if ((! (aux_NL_read == true))) {
                  // assign expression to variable NL
                  var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  aux_NL_read = true;
                  validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
                  aux_last_type_read_for_NL = SCALAR_INT;
                } else {
                }
              } catch (const std::out_of_range& e) {
                // // accept failure in lookahead
              }
              if (((((((((aux_MT1_read == true)) && ((var_MT1_0d_int_Scalar)==(0))))))||(((((aux_MT_read == true)) && ((var_MT_0d_int_Scalar)==(var_MT1_0d_int_Scalar)))))))) {
                cpp_found_match = true;
              }
              cont.seekg(cpp_old_streampos);
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , MAT1 , MT1 , NL , NL ] CONT";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read CONT record
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable MAT1
              var_MAT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_MAT1_read = true;
              validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
              aux_last_type_read_for_MAT1 = SCALAR_INT;
              // assign expression to variable MT1
              var_MT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_MT1_read = true;
              validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
              aux_last_type_read_for_MT1 = SCALAR_INT;
              // assign expression to variable NL
              var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_NL_read = true;
              validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
              aux_last_type_read_for_NL = SCALAR_INT;
              if ((! (aux_NL_read == true))) {
                // assign expression to variable NL
                var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                aux_NL_read = true;
                validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = SCALAR_INT;
              } else {
                cpp_validate_field(var_NL_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NL",
                  cpp_template, cpp_line, parse_opts);
              }

              for (int var_n_0d_int_Scalar = 1;
                 var_n_0d_int_Scalar <= ((var_NL_0d_int_Scalar*(var_NL_0d_int_Scalar+1))/2); var_n_0d_int_Scalar++) {
                bool aux_n_read = true;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if ((((((((aux_n_read == true)) && ((var_n_0d_int_Scalar)==(1)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , LCT , NI ] CONT";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read CONT record
                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable L
                      var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
                      validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                      aux_last_type_read_for_L = NESTEDVECTOR_INT;
                      // assign expression to variable L1
                      var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
                      validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                      aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                      // assign expression to variable LCT
                      var_LCT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_LCT_read = true;
                      validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
                      aux_last_type_read_for_LCT = SCALAR_INT;
                      // assign expression to variable NI
                      var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                      validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                      aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                    }
                  }
                  if (! cpp_found_match) {
                    cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , 0 , NI ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable L
                    var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
                    validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                    aux_last_type_read_for_L = NESTEDVECTOR_INT;
                    // assign expression to variable L1
                    var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
                    validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                    aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NI
                    var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                    validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                    aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                  }
                }
                ptr_LS_2d_idx0 = var_LS_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                ptr_LB_2d_idx0 = var_LB_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                ptr_NE_2d_idx0 = var_NE_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                ptr_Data_3d_idx0 = var_Data_3d_double_NestedVector.prepare(var_n_0d_int_Scalar);

                for (int var_m_0d_int_Scalar = 1;
                   var_m_0d_int_Scalar <= var_NI_1d_int_NestedVector[var_n_0d_int_Scalar]; var_m_0d_int_Scalar++) {
                  bool aux_m_read = true;
                  cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { Data } { q = 1 to NT } ] LIST";
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST record
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable LS
                  ptr_LS_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
                  validate_vartype_consistency("LS", NESTEDVECTOR_INT, aux_last_type_read_for_LS);
                  aux_last_type_read_for_LS = NESTEDVECTOR_INT;
                  // assign expression to variable LB
                  ptr_LB_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
                  validate_vartype_consistency("LB", NESTEDVECTOR_INT, aux_last_type_read_for_LB);
                  aux_last_type_read_for_LB = NESTEDVECTOR_INT;
                  // assign expression to variable NT
                  ptr_NT_2d_idx0 = var_NT_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                  ptr_NT_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
                  validate_vartype_consistency("NT", NESTEDVECTOR_INT, aux_last_type_read_for_NT);
                  aux_last_type_read_for_NT = NESTEDVECTOR_INT;
                  // assign expression to variable NE
                  ptr_NE_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                  validate_vartype_consistency("NE", NESTEDVECTOR_INT, aux_last_type_read_for_NE);
                  aux_last_type_read_for_NE = NESTEDVECTOR_INT;
                  {
                    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    int cpp_i = 0;
                    int cpp_j = 0;
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST body
                    ptr_Data_3d_idx1 = ptr_Data_3d_idx0->prepare(var_m_0d_int_Scalar);

                    for (int var_q_0d_int_Scalar = 1;
                       var_q_0d_int_Scalar <= var_NT_2d_int_NestedVector[var_n_0d_int_Scalar][var_m_0d_int_Scalar]; var_q_0d_int_Scalar++) {
                      bool aux_q_read = true;
                      // read LIST body
                      // assign expression to variable Data
                      ptr_Data_3d_idx1->set(var_q_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                      validate_vartype_consistency("Data", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Data);
                      aux_last_type_read_for_Data = NESTEDVECTOR_DOUBLE;
                      cpp_i++;
                      cpp_j++;
                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        cpp_j = 0;
                      }
                    }
                    if (cpp_i != cpp_npl) {
                      throw std::runtime_error("not exactly NPL elements consumed");
                    }
                  }
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , MAT1 , MT1 , NL , NL1 ] CONT";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable MAT1
          var_MAT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_MAT1_read = true;
          validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
          aux_last_type_read_for_MAT1 = SCALAR_INT;
          // assign expression to variable MT1
          var_MT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_MT1_read = true;
          validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
          aux_last_type_read_for_MT1 = SCALAR_INT;
          // assign expression to variable NL
          var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NL_read = true;
          validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
          aux_last_type_read_for_NL = SCALAR_INT;
          // assign expression to variable NL1
          var_NL1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NL1_read = true;
          validate_vartype_consistency("NL1", SCALAR_INT, aux_last_type_read_for_NL1);
          aux_last_type_read_for_NL1 = SCALAR_INT;

          for (int var_n_0d_int_Scalar = 1;
             var_n_0d_int_Scalar <= (var_NL_0d_int_Scalar*var_NL1_0d_int_Scalar); var_n_0d_int_Scalar++) {
            bool aux_n_read = true;
            // evaluate if-elif-else clause
            {
              bool cpp_found_match = false;
              if (! cpp_found_match) {
                if ((((((((aux_n_read == true)) && ((var_n_0d_int_Scalar)==(1)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , LCT , NI ] CONT";
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read CONT record
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable L
                  var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
                  validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                  aux_last_type_read_for_L = NESTEDVECTOR_INT;
                  // assign expression to variable L1
                  var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
                  validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                  aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                  // assign expression to variable LCT
                  var_LCT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  aux_LCT_read = true;
                  validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
                  aux_last_type_read_for_LCT = SCALAR_INT;
                  // assign expression to variable NI
                  var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                  validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                  aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                }
              }
              if (! cpp_found_match) {
                cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , 0 , NI ] CONT";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read CONT record
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable L
                var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
                validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                aux_last_type_read_for_L = NESTEDVECTOR_INT;
                // assign expression to variable L1
                var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
                validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable NI
                var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                aux_last_type_read_for_NI = NESTEDVECTOR_INT;
              }
            }
            ptr_LS_2d_idx0 = var_LS_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
            ptr_LB_2d_idx0 = var_LB_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
            ptr_NE_2d_idx0 = var_NE_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
            ptr_Data_3d_idx0 = var_Data_3d_double_NestedVector.prepare(var_n_0d_int_Scalar);

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NI_1d_int_NestedVector[var_n_0d_int_Scalar]; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { Data } { q = 1 to NT } ] LIST";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST record
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable LS
              ptr_LS_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
              validate_vartype_consistency("LS", NESTEDVECTOR_INT, aux_last_type_read_for_LS);
              aux_last_type_read_for_LS = NESTEDVECTOR_INT;
              // assign expression to variable LB
              ptr_LB_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
              validate_vartype_consistency("LB", NESTEDVECTOR_INT, aux_last_type_read_for_LB);
              aux_last_type_read_for_LB = NESTEDVECTOR_INT;
              // assign expression to variable NT
              ptr_NT_2d_idx0 = var_NT_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
              ptr_NT_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
              validate_vartype_consistency("NT", NESTEDVECTOR_INT, aux_last_type_read_for_NT);
              aux_last_type_read_for_NT = NESTEDVECTOR_INT;
              // assign expression to variable NE
              ptr_NE_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
              validate_vartype_consistency("NE", NESTEDVECTOR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = NESTEDVECTOR_INT;
              {
                int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST body
                ptr_Data_3d_idx1 = ptr_Data_3d_idx0->prepare(var_m_0d_int_Scalar);

                for (int var_q_0d_int_Scalar = 1;
                   var_q_0d_int_Scalar <= var_NT_2d_int_NestedVector[var_n_0d_int_Scalar][var_m_0d_int_Scalar]; var_q_0d_int_Scalar++) {
                  bool aux_q_read = true;
                  // read LIST body
                  // assign expression to variable Data
                  ptr_Data_3d_idx1->set(var_q_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                  validate_vartype_consistency("Data", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Data);
                  aux_last_type_read_for_Data = NESTEDVECTOR_DOUBLE;
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
            }
          }
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_MAT1 == SCALAR_INT) && (aux_MAT1_read == true))) {
        cpp_current_dict["MAT1"] = var_MAT1_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_MT1 == SCALAR_INT) && (aux_MT1_read == true))) {
        cpp_current_dict["MT1"] = var_MT1_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NL == SCALAR_INT) && (aux_NL_read == true))) {
        cpp_current_dict["NL"] = var_NL_0d_int_Scalar;
      }
      if ((var_L_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["L"] = var_L_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_L1_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["L1"] = var_L1_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if (((aux_last_type_read_for_LCT == SCALAR_INT) && (aux_LCT_read == true))) {
        cpp_current_dict["LCT"] = var_LCT_0d_int_Scalar;
      }
      if ((var_NI_1d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["NI"] = var_NI_1d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_LS_2d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["LS"] = var_LS_2d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_LB_2d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["LB"] = var_LB_2d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_NT_2d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["NT"] = var_NT_2d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_NE_2d_int_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["NE"] = var_NE_2d_int_NestedVector.to_pyobj(list_mode);
      }
      if ((var_Data_3d_double_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["Data"] = var_Data_3d_double_NestedVector.to_pyobj(list_mode);
      }
      if (((aux_last_type_read_for_NL1 == SCALAR_INT) && (aux_NL1_read == true))) {
        cpp_current_dict["NL1"] = var_NL1_0d_int_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LTT == SCALAR_INT) && (aux_LTT_read == true))) {
    cpp_current_dict["LTT"] = var_LTT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NMT1 == SCALAR_INT) && (aux_NMT1_read == true))) {
    cpp_current_dict["NMT1"] = var_NMT1_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: ef5fac1c99989a26cffcf79262c5c69c
// MD5 hash of the following function definition: 53f8a338ffff25adb78d117ea8cea783
py::dict parse_mf35_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 35;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 35;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 35 , MT / ZA , AWR , 0 , 0 , NK , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.setdefault("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_E1_0d_double_Scalar;
      bool aux_E1_read = false;
      vartype aux_last_type_read_for_E1 = UNKNOWN;
      EndfFloatCpp var_E2_0d_double_Scalar;
      bool aux_E2_read = false;
      vartype aux_last_type_read_for_E2 = UNKNOWN;
      int var_LS_0d_int_Scalar;
      bool aux_LS_read = false;
      vartype aux_last_type_read_for_LS = UNKNOWN;
      int var_LB_0d_int_Scalar;
      bool aux_LB_read = false;
      vartype aux_last_type_read_for_LB = UNKNOWN;
      int var_NT_0d_int_Scalar;
      bool aux_NT_read = false;
      vartype aux_last_type_read_for_NT = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      Matrix2d<EndfFloatCpp> var_F_2d_double_Matrix2d;
      vartype aux_last_type_read_for_F = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            std::streampos cpp_old_streampos = cont.tellg();
            {
              // variable declarations
              EndfFloatCpp& glob_var_E1_0d_double_Scalar = var_E1_0d_double_Scalar;
              EndfFloatCpp var_E1_0d_double_Scalar = glob_var_E1_0d_double_Scalar;
              bool& glob_aux_E1_read = aux_E1_read;
              bool aux_E1_read = glob_aux_E1_read;
              vartype aux_last_type_read_for_E1 = UNKNOWN;
              EndfFloatCpp& glob_var_E2_0d_double_Scalar = var_E2_0d_double_Scalar;
              EndfFloatCpp var_E2_0d_double_Scalar = glob_var_E2_0d_double_Scalar;
              bool& glob_aux_E2_read = aux_E2_read;
              bool aux_E2_read = glob_aux_E2_read;
              vartype aux_last_type_read_for_E2 = UNKNOWN;
              int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
              int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
              bool& glob_aux_LS_read = aux_LS_read;
              bool aux_LS_read = glob_aux_LS_read;
              vartype aux_last_type_read_for_LS = UNKNOWN;
              int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
              int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
              bool& glob_aux_LB_read = aux_LB_read;
              bool aux_LB_read = glob_aux_LB_read;
              vartype aux_last_type_read_for_LB = UNKNOWN;
              int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
              int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
              bool& glob_aux_NT_read = aux_NT_read;
              bool aux_NT_read = glob_aux_NT_read;
              vartype aux_last_type_read_for_NT = UNKNOWN;
              int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
              int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
              bool& glob_aux_NE_read = aux_NE_read;
              bool aux_NE_read = glob_aux_NE_read;
              vartype aux_last_type_read_for_NE = UNKNOWN;
              try {
                cpp_template = "[ MAT , 35 , MT / E1 , E2 , LS , LB , NT , NE / \n { E } { i = 1 to NE } , { { F } { j = i to (NE-1) } } { i = 1 to (NE-1) } ] LIST";
                cpp_line = cpp_read_raw_line(cont);
                // read LIST record
                // assign expression to variable E1
                var_E1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                aux_E1_read = true;
                validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                // assign expression to variable E2
                var_E2_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                aux_E2_read = true;
                validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                // assign expression to variable LS
                var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                aux_LS_read = true;
                validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                aux_last_type_read_for_LS = SCALAR_INT;
                // assign expression to variable LB
                var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LB_read = true;
                validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                aux_last_type_read_for_LB = SCALAR_INT;
                // assign expression to variable NT
                var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                aux_NT_read = true;
                validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                aux_last_type_read_for_NT = SCALAR_INT;
                // assign expression to variable NE
                var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                aux_NE_read = true;
                validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                aux_last_type_read_for_NE = SCALAR_INT;
              } catch (const std::out_of_range& e) {
                // // accept failure in lookahead
              }
              if (((((((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(7)))))))) {
                cpp_found_match = true;
              }
              cont.seekg(cpp_old_streampos);
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 35 , MT / E1 , E2 , LS , LB , NT , NE / \n { E } { i = 1 to NE } , { { F } { j = i to (NE-1) } } { i = 1 to (NE-1) } ] LIST";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST record
              // assign expression to variable E1
              var_E1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
              aux_E1_read = true;
              validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
              aux_last_type_read_for_E1 = SCALAR_DOUBLE;
              // assign expression to variable E2
              var_E2_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
              aux_E2_read = true;
              validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
              aux_last_type_read_for_E2 = SCALAR_DOUBLE;
              // assign expression to variable LS
              var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LS_read = true;
              validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
              aux_last_type_read_for_LS = SCALAR_INT;
              // assign expression to variable LB
              var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LB_read = true;
              validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
              aux_last_type_read_for_LB = SCALAR_INT;
              // assign expression to variable NT
              var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_NT_read = true;
              validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
              aux_last_type_read_for_NT = SCALAR_INT;
              // assign expression to variable NE
              var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              {
                int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST body

                for (int var_i_0d_int_Scalar = 1;
                   var_i_0d_int_Scalar <= var_NE_0d_int_Scalar; var_i_0d_int_Scalar++) {
                  bool aux_i_read = true;
                  // read LIST body
                  // assign expression to variable E
                  var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                  validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                }
                var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                for (int var_i_0d_int_Scalar = 1;
                   var_i_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_i_0d_int_Scalar++) {
                  bool aux_i_read = true;
                  // read LIST body

                  for (int var_j_0d_int_Scalar = var_i_0d_int_Scalar;
                     var_j_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_j_0d_int_Scalar++) {
                    bool aux_j_read = true;
                    // read LIST body
                    // assign expression to variable F
                    var_F_2d_double_Matrix2d(var_i_0d_int_Scalar, var_j_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                    validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                    aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      cpp_j = 0;
                    }
                  }
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
            }
          }
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_E1 == SCALAR_DOUBLE) && (aux_E1_read == true))) {
        cpp_current_dict["E1"] = var_E1_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_E2 == SCALAR_DOUBLE) && (aux_E2_read == true))) {
        cpp_current_dict["E2"] = var_E2_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_LS == SCALAR_INT) && (aux_LS_read == true))) {
        cpp_current_dict["LS"] = var_LS_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LB == SCALAR_INT) && (aux_LB_read == true))) {
        cpp_current_dict["LB"] = var_LB_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NT == SCALAR_INT) && (aux_NT_read == true))) {
        cpp_current_dict["NT"] = var_NT_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
        cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
      }
      if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
        cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
      }
      if (var_F_2d_double_Matrix2d.did_read()) {
        cpp_current_dict["F"] = var_F_2d_double_Matrix2d.to_pyobj(list_mode);
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NK == SCALAR_INT) && (aux_NK_read == true))) {
    cpp_current_dict["NK"] = var_NK_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 9762b69b4ad00343103fe284b177ae48
// MD5 hash of the following function definition: 663fc2ad6ae007d433f58272d77a9b83
py::dict parse_mf40_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  bool list_mode = parse_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 40;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 40;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 40 , MT / ZA , AWR , LIS , 0 , NS , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.setdefault("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_QM_0d_double_Scalar;
      bool aux_QM_read = false;
      vartype aux_last_type_read_for_QM = UNKNOWN;
      EndfFloatCpp var_QI_0d_double_Scalar;
      bool aux_QI_read = false;
      vartype aux_last_type_read_for_QI = UNKNOWN;
      int var_IZAP_0d_int_Scalar;
      bool aux_IZAP_read = false;
      vartype aux_last_type_read_for_IZAP = UNKNOWN;
      int var_LFS_0d_int_Scalar;
      bool aux_LFS_read = false;
      vartype aux_last_type_read_for_LFS = UNKNOWN;
      int var_NL_0d_int_Scalar;
      bool aux_NL_read = false;
      vartype aux_last_type_read_for_NL = UNKNOWN;
      cpp_template = "[ MAT , 40 , MT / QM , QI , IZAP , LFS , 0 , NL ] CONT";
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read CONT record
      // assign expression to variable QM
      var_QM_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
      aux_QM_read = true;
      validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
      aux_last_type_read_for_QM = SCALAR_DOUBLE;
      // assign expression to variable QI
      var_QI_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
      aux_QI_read = true;
      validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
      aux_last_type_read_for_QI = SCALAR_DOUBLE;
      // assign expression to variable IZAP
      var_IZAP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
      aux_IZAP_read = true;
      validate_vartype_consistency("IZAP", SCALAR_INT, aux_last_type_read_for_IZAP);
      aux_last_type_read_for_IZAP = SCALAR_INT;
      // assign expression to variable LFS
      var_LFS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LFS_read = true;
      validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
      aux_last_type_read_for_LFS = SCALAR_INT;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
      // assign expression to variable NL
      var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
      aux_NL_read = true;
      validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
      aux_last_type_read_for_NL = SCALAR_INT;

      for (int var_i_0d_int_Scalar = 1;
         var_i_0d_int_Scalar <= var_NL_0d_int_Scalar; var_i_0d_int_Scalar++) {
        bool aux_i_read = true;
        // open section subsubsec
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.setdefault("subsubsec", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          // variable declarations
          EndfFloatCpp var_XMF1_0d_double_Scalar;
          bool aux_XMF1_read = false;
          vartype aux_last_type_read_for_XMF1 = UNKNOWN;
          EndfFloatCpp var_XLFS1_0d_double_Scalar;
          bool aux_XLFS1_read = false;
          vartype aux_last_type_read_for_XLFS1 = UNKNOWN;
          int var_MAT1_0d_int_Scalar;
          bool aux_MAT1_read = false;
          vartype aux_last_type_read_for_MAT1 = UNKNOWN;
          int var_MT1_0d_int_Scalar;
          bool aux_MT1_read = false;
          vartype aux_last_type_read_for_MT1 = UNKNOWN;
          int var_NC_0d_int_Scalar;
          bool aux_NC_read = false;
          vartype aux_last_type_read_for_NC = UNKNOWN;
          int var_NI_0d_int_Scalar;
          bool aux_NI_read = false;
          vartype aux_last_type_read_for_NI = UNKNOWN;
          cpp_template = "[ MAT , 40 , MT / XMF1 , XLFS1 , MAT1 , MT1 , NC , NI ] CONT";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable XMF1
          var_XMF1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
          aux_XMF1_read = true;
          validate_vartype_consistency("XMF1", SCALAR_DOUBLE, aux_last_type_read_for_XMF1);
          aux_last_type_read_for_XMF1 = SCALAR_DOUBLE;
          // assign expression to variable XLFS1
          var_XLFS1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
          aux_XLFS1_read = true;
          validate_vartype_consistency("XLFS1", SCALAR_DOUBLE, aux_last_type_read_for_XLFS1);
          aux_last_type_read_for_XLFS1 = SCALAR_DOUBLE;
          // assign expression to variable MAT1
          var_MAT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_MAT1_read = true;
          validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
          aux_last_type_read_for_MAT1 = SCALAR_INT;
          // assign expression to variable MT1
          var_MT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_MT1_read = true;
          validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
          aux_last_type_read_for_MT1 = SCALAR_INT;
          // assign expression to variable NC
          var_NC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NC_read = true;
          validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
          aux_last_type_read_for_NC = SCALAR_INT;
          // assign expression to variable NI
          var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NI_read = true;
          validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
          aux_last_type_read_for_NI = SCALAR_INT;

          for (int var_j_0d_int_Scalar = 1;
             var_j_0d_int_Scalar <= var_NC_0d_int_Scalar; var_j_0d_int_Scalar++) {
            bool aux_j_read = true;
            // open section nc_subsubsubsec
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.setdefault("nc_subsubsubsec", std::vector<int>({var_j_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              // variable declarations
              int var_LTY_0d_int_Scalar;
              bool aux_LTY_read = false;
              vartype aux_last_type_read_for_LTY = UNKNOWN;
              EndfFloatCpp var_E1_0d_double_Scalar;
              bool aux_E1_read = false;
              vartype aux_last_type_read_for_E1 = UNKNOWN;
              EndfFloatCpp var_E2_0d_double_Scalar;
              bool aux_E2_read = false;
              vartype aux_last_type_read_for_E2 = UNKNOWN;
              int cpp_int_val;
              bool aux_cpp_int_val_read = false;
              vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
              int var_NCI_0d_int_Scalar;
              bool aux_NCI_read = false;
              vartype aux_last_type_read_for_NCI = UNKNOWN;
              NestedVector<EndfFloatCpp> var_C_1d_double_NestedVector;
              vartype aux_last_type_read_for_C = UNKNOWN;
              NestedVector<EndfFloatCpp> var_XMT_1d_double_NestedVector;
              vartype aux_last_type_read_for_XMT = UNKNOWN;
              int var_MATS_0d_int_Scalar;
              bool aux_MATS_read = false;
              vartype aux_last_type_read_for_MATS = UNKNOWN;
              int var_MTS_0d_int_Scalar;
              bool aux_MTS_read = false;
              vartype aux_last_type_read_for_MTS = UNKNOWN;
              int var_NEI_0d_int_Scalar;
              bool aux_NEI_read = false;
              vartype aux_last_type_read_for_NEI = UNKNOWN;
              EndfFloatCpp var_XMFS_0d_double_Scalar;
              bool aux_XMFS_read = false;
              vartype aux_last_type_read_for_XMFS = UNKNOWN;
              EndfFloatCpp var_XLFSS_0d_double_Scalar;
              bool aux_XLFSS_read = false;
              vartype aux_last_type_read_for_XLFSS = UNKNOWN;
              NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
              vartype aux_last_type_read_for_E = UNKNOWN;
              NestedVector<EndfFloatCpp> var_WE_1d_double_NestedVector;
              vartype aux_last_type_read_for_WE = UNKNOWN;
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  // if statement evaluation with lookahead
                  {
                    std::streampos cpp_old_streampos = cont.tellg();
                    {
                      // variable declarations
                      int& glob_var_LTY_0d_int_Scalar = var_LTY_0d_int_Scalar;
                      int var_LTY_0d_int_Scalar = glob_var_LTY_0d_int_Scalar;
                      bool& glob_aux_LTY_read = aux_LTY_read;
                      bool aux_LTY_read = glob_aux_LTY_read;
                      vartype aux_last_type_read_for_LTY = UNKNOWN;
                      try {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                        cpp_line = cpp_read_raw_line(cont);
                        // read CONT record
                        // assign expression to variable LTY
                        var_LTY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LTY_read = true;
                        validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                        aux_last_type_read_for_LTY = SCALAR_INT;
                      } catch (const std::out_of_range& e) {
                        // // accept failure in lookahead
                      }
                      if ((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(0)))))))) {
                        cpp_found_match = true;
                      }
                      cont.seekg(cpp_old_streampos);
                    }
                    if (cpp_found_match) {
                      cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read CONT record
                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable LTY
                      var_LTY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                      aux_LTY_read = true;
                      validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                      aux_last_type_read_for_LTY = SCALAR_INT;
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_template = "[ MAT , 40 , MT / E1 , E2 , 0 , 0 , (2*NCI) , NCI / \n { C , XMT } { i = 1 to NCI } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      // assign expression to variable E1
                      var_E1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                      aux_E1_read = true;
                      validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                      aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                      // assign expression to variable E2
                      var_E2_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                      aux_E2_read = true;
                      validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                      aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NCI
                      var_NCI_0d_int_Scalar = (cpp_int_val/2);
                      aux_NCI_read = true;
                      validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                      aux_last_type_read_for_NCI = SCALAR_INT;
                      if ((! (aux_NCI_read == true))) {
                        // assign expression to variable NCI
                        var_NCI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NCI_read = true;
                        validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                        aux_last_type_read_for_NCI = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NCI_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NCI",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_i_0d_int_Scalar = 1;
                           var_i_0d_int_Scalar <= var_NCI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                          bool aux_i_read = true;
                          // read LIST body
                          // assign expression to variable C
                          var_C_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
                          aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable XMT
                          var_XMT_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("XMT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_XMT);
                          aux_last_type_read_for_XMT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LTY_0d_int_Scalar = var_LTY_0d_int_Scalar;
                        int var_LTY_0d_int_Scalar = glob_var_LTY_0d_int_Scalar;
                        bool& glob_aux_LTY_read = aux_LTY_read;
                        bool aux_LTY_read = glob_aux_LTY_read;
                        vartype aux_last_type_read_for_LTY = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                          cpp_line = cpp_read_raw_line(cont);
                          // read CONT record
                          // assign expression to variable LTY
                          var_LTY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LTY_read = true;
                          validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                          aux_last_type_read_for_LTY = SCALAR_INT;
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if ((((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(1))))))||(((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(2))))))||(((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(3)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read CONT record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LTY
                        var_LTY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LTY_read = true;
                        validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                        aux_last_type_read_for_LTY = SCALAR_INT;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_template = "[ MAT , 40 , MT / E1 , E2 , MATS , MTS , ((2*NEI)+2) , NEI / \n XMFS , XLFSS , { E , WE } { i = 1 to NEI } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        // assign expression to variable E1
                        var_E1_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts);
                        aux_E1_read = true;
                        validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                        aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                        // assign expression to variable E2
                        var_E2_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts);
                        aux_E2_read = true;
                        validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                        aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                        // assign expression to variable MATS
                        var_MATS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_MATS_read = true;
                        validate_vartype_consistency("MATS", SCALAR_INT, aux_last_type_read_for_MATS);
                        aux_last_type_read_for_MATS = SCALAR_INT;
                        // assign expression to variable MTS
                        var_MTS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_MTS_read = true;
                        validate_vartype_consistency("MTS", SCALAR_INT, aux_last_type_read_for_MTS);
                        aux_last_type_read_for_MTS = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NEI
                        var_NEI_0d_int_Scalar = ((cpp_int_val+(-2))/2);
                        aux_NEI_read = true;
                        validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                        aux_last_type_read_for_NEI = SCALAR_INT;
                        if ((! (aux_NEI_read == true))) {
                          // assign expression to variable NEI
                          var_NEI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NEI_read = true;
                          validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                          aux_last_type_read_for_NEI = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NEI_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NEI",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body
                          // assign expression to variable XMFS
                          var_XMFS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                          aux_XMFS_read = true;
                          validate_vartype_consistency("XMFS", SCALAR_DOUBLE, aux_last_type_read_for_XMFS);
                          aux_last_type_read_for_XMFS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable XLFSS
                          var_XLFSS_0d_double_Scalar = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                          aux_XLFSS_read = true;
                          validate_vartype_consistency("XLFSS", SCALAR_DOUBLE, aux_last_type_read_for_XLFSS);
                          aux_last_type_read_for_XLFSS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }

                          for (int var_i_0d_int_Scalar = 1;
                             var_i_0d_int_Scalar <= var_NEI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                            bool aux_i_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable WE
                            var_WE_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("WE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_WE);
                            aux_last_type_read_for_WE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
              }
              // store data in Python dictionary
              if (((aux_last_type_read_for_LTY == SCALAR_INT) && (aux_LTY_read == true))) {
                cpp_current_dict["LTY"] = var_LTY_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_E1 == SCALAR_DOUBLE) && (aux_E1_read == true))) {
                cpp_current_dict["E1"] = var_E1_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_E2 == SCALAR_DOUBLE) && (aux_E2_read == true))) {
                cpp_current_dict["E2"] = var_E2_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_NCI == SCALAR_INT) && (aux_NCI_read == true))) {
                cpp_current_dict["NCI"] = var_NCI_0d_int_Scalar;
              }
              if ((var_C_1d_double_NestedVector.get_last_index() != -1)) {
                cpp_current_dict["C"] = var_C_1d_double_NestedVector.to_pyobj(list_mode);
              }
              if ((var_XMT_1d_double_NestedVector.get_last_index() != -1)) {
                cpp_current_dict["XMT"] = var_XMT_1d_double_NestedVector.to_pyobj(list_mode);
              }
              if (((aux_last_type_read_for_MATS == SCALAR_INT) && (aux_MATS_read == true))) {
                cpp_current_dict["MATS"] = var_MATS_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_MTS == SCALAR_INT) && (aux_MTS_read == true))) {
                cpp_current_dict["MTS"] = var_MTS_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_NEI == SCALAR_INT) && (aux_NEI_read == true))) {
                cpp_current_dict["NEI"] = var_NEI_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_XMFS == SCALAR_DOUBLE) && (aux_XMFS_read == true))) {
                cpp_current_dict["XMFS"] = var_XMFS_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_XLFSS == SCALAR_DOUBLE) && (aux_XLFSS_read == true))) {
                cpp_current_dict["XLFSS"] = var_XLFSS_0d_double_Scalar;
              }
              if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
              }
              if ((var_WE_1d_double_NestedVector.get_last_index() != -1)) {
                cpp_current_dict["WE"] = var_WE_1d_double_NestedVector.to_pyobj(list_mode);
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }

          for (int var_j_0d_int_Scalar = 1;
             var_j_0d_int_Scalar <= var_NI_0d_int_Scalar; var_j_0d_int_Scalar++) {
            bool aux_j_read = true;
            // open section ni_subsubsubsec
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.setdefault("ni_subsubsubsec", std::vector<int>({var_j_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              // variable declarations
              int var_LT_0d_int_Scalar;
              bool aux_LT_read = false;
              vartype aux_last_type_read_for_LT = UNKNOWN;
              int var_LB_0d_int_Scalar;
              bool aux_LB_read = false;
              vartype aux_last_type_read_for_LB = UNKNOWN;
              int cpp_int_val;
              bool aux_cpp_int_val_read = false;
              vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
              int var_NP_0d_int_Scalar;
              bool aux_NP_read = false;
              vartype aux_last_type_read_for_NP = UNKNOWN;
              NestedVector<EndfFloatCpp> var_Ek_1d_double_NestedVector;
              vartype aux_last_type_read_for_Ek = UNKNOWN;
              NestedVector<EndfFloatCpp> var_Fk_1d_double_NestedVector;
              vartype aux_last_type_read_for_Fk = UNKNOWN;
              NestedVector<EndfFloatCpp> var_El_1d_double_NestedVector;
              vartype aux_last_type_read_for_El = UNKNOWN;
              NestedVector<EndfFloatCpp> var_Fl_1d_double_NestedVector;
              vartype aux_last_type_read_for_Fl = UNKNOWN;
              int var_LS_0d_int_Scalar;
              bool aux_LS_read = false;
              vartype aux_last_type_read_for_LS = UNKNOWN;
              int var_NT_0d_int_Scalar;
              bool aux_NT_read = false;
              vartype aux_last_type_read_for_NT = UNKNOWN;
              int var_NE_0d_int_Scalar;
              bool aux_NE_read = false;
              vartype aux_last_type_read_for_NE = UNKNOWN;
              NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
              vartype aux_last_type_read_for_E = UNKNOWN;
              Matrix2d<EndfFloatCpp> var_F_2d_double_Matrix2d;
              vartype aux_last_type_read_for_F = UNKNOWN;
              int var_NER_0d_int_Scalar;
              bool aux_NER_read = false;
              vartype aux_last_type_read_for_NER = UNKNOWN;
              NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
              vartype aux_last_type_read_for_ER = UNKNOWN;
              NestedVector<EndfFloatCpp> var_EC_1d_double_NestedVector;
              vartype aux_last_type_read_for_EC = UNKNOWN;
              NestedVector<EndfFloatCpp> var_F_1d_double_NestedVector;
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  // if statement evaluation with lookahead
                  {
                    std::streampos cpp_old_streampos = cont.tellg();
                    {
                      // variable declarations
                      int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                      int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                      bool& glob_aux_LT_read = aux_LT_read;
                      bool aux_LT_read = glob_aux_LT_read;
                      vartype aux_last_type_read_for_LT = UNKNOWN;
                      int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                      int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                      bool& glob_aux_LB_read = aux_LB_read;
                      bool aux_LB_read = glob_aux_LB_read;
                      vartype aux_last_type_read_for_LB = UNKNOWN;
                      int& glob_cpp_int_val = cpp_int_val;
                      int cpp_int_val = glob_cpp_int_val;
                      bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                      bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                      int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                      bool& glob_aux_NP_read = aux_NP_read;
                      bool aux_NP_read = glob_aux_NP_read;
                      vartype aux_last_type_read_for_NP = UNKNOWN;
                      try {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { q = 1 to (NP-LT) } \n { El , Fl } { q = 1 to LT } ] LIST";
                        cpp_line = cpp_read_raw_line(cont);
                        // read LIST record
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                      } catch (const std::out_of_range& e) {
                        // // accept failure in lookahead
                      }
                      if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)>=(0)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)<=(4)))))))) {
                        cpp_found_match = true;
                      }
                      cont.seekg(cpp_old_streampos);
                    }
                    if (cpp_found_match) {
                      cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { q = 1 to (NP-LT) } \n { El , Fl } { q = 1 to LT } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable LT
                      var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                      aux_LT_read = true;
                      validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                      aux_last_type_read_for_LT = SCALAR_INT;
                      // assign expression to variable LB
                      var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                      aux_LB_read = true;
                      validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                      aux_last_type_read_for_LB = SCALAR_INT;
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NP
                      var_NP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NP_read = true;
                      validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                      aux_last_type_read_for_NP = SCALAR_INT;
                      if ((! (aux_NP_read == true))) {
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NP",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_q_0d_int_Scalar = 1;
                           var_q_0d_int_Scalar <= (var_NP_0d_int_Scalar-var_LT_0d_int_Scalar); var_q_0d_int_Scalar++) {
                          bool aux_q_read = true;
                          // read LIST body
                          // assign expression to variable Ek
                          var_Ek_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("Ek", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ek);
                          aux_last_type_read_for_Ek = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable Fk
                          var_Fk_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("Fk", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fk);
                          aux_last_type_read_for_Fk = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }

                        for (int var_q_0d_int_Scalar = 1;
                           var_q_0d_int_Scalar <= var_LT_0d_int_Scalar; var_q_0d_int_Scalar++) {
                          bool aux_q_read = true;
                          // read LIST body
                          // assign expression to variable El
                          var_El_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("El", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_El);
                          aux_last_type_read_for_El = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable Fl
                          var_Fl_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("Fl", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fl);
                          aux_last_type_read_for_Fl = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                        int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                        bool& glob_aux_LS_read = aux_LS_read;
                        bool aux_LS_read = glob_aux_LS_read;
                        vartype aux_last_type_read_for_LS = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                        int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                        bool& glob_aux_NT_read = aux_NT_read;
                        bool aux_NT_read = glob_aux_NT_read;
                        vartype aux_last_type_read_for_NT = UNKNOWN;
                        int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                        int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                        bool& glob_aux_NE_read = aux_NE_read;
                        bool aux_NE_read = glob_aux_NE_read;
                        vartype aux_last_type_read_for_NE = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = 1 to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NT
                          var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_NT_read = true;
                          validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                          aux_last_type_read_for_NT = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(0)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = 1 to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NE_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), false, false);

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body

                            for (int var_qp_0d_int_Scalar = 1;
                               var_qp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_qp_0d_int_Scalar++) {
                              bool aux_qp_read = true;
                              // read LIST body
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_q_0d_int_Scalar, var_qp_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                        int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                        bool& glob_aux_LS_read = aux_LS_read;
                        bool aux_LS_read = glob_aux_LS_read;
                        vartype aux_last_type_read_for_LS = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                        int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                        bool& glob_aux_NT_read = aux_NT_read;
                        bool aux_NT_read = glob_aux_NT_read;
                        vartype aux_last_type_read_for_NT = UNKNOWN;
                        int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                        int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                        bool& glob_aux_NE_read = aux_NE_read;
                        bool aux_NE_read = glob_aux_NE_read;
                        vartype aux_last_type_read_for_NE = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = q to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NT
                          var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_NT_read = true;
                          validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                          aux_last_type_read_for_NT = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = q to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NE_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body

                            for (int var_qp_0d_int_Scalar = var_q_0d_int_Scalar;
                               var_qp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_qp_0d_int_Scalar++) {
                              bool aux_qp_read = true;
                              // read LIST body
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_q_0d_int_Scalar, var_qp_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                        int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                        bool& glob_aux_NT_read = aux_NT_read;
                        bool aux_NT_read = glob_aux_NT_read;
                        vartype aux_last_type_read_for_NT = UNKNOWN;
                        int& glob_var_NER_0d_int_Scalar = var_NER_0d_int_Scalar;
                        int var_NER_0d_int_Scalar = glob_var_NER_0d_int_Scalar;
                        bool& glob_aux_NER_read = aux_NER_read;
                        bool aux_NER_read = glob_aux_NER_read;
                        vartype aux_last_type_read_for_NER = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { q = 1 to NER } { EC } { q = 1 to ((NT-1)/NER) } \n { { F } { l = 1 to (((NT-1)/NER)-1) } } { q = 1 to (NER-1) } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NT
                          var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_NT_read = true;
                          validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                          aux_last_type_read_for_NT = SCALAR_INT;
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if ((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(6)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { q = 1 to NER } { EC } { q = 1 to ((NT-1)/NER) } \n { { F } { l = 1 to (((NT-1)/NER)-1) } } { q = 1 to (NER-1) } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        // assign expression to variable NER
                        var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NER_read = true;
                        validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                        aux_last_type_read_for_NER = SCALAR_INT;
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NER_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= ((var_NT_0d_int_Scalar-1)/var_NER_0d_int_Scalar); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            // assign expression to variable EC
                            var_EC_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("EC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EC);
                            aux_last_type_read_for_EC = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NER_0d_int_Scalar-1), 1, (((var_NT_0d_int_Scalar-1)/var_NER_0d_int_Scalar)-1), false, false);

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= (var_NER_0d_int_Scalar-1); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body

                            for (int var_l_0d_int_Scalar = 1;
                               var_l_0d_int_Scalar <= (((var_NT_0d_int_Scalar-1)/var_NER_0d_int_Scalar)-1); var_l_0d_int_Scalar++) {
                              bool aux_l_read = true;
                              // read LIST body
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_q_0d_int_Scalar, var_l_0d_int_Scalar) = cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                        int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                        bool& glob_aux_LT_read = aux_LT_read;
                        bool aux_LT_read = glob_aux_LT_read;
                        vartype aux_last_type_read_for_LT = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_cpp_int_val = cpp_int_val;
                        int cpp_int_val = glob_cpp_int_val;
                        bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                        bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                        int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                        bool& glob_aux_NP_read = aux_NP_read;
                        bool aux_NP_read = glob_aux_NP_read;
                        vartype aux_last_type_read_for_NP = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { q = 1 to NP } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if ((((((((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(8))))))||(((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(9)))))))))&&((((aux_LT_read == true)) && ((var_LT_0d_int_Scalar)==(0)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { q = 1 to NP } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NP",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable F
                            var_F_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<EndfFloatCpp>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                            aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
              }
              // store data in Python dictionary
              if (((aux_last_type_read_for_LT == SCALAR_INT) && (aux_LT_read == true))) {
                cpp_current_dict["LT"] = var_LT_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_LB == SCALAR_INT) && (aux_LB_read == true))) {
                cpp_current_dict["LB"] = var_LB_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_NP == SCALAR_INT) && (aux_NP_read == true))) {
                cpp_current_dict["NP"] = var_NP_0d_int_Scalar;
              }
              if ((var_Ek_1d_double_NestedVector.get_last_index() != -1)) {
                cpp_current_dict["Ek"] = var_Ek_1d_double_NestedVector.to_pyobj(list_mode);
              }
              if ((var_Fk_1d_double_NestedVector.get_last_index() != -1)) {
                cpp_current_dict["Fk"] = var_Fk_1d_double_NestedVector.to_pyobj(list_mode);
              }
              if ((var_El_1d_double_NestedVector.get_last_index() != -1)) {
                cpp_current_dict["El"] = var_El_1d_double_NestedVector.to_pyobj(list_mode);
              }
              if ((var_Fl_1d_double_NestedVector.get_last_index() != -1)) {
                cpp_current_dict["Fl"] = var_Fl_1d_double_NestedVector.to_pyobj(list_mode);
              }
              if (((aux_last_type_read_for_LS == SCALAR_INT) && (aux_LS_read == true))) {
                cpp_current_dict["LS"] = var_LS_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_NT == SCALAR_INT) && (aux_NT_read == true))) {
                cpp_current_dict["NT"] = var_NT_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
                cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
              }
              if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                cpp_current_dict["E"] = var_E_1d_double_NestedVector.to_pyobj(list_mode);
              }
              if (var_F_2d_double_Matrix2d.did_read()) {
                cpp_current_dict["F"] = var_F_2d_double_Matrix2d.to_pyobj(list_mode);
              }
              if (((aux_last_type_read_for_NER == SCALAR_INT) && (aux_NER_read == true))) {
                cpp_current_dict["NER"] = var_NER_0d_int_Scalar;
              }
              if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                cpp_current_dict["ER"] = var_ER_1d_double_NestedVector.to_pyobj(list_mode);
              }
              if ((var_EC_1d_double_NestedVector.get_last_index() != -1)) {
                cpp_current_dict["EC"] = var_EC_1d_double_NestedVector.to_pyobj(list_mode);
              }
              if ((var_F_1d_double_NestedVector.get_last_index() != -1)) {
                cpp_current_dict["F"] = var_F_1d_double_NestedVector.to_pyobj(list_mode);
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_XMF1 == SCALAR_DOUBLE) && (aux_XMF1_read == true))) {
            cpp_current_dict["XMF1"] = var_XMF1_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_XLFS1 == SCALAR_DOUBLE) && (aux_XLFS1_read == true))) {
            cpp_current_dict["XLFS1"] = var_XLFS1_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_MAT1 == SCALAR_INT) && (aux_MAT1_read == true))) {
            cpp_current_dict["MAT1"] = var_MAT1_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_MT1 == SCALAR_INT) && (aux_MT1_read == true))) {
            cpp_current_dict["MT1"] = var_MT1_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
            cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NI == SCALAR_INT) && (aux_NI_read == true))) {
            cpp_current_dict["NI"] = var_NI_0d_int_Scalar;
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_QM == SCALAR_DOUBLE) && (aux_QM_read == true))) {
        cpp_current_dict["QM"] = var_QM_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_QI == SCALAR_DOUBLE) && (aux_QI_read == true))) {
        cpp_current_dict["QI"] = var_QI_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_IZAP == SCALAR_INT) && (aux_IZAP_read == true))) {
        cpp_current_dict["IZAP"] = var_IZAP_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LFS == SCALAR_INT) && (aux_LFS_read == true))) {
        cpp_current_dict["LFS"] = var_LFS_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NL == SCALAR_INT) && (aux_NL_read == true))) {
        cpp_current_dict["NL"] = var_NL_0d_int_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LIS == SCALAR_INT) && (aux_LIS_read == true))) {
    cpp_current_dict["LIS"] = var_LIS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NS == SCALAR_INT) && (aux_NS_read == true))) {
    cpp_current_dict["NS"] = var_NS_0d_int_Scalar;
  }
  return cpp_current_dict;
}

void _check_end_records(bool after_fend, bool after_mend, bool after_tend, bool mat, bool mf, bool mt, bool last_mat, bool last_mf, bool last_mt, bool section_encountered, bool found_tpid, ParsingOptions parse_opts) {
  if (parse_opts.ignore_send_records == false) {
    if ((after_mend == true || after_tend == true)) {
      throw std::runtime_error("No MF/MT section allowed after MEND/TEND record");
    }
    if ((after_fend == true && section_encountered == false)) {
      throw std::runtime_error("FEND record without preceding MF/MT section encountered");
    }
    if ((after_fend == true && last_mf >= mf)) {
      throw std::runtime_error("MF sections must be in ascending order");
    }
  }
  if ((found_tpid == false && parse_opts.ignore_missing_tpid == false)) {
    throw std::runtime_error("Tape ID (TPID) record missing in first line");
  }
}

py::dict parse_endf_istream(std::istream& cont, py::object exclude, py::object include, ParsingOptions parse_opts=default_parsing_options()) {
  bool is_firstline = true;
  std::streampos curpos;
  py::dict mfmt_dict;
  py::dict curdict;
  int mat;
  int mf;
  int mt;
  bool section_encountered = false;
  int last_mat;
  int last_mf;
  int last_mt;
  std::string cpp_line;
  std::vector<std::string> verbatim_section;
  bool found_tpid = false;
  bool after_fend = false;
  bool after_mend = false;
  bool after_tend = false;
  curpos = cont.tellg();
  while (std::getline(cont, cpp_line)) {
    mat = cpp_read_custom_int_field(cpp_line.c_str(), 66, 4);
    mf = cpp_read_custom_int_field(cpp_line.c_str(), 70, 2);
    mt = cpp_read_custom_int_field(cpp_line.c_str(), 72, 3);
    if ((mf == 0 && mt == 0 && is_firstline)) {
      found_tpid = true;
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf0mt0_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 1 && mt == 460) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf1mt460_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 1 && mt == 458) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf1mt458_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 1 && mt == 456) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf1mt456_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 1 && mt == 455) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf1mt455_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 1 && mt == 452) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf1mt452_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 1 && mt == 451) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf1mt451_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 2 && mt == 151) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf2mt151_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 3) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf3_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 4) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf4_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 5) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf5_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 6) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf6_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 7 && mt == 451) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf7mt451_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 7 && mt == 4) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf7mt4_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 7 && mt == 2) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf7mt2_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 8 && mt == 459) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf8mt459_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 8 && mt == 457) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf8mt457_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 8 && mt == 454) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf8mt454_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 8) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf8_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 9) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf9_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 10) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf10_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 12) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf12_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 13) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf13_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 14) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf14_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 15) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf15_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 23) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf23_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 26) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf26_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 27) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf27_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 28) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf28_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 31) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf31_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 32) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf32_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 33) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf33_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 34) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf34_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 35) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf35_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 40) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (mt != 0) {
        is_firstline = false;
      }
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf40_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if ((mf != 0 && mt != 0)) {
      verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
      {
        py::dict curdict = mfmt_dict;
        if (! curdict.contains(py::cast(mf))) {
          curdict[py::cast(mf)] = py::dict();
        }
        curdict = curdict[py::cast(mf)];
        curdict[py::cast(mt)] = verbatim_section;
      }
    } else if ((cpp_is_blank_line(cpp_line) && after_tend == false)) {
      if ((! parse_opts.ignore_blank_lines)) {
        throw std::runtime_error("Blank line detected: Correct file or use `ignore_blank_lines` option");
      }
    } else if ((after_mend == true && cpp_is_tend_record(cpp_line, parse_opts))) {
      after_mend = false;
      after_tend = true;
    } else if ((after_fend == true && cpp_is_mend_record(cpp_line, parse_opts))) {
      after_mend = true;
    } else if (cpp_is_fend_record(cpp_line, mat, parse_opts)) {
      after_fend = true;
    } else {
      throw std::runtime_error(
        std::string("Invalid line encountered! This line is outside any MF/MT section.\n")
        + "Line: " + cpp_line
      );
    }
    last_mat = mat;
    last_mf = mf;
    last_mt = mt;
    curpos = cont.tellg();
    is_firstline = false;
  }
  return mfmt_dict;
}

py::dict parse_mf0mt0(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf0mt0_istream(iss, parse_opts);
}

py::dict parse_mf1mt451(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf1mt451_istream(iss, parse_opts);
}

py::dict parse_mf1mt452(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf1mt452_istream(iss, parse_opts);
}

py::dict parse_mf1mt455(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf1mt455_istream(iss, parse_opts);
}

py::dict parse_mf1mt456(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf1mt456_istream(iss, parse_opts);
}

py::dict parse_mf1mt458(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf1mt458_istream(iss, parse_opts);
}

py::dict parse_mf1mt460(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf1mt460_istream(iss, parse_opts);
}

py::dict parse_mf2mt151(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf2mt151_istream(iss, parse_opts);
}

py::dict parse_mf3(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf3_istream(iss, parse_opts);
}

py::dict parse_mf4(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf4_istream(iss, parse_opts);
}

py::dict parse_mf5(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf5_istream(iss, parse_opts);
}

py::dict parse_mf6(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf6_istream(iss, parse_opts);
}

py::dict parse_mf7mt2(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf7mt2_istream(iss, parse_opts);
}

py::dict parse_mf7mt4(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf7mt4_istream(iss, parse_opts);
}

py::dict parse_mf7mt451(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf7mt451_istream(iss, parse_opts);
}

py::dict parse_mf8(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf8_istream(iss, parse_opts);
}

py::dict parse_mf8mt454(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf8mt454_istream(iss, parse_opts);
}

py::dict parse_mf8mt457(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf8mt457_istream(iss, parse_opts);
}

py::dict parse_mf8mt459(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf8mt459_istream(iss, parse_opts);
}

py::dict parse_mf9(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf9_istream(iss, parse_opts);
}

py::dict parse_mf10(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf10_istream(iss, parse_opts);
}

py::dict parse_mf12(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf12_istream(iss, parse_opts);
}

py::dict parse_mf13(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf13_istream(iss, parse_opts);
}

py::dict parse_mf14(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf14_istream(iss, parse_opts);
}

py::dict parse_mf15(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf15_istream(iss, parse_opts);
}

py::dict parse_mf23(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf23_istream(iss, parse_opts);
}

py::dict parse_mf26(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf26_istream(iss, parse_opts);
}

py::dict parse_mf27(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf27_istream(iss, parse_opts);
}

py::dict parse_mf28(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf28_istream(iss, parse_opts);
}

py::dict parse_mf31(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf31_istream(iss, parse_opts);
}

py::dict parse_mf32(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf32_istream(iss, parse_opts);
}

py::dict parse_mf33(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf33_istream(iss, parse_opts);
}

py::dict parse_mf34(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf34_istream(iss, parse_opts);
}

py::dict parse_mf35(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf35_istream(iss, parse_opts);
}

py::dict parse_mf40(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf40_istream(iss, parse_opts);
}

py::dict parse_endf(std::string& strcont, py::object exclude, py::object include, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_endf_istream(iss, exclude, include, parse_opts);
}

py::dict parse_mf0mt0_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf0mt0_istream(inpfile, parse_opts);
}

py::dict parse_mf1mt451_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf1mt451_istream(inpfile, parse_opts);
}

py::dict parse_mf1mt452_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf1mt452_istream(inpfile, parse_opts);
}

py::dict parse_mf1mt455_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf1mt455_istream(inpfile, parse_opts);
}

py::dict parse_mf1mt456_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf1mt456_istream(inpfile, parse_opts);
}

py::dict parse_mf1mt458_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf1mt458_istream(inpfile, parse_opts);
}

py::dict parse_mf1mt460_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf1mt460_istream(inpfile, parse_opts);
}

py::dict parse_mf2mt151_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf2mt151_istream(inpfile, parse_opts);
}

py::dict parse_mf3_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf3_istream(inpfile, parse_opts);
}

py::dict parse_mf4_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf4_istream(inpfile, parse_opts);
}

py::dict parse_mf5_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf5_istream(inpfile, parse_opts);
}

py::dict parse_mf6_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf6_istream(inpfile, parse_opts);
}

py::dict parse_mf7mt2_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf7mt2_istream(inpfile, parse_opts);
}

py::dict parse_mf7mt4_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf7mt4_istream(inpfile, parse_opts);
}

py::dict parse_mf7mt451_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf7mt451_istream(inpfile, parse_opts);
}

py::dict parse_mf8_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf8_istream(inpfile, parse_opts);
}

py::dict parse_mf8mt454_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf8mt454_istream(inpfile, parse_opts);
}

py::dict parse_mf8mt457_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf8mt457_istream(inpfile, parse_opts);
}

py::dict parse_mf8mt459_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf8mt459_istream(inpfile, parse_opts);
}

py::dict parse_mf9_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf9_istream(inpfile, parse_opts);
}

py::dict parse_mf10_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf10_istream(inpfile, parse_opts);
}

py::dict parse_mf12_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf12_istream(inpfile, parse_opts);
}

py::dict parse_mf13_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf13_istream(inpfile, parse_opts);
}

py::dict parse_mf14_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf14_istream(inpfile, parse_opts);
}

py::dict parse_mf15_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf15_istream(inpfile, parse_opts);
}

py::dict parse_mf23_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf23_istream(inpfile, parse_opts);
}

py::dict parse_mf26_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf26_istream(inpfile, parse_opts);
}

py::dict parse_mf27_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf27_istream(inpfile, parse_opts);
}

py::dict parse_mf28_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf28_istream(inpfile, parse_opts);
}

py::dict parse_mf31_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf31_istream(inpfile, parse_opts);
}

py::dict parse_mf32_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf32_istream(inpfile, parse_opts);
}

py::dict parse_mf33_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf33_istream(inpfile, parse_opts);
}

py::dict parse_mf34_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf34_istream(inpfile, parse_opts);
}

py::dict parse_mf35_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf35_istream(inpfile, parse_opts);
}

py::dict parse_mf40_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf40_istream(inpfile, parse_opts);
}

py::dict parse_endf_file(std::string& filename, py::object exclude, py::object include, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename, std::ios::binary);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_endf_istream(inpfile, exclude, include, parse_opts);
}



// MD5 hash of ENDF recipe underlying the following function: a38e6e76968fb4463ab67282d5c7f80d
// MD5 hash of the following function definition: 9ff583f3d69360039fd954893548056a
void write_mf0mt0_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  std::string var_TAPEDESCR_0d_string_Scalar;
  bool aux_TAPEDESCR_read = false;
  vartype aux_last_type_read_for_TAPEDESCR = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 0;
  int mt = 0;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 0;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 0;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 0 , 0 / TAPEDESCR ] TEXT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  cpp_draft_line.replace(0, 66, py::cast<std::string>(cpp_index_shifter_store.get_value("TAPEDESCR", std::vector<int>({}), py::none())));
  // assign expression to variable TAPEDESCR
  var_TAPEDESCR_0d_string_Scalar = py::cast<std::string>(cpp_index_shifter_store.get_value("TAPEDESCR", std::vector<int>({}), py::none()));
  aux_TAPEDESCR_read = true;
  validate_vartype_consistency("TAPEDESCR", SCALAR_STRING, aux_last_type_read_for_TAPEDESCR);
  aux_last_type_read_for_TAPEDESCR = SCALAR_STRING;
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 58de2de2b82537497333c5e7a5bc310c
// MD5 hash of the following function definition: f237e5815268e9b1ff178c7d13daaef6
void write_mf1mt451_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LRP_0d_int_Scalar;
  bool aux_LRP_read = false;
  vartype aux_last_type_read_for_LRP = UNKNOWN;
  int var_LFI_0d_int_Scalar;
  bool aux_LFI_read = false;
  vartype aux_last_type_read_for_LFI = UNKNOWN;
  int var_NLIB_0d_int_Scalar;
  bool aux_NLIB_read = false;
  vartype aux_last_type_read_for_NLIB = UNKNOWN;
  int var_NMOD_0d_int_Scalar;
  bool aux_NMOD_read = false;
  vartype aux_last_type_read_for_NMOD = UNKNOWN;
  EndfFloatCpp var_ELIS_0d_double_Scalar;
  bool aux_ELIS_read = false;
  vartype aux_last_type_read_for_ELIS = UNKNOWN;
  EndfFloatCpp var_STA_0d_double_Scalar;
  bool aux_STA_read = false;
  vartype aux_last_type_read_for_STA = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_LISO_0d_int_Scalar;
  bool aux_LISO_read = false;
  vartype aux_last_type_read_for_LISO = UNKNOWN;
  int var_NFOR_0d_int_Scalar;
  bool aux_NFOR_read = false;
  vartype aux_last_type_read_for_NFOR = UNKNOWN;
  EndfFloatCpp var_AWI_0d_double_Scalar;
  bool aux_AWI_read = false;
  vartype aux_last_type_read_for_AWI = UNKNOWN;
  EndfFloatCpp var_EMAX_0d_double_Scalar;
  bool aux_EMAX_read = false;
  vartype aux_last_type_read_for_EMAX = UNKNOWN;
  int var_LREL_0d_int_Scalar;
  bool aux_LREL_read = false;
  vartype aux_last_type_read_for_LREL = UNKNOWN;
  int var_NSUB_0d_int_Scalar;
  bool aux_NSUB_read = false;
  vartype aux_last_type_read_for_NSUB = UNKNOWN;
  int var_NVER_0d_int_Scalar;
  bool aux_NVER_read = false;
  vartype aux_last_type_read_for_NVER = UNKNOWN;
  EndfFloatCpp var_TEMP_0d_double_Scalar;
  bool aux_TEMP_read = false;
  vartype aux_last_type_read_for_TEMP = UNKNOWN;
  int var_LDRV_0d_int_Scalar;
  bool aux_LDRV_read = false;
  vartype aux_last_type_read_for_LDRV = UNKNOWN;
  int var_NWD_0d_int_Scalar;
  bool aux_NWD_read = false;
  vartype aux_last_type_read_for_NWD = UNKNOWN;
  int var_NXC_0d_int_Scalar;
  bool aux_NXC_read = false;
  vartype aux_last_type_read_for_NXC = UNKNOWN;
  std::string var_ZSYMAM_0d_string_Scalar;
  bool aux_ZSYMAM_read = false;
  vartype aux_last_type_read_for_ZSYMAM = UNKNOWN;
  std::string var_ALAB_0d_string_Scalar;
  bool aux_ALAB_read = false;
  vartype aux_last_type_read_for_ALAB = UNKNOWN;
  std::string var_EDATE_0d_string_Scalar;
  bool aux_EDATE_read = false;
  vartype aux_last_type_read_for_EDATE = UNKNOWN;
  std::string var_AUTH_0d_string_Scalar;
  bool aux_AUTH_read = false;
  vartype aux_last_type_read_for_AUTH = UNKNOWN;
  std::string var_REF_0d_string_Scalar;
  bool aux_REF_read = false;
  vartype aux_last_type_read_for_REF = UNKNOWN;
  std::string var_DDATE_0d_string_Scalar;
  bool aux_DDATE_read = false;
  vartype aux_last_type_read_for_DDATE = UNKNOWN;
  std::string var_RDATE_0d_string_Scalar;
  bool aux_RDATE_read = false;
  vartype aux_last_type_read_for_RDATE = UNKNOWN;
  std::string var_ENDATE_0d_string_Scalar;
  bool aux_ENDATE_read = false;
  vartype aux_last_type_read_for_ENDATE = UNKNOWN;
  NestedVector<std::string> var_HSUB_1d_string_NestedVector;
  vartype aux_last_type_read_for_HSUB = UNKNOWN;
  NestedVector<std::string> var_DESCRIPTION_1d_string_NestedVector;
  vartype aux_last_type_read_for_DESCRIPTION = UNKNOWN;
  NestedVector<int> var_MFx_1d_int_NestedVector;
  vartype aux_last_type_read_for_MFx = UNKNOWN;
  NestedVector<int> var_MTx_1d_int_NestedVector;
  vartype aux_last_type_read_for_MTx = UNKNOWN;
  NestedVector<int> var_NCx_1d_int_NestedVector;
  vartype aux_last_type_read_for_NCx = UNKNOWN;
  NestedVector<int> var_MOD_1d_int_NestedVector;
  vartype aux_last_type_read_for_MOD = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 1;
  int mt = 451;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 451;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 1 , 451 / ZA , AWR , LRP , LFI , NLIB , NMOD ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LRP", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LRP
  var_LRP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LRP", std::vector<int>({}), py::none()));
  aux_LRP_read = true;
  validate_vartype_consistency("LRP", SCALAR_INT, aux_last_type_read_for_LRP);
  aux_last_type_read_for_LRP = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LFI", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LFI
  var_LFI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFI", std::vector<int>({}), py::none()));
  aux_LFI_read = true;
  validate_vartype_consistency("LFI", SCALAR_INT, aux_last_type_read_for_LFI);
  aux_last_type_read_for_LFI = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLIB", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NLIB
  var_NLIB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLIB", std::vector<int>({}), py::none()));
  aux_NLIB_read = true;
  validate_vartype_consistency("NLIB", SCALAR_INT, aux_last_type_read_for_NLIB);
  aux_last_type_read_for_NLIB = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NMOD", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NMOD
  var_NMOD_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NMOD", std::vector<int>({}), py::none()));
  aux_NMOD_read = true;
  validate_vartype_consistency("NMOD", SCALAR_INT, aux_last_type_read_for_NMOD);
  aux_last_type_read_for_NMOD = SCALAR_INT;
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 1 , 451 / ELIS , STA , LIS , LISO , 0 , NFOR ] CONT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ELIS", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ELIS
  var_ELIS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ELIS", std::vector<int>({}), py::none()));
  aux_ELIS_read = true;
  validate_vartype_consistency("ELIS", SCALAR_DOUBLE, aux_last_type_read_for_ELIS);
  aux_last_type_read_for_ELIS = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("STA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable STA
  var_STA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("STA", std::vector<int>({}), py::none()));
  aux_STA_read = true;
  validate_vartype_consistency("STA", SCALAR_DOUBLE, aux_last_type_read_for_STA);
  aux_last_type_read_for_STA = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none()));
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LISO", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LISO
  var_LISO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LISO", std::vector<int>({}), py::none()));
  aux_LISO_read = true;
  validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
  aux_last_type_read_for_LISO = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NFOR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NFOR
  var_NFOR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NFOR", std::vector<int>({}), py::none()));
  aux_NFOR_read = true;
  validate_vartype_consistency("NFOR", SCALAR_INT, aux_last_type_read_for_NFOR);
  aux_last_type_read_for_NFOR = SCALAR_INT;
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 1 , 451 / AWI , EMAX , LREL , 0 , NSUB , NVER ] CONT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWI", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWI
  var_AWI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWI", std::vector<int>({}), py::none()));
  aux_AWI_read = true;
  validate_vartype_consistency("AWI", SCALAR_DOUBLE, aux_last_type_read_for_AWI);
  aux_last_type_read_for_AWI = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EMAX", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable EMAX
  var_EMAX_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EMAX", std::vector<int>({}), py::none()));
  aux_EMAX_read = true;
  validate_vartype_consistency("EMAX", SCALAR_DOUBLE, aux_last_type_read_for_EMAX);
  aux_last_type_read_for_EMAX = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LREL", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LREL
  var_LREL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LREL", std::vector<int>({}), py::none()));
  aux_LREL_read = true;
  validate_vartype_consistency("LREL", SCALAR_INT, aux_last_type_read_for_LREL);
  aux_last_type_read_for_LREL = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NSUB", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NSUB
  var_NSUB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NSUB", std::vector<int>({}), py::none()));
  aux_NSUB_read = true;
  validate_vartype_consistency("NSUB", SCALAR_INT, aux_last_type_read_for_NSUB);
  aux_last_type_read_for_NSUB = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NVER", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NVER
  var_NVER_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NVER", std::vector<int>({}), py::none()));
  aux_NVER_read = true;
  validate_vartype_consistency("NVER", SCALAR_INT, aux_last_type_read_for_NVER);
  aux_last_type_read_for_NVER = SCALAR_INT;
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 1 , 451 / TEMP , 0.0 , LDRV , 0 , NWD , NXC ] CONT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TEMP", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable TEMP
  var_TEMP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TEMP", std::vector<int>({}), py::none()));
  aux_TEMP_read = true;
  validate_vartype_consistency("TEMP", SCALAR_DOUBLE, aux_last_type_read_for_TEMP);
  aux_last_type_read_for_TEMP = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LDRV", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LDRV
  var_LDRV_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LDRV", std::vector<int>({}), py::none()));
  aux_LDRV_read = true;
  validate_vartype_consistency("LDRV", SCALAR_INT, aux_last_type_read_for_LDRV);
  aux_last_type_read_for_LDRV = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NWD", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NWD
  var_NWD_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NWD", std::vector<int>({}), py::none()));
  aux_NWD_read = true;
  validate_vartype_consistency("NWD", SCALAR_INT, aux_last_type_read_for_NWD);
  aux_last_type_read_for_NWD = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NXC", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NXC
  var_NXC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NXC", std::vector<int>({}), py::none()));
  aux_NXC_read = true;
  validate_vartype_consistency("NXC", SCALAR_INT, aux_last_type_read_for_NXC);
  aux_last_type_read_for_NXC = SCALAR_INT;
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 1 , 451 / ZSYMAM { 11 } , ALAB { 11 } , EDATE { 10 } , { 1 } , AUTH { 33 } ] TEXT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  cpp_draft_line.replace(0, 11, py::cast<std::string>(cpp_index_shifter_store.get_value("ZSYMAM", std::vector<int>({}), py::none())));
  // assign expression to variable ZSYMAM
  var_ZSYMAM_0d_string_Scalar = py::cast<std::string>(cpp_index_shifter_store.get_value("ZSYMAM", std::vector<int>({}), py::none()));
  aux_ZSYMAM_read = true;
  validate_vartype_consistency("ZSYMAM", SCALAR_STRING, aux_last_type_read_for_ZSYMAM);
  aux_last_type_read_for_ZSYMAM = SCALAR_STRING;
  cpp_draft_line.replace(11, 11, py::cast<std::string>(cpp_index_shifter_store.get_value("ALAB", std::vector<int>({}), py::none())));
  // assign expression to variable ALAB
  var_ALAB_0d_string_Scalar = py::cast<std::string>(cpp_index_shifter_store.get_value("ALAB", std::vector<int>({}), py::none()));
  aux_ALAB_read = true;
  validate_vartype_consistency("ALAB", SCALAR_STRING, aux_last_type_read_for_ALAB);
  aux_last_type_read_for_ALAB = SCALAR_STRING;
  cpp_draft_line.replace(22, 10, py::cast<std::string>(cpp_index_shifter_store.get_value("EDATE", std::vector<int>({}), py::none())));
  // assign expression to variable EDATE
  var_EDATE_0d_string_Scalar = py::cast<std::string>(cpp_index_shifter_store.get_value("EDATE", std::vector<int>({}), py::none()));
  aux_EDATE_read = true;
  validate_vartype_consistency("EDATE", SCALAR_STRING, aux_last_type_read_for_EDATE);
  aux_last_type_read_for_EDATE = SCALAR_STRING;
  cpp_draft_line.replace(33, 33, py::cast<std::string>(cpp_index_shifter_store.get_value("AUTH", std::vector<int>({}), py::none())));
  // assign expression to variable AUTH
  var_AUTH_0d_string_Scalar = py::cast<std::string>(cpp_index_shifter_store.get_value("AUTH", std::vector<int>({}), py::none()));
  aux_AUTH_read = true;
  validate_vartype_consistency("AUTH", SCALAR_STRING, aux_last_type_read_for_AUTH);
  aux_last_type_read_for_AUTH = SCALAR_STRING;
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 1 , 451 / { 1 } , REF { 21 } , DDATE { 10 } , { 1 } , \n RDATE { 10 } , { 12 } , ENDATE { 8 } , { 3 } ] TEXT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  cpp_draft_line.replace(1, 21, py::cast<std::string>(cpp_index_shifter_store.get_value("REF", std::vector<int>({}), py::none())));
  // assign expression to variable REF
  var_REF_0d_string_Scalar = py::cast<std::string>(cpp_index_shifter_store.get_value("REF", std::vector<int>({}), py::none()));
  aux_REF_read = true;
  validate_vartype_consistency("REF", SCALAR_STRING, aux_last_type_read_for_REF);
  aux_last_type_read_for_REF = SCALAR_STRING;
  cpp_draft_line.replace(22, 10, py::cast<std::string>(cpp_index_shifter_store.get_value("DDATE", std::vector<int>({}), py::none())));
  // assign expression to variable DDATE
  var_DDATE_0d_string_Scalar = py::cast<std::string>(cpp_index_shifter_store.get_value("DDATE", std::vector<int>({}), py::none()));
  aux_DDATE_read = true;
  validate_vartype_consistency("DDATE", SCALAR_STRING, aux_last_type_read_for_DDATE);
  aux_last_type_read_for_DDATE = SCALAR_STRING;
  cpp_draft_line.replace(33, 10, py::cast<std::string>(cpp_index_shifter_store.get_value("RDATE", std::vector<int>({}), py::none())));
  // assign expression to variable RDATE
  var_RDATE_0d_string_Scalar = py::cast<std::string>(cpp_index_shifter_store.get_value("RDATE", std::vector<int>({}), py::none()));
  aux_RDATE_read = true;
  validate_vartype_consistency("RDATE", SCALAR_STRING, aux_last_type_read_for_RDATE);
  aux_last_type_read_for_RDATE = SCALAR_STRING;
  cpp_draft_line.replace(55, 8, py::cast<std::string>(cpp_index_shifter_store.get_value("ENDATE", std::vector<int>({}), py::none())));
  // assign expression to variable ENDATE
  var_ENDATE_0d_string_Scalar = py::cast<std::string>(cpp_index_shifter_store.get_value("ENDATE", std::vector<int>({}), py::none()));
  aux_ENDATE_read = true;
  validate_vartype_consistency("ENDATE", SCALAR_STRING, aux_last_type_read_for_ENDATE);
  aux_last_type_read_for_ENDATE = SCALAR_STRING;
  cont << cpp_draft_line;

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= 3; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 1 , 451 / HSUB [ i ] ] TEXT";
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
    cpp_draft_line.replace(0, 66, py::cast<std::string>(cpp_index_shifter_store.get_value("HSUB", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
    // assign expression to variable HSUB
    var_HSUB_1d_string_NestedVector.set(var_i_0d_int_Scalar, py::cast<std::string>(cpp_index_shifter_store.get_value("HSUB", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
    validate_vartype_consistency("HSUB", NESTEDVECTOR_STRING, aux_last_type_read_for_HSUB);
    aux_last_type_read_for_HSUB = NESTEDVECTOR_STRING;
    cont << cpp_draft_line;
  }

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= (var_NWD_0d_int_Scalar-5); var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 1 , 451 / DESCRIPTION [ i ] ] TEXT";
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
    cpp_draft_line.replace(0, 66, py::cast<std::string>(cpp_index_shifter_store.get_value("DESCRIPTION", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
    // assign expression to variable DESCRIPTION
    var_DESCRIPTION_1d_string_NestedVector.set(var_i_0d_int_Scalar, py::cast<std::string>(cpp_index_shifter_store.get_value("DESCRIPTION", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
    validate_vartype_consistency("DESCRIPTION", NESTEDVECTOR_STRING, aux_last_type_read_for_DESCRIPTION);
    aux_last_type_read_for_DESCRIPTION = NESTEDVECTOR_STRING;
    cont << cpp_draft_line;
  }

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NXC_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 1 , 451 / blank , blank , MFx , MTx , NCx , MOD ] DIR";
    // read TEXT record
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("MFx", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
    // assign expression to variable MFx
    var_MFx_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("MFx", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
    validate_vartype_consistency("MFx", NESTEDVECTOR_INT, aux_last_type_read_for_MFx);
    aux_last_type_read_for_MFx = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MTx", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
    // assign expression to variable MTx
    var_MTx_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("MTx", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
    validate_vartype_consistency("MTx", NESTEDVECTOR_INT, aux_last_type_read_for_MTx);
    aux_last_type_read_for_MTx = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NCx", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
    // assign expression to variable NCx
    var_NCx_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NCx", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
    validate_vartype_consistency("NCx", NESTEDVECTOR_INT, aux_last_type_read_for_NCx);
    aux_last_type_read_for_NCx = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("MOD", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
    // assign expression to variable MOD
    var_MOD_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("MOD", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
    validate_vartype_consistency("MOD", NESTEDVECTOR_INT, aux_last_type_read_for_MOD);
    aux_last_type_read_for_MOD = NESTEDVECTOR_INT;
    cont << cpp_draft_line;
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 714e5d90ebe6fa41e07bef414c2ac8f4
// MD5 hash of the following function definition: a92cd0ac35f0910f53cc83c8ab301b75
void write_mf1mt452_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LNU_0d_int_Scalar;
  bool aux_LNU_read = false;
  vartype aux_last_type_read_for_LNU = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  NestedVector<EndfFloatCpp> var_C_1d_double_NestedVector;
  vartype aux_last_type_read_for_C = UNKNOWN;
  std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<EndfFloatCpp> var_nu_0d_floatvec_Scalar;
  bool aux_nu_read = false;
  vartype aux_last_type_read_for_nu = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 1;
  int mt = 452;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 452;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 1 , 452 / ZA , AWR , 0 , LNU , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LNU", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LNU
  var_LNU_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LNU", std::vector<int>({}), py::none()));
  aux_LNU_read = true;
  validate_vartype_consistency("LNU", SCALAR_INT, aux_last_type_read_for_LNU);
  aux_last_type_read_for_LNU = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 1 , 452 / 0.0 , 0.0 , 0 , 0 , NC , 0 / { C } { k = 1 to NC } ] LIST";
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        // read LIST record
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none())), write_opts);
        // assign expression to variable NC
        var_NC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none()));
        aux_NC_read = true;
        validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
        aux_last_type_read_for_NC = SCALAR_INT;
        cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none())), write_opts);
        cont << cpp_draft_line;
        {
          int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none()));
          int cpp_i = 0;
          int cpp_j = 0;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read LIST body

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NC_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // read LIST body
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("C", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
            // assign expression to variable C
            var_C_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("C", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
            validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
            aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
          }
          if (cpp_i != cpp_npl) {
            throw std::runtime_error("not exactly NPL elements consumed");
          }
        }
        cont << cpp_draft_line;
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 452 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nu ] TAB1";
          // read TAB1 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
          cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
          cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
          tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("nu", std::vector<int>({}), py::none()));
          tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Eint
            var_Eint_0d_floatvec_Scalar = tab_body.X;
            aux_Eint_read = true;
            validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
            aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
            // assign expression to variable nu
            var_nu_0d_floatvec_Scalar = tab_body.Y;
            aux_nu_read = true;
            validate_vartype_consistency("nu", SCALAR_FLOATVEC, aux_last_type_read_for_nu);
            aux_last_type_read_for_nu = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 6372082f09eb7576770b456ddd80b3fb
// MD5 hash of the following function definition: 61d8d58b07228a7fc2e4aabef085575d
void write_mf1mt455_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LDG_0d_int_Scalar;
  bool aux_LDG_read = false;
  vartype aux_last_type_read_for_LDG = UNKNOWN;
  int var_LNU_0d_int_Scalar;
  bool aux_LNU_read = false;
  vartype aux_last_type_read_for_LNU = UNKNOWN;
  int var_NNF_0d_int_Scalar;
  bool aux_NNF_read = false;
  vartype aux_last_type_read_for_NNF = UNKNOWN;
  NestedVector<EndfFloatCpp> var_lambda_1d_double_NestedVector;
  vartype aux_last_type_read_for_lambda = UNKNOWN;
  std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<EndfFloatCpp> var_nubar_d_0d_floatvec_Scalar;
  EndfFloatCpp var_nubar_d_0d_double_Scalar;
  bool aux_nubar_d_read = false;
  vartype aux_last_type_read_for_nubar_d = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int var_NE_0d_int_Scalar;
  bool aux_NE_read = false;
  vartype aux_last_type_read_for_NE = UNKNOWN;
  NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_lambda_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_lambda_2d_idx0;
  NestedVector<NestedVector<EndfFloatCpp>> var_alpha_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_alpha_2d_idx0;
  vartype aux_last_type_read_for_alpha = UNKNOWN;
  EndfFloatCpp var_E1_0d_double_Scalar;
  bool aux_E1_read = false;
  vartype aux_last_type_read_for_E1 = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  NestedVector<EndfFloatCpp> var_nubar_d_1d_double_NestedVector;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 1;
  int mt = 455;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 455;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 1 , 455 / ZA , AWR , LDG , LNU , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LDG", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LDG
  var_LDG_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LDG", std::vector<int>({}), py::none()));
  aux_LDG_read = true;
  validate_vartype_consistency("LDG", SCALAR_INT, aux_last_type_read_for_LDG);
  aux_last_type_read_for_LDG = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LNU", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LNU
  var_LNU_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LNU", std::vector<int>({}), py::none()));
  aux_LNU_read = true;
  validate_vartype_consistency("LNU", SCALAR_INT, aux_last_type_read_for_LNU);
  aux_last_type_read_for_LNU = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(0)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NNF , 0 / \n { lambda } { k = 1 to NNF } ] LIST";
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        // read LIST record
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none())), write_opts);
        // assign expression to variable NNF
        var_NNF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()));
        aux_NNF_read = true;
        validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
        aux_last_type_read_for_NNF = SCALAR_INT;
        cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none())), write_opts);
        cont << cpp_draft_line;
        {
          int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()));
          int cpp_i = 0;
          int cpp_j = 0;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read LIST body

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // read LIST body
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("lambda", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
            // assign expression to variable lambda
            var_lambda_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("lambda", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
            validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
            aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
          }
          if (cpp_i != cpp_npl) {
            throw std::runtime_error("not exactly NPL elements consumed");
          }
        }
        cont << cpp_draft_line;
        cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nubar_d ] TAB1";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
        cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
        cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
        cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
        cont << cpp_draft_line;
        tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
        tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("nubar_d", std::vector<int>({}), py::none()));
        tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
        tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
        write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
        {
          Tab1Body tab_body = tab1_body;
          // assign expression to variable Eint
          var_Eint_0d_floatvec_Scalar = tab_body.X;
          aux_Eint_read = true;
          validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
          aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
          // assign expression to variable nubar_d
          var_nubar_d_0d_floatvec_Scalar = tab_body.Y;
          aux_nubar_d_read = true;
          validate_vartype_consistency("nubar_d", SCALAR_FLOATVEC, aux_last_type_read_for_nubar_d);
          aux_last_type_read_for_nubar_d = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
        cont << cpp_draft_line;
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(1)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
          // read TAB2 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NE
          var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
          aux_NE_read = true;
          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
          aux_last_type_read_for_NE = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
          cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          cont << cpp_draft_line;
          tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
          write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
          {
            Tab2Body tab_body = tab2_body;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            cpp_template = "[ MAT , 1 , 455 / 0.0 , E , 0 , 0 , (NNF*2) , 0 / \n { lambda , alpha } { l = 1 to NNF } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()))*2), write_opts);
            // assign expression to variable cpp_int_val
            cpp_int_val = (py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()))*2);
            aux_cpp_int_val_read = true;
            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
            // assign expression to variable NNF
            var_NNF_0d_int_Scalar = (cpp_int_val/2);
            aux_NNF_read = true;
            validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
            aux_last_type_read_for_NNF = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()))*2), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = (py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()))*2);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read LIST body
              ptr_lambda_2d_idx0 = var_lambda_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
              ptr_alpha_2d_idx0 = var_alpha_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                // read LIST body
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("lambda", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable lambda
                ptr_lambda_2d_idx0->set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("lambda", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
                aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("alpha", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable alpha
                ptr_alpha_2d_idx0->set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("alpha", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("alpha", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_alpha);
                aux_last_type_read_for_alpha = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
          }
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nubar_d ] TAB1";
          // read TAB1 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
          cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
          cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
          tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("nubar_d", std::vector<int>({}), py::none()));
          tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Eint
            var_Eint_0d_floatvec_Scalar = tab_body.X;
            aux_Eint_read = true;
            validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
            aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
            // assign expression to variable nubar_d
            var_nubar_d_0d_floatvec_Scalar = tab_body.Y;
            aux_nubar_d_read = true;
            validate_vartype_consistency("nubar_d", SCALAR_FLOATVEC, aux_last_type_read_for_nubar_d);
            aux_last_type_read_for_nubar_d = SCALAR_FLOATVEC;
            if ((! (aux_INT_read == true))) {
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
            } else {
            }
            if ((! (aux_NBT_read == true))) {
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            } else {
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(0)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NNF , 0 / { lambda } { k = 1 to NNF } ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read LIST record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NNF
          var_NNF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()));
          aux_NNF_read = true;
          validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
          aux_last_type_read_for_NNF = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none())), write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()));
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("lambda", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable lambda
              var_lambda_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("lambda", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
              aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , 1 , 0 / nubar_d ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read LIST record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, 1, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, 1, write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = 1;
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST body
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("nubar_d", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable nubar_d
            var_nubar_d_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("nubar_d", std::vector<int>({}), py::none()));
            aux_nubar_d_read = true;
            validate_vartype_consistency("nubar_d", SCALAR_DOUBLE, aux_last_type_read_for_nubar_d);
            aux_last_type_read_for_nubar_d = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(1)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
          // read TAB2 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NE
          var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
          aux_NE_read = true;
          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
          aux_last_type_read_for_NE = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
          cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          cont << cpp_draft_line;
          tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
          write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
          {
            Tab2Body tab_body = tab2_body;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            cpp_template = "[ MAT , 1 , 455 / 0.0 , E1 , 0 , 0 , (NNF*2) , 0 / \n { lambda , alpha } { l = 1 to NNF } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable E1
            var_E1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none()));
            aux_E1_read = true;
            validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
            aux_last_type_read_for_E1 = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()))*2), write_opts);
            // assign expression to variable cpp_int_val
            cpp_int_val = (py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()))*2);
            aux_cpp_int_val_read = true;
            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
            // assign expression to variable NNF
            var_NNF_0d_int_Scalar = (cpp_int_val/2);
            aux_NNF_read = true;
            validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
            aux_last_type_read_for_NNF = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()))*2), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = (py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()))*2);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read LIST body
              ptr_lambda_2d_idx0 = var_lambda_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
              ptr_alpha_2d_idx0 = var_alpha_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                // read LIST body
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("lambda", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable lambda
                ptr_lambda_2d_idx0->set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("lambda", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
                aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("alpha", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable alpha
                ptr_alpha_2d_idx0->set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("alpha", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("alpha", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_alpha);
                aux_last_type_read_for_alpha = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
          }
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NC , 0 / { nubar_d } { k = 1 to NC } ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read LIST record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NC
          var_NC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none()));
          aux_NC_read = true;
          validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
          aux_last_type_read_for_NC = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none())), write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none()));
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NC_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("nubar_d", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable nubar_d
              var_nubar_d_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("nubar_d", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("nubar_d", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_nubar_d);
              aux_last_type_read_for_nubar_d = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: dc95e75784d9f676b28daf84959ecfb2
// MD5 hash of the following function definition: cdf4298b26a2b0977e246ead1601f7bd
void write_mf1mt456_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LNU_0d_int_Scalar;
  bool aux_LNU_read = false;
  vartype aux_last_type_read_for_LNU = UNKNOWN;
  std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<EndfFloatCpp> var_nubar_p_0d_floatvec_Scalar;
  EndfFloatCpp var_nubar_p_0d_double_Scalar;
  bool aux_nubar_p_read = false;
  vartype aux_last_type_read_for_nubar_p = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 1;
  int mt = 456;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 456;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 1 , 456 / ZA , AWR , 0 , LNU , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LNU", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LNU
  var_LNU_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LNU", std::vector<int>({}), py::none()));
  aux_LNU_read = true;
  validate_vartype_consistency("LNU", SCALAR_INT, aux_last_type_read_for_LNU);
  aux_last_type_read_for_LNU = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 1 , 456 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nubar_p ] TAB1";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
        cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
        cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
        cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
        cont << cpp_draft_line;
        tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
        tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("nubar_p", std::vector<int>({}), py::none()));
        tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
        tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
        write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
        {
          Tab1Body tab_body = tab1_body;
          // assign expression to variable Eint
          var_Eint_0d_floatvec_Scalar = tab_body.X;
          aux_Eint_read = true;
          validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
          aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
          // assign expression to variable nubar_p
          var_nubar_p_0d_floatvec_Scalar = tab_body.Y;
          aux_nubar_p_read = true;
          validate_vartype_consistency("nubar_p", SCALAR_FLOATVEC, aux_last_type_read_for_nubar_p);
          aux_last_type_read_for_nubar_p = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
        cont << cpp_draft_line;
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 456 / 0.0 , 0.0 , 0 , 0 , 1 , 0 / nubar_p ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read LIST record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, 1, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, 1, write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = 1;
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST body
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("nubar_p", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable nubar_p
            var_nubar_p_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("nubar_p", std::vector<int>({}), py::none()));
            aux_nubar_p_read = true;
            validate_vartype_consistency("nubar_p", SCALAR_DOUBLE, aux_last_type_read_for_nubar_p);
            aux_last_type_read_for_nubar_p = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 5b7d22a0815ff99a2cbd6db8a6ad59a3
// MD5 hash of the following function definition: 08b12b73869b880999d5c3fb5605574e
void write_mf1mt458_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LFC_0d_int_Scalar;
  bool aux_LFC_read = false;
  vartype aux_last_type_read_for_LFC = UNKNOWN;
  int var_NPLY_0d_int_Scalar;
  bool aux_NPLY_read = false;
  vartype aux_last_type_read_for_NPLY = UNKNOWN;
  EndfFloatCpp var_EFR_0d_double_Scalar;
  bool aux_EFR_read = false;
  vartype aux_last_type_read_for_EFR = UNKNOWN;
  EndfFloatCpp var_dEFR_0d_double_Scalar;
  bool aux_dEFR_read = false;
  vartype aux_last_type_read_for_dEFR = UNKNOWN;
  EndfFloatCpp var_ENP_0d_double_Scalar;
  bool aux_ENP_read = false;
  vartype aux_last_type_read_for_ENP = UNKNOWN;
  EndfFloatCpp var_dENP_0d_double_Scalar;
  bool aux_dENP_read = false;
  vartype aux_last_type_read_for_dENP = UNKNOWN;
  EndfFloatCpp var_END_0d_double_Scalar;
  bool aux_END_read = false;
  vartype aux_last_type_read_for_END = UNKNOWN;
  EndfFloatCpp var_dEND_0d_double_Scalar;
  bool aux_dEND_read = false;
  vartype aux_last_type_read_for_dEND = UNKNOWN;
  EndfFloatCpp var_EGP_0d_double_Scalar;
  bool aux_EGP_read = false;
  vartype aux_last_type_read_for_EGP = UNKNOWN;
  EndfFloatCpp var_dEGP_0d_double_Scalar;
  bool aux_dEGP_read = false;
  vartype aux_last_type_read_for_dEGP = UNKNOWN;
  EndfFloatCpp var_EGD_0d_double_Scalar;
  bool aux_EGD_read = false;
  vartype aux_last_type_read_for_EGD = UNKNOWN;
  EndfFloatCpp var_dEGD_0d_double_Scalar;
  bool aux_dEGD_read = false;
  vartype aux_last_type_read_for_dEGD = UNKNOWN;
  EndfFloatCpp var_EB_0d_double_Scalar;
  bool aux_EB_read = false;
  vartype aux_last_type_read_for_EB = UNKNOWN;
  EndfFloatCpp var_dEB_0d_double_Scalar;
  bool aux_dEB_read = false;
  vartype aux_last_type_read_for_dEB = UNKNOWN;
  EndfFloatCpp var_ENU_0d_double_Scalar;
  bool aux_ENU_read = false;
  vartype aux_last_type_read_for_ENU = UNKNOWN;
  EndfFloatCpp var_dENU_0d_double_Scalar;
  bool aux_dENU_read = false;
  vartype aux_last_type_read_for_dENU = UNKNOWN;
  EndfFloatCpp var_ER_0d_double_Scalar;
  bool aux_ER_read = false;
  vartype aux_last_type_read_for_ER = UNKNOWN;
  EndfFloatCpp var_dER_0d_double_Scalar;
  bool aux_dER_read = false;
  vartype aux_last_type_read_for_dER = UNKNOWN;
  EndfFloatCpp var_ET_0d_double_Scalar;
  bool aux_ET_read = false;
  vartype aux_last_type_read_for_ET = UNKNOWN;
  EndfFloatCpp var_dET_0d_double_Scalar;
  bool aux_dET_read = false;
  vartype aux_last_type_read_for_dET = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_EFR_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EFR = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_EFR_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EFR = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_ENP_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ENP = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_ENP_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ENP = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_END_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_END = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_END_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_END = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_EGP_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EGP = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_EGP_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EGP = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_EGD_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EGD = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_EGD_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EGD = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_EB_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EB = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_EB_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EB = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_ENU_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ENU = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_ENU_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ENU = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_ER_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ER = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_ER_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ER = UNKNOWN;
  NestedVector<EndfFloatCpp> var_c_ET_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ET = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dc_ET_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ET = UNKNOWN;
  int var_NFC_0d_int_Scalar;
  bool aux_NFC_read = false;
  vartype aux_last_type_read_for_NFC = UNKNOWN;
  NestedVector<int> var_LDRV_1d_int_NestedVector;
  vartype aux_last_type_read_for_LDRV = UNKNOWN;
  NestedVector<int> var_IFC_1d_int_NestedVector;
  vartype aux_last_type_read_for_IFC = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 1;
  int mt = 458;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 458;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LFC_0d_int_Scalar = var_LFC_0d_int_Scalar;
          int var_LFC_0d_int_Scalar = glob_var_LFC_0d_int_Scalar;
          bool& glob_aux_LFC_read = aux_LFC_read;
          bool aux_LFC_read = glob_aux_LFC_read;
          vartype aux_last_type_read_for_LFC = UNKNOWN;
          int& glob_var_NPLY_0d_int_Scalar = var_NPLY_0d_int_Scalar;
          int var_NPLY_0d_int_Scalar = glob_var_NPLY_0d_int_Scalar;
          bool& glob_aux_NPLY_read = aux_NPLY_read;
          bool aux_NPLY_read = glob_aux_NPLY_read;
          vartype aux_last_type_read_for_NPLY = UNKNOWN;
          try {
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::cast(-99999.9)));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::cast(-99999.9)));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFC", std::vector<int>({}), py::cast(-99999)));
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
            // read LIST record
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::cast(-99999)));
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
          } catch (const std::out_of_range& e) {
            // // accept failure in lookahead
          }
          if (((((((((aux_LFC_read == true)) && ((var_LFC_0d_int_Scalar)==(0)))))&&((((aux_NPLY_read == true)) && ((var_NPLY_0d_int_Scalar)==(0)))))))) {
            cpp_found_match = true;
          }
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read CONT record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LFC", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LFC
          var_LFC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFC", std::vector<int>({}), py::none()));
          aux_LFC_read = true;
          validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
          aux_last_type_read_for_LFC = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cont << cpp_draft_line;
          cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read LIST record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NPLY
          var_NPLY_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::none()));
          aux_NPLY_read = true;
          validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
          aux_last_type_read_for_NPLY = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, 18, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, 9, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, 18, write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = 18;
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST body
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EFR", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable EFR
            var_EFR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EFR", std::vector<int>({}), py::none()));
            aux_EFR_read = true;
            validate_vartype_consistency("EFR", SCALAR_DOUBLE, aux_last_type_read_for_EFR);
            aux_last_type_read_for_EFR = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEFR", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable dEFR
            var_dEFR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEFR", std::vector<int>({}), py::none()));
            aux_dEFR_read = true;
            validate_vartype_consistency("dEFR", SCALAR_DOUBLE, aux_last_type_read_for_dEFR);
            aux_last_type_read_for_dEFR = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ENP", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable ENP
            var_ENP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ENP", std::vector<int>({}), py::none()));
            aux_ENP_read = true;
            validate_vartype_consistency("ENP", SCALAR_DOUBLE, aux_last_type_read_for_ENP);
            aux_last_type_read_for_ENP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dENP", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable dENP
            var_dENP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dENP", std::vector<int>({}), py::none()));
            aux_dENP_read = true;
            validate_vartype_consistency("dENP", SCALAR_DOUBLE, aux_last_type_read_for_dENP);
            aux_last_type_read_for_dENP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("END", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable END
            var_END_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("END", std::vector<int>({}), py::none()));
            aux_END_read = true;
            validate_vartype_consistency("END", SCALAR_DOUBLE, aux_last_type_read_for_END);
            aux_last_type_read_for_END = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEND", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable dEND
            var_dEND_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEND", std::vector<int>({}), py::none()));
            aux_dEND_read = true;
            validate_vartype_consistency("dEND", SCALAR_DOUBLE, aux_last_type_read_for_dEND);
            aux_last_type_read_for_dEND = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EGP", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable EGP
            var_EGP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EGP", std::vector<int>({}), py::none()));
            aux_EGP_read = true;
            validate_vartype_consistency("EGP", SCALAR_DOUBLE, aux_last_type_read_for_EGP);
            aux_last_type_read_for_EGP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEGP", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable dEGP
            var_dEGP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEGP", std::vector<int>({}), py::none()));
            aux_dEGP_read = true;
            validate_vartype_consistency("dEGP", SCALAR_DOUBLE, aux_last_type_read_for_dEGP);
            aux_last_type_read_for_dEGP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EGD", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable EGD
            var_EGD_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EGD", std::vector<int>({}), py::none()));
            aux_EGD_read = true;
            validate_vartype_consistency("EGD", SCALAR_DOUBLE, aux_last_type_read_for_EGD);
            aux_last_type_read_for_EGD = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEGD", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable dEGD
            var_dEGD_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEGD", std::vector<int>({}), py::none()));
            aux_dEGD_read = true;
            validate_vartype_consistency("dEGD", SCALAR_DOUBLE, aux_last_type_read_for_dEGD);
            aux_last_type_read_for_dEGD = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EB", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable EB
            var_EB_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EB", std::vector<int>({}), py::none()));
            aux_EB_read = true;
            validate_vartype_consistency("EB", SCALAR_DOUBLE, aux_last_type_read_for_EB);
            aux_last_type_read_for_EB = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEB", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable dEB
            var_dEB_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEB", std::vector<int>({}), py::none()));
            aux_dEB_read = true;
            validate_vartype_consistency("dEB", SCALAR_DOUBLE, aux_last_type_read_for_dEB);
            aux_last_type_read_for_dEB = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ENU", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable ENU
            var_ENU_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ENU", std::vector<int>({}), py::none()));
            aux_ENU_read = true;
            validate_vartype_consistency("ENU", SCALAR_DOUBLE, aux_last_type_read_for_ENU);
            aux_last_type_read_for_ENU = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dENU", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable dENU
            var_dENU_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dENU", std::vector<int>({}), py::none()));
            aux_dENU_read = true;
            validate_vartype_consistency("dENU", SCALAR_DOUBLE, aux_last_type_read_for_dENU);
            aux_last_type_read_for_dENU = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable ER
            var_ER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none()));
            aux_ER_read = true;
            validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
            aux_last_type_read_for_ER = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable dER
            var_dER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none()));
            aux_dER_read = true;
            validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
            aux_last_type_read_for_dER = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ET", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable ET
            var_ET_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ET", std::vector<int>({}), py::none()));
            aux_ET_read = true;
            validate_vartype_consistency("ET", SCALAR_DOUBLE, aux_last_type_read_for_ET);
            aux_last_type_read_for_ET = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dET", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable dET
            var_dET_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dET", std::vector<int>({}), py::none()));
            aux_dET_read = true;
            validate_vartype_consistency("dET", SCALAR_DOUBLE, aux_last_type_read_for_dET);
            aux_last_type_read_for_dET = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_j = 0;
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LFC_0d_int_Scalar = var_LFC_0d_int_Scalar;
            int var_LFC_0d_int_Scalar = glob_var_LFC_0d_int_Scalar;
            bool& glob_aux_LFC_read = aux_LFC_read;
            bool aux_LFC_read = glob_aux_LFC_read;
            vartype aux_last_type_read_for_LFC = UNKNOWN;
            int& glob_var_NPLY_0d_int_Scalar = var_NPLY_0d_int_Scalar;
            int var_NPLY_0d_int_Scalar = glob_var_NPLY_0d_int_Scalar;
            bool& glob_aux_NPLY_read = aux_NPLY_read;
            bool aux_NPLY_read = glob_aux_NPLY_read;
            vartype aux_last_type_read_for_NPLY = UNKNOWN;
            int& glob_cpp_int_val = cpp_int_val;
            int cpp_int_val = glob_cpp_int_val;
            bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
            bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
            try {
              cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::cast(-99999.9)));
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::cast(-99999.9)));
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LFC
              var_LFC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFC", std::vector<int>({}), py::cast(-99999)));
              aux_LFC_read = true;
              validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
              aux_last_type_read_for_LFC = SCALAR_INT;
              cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , (18*(NPLY+1)) , (9*(NPLY+1)) / \n { c_EFR , dc_EFR , c_ENP , dc_ENP , c_END , dc_END , \n c_EGP , dc_EGP , c_EGD , dc_EGD , c_EB , dc_EB , \n c_ENU , dc_ENU , c_ER , dc_ER , c_ET , dc_ET } { k = 0 to NPLY } ] LIST";
              // read LIST record
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::cast(-99999)));
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
              if ((! (aux_NPLY_read == true))) {
                // assign expression to variable cpp_int_val
                cpp_int_val = (18*(py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::cast(-99999)))+1));
                aux_cpp_int_val_read = true;
                validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                // assign expression to variable NPLY
                var_NPLY_0d_int_Scalar = ((cpp_int_val+(-18))/18);
                aux_NPLY_read = true;
                validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
                aux_last_type_read_for_NPLY = SCALAR_INT;
              } else {
              }
              if ((! (aux_NPLY_read == true))) {
                // assign expression to variable cpp_int_val
                cpp_int_val = (9*(py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::cast(-99999)))+1));
                aux_cpp_int_val_read = true;
                validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                // assign expression to variable NPLY
                var_NPLY_0d_int_Scalar = ((cpp_int_val+(-9))/9);
                aux_NPLY_read = true;
                validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
                aux_last_type_read_for_NPLY = SCALAR_INT;
              } else {
              }
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if (((((((((aux_LFC_read == true)) && ((var_LFC_0d_int_Scalar)==(0)))))&&((((aux_NPLY_read == true)) && ((var_NPLY_0d_int_Scalar)>(0)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read CONT record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LFC", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFC", std::vector<int>({}), py::none()));
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cont << cpp_draft_line;
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , (18*(NPLY+1)) , (9*(NPLY+1)) / \n { c_EFR , dc_EFR , c_ENP , dc_ENP , c_END , dc_END , \n c_EGP , dc_EGP , c_EGD , dc_EGD , c_EB , dc_EB , \n c_ENU , dc_ENU , c_ER , dc_ER , c_ET , dc_ET } { k = 0 to NPLY } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::none()));
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, (18*(py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::none()))+1)), write_opts);
            if ((! (aux_NPLY_read == true))) {
              // assign expression to variable cpp_int_val
              cpp_int_val = (18*(py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::none()))+1));
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = ((cpp_int_val+(-18))/18);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } else {
            }
            cpp_write_field<int>(cpp_draft_line, 5, (9*(py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::none()))+1)), write_opts);
            if ((! (aux_NPLY_read == true))) {
              // assign expression to variable cpp_int_val
              cpp_int_val = (9*(py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::none()))+1));
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = ((cpp_int_val+(-9))/9);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } else {
            }
            cpp_write_field<int>(cpp_draft_line, 4, (18*(py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::none()))+1)), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = (18*(py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::none()))+1));
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read LIST body

              for (int var_k_0d_int_Scalar = 0;
                 var_k_0d_int_Scalar <= var_NPLY_0d_int_Scalar; var_k_0d_int_Scalar++) {
                bool aux_k_read = true;
                // read LIST body
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_EFR", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable c_EFR
                var_c_EFR_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_EFR", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("c_EFR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EFR);
                aux_last_type_read_for_c_EFR = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_EFR", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable dc_EFR
                var_dc_EFR_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_EFR", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("dc_EFR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EFR);
                aux_last_type_read_for_dc_EFR = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_ENP", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable c_ENP
                var_c_ENP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_ENP", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("c_ENP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ENP);
                aux_last_type_read_for_c_ENP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_ENP", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable dc_ENP
                var_dc_ENP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_ENP", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("dc_ENP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ENP);
                aux_last_type_read_for_dc_ENP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_END", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable c_END
                var_c_END_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_END", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("c_END", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_END);
                aux_last_type_read_for_c_END = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_END", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable dc_END
                var_dc_END_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_END", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("dc_END", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_END);
                aux_last_type_read_for_dc_END = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_EGP", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable c_EGP
                var_c_EGP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_EGP", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("c_EGP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EGP);
                aux_last_type_read_for_c_EGP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_EGP", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable dc_EGP
                var_dc_EGP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_EGP", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("dc_EGP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EGP);
                aux_last_type_read_for_dc_EGP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_EGD", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable c_EGD
                var_c_EGD_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_EGD", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("c_EGD", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EGD);
                aux_last_type_read_for_c_EGD = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_EGD", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable dc_EGD
                var_dc_EGD_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_EGD", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("dc_EGD", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EGD);
                aux_last_type_read_for_dc_EGD = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_EB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable c_EB
                var_c_EB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_EB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("c_EB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EB);
                aux_last_type_read_for_c_EB = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_EB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable dc_EB
                var_dc_EB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_EB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("dc_EB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EB);
                aux_last_type_read_for_dc_EB = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_ENU", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable c_ENU
                var_c_ENU_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_ENU", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("c_ENU", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ENU);
                aux_last_type_read_for_c_ENU = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_ENU", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable dc_ENU
                var_dc_ENU_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_ENU", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("dc_ENU", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ENU);
                aux_last_type_read_for_dc_ENU = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable c_ER
                var_c_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("c_ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ER);
                aux_last_type_read_for_c_ER = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable dc_ER
                var_dc_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("dc_ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ER);
                aux_last_type_read_for_dc_ER = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_ET", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable c_ET
                var_c_ET_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("c_ET", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("c_ET", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ET);
                aux_last_type_read_for_c_ET = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_ET", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable dc_ET
                var_dc_ET_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dc_ET", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("dc_ET", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ET);
                aux_last_type_read_for_dc_ET = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LFC_0d_int_Scalar = var_LFC_0d_int_Scalar;
            int var_LFC_0d_int_Scalar = glob_var_LFC_0d_int_Scalar;
            bool& glob_aux_LFC_read = aux_LFC_read;
            bool aux_LFC_read = glob_aux_LFC_read;
            vartype aux_last_type_read_for_LFC = UNKNOWN;
            int& glob_var_NFC_0d_int_Scalar = var_NFC_0d_int_Scalar;
            int var_NFC_0d_int_Scalar = glob_var_NFC_0d_int_Scalar;
            bool& glob_aux_NFC_read = aux_NFC_read;
            bool aux_NFC_read = glob_aux_NFC_read;
            vartype aux_last_type_read_for_NFC = UNKNOWN;
            int& glob_var_NPLY_0d_int_Scalar = var_NPLY_0d_int_Scalar;
            int var_NPLY_0d_int_Scalar = glob_var_NPLY_0d_int_Scalar;
            bool& glob_aux_NPLY_read = aux_NPLY_read;
            bool aux_NPLY_read = glob_aux_NPLY_read;
            vartype aux_last_type_read_for_NPLY = UNKNOWN;
            try {
              cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , NFC ] HEAD";
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::cast(-99999.9)));
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::cast(-99999.9)));
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LFC
              var_LFC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFC", std::vector<int>({}), py::cast(-99999)));
              aux_LFC_read = true;
              validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
              aux_last_type_read_for_LFC = SCALAR_INT;
              // assign expression to variable NFC
              var_NFC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NFC", std::vector<int>({}), py::cast(-99999)));
              aux_NFC_read = true;
              validate_vartype_consistency("NFC", SCALAR_INT, aux_last_type_read_for_NFC);
              aux_last_type_read_for_NFC = SCALAR_INT;
              cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
              // read LIST record
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::cast(-99999)));
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if (((((((((aux_LFC_read == true)) && ((var_LFC_0d_int_Scalar)==(1)))))&&((((aux_NPLY_read == true)) && ((var_NPLY_0d_int_Scalar)==(0)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , NFC ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read CONT record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LFC", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFC", std::vector<int>({}), py::none()));
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NFC", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NFC
            var_NFC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NFC", std::vector<int>({}), py::none()));
            aux_NFC_read = true;
            validate_vartype_consistency("NFC", SCALAR_INT, aux_last_type_read_for_NFC);
            aux_last_type_read_for_NFC = SCALAR_INT;
            cont << cpp_draft_line;
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NPLY", std::vector<int>({}), py::none()));
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, 18, write_opts);
            cpp_write_field<int>(cpp_draft_line, 5, 9, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, 18, write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = 18;
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read LIST body
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EFR", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable EFR
              var_EFR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EFR", std::vector<int>({}), py::none()));
              aux_EFR_read = true;
              validate_vartype_consistency("EFR", SCALAR_DOUBLE, aux_last_type_read_for_EFR);
              aux_last_type_read_for_EFR = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEFR", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable dEFR
              var_dEFR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEFR", std::vector<int>({}), py::none()));
              aux_dEFR_read = true;
              validate_vartype_consistency("dEFR", SCALAR_DOUBLE, aux_last_type_read_for_dEFR);
              aux_last_type_read_for_dEFR = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ENP", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable ENP
              var_ENP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ENP", std::vector<int>({}), py::none()));
              aux_ENP_read = true;
              validate_vartype_consistency("ENP", SCALAR_DOUBLE, aux_last_type_read_for_ENP);
              aux_last_type_read_for_ENP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dENP", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable dENP
              var_dENP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dENP", std::vector<int>({}), py::none()));
              aux_dENP_read = true;
              validate_vartype_consistency("dENP", SCALAR_DOUBLE, aux_last_type_read_for_dENP);
              aux_last_type_read_for_dENP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("END", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable END
              var_END_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("END", std::vector<int>({}), py::none()));
              aux_END_read = true;
              validate_vartype_consistency("END", SCALAR_DOUBLE, aux_last_type_read_for_END);
              aux_last_type_read_for_END = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEND", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable dEND
              var_dEND_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEND", std::vector<int>({}), py::none()));
              aux_dEND_read = true;
              validate_vartype_consistency("dEND", SCALAR_DOUBLE, aux_last_type_read_for_dEND);
              aux_last_type_read_for_dEND = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EGP", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable EGP
              var_EGP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EGP", std::vector<int>({}), py::none()));
              aux_EGP_read = true;
              validate_vartype_consistency("EGP", SCALAR_DOUBLE, aux_last_type_read_for_EGP);
              aux_last_type_read_for_EGP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEGP", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable dEGP
              var_dEGP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEGP", std::vector<int>({}), py::none()));
              aux_dEGP_read = true;
              validate_vartype_consistency("dEGP", SCALAR_DOUBLE, aux_last_type_read_for_dEGP);
              aux_last_type_read_for_dEGP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EGD", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable EGD
              var_EGD_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EGD", std::vector<int>({}), py::none()));
              aux_EGD_read = true;
              validate_vartype_consistency("EGD", SCALAR_DOUBLE, aux_last_type_read_for_EGD);
              aux_last_type_read_for_EGD = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEGD", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable dEGD
              var_dEGD_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEGD", std::vector<int>({}), py::none()));
              aux_dEGD_read = true;
              validate_vartype_consistency("dEGD", SCALAR_DOUBLE, aux_last_type_read_for_dEGD);
              aux_last_type_read_for_dEGD = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EB", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable EB
              var_EB_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EB", std::vector<int>({}), py::none()));
              aux_EB_read = true;
              validate_vartype_consistency("EB", SCALAR_DOUBLE, aux_last_type_read_for_EB);
              aux_last_type_read_for_EB = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEB", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable dEB
              var_dEB_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEB", std::vector<int>({}), py::none()));
              aux_dEB_read = true;
              validate_vartype_consistency("dEB", SCALAR_DOUBLE, aux_last_type_read_for_dEB);
              aux_last_type_read_for_dEB = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ENU", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable ENU
              var_ENU_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ENU", std::vector<int>({}), py::none()));
              aux_ENU_read = true;
              validate_vartype_consistency("ENU", SCALAR_DOUBLE, aux_last_type_read_for_ENU);
              aux_last_type_read_for_ENU = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dENU", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable dENU
              var_dENU_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dENU", std::vector<int>({}), py::none()));
              aux_dENU_read = true;
              validate_vartype_consistency("dENU", SCALAR_DOUBLE, aux_last_type_read_for_dENU);
              aux_last_type_read_for_dENU = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable ER
              var_ER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none()));
              aux_ER_read = true;
              validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
              aux_last_type_read_for_ER = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable dER
              var_dER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none()));
              aux_dER_read = true;
              validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
              aux_last_type_read_for_dER = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ET", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable ET
              var_ET_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ET", std::vector<int>({}), py::none()));
              aux_ET_read = true;
              validate_vartype_consistency("ET", SCALAR_DOUBLE, aux_last_type_read_for_ET);
              aux_last_type_read_for_ET = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dET", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable dET
              var_dET_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dET", std::vector<int>({}), py::none()));
              aux_dET_read = true;
              validate_vartype_consistency("dET", SCALAR_DOUBLE, aux_last_type_read_for_dET);
              aux_last_type_read_for_dET = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NFC_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , LDRV , IFC , NR , NP / Eint / EIFC ] TAB1 ( fiscomp [ k ] )";
              // read TAB1 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LDRV", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable LDRV
              var_LDRV_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("LDRV", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("LDRV", NESTEDVECTOR_INT, aux_last_type_read_for_LDRV);
              aux_last_type_read_for_LDRV = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("IFC", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable IFC
              var_IFC_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("IFC", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("IFC", NESTEDVECTOR_INT, aux_last_type_read_for_IFC);
              aux_last_type_read_for_IFC = NESTEDVECTOR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.get_value("fiscomp", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
                cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                cont << cpp_draft_line;
                tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("EIFC", std::vector<int>({}), py::none()));
                tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                // variable declarations
                std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
                bool aux_Eint_read = false;
                vartype aux_last_type_read_for_Eint = UNKNOWN;
                std::vector<EndfFloatCpp> var_EIFC_0d_floatvec_Scalar;
                bool aux_EIFC_read = false;
                vartype aux_last_type_read_for_EIFC = UNKNOWN;
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab1Body tab_body = tab1_body;
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                  // assign expression to variable EIFC
                  var_EIFC_0d_floatvec_Scalar = tab_body.Y;
                  aux_EIFC_read = true;
                  validate_vartype_consistency("EIFC", SCALAR_FLOATVEC, aux_last_type_read_for_EIFC);
                  aux_last_type_read_for_EIFC = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
                cpp_current_dict = cpp_parent_dict;
              }
            }
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: e21d94e5c8e9c65689f5e8851bc9d1cf
// MD5 hash of the following function definition: 171c86df12f2b6f2eadaed0e44221bed
void write_mf1mt460_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LO_0d_int_Scalar;
  bool aux_LO_read = false;
  vartype aux_last_type_read_for_LO = UNKNOWN;
  int var_NG_0d_int_Scalar;
  bool aux_NG_read = false;
  vartype aux_last_type_read_for_NG = UNKNOWN;
  NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  int var_NNF_0d_int_Scalar;
  bool aux_NNF_read = false;
  vartype aux_last_type_read_for_NNF = UNKNOWN;
  NestedVector<EndfFloatCpp> var_lambda_1d_double_NestedVector;
  vartype aux_last_type_read_for_lambda = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 1;
  int mt = 460;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 460;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
          int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
          bool& glob_aux_LO_read = aux_LO_read;
          bool aux_LO_read = glob_aux_LO_read;
          vartype aux_last_type_read_for_LO = UNKNOWN;
          int& glob_var_NG_0d_int_Scalar = var_NG_0d_int_Scalar;
          int var_NG_0d_int_Scalar = glob_var_NG_0d_int_Scalar;
          bool& glob_aux_NG_read = aux_NG_read;
          bool aux_NG_read = glob_aux_NG_read;
          vartype aux_last_type_read_for_NG = UNKNOWN;
          try {
            cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , NG , 0 ] HEAD";
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::cast(-99999.9)));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::cast(-99999.9)));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LO
            var_LO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LO", std::vector<int>({}), py::cast(-99999)));
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            // assign expression to variable NG
            var_NG_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::cast(-99999)));
            aux_NG_read = true;
            validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
            aux_last_type_read_for_NG = SCALAR_INT;
          } catch (const std::out_of_range& e) {
            // // accept failure in lookahead
          }
          if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(1)))))))) {
            cpp_found_match = true;
          }
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , NG , 0 ] HEAD";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read CONT record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LO", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LO
          var_LO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LO", std::vector<int>({}), py::none()));
          aux_LO_read = true;
          validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
          aux_last_type_read_for_LO = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NG
          var_NG_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NG", std::vector<int>({}), py::none()));
          aux_NG_read = true;
          validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
          aux_last_type_read_for_NG = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cont << cpp_draft_line;

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_NG_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 1 , 460 / E , 0.0 , i , 0 , NR , NP / tint / T ] TAB1 ( table [ i ] )";
            // read TAB1 record
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, var_i_0d_int_Scalar, write_opts);
            if ((! (aux_i_read == true))) {
              // assign expression to variable i
            } else {
            }
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.get_value("table", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
              cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("tint", std::vector<int>({}), py::none())), write_opts);
              cpp_np_val = py::len(cpp_index_shifter_store.get_value("tint", std::vector<int>({}), py::none()));
              cont << cpp_draft_line;
              tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("tint", std::vector<int>({}), py::none()));
              tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("T", std::vector<int>({}), py::none()));
              tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
              write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
              // variable declarations
              std::vector<EndfFloatCpp> var_tint_0d_floatvec_Scalar;
              bool aux_tint_read = false;
              vartype aux_last_type_read_for_tint = UNKNOWN;
              std::vector<EndfFloatCpp> var_T_0d_floatvec_Scalar;
              bool aux_T_read = false;
              vartype aux_last_type_read_for_T = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = tab1_body;
                // assign expression to variable tint
                var_tint_0d_floatvec_Scalar = tab_body.X;
                aux_tint_read = true;
                validate_vartype_consistency("tint", SCALAR_FLOATVEC, aux_last_type_read_for_tint);
                aux_last_type_read_for_tint = SCALAR_FLOATVEC;
                // assign expression to variable T
                var_T_0d_floatvec_Scalar = tab_body.Y;
                aux_T_read = true;
                validate_vartype_consistency("T", SCALAR_FLOATVEC, aux_last_type_read_for_T);
                aux_last_type_read_for_T = SCALAR_FLOATVEC;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              cont << cpp_draft_line;
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
            int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
            bool& glob_aux_LO_read = aux_LO_read;
            bool aux_LO_read = glob_aux_LO_read;
            vartype aux_last_type_read_for_LO = UNKNOWN;
            try {
              cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , 0 , 0 ] HEAD";
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::cast(-99999.9)));
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::cast(-99999.9)));
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LO
              var_LO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LO", std::vector<int>({}), py::cast(-99999)));
              aux_LO_read = true;
              validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
              aux_last_type_read_for_LO = SCALAR_INT;
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(2)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , 0 , 0 ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read CONT record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LO", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LO
            var_LO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LO", std::vector<int>({}), py::none()));
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cont << cpp_draft_line;
            cpp_template = "[ MAT , 1 , 460 / 0.0 , 0.0 , 0 , 0 , NNF , 0 / \n { lambda } { i = 1 to NNF } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NNF
            var_NNF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()));
            aux_NNF_read = true;
            validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
            aux_last_type_read_for_NNF = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none())), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NNF", std::vector<int>({}), py::none()));
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read LIST body

              for (int var_i_0d_int_Scalar = 1;
                 var_i_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_i_0d_int_Scalar++) {
                bool aux_i_read = true;
                // read LIST body
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("lambda", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable lambda
                var_lambda_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("lambda", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
                aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 5fa12bb2c8f7635e2932396375ed29d8
// MD5 hash of the following function definition: a5bea0f3d40fdc94a93fb9ba1c1d5510
void write_mf2mt151_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NIS_0d_int_Scalar;
  bool aux_NIS_read = false;
  vartype aux_last_type_read_for_NIS = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 2;
  int mt = 151;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 2;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 151;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 2 , 151 / ZA , AWR , 0 , 0 , NIS , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NIS", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NIS
  var_NIS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NIS", std::vector<int>({}), py::none()));
  aux_NIS_read = true;
  validate_vartype_consistency("NIS", SCALAR_INT, aux_last_type_read_for_NIS);
  aux_last_type_read_for_NIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NIS_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    // open section isotope
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.get_value("isotope", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_ZAI_0d_double_Scalar;
      bool aux_ZAI_read = false;
      vartype aux_last_type_read_for_ZAI = UNKNOWN;
      EndfFloatCpp var_ABN_0d_double_Scalar;
      bool aux_ABN_read = false;
      vartype aux_last_type_read_for_ABN = UNKNOWN;
      int var_LFW_0d_int_Scalar;
      bool aux_LFW_read = false;
      vartype aux_last_type_read_for_LFW = UNKNOWN;
      int var_NER_0d_int_Scalar;
      bool aux_NER_read = false;
      vartype aux_last_type_read_for_NER = UNKNOWN;
      cpp_template = "[ MAT , 2 , 151 / ZAI , ABN , 0 , LFW , NER , 0 ] CONT";
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      // read CONT record
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAI", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable ZAI
      var_ZAI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAI", std::vector<int>({}), py::none()));
      aux_ZAI_read = true;
      validate_vartype_consistency("ZAI", SCALAR_DOUBLE, aux_last_type_read_for_ZAI);
      aux_last_type_read_for_ZAI = SCALAR_DOUBLE;
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ABN", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable ABN
      var_ABN_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ABN", std::vector<int>({}), py::none()));
      aux_ABN_read = true;
      validate_vartype_consistency("ABN", SCALAR_DOUBLE, aux_last_type_read_for_ABN);
      aux_last_type_read_for_ABN = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LFW", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable LFW
      var_LFW_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFW", std::vector<int>({}), py::none()));
      aux_LFW_read = true;
      validate_vartype_consistency("LFW", SCALAR_INT, aux_last_type_read_for_LFW);
      aux_last_type_read_for_LFW = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable NER
      var_NER_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()));
      aux_NER_read = true;
      validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
      aux_last_type_read_for_NER = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
      cont << cpp_draft_line;

      for (int var_j_0d_int_Scalar = 1;
         var_j_0d_int_Scalar <= var_NER_0d_int_Scalar; var_j_0d_int_Scalar++) {
        bool aux_j_read = true;
        // open section range
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.get_value("range", std::vector<int>({var_j_0d_int_Scalar}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          // variable declarations
          EndfFloatCpp var_EL_0d_double_Scalar;
          bool aux_EL_read = false;
          vartype aux_last_type_read_for_EL = UNKNOWN;
          EndfFloatCpp var_EH_0d_double_Scalar;
          bool aux_EH_read = false;
          vartype aux_last_type_read_for_EH = UNKNOWN;
          int var_LRU_0d_int_Scalar;
          bool aux_LRU_read = false;
          vartype aux_last_type_read_for_LRU = UNKNOWN;
          int var_LRF_0d_int_Scalar;
          bool aux_LRF_read = false;
          vartype aux_last_type_read_for_LRF = UNKNOWN;
          int var_NRO_0d_int_Scalar;
          bool aux_NRO_read = false;
          vartype aux_last_type_read_for_NRO = UNKNOWN;
          int var_NAPS_0d_int_Scalar;
          bool aux_NAPS_read = false;
          vartype aux_last_type_read_for_NAPS = UNKNOWN;
          EndfFloatCpp var_SPI_0d_double_Scalar;
          bool aux_SPI_read = false;
          vartype aux_last_type_read_for_SPI = UNKNOWN;
          EndfFloatCpp var_AP_0d_double_Scalar;
          std::vector<EndfFloatCpp> var_AP_0d_floatvec_Scalar;
          bool aux_AP_read = false;
          vartype aux_last_type_read_for_AP = UNKNOWN;
          int var_NLS_0d_int_Scalar;
          bool aux_NLS_read = false;
          vartype aux_last_type_read_for_NLS = UNKNOWN;
          std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
          bool aux_Eint_read = false;
          vartype aux_last_type_read_for_Eint = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          int var_LAD_0d_int_Scalar;
          bool aux_LAD_read = false;
          vartype aux_last_type_read_for_LAD = UNKNOWN;
          int var_NLSC_0d_int_Scalar;
          bool aux_NLSC_read = false;
          vartype aux_last_type_read_for_NLSC = UNKNOWN;
          int var_IFG_0d_int_Scalar;
          bool aux_IFG_read = false;
          vartype aux_last_type_read_for_IFG = UNKNOWN;
          int var_KRM_0d_int_Scalar;
          bool aux_KRM_read = false;
          vartype aux_last_type_read_for_KRM = UNKNOWN;
          int var_NJS_0d_int_Scalar;
          bool aux_NJS_read = false;
          vartype aux_last_type_read_for_NJS = UNKNOWN;
          int var_KRL_0d_int_Scalar;
          bool aux_KRL_read = false;
          vartype aux_last_type_read_for_KRL = UNKNOWN;
          int var_NPP_0d_int_Scalar;
          bool aux_NPP_read = false;
          vartype aux_last_type_read_for_NPP = UNKNOWN;
          int cpp_int_val;
          bool aux_cpp_int_val_read = false;
          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
          NestedVector<EndfFloatCpp> var_MA_1d_double_NestedVector;
          vartype aux_last_type_read_for_MA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_MB_1d_double_NestedVector;
          vartype aux_last_type_read_for_MB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_ZA_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_ZB_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_IA_1d_double_NestedVector;
          vartype aux_last_type_read_for_IA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_IB_1d_double_NestedVector;
          vartype aux_last_type_read_for_IB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_Q_1d_double_NestedVector;
          vartype aux_last_type_read_for_Q = UNKNOWN;
          NestedVector<EndfFloatCpp> var_PNT_1d_double_NestedVector;
          vartype aux_last_type_read_for_PNT = UNKNOWN;
          NestedVector<EndfFloatCpp> var_SHF_1d_double_NestedVector;
          vartype aux_last_type_read_for_SHF = UNKNOWN;
          NestedVector<EndfFloatCpp> var_MT_1d_double_NestedVector;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          NestedVector<EndfFloatCpp> var_PA_1d_double_NestedVector;
          vartype aux_last_type_read_for_PA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_PB_1d_double_NestedVector;
          vartype aux_last_type_read_for_PB = UNKNOWN;
          int var_LSSF_0d_int_Scalar;
          bool aux_LSSF_read = false;
          vartype aux_last_type_read_for_LSSF = UNKNOWN;
          int var_NE_0d_int_Scalar;
          bool aux_NE_read = false;
          vartype aux_last_type_read_for_NE = UNKNOWN;
          NestedVector<EndfFloatCpp> var_ES_1d_double_NestedVector;
          vartype aux_last_type_read_for_ES = UNKNOWN;
          cpp_template = "[ MAT , 2 , 151 / EL , EH , LRU , LRF , NRO , NAPS ] CONT";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read CONT record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EL", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable EL
          var_EL_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EL", std::vector<int>({}), py::none()));
          aux_EL_read = true;
          validate_vartype_consistency("EL", SCALAR_DOUBLE, aux_last_type_read_for_EL);
          aux_last_type_read_for_EL = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EH", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable EH
          var_EH_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EH", std::vector<int>({}), py::none()));
          aux_EH_read = true;
          validate_vartype_consistency("EH", SCALAR_DOUBLE, aux_last_type_read_for_EH);
          aux_last_type_read_for_EH = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LRU", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LRU
          var_LRU_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LRU", std::vector<int>({}), py::none()));
          aux_LRU_read = true;
          validate_vartype_consistency("LRU", SCALAR_INT, aux_last_type_read_for_LRU);
          aux_last_type_read_for_LRU = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LRF", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LRF
          var_LRF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LRF", std::vector<int>({}), py::none()));
          aux_LRF_read = true;
          validate_vartype_consistency("LRF", SCALAR_INT, aux_last_type_read_for_LRF);
          aux_last_type_read_for_LRF = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NRO", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NRO
          var_NRO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRO", std::vector<int>({}), py::none()));
          aux_NRO_read = true;
          validate_vartype_consistency("NRO", SCALAR_INT, aux_last_type_read_for_NRO);
          aux_last_type_read_for_NRO = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NAPS", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NAPS
          var_NAPS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NAPS", std::vector<int>({}), py::none()));
          aux_NAPS_read = true;
          validate_vartype_consistency("NAPS", SCALAR_INT, aux_last_type_read_for_NAPS);
          aux_last_type_read_for_NAPS = SCALAR_INT;
          cont << cpp_draft_line;
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((((((aux_NIS_read == true)) && ((var_NIS_0d_int_Scalar)==(1)))))&&((((aux_ZAI_read == true)) && ((var_ZAI_0d_double_Scalar)==(var_ZA_0d_double_Scalar)))))&&((((aux_ABN_read == true)) && ((var_ABN_0d_double_Scalar)==(1)))))&&((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(0)))))&&((((aux_NER_read == true)) && ((var_NER_0d_int_Scalar)==(1)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if (((((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(0)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(0)))))&&((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)==(0)))))&&((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      // evaluate if-elif-else clause
                      {
                        bool cpp_found_match = false;
                        if (! cpp_found_match) {
                          // if statement evaluation with lookahead
                          {
                            {
                              // variable declarations
                              EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                              EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                              bool& glob_aux_EL_read = aux_EL_read;
                              bool aux_EL_read = glob_aux_EL_read;
                              vartype aux_last_type_read_for_EL = UNKNOWN;
                              EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                              EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                              bool& glob_aux_EH_read = aux_EH_read;
                              bool aux_EH_read = glob_aux_EH_read;
                              vartype aux_last_type_read_for_EH = UNKNOWN;
                              int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                              int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                              bool& glob_aux_LRU_read = aux_LRU_read;
                              bool aux_LRU_read = glob_aux_LRU_read;
                              vartype aux_last_type_read_for_LRU = UNKNOWN;
                              int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                              int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                              bool& glob_aux_LRF_read = aux_LRF_read;
                              bool aux_LRF_read = glob_aux_LRF_read;
                              vartype aux_last_type_read_for_LRF = UNKNOWN;
                              int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                              int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                              bool& glob_aux_NRO_read = aux_NRO_read;
                              bool aux_NRO_read = glob_aux_NRO_read;
                              vartype aux_last_type_read_for_NRO = UNKNOWN;
                              int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                              int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                              bool& glob_aux_NAPS_read = aux_NAPS_read;
                              bool aux_NAPS_read = glob_aux_NAPS_read;
                              vartype aux_last_type_read_for_NAPS = UNKNOWN;
                              EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                              EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                              bool& glob_aux_SPI_read = aux_SPI_read;
                              bool aux_SPI_read = glob_aux_SPI_read;
                              vartype aux_last_type_read_for_SPI = UNKNOWN;
                              EndfFloatCpp& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                              EndfFloatCpp var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                              bool& glob_aux_AP_read = aux_AP_read;
                              bool aux_AP_read = glob_aux_AP_read;
                              vartype aux_last_type_read_for_AP = UNKNOWN;
                              int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                              int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                              bool& glob_aux_NLS_read = aux_NLS_read;
                              bool aux_NLS_read = glob_aux_NLS_read;
                              vartype aux_last_type_read_for_NLS = UNKNOWN;
                              try {
                                cpp_template = "[ MAT , 2 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                                // read CONT record
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::cast(-99999.9)));
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                                // assign expression to variable AP
                                var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::cast(-99999.9)));
                                aux_AP_read = true;
                                validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                                aux_last_type_read_for_AP = SCALAR_DOUBLE;
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::cast(-99999)));
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } catch (const std::out_of_range& e) {
                                // // accept failure in lookahead
                              }
                              if ((((((((aux_NLS_read == true)) && ((var_NLS_0d_int_Scalar)==(0)))))))) {
                                cpp_found_match = true;
                              }
                            }
                            if (cpp_found_match) {
                              cpp_template = "[ MAT , 2 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              // read CONT record
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none())), write_opts);
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                              cont << cpp_draft_line;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if (((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      // evaluate if-elif-else clause
                      {
                        bool cpp_found_match = false;
                        if (! cpp_found_match) {
                          if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                            // if statement evaluation
                            cpp_found_match = true;
                            cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                            // read TAB1 record
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                            cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                            cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
                            cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                            cont << cpp_draft_line;
                            tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                            tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                            tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                            tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                            write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                            {
                              Tab1Body tab_body = tab1_body;
                              // assign expression to variable Eint
                              var_Eint_0d_floatvec_Scalar = tab_body.X;
                              aux_Eint_read = true;
                              validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                              aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                              if ((! (aux_AP_read == true))) {
                                // assign expression to variable AP
                                var_AP_0d_floatvec_Scalar = tab_body.Y;
                                aux_AP_read = true;
                                validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                              } else {
                              }
                              // assign expression to variable INT
                              var_INT_0d_intvec_Scalar = tab_body.INT;
                              aux_INT_read = true;
                              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                              aux_last_type_read_for_INT = SCALAR_INTVEC;
                              // assign expression to variable NBT
                              var_NBT_0d_intvec_Scalar = tab_body.NBT;
                              aux_NBT_read = true;
                              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                              aux_last_type_read_for_NBT = SCALAR_INTVEC;
                            }
                            cont << cpp_draft_line;
                          }
                        }
                      }
                      // evaluate if-elif-else clause
                      {
                        bool cpp_found_match = false;
                        if (! cpp_found_match) {
                          if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                            // if statement evaluation
                            cpp_found_match = true;
                            cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , 0 , 0 , NLS , 0 ] CONT";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read CONT record
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                            if ((! (aux_SPI_read == true))) {
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                            } else {
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                            if ((! (aux_NLS_read == true))) {
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                            cont << cpp_draft_line;
                          }
                        }
                        if (! cpp_found_match) {
                          cpp_template = "[ MAT , 2 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read CONT record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                          if ((! (aux_SPI_read == true))) {
                            // assign expression to variable SPI
                            var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                            aux_SPI_read = true;
                            validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                            aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                          } else {
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none())), write_opts);
                          if ((! (aux_AP_read == true))) {
                            // assign expression to variable AP
                            var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                            aux_AP_read = true;
                            validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                            aux_last_type_read_for_AP = SCALAR_DOUBLE;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                          if ((! (aux_NLS_read == true))) {
                            // assign expression to variable NLS
                            var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                            aux_NLS_read = true;
                            validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                            aux_last_type_read_for_NLS = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                          cont << cpp_draft_line;
                        }
                      }

                      for (int var_m_0d_int_Scalar = 1;
                         var_m_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                        bool aux_m_read = true;
                        // open section spingroup
                        {
                          py::dict cpp_parent_dict = cpp_current_dict;
                          cpp_current_dict = cpp_index_shifter_store.get_value("spingroup", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                          // variable declarations
                          EndfFloatCpp var_AWRI_0d_double_Scalar;
                          bool aux_AWRI_read = false;
                          vartype aux_last_type_read_for_AWRI = UNKNOWN;
                          EndfFloatCpp var_QX_0d_double_Scalar;
                          bool aux_QX_read = false;
                          vartype aux_last_type_read_for_QX = UNKNOWN;
                          int var_L_0d_int_Scalar;
                          bool aux_L_read = false;
                          vartype aux_last_type_read_for_L = UNKNOWN;
                          int var_LRX_0d_int_Scalar;
                          bool aux_LRX_read = false;
                          vartype aux_last_type_read_for_LRX = UNKNOWN;
                          int cpp_int_val;
                          bool aux_cpp_int_val_read = false;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int var_NRS_0d_int_Scalar;
                          bool aux_NRS_read = false;
                          vartype aux_last_type_read_for_NRS = UNKNOWN;
                          NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                          vartype aux_last_type_read_for_ER = UNKNOWN;
                          NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                          vartype aux_last_type_read_for_AJ = UNKNOWN;
                          NestedVector<EndfFloatCpp> var_GT_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GT = UNKNOWN;
                          NestedVector<EndfFloatCpp> var_GN_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GN = UNKNOWN;
                          NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GG = UNKNOWN;
                          NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GF = UNKNOWN;
                          cpp_template = "[ MAT , 2 , 151 / AWRI , QX , L , LRX , (6*NRS) , NRS / \n { ER , AJ , GT , GN , GG , GF } { k = 1 to NRS } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable AWRI
                          var_AWRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none()));
                          aux_AWRI_read = true;
                          validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                          aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QX", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable QX
                          var_QX_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QX", std::vector<int>({}), py::none()));
                          aux_QX_read = true;
                          validate_vartype_consistency("QX", SCALAR_DOUBLE, aux_last_type_read_for_QX);
                          aux_last_type_read_for_QX = SCALAR_DOUBLE;
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable L
                          var_L_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none()));
                          aux_L_read = true;
                          validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                          aux_last_type_read_for_L = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LRX", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LRX
                          var_LRX_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LRX", std::vector<int>({}), py::none()));
                          aux_LRX_read = true;
                          validate_vartype_consistency("LRX", SCALAR_INT, aux_last_type_read_for_LRX);
                          aux_last_type_read_for_LRX = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none()))), write_opts);
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (6*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NRS
                          var_NRS_0d_int_Scalar = (cpp_int_val/6);
                          aux_NRS_read = true;
                          validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                          aux_last_type_read_for_NRS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())), write_opts);
                          if ((! (aux_NRS_read == true))) {
                            // assign expression to variable NRS
                            var_NRS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none()));
                            aux_NRS_read = true;
                            validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                            aux_last_type_read_for_NRS = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none()))), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = (6*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable ER
                              var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                              aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable AJ
                              var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                              aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GT", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable GT
                              var_GT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GT", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                              aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable GN
                              var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                              aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable GG
                              var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                              aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable GF
                              var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                              aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                          cpp_current_dict = cpp_parent_dict;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if ((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(3)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                              // read TAB1 record
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                              cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                              cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
                              cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                              cont << cpp_draft_line;
                              tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                              tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                              tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                              tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                              write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                              {
                                Tab1Body tab_body = tab1_body;
                                // assign expression to variable Eint
                                var_Eint_0d_floatvec_Scalar = tab_body.X;
                                aux_Eint_read = true;
                                validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                                aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                                if ((! (aux_AP_read == true))) {
                                  // assign expression to variable AP
                                  var_AP_0d_floatvec_Scalar = tab_body.Y;
                                  aux_AP_read = true;
                                  validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                  aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                                } else {
                                }
                                // assign expression to variable INT
                                var_INT_0d_intvec_Scalar = tab_body.INT;
                                aux_INT_read = true;
                                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                aux_last_type_read_for_INT = SCALAR_INTVEC;
                                // assign expression to variable NBT
                                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                aux_NBT_read = true;
                                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                aux_last_type_read_for_NBT = SCALAR_INTVEC;
                              }
                              cont << cpp_draft_line;
                            }
                          }
                        }
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , LAD , 0 , NLS , NLSC ] CONT";
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              // read CONT record
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                              if ((! (aux_SPI_read == true))) {
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              } else {
                              }
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LAD", std::vector<int>({}), py::none())), write_opts);
                              // assign expression to variable LAD
                              var_LAD_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LAD", std::vector<int>({}), py::none()));
                              aux_LAD_read = true;
                              validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                              aux_last_type_read_for_LAD = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                              if ((! (aux_NLS_read == true))) {
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } else {
                              }
                              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NLSC", std::vector<int>({}), py::none())), write_opts);
                              // assign expression to variable NLSC
                              var_NLSC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLSC", std::vector<int>({}), py::none()));
                              aux_NLSC_read = true;
                              validate_vartype_consistency("NLSC", SCALAR_INT, aux_last_type_read_for_NLSC);
                              aux_last_type_read_for_NLSC = SCALAR_INT;
                              cont << cpp_draft_line;
                            }
                          }
                          if (! cpp_found_match) {
                            cpp_template = "[ MAT , 2 , 151 / SPI , AP , LAD , 0 , NLS , NLSC ] CONT";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read CONT record
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                            if ((! (aux_SPI_read == true))) {
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                            } else {
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none())), write_opts);
                            if ((! (aux_AP_read == true))) {
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LAD", std::vector<int>({}), py::none())), write_opts);
                            // assign expression to variable LAD
                            var_LAD_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LAD", std::vector<int>({}), py::none()));
                            aux_LAD_read = true;
                            validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                            aux_last_type_read_for_LAD = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                            if ((! (aux_NLS_read == true))) {
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NLSC", std::vector<int>({}), py::none())), write_opts);
                            // assign expression to variable NLSC
                            var_NLSC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLSC", std::vector<int>({}), py::none()));
                            aux_NLSC_read = true;
                            validate_vartype_consistency("NLSC", SCALAR_INT, aux_last_type_read_for_NLSC);
                            aux_last_type_read_for_NLSC = SCALAR_INT;
                            cont << cpp_draft_line;
                          }
                        }

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // open section spingroup
                          {
                            py::dict cpp_parent_dict = cpp_current_dict;
                            cpp_current_dict = cpp_index_shifter_store.get_value("spingroup", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                            // variable declarations
                            EndfFloatCpp var_AWRI_0d_double_Scalar;
                            bool aux_AWRI_read = false;
                            vartype aux_last_type_read_for_AWRI = UNKNOWN;
                            EndfFloatCpp var_APL_0d_double_Scalar;
                            bool aux_APL_read = false;
                            vartype aux_last_type_read_for_APL = UNKNOWN;
                            int var_L_0d_int_Scalar;
                            bool aux_L_read = false;
                            vartype aux_last_type_read_for_L = UNKNOWN;
                            int cpp_int_val;
                            bool aux_cpp_int_val_read = false;
                            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                            int var_NRS_0d_int_Scalar;
                            bool aux_NRS_read = false;
                            vartype aux_last_type_read_for_NRS = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                            vartype aux_last_type_read_for_ER = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                            vartype aux_last_type_read_for_AJ = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_GN_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GN = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GG = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_GFA_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GFA = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_GFB_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GFB = UNKNOWN;
                            cpp_template = "[ MAT , 2 , 151 / AWRI , APL , L , 0 , (6*NRS) , NRS / \n { ER , AJ , GN , GG , GFA , GFB } { k = 1 to NRS } ] LIST";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST record
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none())), write_opts);
                            // assign expression to variable AWRI
                            var_AWRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none()));
                            aux_AWRI_read = true;
                            validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                            aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APL", std::vector<int>({}), py::none())), write_opts);
                            // assign expression to variable APL
                            var_APL_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APL", std::vector<int>({}), py::none()));
                            aux_APL_read = true;
                            validate_vartype_consistency("APL", SCALAR_DOUBLE, aux_last_type_read_for_APL);
                            aux_last_type_read_for_APL = SCALAR_DOUBLE;
                            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none())), write_opts);
                            // assign expression to variable L
                            var_L_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none()));
                            aux_L_read = true;
                            validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                            aux_last_type_read_for_L = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none()))), write_opts);
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (6*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NRS
                            var_NRS_0d_int_Scalar = (cpp_int_val/6);
                            aux_NRS_read = true;
                            validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                            aux_last_type_read_for_NRS = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())), write_opts);
                            if ((! (aux_NRS_read == true))) {
                              // assign expression to variable NRS
                              var_NRS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none()));
                              aux_NRS_read = true;
                              validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                              aux_last_type_read_for_NRS = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none()))), write_opts);
                            cont << cpp_draft_line;
                            {
                              int cpp_npl = (6*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())));
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              // read LIST body

                              for (int var_k_0d_int_Scalar = 1;
                                 var_k_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                                bool aux_k_read = true;
                                // read LIST body
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable ER
                                var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                                aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable AJ
                                var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                                aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable GN
                                var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                                aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable GG
                                var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                                aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GFA", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable GFA
                                var_GFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GFA", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("GFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFA);
                                aux_last_type_read_for_GFA = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GFB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable GFB
                                var_GFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GFB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("GFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFB);
                                aux_last_type_read_for_GFB = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            cont << cpp_draft_line;
                            cpp_current_dict = cpp_parent_dict;
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if ((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(7)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , IFG , KRM , NJS , KRL ] CONT";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read CONT record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("IFG", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable IFG
                        var_IFG_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("IFG", std::vector<int>({}), py::none()));
                        aux_IFG_read = true;
                        validate_vartype_consistency("IFG", SCALAR_INT, aux_last_type_read_for_IFG);
                        aux_last_type_read_for_IFG = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("KRM", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable KRM
                        var_KRM_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("KRM", std::vector<int>({}), py::none()));
                        aux_KRM_read = true;
                        validate_vartype_consistency("KRM", SCALAR_INT, aux_last_type_read_for_KRM);
                        aux_last_type_read_for_KRM = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NJS
                        var_NJS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none()));
                        aux_NJS_read = true;
                        validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                        aux_last_type_read_for_NJS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("KRL", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable KRL
                        var_KRL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("KRL", std::vector<int>({}), py::none()));
                        aux_KRL_read = true;
                        validate_vartype_consistency("KRL", SCALAR_INT, aux_last_type_read_for_KRL);
                        aux_last_type_read_for_KRL = SCALAR_INT;
                        cont << cpp_draft_line;
                        cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , NPP , 0 , (12*NPP) , (2*NPP) / \n { MA , MB , ZA , ZB , IA , IB , \n Q , PNT , SHF , MT , PA , PB } { k = 1 to NPP } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NPP
                        var_NPP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none()));
                        aux_NPP_read = true;
                        validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                        aux_last_type_read_for_NPP = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none()))), write_opts);
                        if ((! (aux_NPP_read == true))) {
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (12*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none())));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NPP
                          var_NPP_0d_int_Scalar = (cpp_int_val/12);
                          aux_NPP_read = true;
                          validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                          aux_last_type_read_for_NPP = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 5, (2*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none()))), write_opts);
                        if ((! (aux_NPP_read == true))) {
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none())));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NPP
                          var_NPP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NPP_read = true;
                          validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                          aux_last_type_read_for_NPP = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none()))), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = (12*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none())));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NPP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("MA", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable MA
                            var_MA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("MA", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("MA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MA);
                            aux_last_type_read_for_MA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("MB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable MB
                            var_MB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("MB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("MB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MB);
                            aux_last_type_read_for_MB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable ZA
                            var_ZA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("ZA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZA);
                            aux_last_type_read_for_ZA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable ZB
                            var_ZB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("ZB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZB);
                            aux_last_type_read_for_ZB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("IA", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable IA
                            var_IA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("IA", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("IA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IA);
                            aux_last_type_read_for_IA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("IB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable IB
                            var_IB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("IB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("IB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IB);
                            aux_last_type_read_for_IB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Q", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable Q
                            var_Q_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Q", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("Q", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Q);
                            aux_last_type_read_for_Q = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PNT", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable PNT
                            var_PNT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PNT", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("PNT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PNT);
                            aux_last_type_read_for_PNT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SHF", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable SHF
                            var_SHF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SHF", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("SHF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SHF);
                            aux_last_type_read_for_SHF = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("MT", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable MT
                            var_MT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("MT", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("MT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MT);
                            aux_last_type_read_for_MT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PA", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable PA
                            var_PA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PA", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("PA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PA);
                            aux_last_type_read_for_PA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable PB
                            var_PB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("PB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PB);
                            aux_last_type_read_for_PB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;

                        for (int var_k_0d_int_Scalar = 1;
                           var_k_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                          bool aux_k_read = true;
                          // open section spingroup
                          {
                            py::dict cpp_parent_dict = cpp_current_dict;
                            cpp_current_dict = cpp_index_shifter_store.get_value("spingroup", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                            // variable declarations
                            EndfFloatCpp var_AJ_0d_double_Scalar;
                            bool aux_AJ_read = false;
                            vartype aux_last_type_read_for_AJ = UNKNOWN;
                            EndfFloatCpp var_PJ_0d_double_Scalar;
                            bool aux_PJ_read = false;
                            vartype aux_last_type_read_for_PJ = UNKNOWN;
                            int var_KBK_0d_int_Scalar;
                            bool aux_KBK_read = false;
                            vartype aux_last_type_read_for_KBK = UNKNOWN;
                            int var_KPS_0d_int_Scalar;
                            bool aux_KPS_read = false;
                            vartype aux_last_type_read_for_KPS = UNKNOWN;
                            int cpp_int_val;
                            bool aux_cpp_int_val_read = false;
                            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                            int var_NCH_0d_int_Scalar;
                            bool aux_NCH_read = false;
                            vartype aux_last_type_read_for_NCH = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_PPI_1d_double_NestedVector;
                            vartype aux_last_type_read_for_PPI = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_L_1d_double_NestedVector;
                            vartype aux_last_type_read_for_L = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_SCH_1d_double_NestedVector;
                            vartype aux_last_type_read_for_SCH = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_BND_1d_double_NestedVector;
                            vartype aux_last_type_read_for_BND = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_APE_1d_double_NestedVector;
                            vartype aux_last_type_read_for_APE = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_APT_1d_double_NestedVector;
                            vartype aux_last_type_read_for_APT = UNKNOWN;
                            int var_NRS_0d_int_Scalar;
                            bool aux_NRS_read = false;
                            vartype aux_last_type_read_for_NRS = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                            vartype aux_last_type_read_for_ER = UNKNOWN;
                            Matrix2d<EndfFloatCpp> var_GAM_2d_double_Matrix2d;
                            vartype aux_last_type_read_for_GAM = UNKNOWN;
                            int var_NX_0d_int_Scalar;
                            bool aux_NX_read = false;
                            vartype aux_last_type_read_for_NX = UNKNOWN;
                            int var_LCH_0d_int_Scalar;
                            bool aux_LCH_read = false;
                            vartype aux_last_type_read_for_LCH = UNKNOWN;
                            int var_LBK_0d_int_Scalar;
                            bool aux_LBK_read = false;
                            vartype aux_last_type_read_for_LBK = UNKNOWN;
                            EndfFloatCpp var_ED_0d_double_Scalar;
                            bool aux_ED_read = false;
                            vartype aux_last_type_read_for_ED = UNKNOWN;
                            EndfFloatCpp var_EU_0d_double_Scalar;
                            bool aux_EU_read = false;
                            vartype aux_last_type_read_for_EU = UNKNOWN;
                            EndfFloatCpp var_R0_0d_double_Scalar;
                            bool aux_R0_read = false;
                            vartype aux_last_type_read_for_R0 = UNKNOWN;
                            EndfFloatCpp var_R1_0d_double_Scalar;
                            bool aux_R1_read = false;
                            vartype aux_last_type_read_for_R1 = UNKNOWN;
                            EndfFloatCpp var_R2_0d_double_Scalar;
                            bool aux_R2_read = false;
                            vartype aux_last_type_read_for_R2 = UNKNOWN;
                            EndfFloatCpp var_S0_0d_double_Scalar;
                            bool aux_S0_read = false;
                            vartype aux_last_type_read_for_S0 = UNKNOWN;
                            EndfFloatCpp var_S1_0d_double_Scalar;
                            bool aux_S1_read = false;
                            vartype aux_last_type_read_for_S1 = UNKNOWN;
                            EndfFloatCpp var_GA_0d_double_Scalar;
                            bool aux_GA_read = false;
                            vartype aux_last_type_read_for_GA = UNKNOWN;
                            int var_LPS_0d_int_Scalar;
                            bool aux_LPS_read = false;
                            vartype aux_last_type_read_for_LPS = UNKNOWN;
                            cpp_template = "[ MAT , 2 , 151 / AJ , PJ , KBK , KPS , (6*NCH) , NCH / \n { PPI , L , SCH , BND , APE , APT } { l = 1 to NCH } ] LIST";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST record
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({}), py::none())), write_opts);
                            // assign expression to variable AJ
                            var_AJ_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({}), py::none()));
                            aux_AJ_read = true;
                            validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                            aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PJ", std::vector<int>({}), py::none())), write_opts);
                            // assign expression to variable PJ
                            var_PJ_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PJ", std::vector<int>({}), py::none()));
                            aux_PJ_read = true;
                            validate_vartype_consistency("PJ", SCALAR_DOUBLE, aux_last_type_read_for_PJ);
                            aux_last_type_read_for_PJ = SCALAR_DOUBLE;
                            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("KBK", std::vector<int>({}), py::none())), write_opts);
                            // assign expression to variable KBK
                            var_KBK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("KBK", std::vector<int>({}), py::none()));
                            aux_KBK_read = true;
                            validate_vartype_consistency("KBK", SCALAR_INT, aux_last_type_read_for_KBK);
                            aux_last_type_read_for_KBK = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("KPS", std::vector<int>({}), py::none())), write_opts);
                            // assign expression to variable KPS
                            var_KPS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("KPS", std::vector<int>({}), py::none()));
                            aux_KPS_read = true;
                            validate_vartype_consistency("KPS", SCALAR_INT, aux_last_type_read_for_KPS);
                            aux_last_type_read_for_KPS = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none()))), write_opts);
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (6*py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NCH
                            var_NCH_0d_int_Scalar = (cpp_int_val/6);
                            aux_NCH_read = true;
                            validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                            aux_last_type_read_for_NCH = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())), write_opts);
                            if ((! (aux_NCH_read == true))) {
                              // assign expression to variable NCH
                              var_NCH_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none()));
                              aux_NCH_read = true;
                              validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                              aux_last_type_read_for_NCH = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none()))), write_opts);
                            cont << cpp_draft_line;
                            {
                              int cpp_npl = (6*py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())));
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              // read LIST body

                              for (int var_l_0d_int_Scalar = 1;
                                 var_l_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_l_0d_int_Scalar++) {
                                bool aux_l_read = true;
                                // read LIST body
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PPI", std::vector<int>({var_l_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable PPI
                                var_PPI_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PPI", std::vector<int>({var_l_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("PPI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PPI);
                                aux_last_type_read_for_PPI = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("L", std::vector<int>({var_l_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable L
                                var_L_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("L", std::vector<int>({var_l_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("L", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_L);
                                aux_last_type_read_for_L = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SCH", std::vector<int>({var_l_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable SCH
                                var_SCH_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SCH", std::vector<int>({var_l_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("SCH", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SCH);
                                aux_last_type_read_for_SCH = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("BND", std::vector<int>({var_l_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable BND
                                var_BND_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("BND", std::vector<int>({var_l_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("BND", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BND);
                                aux_last_type_read_for_BND = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APE", std::vector<int>({var_l_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable APE
                                var_APE_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APE", std::vector<int>({var_l_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("APE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APE);
                                aux_last_type_read_for_APE = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APT", std::vector<int>({var_l_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable APT
                                var_APT_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APT", std::vector<int>({var_l_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("APT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APT);
                                aux_last_type_read_for_APT = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            cont << cpp_draft_line;
                            // evaluate if-elif-else clause
                            {
                              bool cpp_found_match = false;
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  {
                                    // variable declarations
                                    EndfFloatCpp& glob_var_AJ_0d_double_Scalar = var_AJ_0d_double_Scalar;
                                    EndfFloatCpp var_AJ_0d_double_Scalar = glob_var_AJ_0d_double_Scalar;
                                    bool& glob_aux_AJ_read = aux_AJ_read;
                                    bool aux_AJ_read = glob_aux_AJ_read;
                                    vartype aux_last_type_read_for_AJ = UNKNOWN;
                                    EndfFloatCpp& glob_var_PJ_0d_double_Scalar = var_PJ_0d_double_Scalar;
                                    EndfFloatCpp var_PJ_0d_double_Scalar = glob_var_PJ_0d_double_Scalar;
                                    bool& glob_aux_PJ_read = aux_PJ_read;
                                    bool aux_PJ_read = glob_aux_PJ_read;
                                    vartype aux_last_type_read_for_PJ = UNKNOWN;
                                    int& glob_var_KBK_0d_int_Scalar = var_KBK_0d_int_Scalar;
                                    int var_KBK_0d_int_Scalar = glob_var_KBK_0d_int_Scalar;
                                    bool& glob_aux_KBK_read = aux_KBK_read;
                                    bool aux_KBK_read = glob_aux_KBK_read;
                                    vartype aux_last_type_read_for_KBK = UNKNOWN;
                                    int& glob_var_KPS_0d_int_Scalar = var_KPS_0d_int_Scalar;
                                    int var_KPS_0d_int_Scalar = glob_var_KPS_0d_int_Scalar;
                                    bool& glob_aux_KPS_read = aux_KPS_read;
                                    bool aux_KPS_read = glob_aux_KPS_read;
                                    vartype aux_last_type_read_for_KPS = UNKNOWN;
                                    int& glob_cpp_int_val = cpp_int_val;
                                    int cpp_int_val = glob_cpp_int_val;
                                    bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                                    bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                                    vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                    int& glob_var_NCH_0d_int_Scalar = var_NCH_0d_int_Scalar;
                                    int var_NCH_0d_int_Scalar = glob_var_NCH_0d_int_Scalar;
                                    bool& glob_aux_NCH_read = aux_NCH_read;
                                    bool aux_NCH_read = glob_aux_NCH_read;
                                    vartype aux_last_type_read_for_NCH = UNKNOWN;
                                    NestedVector<EndfFloatCpp>& glob_var_PPI_1d_double_NestedVector = var_PPI_1d_double_NestedVector;
                                    NestedVector<EndfFloatCpp> var_PPI_1d_double_NestedVector = glob_var_PPI_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_PPI = UNKNOWN;
                                    NestedVector<EndfFloatCpp>& glob_var_L_1d_double_NestedVector = var_L_1d_double_NestedVector;
                                    NestedVector<EndfFloatCpp> var_L_1d_double_NestedVector = glob_var_L_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_L = UNKNOWN;
                                    NestedVector<EndfFloatCpp>& glob_var_SCH_1d_double_NestedVector = var_SCH_1d_double_NestedVector;
                                    NestedVector<EndfFloatCpp> var_SCH_1d_double_NestedVector = glob_var_SCH_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_SCH = UNKNOWN;
                                    NestedVector<EndfFloatCpp>& glob_var_BND_1d_double_NestedVector = var_BND_1d_double_NestedVector;
                                    NestedVector<EndfFloatCpp> var_BND_1d_double_NestedVector = glob_var_BND_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_BND = UNKNOWN;
                                    NestedVector<EndfFloatCpp>& glob_var_APE_1d_double_NestedVector = var_APE_1d_double_NestedVector;
                                    NestedVector<EndfFloatCpp> var_APE_1d_double_NestedVector = glob_var_APE_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_APE = UNKNOWN;
                                    NestedVector<EndfFloatCpp>& glob_var_APT_1d_double_NestedVector = var_APT_1d_double_NestedVector;
                                    NestedVector<EndfFloatCpp> var_APT_1d_double_NestedVector = glob_var_APT_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_APT = UNKNOWN;
                                    int& glob_var_NRS_0d_int_Scalar = var_NRS_0d_int_Scalar;
                                    int var_NRS_0d_int_Scalar = glob_var_NRS_0d_int_Scalar;
                                    bool& glob_aux_NRS_read = aux_NRS_read;
                                    bool aux_NRS_read = glob_aux_NRS_read;
                                    vartype aux_last_type_read_for_NRS = UNKNOWN;
                                    try {
                                      cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*NX) , NX / \n { ER , { GAM } { m = 1 to NCH } , \n { 0.0 } { p = 1 to num_zeros } } { n = 1 to NRS } ] LIST";
                                      // read LIST record
                                      // assign expression to variable NRS
                                      var_NRS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::cast(-99999)));
                                      aux_NRS_read = true;
                                      validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                      aux_last_type_read_for_NRS = SCALAR_INT;
                                      if ((! (aux_NCH_read == true))) {
                                        throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NCH because the modulo operator is not supported.");
                                      } else {
                                      }
                                      if ((! (aux_NRS_read == true))) {
                                        throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NRS because the modulo operator is not supported.");
                                      } else {
                                      }
                                      if ((! (aux_NCH_read == true))) {
                                        throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NCH because the modulo operator is not supported.");
                                      } else {
                                      }
                                      if ((! (aux_NRS_read == true))) {
                                        throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NRS because the modulo operator is not supported.");
                                      } else {
                                      }
                                    } catch (const std::out_of_range& e) {
                                      // // accept failure in lookahead
                                    }
                                    if ((((((((aux_NRS_read == true)) && ((var_NRS_0d_int_Scalar)>(0)))))))) {
                                      cpp_found_match = true;
                                    }
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*((((1+NCH)+((5-NCH)%6))*NRS)/6)) , ((((1+NCH)+((5-NCH)%6))*NRS)/6) / \n { ER , { GAM } { m = 1 to NCH } , \n { 0.0 } { p = 1 to num_zeros } } { n = 1 to NRS } ] LIST";
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                    // read LIST record
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable NRS
                                    var_NRS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none()));
                                    aux_NRS_read = true;
                                    validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                    aux_last_type_read_for_NRS = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 4, (6*((((1+py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))+((5-py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))%6))*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())))/6)), write_opts);
                                    if ((! (aux_NCH_read == true))) {
                                      throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NCH because the modulo operator is not supported.");
                                    } else {
                                    }
                                    if ((! (aux_NRS_read == true))) {
                                      throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NRS because the modulo operator is not supported.");
                                    } else {
                                    }
                                    cpp_write_field<int>(cpp_draft_line, 5, ((((1+py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))+((5-py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))%6))*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())))/6), write_opts);
                                    if ((! (aux_NCH_read == true))) {
                                      throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NCH because the modulo operator is not supported.");
                                    } else {
                                    }
                                    if ((! (aux_NRS_read == true))) {
                                      throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NRS because the modulo operator is not supported.");
                                    } else {
                                    }
                                    cpp_write_field<int>(cpp_draft_line, 4, (6*((((1+py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))+((5-py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))%6))*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())))/6)), write_opts);
                                    cont << cpp_draft_line;
                                    {
                                      int cpp_npl = (6*((((1+py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))+((5-py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))%6))*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())))/6));
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      // read LIST body
                                      var_GAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRS_0d_int_Scalar, false, false);

                                      for (int var_n_0d_int_Scalar = 1;
                                         var_n_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                        bool aux_n_read = true;
                                        // read LIST body
                                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
                                        // assign expression to variable ER
                                        var_ER_1d_double_NestedVector.set(var_n_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
                                        validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                                        aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                                        cpp_i++;
                                        cpp_j++;
                                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                          cont << cpp_draft_line;
                                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                          cpp_j = 0;
                                        }

                                        for (int var_m_0d_int_Scalar = 1;
                                           var_m_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                          bool aux_m_read = true;
                                          // read LIST body
                                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GAM", std::vector<int>({var_m_0d_int_Scalar, var_n_0d_int_Scalar}), py::none())), write_opts);
                                          // assign expression to variable GAM
                                          var_GAM_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GAM", std::vector<int>({var_m_0d_int_Scalar, var_n_0d_int_Scalar}), py::none()));
                                          validate_vartype_consistency("GAM", MATRIX2D_DOUBLE, aux_last_type_read_for_GAM);
                                          aux_last_type_read_for_GAM = MATRIX2D_DOUBLE;
                                          cpp_i++;
                                          cpp_j++;
                                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                            cont << cpp_draft_line;
                                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                            cpp_j = 0;
                                          }
                                        }

                                        for (int var_p_0d_int_Scalar = 1;
                                           var_p_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_p_0d_int_Scalar++) {
                                          bool aux_p_read = true;
                                          // read LIST body
                                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                          cpp_i++;
                                          cpp_j++;
                                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                            cont << cpp_draft_line;
                                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                            cpp_j = 0;
                                          }
                                        }
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                    cont << cpp_draft_line;
                                  }
                                }
                              }
                              if (! cpp_found_match) {
                                if (! cpp_found_match) {
                                  // if statement evaluation with lookahead
                                  {
                                    {
                                      // variable declarations
                                      EndfFloatCpp& glob_var_AJ_0d_double_Scalar = var_AJ_0d_double_Scalar;
                                      EndfFloatCpp var_AJ_0d_double_Scalar = glob_var_AJ_0d_double_Scalar;
                                      bool& glob_aux_AJ_read = aux_AJ_read;
                                      bool aux_AJ_read = glob_aux_AJ_read;
                                      vartype aux_last_type_read_for_AJ = UNKNOWN;
                                      EndfFloatCpp& glob_var_PJ_0d_double_Scalar = var_PJ_0d_double_Scalar;
                                      EndfFloatCpp var_PJ_0d_double_Scalar = glob_var_PJ_0d_double_Scalar;
                                      bool& glob_aux_PJ_read = aux_PJ_read;
                                      bool aux_PJ_read = glob_aux_PJ_read;
                                      vartype aux_last_type_read_for_PJ = UNKNOWN;
                                      int& glob_var_KBK_0d_int_Scalar = var_KBK_0d_int_Scalar;
                                      int var_KBK_0d_int_Scalar = glob_var_KBK_0d_int_Scalar;
                                      bool& glob_aux_KBK_read = aux_KBK_read;
                                      bool aux_KBK_read = glob_aux_KBK_read;
                                      vartype aux_last_type_read_for_KBK = UNKNOWN;
                                      int& glob_var_KPS_0d_int_Scalar = var_KPS_0d_int_Scalar;
                                      int var_KPS_0d_int_Scalar = glob_var_KPS_0d_int_Scalar;
                                      bool& glob_aux_KPS_read = aux_KPS_read;
                                      bool aux_KPS_read = glob_aux_KPS_read;
                                      vartype aux_last_type_read_for_KPS = UNKNOWN;
                                      int& glob_cpp_int_val = cpp_int_val;
                                      int cpp_int_val = glob_cpp_int_val;
                                      bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                                      bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                      int& glob_var_NCH_0d_int_Scalar = var_NCH_0d_int_Scalar;
                                      int var_NCH_0d_int_Scalar = glob_var_NCH_0d_int_Scalar;
                                      bool& glob_aux_NCH_read = aux_NCH_read;
                                      bool aux_NCH_read = glob_aux_NCH_read;
                                      vartype aux_last_type_read_for_NCH = UNKNOWN;
                                      NestedVector<EndfFloatCpp>& glob_var_PPI_1d_double_NestedVector = var_PPI_1d_double_NestedVector;
                                      NestedVector<EndfFloatCpp> var_PPI_1d_double_NestedVector = glob_var_PPI_1d_double_NestedVector;
                                      vartype aux_last_type_read_for_PPI = UNKNOWN;
                                      NestedVector<EndfFloatCpp>& glob_var_L_1d_double_NestedVector = var_L_1d_double_NestedVector;
                                      NestedVector<EndfFloatCpp> var_L_1d_double_NestedVector = glob_var_L_1d_double_NestedVector;
                                      vartype aux_last_type_read_for_L = UNKNOWN;
                                      NestedVector<EndfFloatCpp>& glob_var_SCH_1d_double_NestedVector = var_SCH_1d_double_NestedVector;
                                      NestedVector<EndfFloatCpp> var_SCH_1d_double_NestedVector = glob_var_SCH_1d_double_NestedVector;
                                      vartype aux_last_type_read_for_SCH = UNKNOWN;
                                      NestedVector<EndfFloatCpp>& glob_var_BND_1d_double_NestedVector = var_BND_1d_double_NestedVector;
                                      NestedVector<EndfFloatCpp> var_BND_1d_double_NestedVector = glob_var_BND_1d_double_NestedVector;
                                      vartype aux_last_type_read_for_BND = UNKNOWN;
                                      NestedVector<EndfFloatCpp>& glob_var_APE_1d_double_NestedVector = var_APE_1d_double_NestedVector;
                                      NestedVector<EndfFloatCpp> var_APE_1d_double_NestedVector = glob_var_APE_1d_double_NestedVector;
                                      vartype aux_last_type_read_for_APE = UNKNOWN;
                                      NestedVector<EndfFloatCpp>& glob_var_APT_1d_double_NestedVector = var_APT_1d_double_NestedVector;
                                      NestedVector<EndfFloatCpp> var_APT_1d_double_NestedVector = glob_var_APT_1d_double_NestedVector;
                                      vartype aux_last_type_read_for_APT = UNKNOWN;
                                      int& glob_var_NRS_0d_int_Scalar = var_NRS_0d_int_Scalar;
                                      int var_NRS_0d_int_Scalar = glob_var_NRS_0d_int_Scalar;
                                      bool& glob_aux_NRS_read = aux_NRS_read;
                                      bool aux_NRS_read = glob_aux_NRS_read;
                                      vartype aux_last_type_read_for_NRS = UNKNOWN;
                                      int& glob_var_NX_0d_int_Scalar = var_NX_0d_int_Scalar;
                                      int var_NX_0d_int_Scalar = glob_var_NX_0d_int_Scalar;
                                      bool& glob_aux_NX_read = aux_NX_read;
                                      bool aux_NX_read = glob_aux_NX_read;
                                      vartype aux_last_type_read_for_NX = UNKNOWN;
                                      try {
                                        cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*NX) , NX / \n { 0.0 } { m = 1 to 6 } ] LIST";
                                        // read LIST record
                                        // assign expression to variable NRS
                                        var_NRS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::cast(-99999)));
                                        aux_NRS_read = true;
                                        validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                        aux_last_type_read_for_NRS = SCALAR_INT;
                                        // assign expression to variable cpp_int_val
                                        cpp_int_val = (6*py::cast<int>(cpp_index_shifter_store.get_value("NX", std::vector<int>({}), py::cast(-99999))));
                                        aux_cpp_int_val_read = true;
                                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                        // assign expression to variable NX
                                        var_NX_0d_int_Scalar = (cpp_int_val/6);
                                        aux_NX_read = true;
                                        validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                        aux_last_type_read_for_NX = SCALAR_INT;
                                        if ((! (aux_NX_read == true))) {
                                          // assign expression to variable NX
                                          var_NX_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NX", std::vector<int>({}), py::cast(-99999)));
                                          aux_NX_read = true;
                                          validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                          aux_last_type_read_for_NX = SCALAR_INT;
                                        } else {
                                        }
                                      } catch (const std::out_of_range& e) {
                                        // // accept failure in lookahead
                                      }
                                      if (((((((((aux_NRS_read == true)) && ((var_NRS_0d_int_Scalar)==(0)))))&&((((aux_NX_read == true)) && ((var_NX_0d_int_Scalar)==(1)))))))) {
                                        cpp_found_match = true;
                                      }
                                    }
                                    if (cpp_found_match) {
                                      cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*NX) , NX / \n { 0.0 } { m = 1 to 6 } ] LIST";
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      // read LIST record
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                                      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable NRS
                                      var_NRS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none()));
                                      aux_NRS_read = true;
                                      validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                      aux_last_type_read_for_NRS = SCALAR_INT;
                                      cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NX", std::vector<int>({}), py::none()))), write_opts);
                                      // assign expression to variable cpp_int_val
                                      cpp_int_val = (6*py::cast<int>(cpp_index_shifter_store.get_value("NX", std::vector<int>({}), py::none())));
                                      aux_cpp_int_val_read = true;
                                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                      // assign expression to variable NX
                                      var_NX_0d_int_Scalar = (cpp_int_val/6);
                                      aux_NX_read = true;
                                      validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                      aux_last_type_read_for_NX = SCALAR_INT;
                                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NX", std::vector<int>({}), py::none())), write_opts);
                                      if ((! (aux_NX_read == true))) {
                                        // assign expression to variable NX
                                        var_NX_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NX", std::vector<int>({}), py::none()));
                                        aux_NX_read = true;
                                        validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                        aux_last_type_read_for_NX = SCALAR_INT;
                                      } else {
                                      }
                                      cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NX", std::vector<int>({}), py::none()))), write_opts);
                                      cont << cpp_draft_line;
                                      {
                                        int cpp_npl = (6*py::cast<int>(cpp_index_shifter_store.get_value("NX", std::vector<int>({}), py::none())));
                                        int cpp_i = 0;
                                        int cpp_j = 0;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        // read LIST body

                                        for (int var_m_0d_int_Scalar = 1;
                                           var_m_0d_int_Scalar <= 6; var_m_0d_int_Scalar++) {
                                          bool aux_m_read = true;
                                          // read LIST body
                                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                          cpp_i++;
                                          cpp_j++;
                                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                            cont << cpp_draft_line;
                                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                            cpp_j = 0;
                                          }
                                        }
                                        if (cpp_i != cpp_npl) {
                                          throw std::runtime_error("not exactly NPL elements consumed");
                                        }
                                      }
                                      cont << cpp_draft_line;
                                    }
                                  }
                                }
                              }
                            }
                            // evaluate if-elif-else clause
                            {
                              bool cpp_found_match = false;
                              if (! cpp_found_match) {
                                if ((((((((aux_KBK_read == true)) && ((var_KBK_0d_int_Scalar)>(0)))))))) {
                                  // if statement evaluation
                                  cpp_found_match = true;

                                  for (int var_n_0d_int_Scalar = 1;
                                     var_n_0d_int_Scalar <= var_KBK_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                    bool aux_n_read = true;
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , LCH , LBK , 0 , 0 ] CONT";
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                    // read CONT record
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LCH", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable LCH
                                    var_LCH_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCH", std::vector<int>({}), py::none()));
                                    aux_LCH_read = true;
                                    validate_vartype_consistency("LCH", SCALAR_INT, aux_last_type_read_for_LCH);
                                    aux_last_type_read_for_LCH = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LBK", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable LBK
                                    var_LBK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LBK", std::vector<int>({}), py::none()));
                                    aux_LBK_read = true;
                                    validate_vartype_consistency("LBK", SCALAR_INT, aux_last_type_read_for_LBK);
                                    aux_last_type_read_for_LBK = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                    cont << cpp_draft_line;
                                    // evaluate if-elif-else clause
                                    {
                                      bool cpp_found_match = false;
                                      if (! cpp_found_match) {
                                        if ((((((((aux_LBK_read == true)) && ((var_LBK_0d_int_Scalar)==(1)))))))) {
                                          // if statement evaluation
                                          cpp_found_match = true;
                                          cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , LCH , LBK , 0 , 0 ] CONT";
                                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                          // read CONT record
                                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LCH", std::vector<int>({}), py::none())), write_opts);
                                          if ((! (aux_LCH_read == true))) {
                                            // assign expression to variable LCH
                                            var_LCH_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCH", std::vector<int>({}), py::none()));
                                            aux_LCH_read = true;
                                            validate_vartype_consistency("LCH", SCALAR_INT, aux_last_type_read_for_LCH);
                                            aux_last_type_read_for_LCH = SCALAR_INT;
                                          } else {
                                          }
                                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LBK", std::vector<int>({}), py::none())), write_opts);
                                          if ((! (aux_LBK_read == true))) {
                                            // assign expression to variable LBK
                                            var_LBK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LBK", std::vector<int>({}), py::none()));
                                            aux_LBK_read = true;
                                            validate_vartype_consistency("LBK", SCALAR_INT, aux_last_type_read_for_LBK);
                                            aux_last_type_read_for_LBK = SCALAR_INT;
                                          } else {
                                          }
                                          cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                                          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                          cont << cpp_draft_line;
                                          cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / E / RBR ] TAB1 ( real_part [ n ] )";
                                          // read TAB1 record
                                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                          {
                                            py::dict cpp_parent_dict = cpp_current_dict;
                                            cpp_current_dict = cpp_index_shifter_store.get_value("real_part", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
                                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                                            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                                            cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                                            cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                                            cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                                            cont << cpp_draft_line;
                                            tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                                            tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("RBR", std::vector<int>({}), py::none()));
                                            tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                                            tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                                            write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                                            // variable declarations
                                            std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                                            bool aux_E_read = false;
                                            vartype aux_last_type_read_for_E = UNKNOWN;
                                            std::vector<EndfFloatCpp> var_RBR_0d_floatvec_Scalar;
                                            bool aux_RBR_read = false;
                                            vartype aux_last_type_read_for_RBR = UNKNOWN;
                                            std::vector<int> var_INT_0d_intvec_Scalar;
                                            bool aux_INT_read = false;
                                            vartype aux_last_type_read_for_INT = UNKNOWN;
                                            std::vector<int> var_NBT_0d_intvec_Scalar;
                                            bool aux_NBT_read = false;
                                            vartype aux_last_type_read_for_NBT = UNKNOWN;
                                            {
                                              Tab1Body tab_body = tab1_body;
                                              // assign expression to variable E
                                              var_E_0d_floatvec_Scalar = tab_body.X;
                                              aux_E_read = true;
                                              validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                                              aux_last_type_read_for_E = SCALAR_FLOATVEC;
                                              // assign expression to variable RBR
                                              var_RBR_0d_floatvec_Scalar = tab_body.Y;
                                              aux_RBR_read = true;
                                              validate_vartype_consistency("RBR", SCALAR_FLOATVEC, aux_last_type_read_for_RBR);
                                              aux_last_type_read_for_RBR = SCALAR_FLOATVEC;
                                              // assign expression to variable INT
                                              var_INT_0d_intvec_Scalar = tab_body.INT;
                                              aux_INT_read = true;
                                              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                              aux_last_type_read_for_INT = SCALAR_INTVEC;
                                              // assign expression to variable NBT
                                              var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                              aux_NBT_read = true;
                                              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                              aux_last_type_read_for_NBT = SCALAR_INTVEC;
                                            }
                                            cont << cpp_draft_line;
                                            cpp_current_dict = cpp_parent_dict;
                                          }
                                          cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / E / RBI ] TAB1 ( imag_part [ n ] )";
                                          // read TAB1 record
                                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                          {
                                            py::dict cpp_parent_dict = cpp_current_dict;
                                            cpp_current_dict = cpp_index_shifter_store.get_value("imag_part", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
                                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                                            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                                            cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                                            cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                                            cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                                            cont << cpp_draft_line;
                                            tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                                            tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("RBI", std::vector<int>({}), py::none()));
                                            tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                                            tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                                            write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                                            // variable declarations
                                            std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                                            bool aux_E_read = false;
                                            vartype aux_last_type_read_for_E = UNKNOWN;
                                            std::vector<EndfFloatCpp> var_RBI_0d_floatvec_Scalar;
                                            bool aux_RBI_read = false;
                                            vartype aux_last_type_read_for_RBI = UNKNOWN;
                                            std::vector<int> var_INT_0d_intvec_Scalar;
                                            bool aux_INT_read = false;
                                            vartype aux_last_type_read_for_INT = UNKNOWN;
                                            std::vector<int> var_NBT_0d_intvec_Scalar;
                                            bool aux_NBT_read = false;
                                            vartype aux_last_type_read_for_NBT = UNKNOWN;
                                            {
                                              Tab1Body tab_body = tab1_body;
                                              // assign expression to variable E
                                              var_E_0d_floatvec_Scalar = tab_body.X;
                                              aux_E_read = true;
                                              validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                                              aux_last_type_read_for_E = SCALAR_FLOATVEC;
                                              // assign expression to variable RBI
                                              var_RBI_0d_floatvec_Scalar = tab_body.Y;
                                              aux_RBI_read = true;
                                              validate_vartype_consistency("RBI", SCALAR_FLOATVEC, aux_last_type_read_for_RBI);
                                              aux_last_type_read_for_RBI = SCALAR_FLOATVEC;
                                              // assign expression to variable INT
                                              var_INT_0d_intvec_Scalar = tab_body.INT;
                                              aux_INT_read = true;
                                              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                              aux_last_type_read_for_INT = SCALAR_INTVEC;
                                              // assign expression to variable NBT
                                              var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                              aux_NBT_read = true;
                                              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                              aux_last_type_read_for_NBT = SCALAR_INTVEC;
                                            }
                                            cont << cpp_draft_line;
                                            cpp_current_dict = cpp_parent_dict;
                                          }
                                        }
                                      }
                                      if (! cpp_found_match) {
                                        if (! cpp_found_match) {
                                          if ((((((((aux_LBK_read == true)) && ((var_LBK_0d_int_Scalar)==(2)))))))) {
                                            // if statement evaluation
                                            cpp_found_match = true;
                                            cpp_template = "[ MAT , 2 , 151 / ED , EU , 0 , 0 , 5 , 0 / R0 , R1 , R2 , S0 , S1 ] LIST";
                                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                            // read LIST record
                                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ED", std::vector<int>({}), py::none())), write_opts);
                                            // assign expression to variable ED
                                            var_ED_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ED", std::vector<int>({}), py::none()));
                                            aux_ED_read = true;
                                            validate_vartype_consistency("ED", SCALAR_DOUBLE, aux_last_type_read_for_ED);
                                            aux_last_type_read_for_ED = SCALAR_DOUBLE;
                                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EU", std::vector<int>({}), py::none())), write_opts);
                                            // assign expression to variable EU
                                            var_EU_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EU", std::vector<int>({}), py::none()));
                                            aux_EU_read = true;
                                            validate_vartype_consistency("EU", SCALAR_DOUBLE, aux_last_type_read_for_EU);
                                            aux_last_type_read_for_EU = SCALAR_DOUBLE;
                                            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                            cpp_write_field<int>(cpp_draft_line, 4, 5, write_opts);
                                            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                            cpp_write_field<int>(cpp_draft_line, 4, 5, write_opts);
                                            cont << cpp_draft_line;
                                            {
                                              int cpp_npl = 5;
                                              int cpp_i = 0;
                                              int cpp_j = 0;
                                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                              // read LIST body
                                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("R0", std::vector<int>({}), py::none())), write_opts);
                                              // assign expression to variable R0
                                              var_R0_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("R0", std::vector<int>({}), py::none()));
                                              aux_R0_read = true;
                                              validate_vartype_consistency("R0", SCALAR_DOUBLE, aux_last_type_read_for_R0);
                                              aux_last_type_read_for_R0 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cont << cpp_draft_line;
                                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                                cpp_j = 0;
                                              }
                                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("R1", std::vector<int>({}), py::none())), write_opts);
                                              // assign expression to variable R1
                                              var_R1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("R1", std::vector<int>({}), py::none()));
                                              aux_R1_read = true;
                                              validate_vartype_consistency("R1", SCALAR_DOUBLE, aux_last_type_read_for_R1);
                                              aux_last_type_read_for_R1 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cont << cpp_draft_line;
                                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                                cpp_j = 0;
                                              }
                                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("R2", std::vector<int>({}), py::none())), write_opts);
                                              // assign expression to variable R2
                                              var_R2_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("R2", std::vector<int>({}), py::none()));
                                              aux_R2_read = true;
                                              validate_vartype_consistency("R2", SCALAR_DOUBLE, aux_last_type_read_for_R2);
                                              aux_last_type_read_for_R2 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cont << cpp_draft_line;
                                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                                cpp_j = 0;
                                              }
                                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("S0", std::vector<int>({}), py::none())), write_opts);
                                              // assign expression to variable S0
                                              var_S0_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("S0", std::vector<int>({}), py::none()));
                                              aux_S0_read = true;
                                              validate_vartype_consistency("S0", SCALAR_DOUBLE, aux_last_type_read_for_S0);
                                              aux_last_type_read_for_S0 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cont << cpp_draft_line;
                                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                                cpp_j = 0;
                                              }
                                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("S1", std::vector<int>({}), py::none())), write_opts);
                                              // assign expression to variable S1
                                              var_S1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("S1", std::vector<int>({}), py::none()));
                                              aux_S1_read = true;
                                              validate_vartype_consistency("S1", SCALAR_DOUBLE, aux_last_type_read_for_S1);
                                              aux_last_type_read_for_S1 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cont << cpp_draft_line;
                                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                                cpp_j = 0;
                                              }
                                              if (cpp_i != cpp_npl) {
                                                throw std::runtime_error("not exactly NPL elements consumed");
                                              }
                                            }
                                            cont << cpp_draft_line;
                                          }
                                        }
                                      }
                                      if (! cpp_found_match) {
                                        if (! cpp_found_match) {
                                          if ((((((((aux_LBK_read == true)) && ((var_LBK_0d_int_Scalar)==(3)))))))) {
                                            // if statement evaluation
                                            cpp_found_match = true;
                                            cpp_template = "[ MAT , 2 , 151 / ED , EU , 0 , 0 , 3 , 0 / R0 , S0 , GA ] LIST";
                                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                            // read LIST record
                                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ED", std::vector<int>({}), py::none())), write_opts);
                                            // assign expression to variable ED
                                            var_ED_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ED", std::vector<int>({}), py::none()));
                                            aux_ED_read = true;
                                            validate_vartype_consistency("ED", SCALAR_DOUBLE, aux_last_type_read_for_ED);
                                            aux_last_type_read_for_ED = SCALAR_DOUBLE;
                                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EU", std::vector<int>({}), py::none())), write_opts);
                                            // assign expression to variable EU
                                            var_EU_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EU", std::vector<int>({}), py::none()));
                                            aux_EU_read = true;
                                            validate_vartype_consistency("EU", SCALAR_DOUBLE, aux_last_type_read_for_EU);
                                            aux_last_type_read_for_EU = SCALAR_DOUBLE;
                                            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                            cpp_write_field<int>(cpp_draft_line, 4, 3, write_opts);
                                            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                            cpp_write_field<int>(cpp_draft_line, 4, 3, write_opts);
                                            cont << cpp_draft_line;
                                            {
                                              int cpp_npl = 3;
                                              int cpp_i = 0;
                                              int cpp_j = 0;
                                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                              // read LIST body
                                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("R0", std::vector<int>({}), py::none())), write_opts);
                                              // assign expression to variable R0
                                              var_R0_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("R0", std::vector<int>({}), py::none()));
                                              aux_R0_read = true;
                                              validate_vartype_consistency("R0", SCALAR_DOUBLE, aux_last_type_read_for_R0);
                                              aux_last_type_read_for_R0 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cont << cpp_draft_line;
                                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                                cpp_j = 0;
                                              }
                                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("S0", std::vector<int>({}), py::none())), write_opts);
                                              // assign expression to variable S0
                                              var_S0_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("S0", std::vector<int>({}), py::none()));
                                              aux_S0_read = true;
                                              validate_vartype_consistency("S0", SCALAR_DOUBLE, aux_last_type_read_for_S0);
                                              aux_last_type_read_for_S0 = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cont << cpp_draft_line;
                                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                                cpp_j = 0;
                                              }
                                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GA", std::vector<int>({}), py::none())), write_opts);
                                              // assign expression to variable GA
                                              var_GA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GA", std::vector<int>({}), py::none()));
                                              aux_GA_read = true;
                                              validate_vartype_consistency("GA", SCALAR_DOUBLE, aux_last_type_read_for_GA);
                                              aux_last_type_read_for_GA = SCALAR_DOUBLE;
                                              cpp_i++;
                                              cpp_j++;
                                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                                cont << cpp_draft_line;
                                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                                cpp_j = 0;
                                              }
                                              if (cpp_i != cpp_npl) {
                                                throw std::runtime_error("not exactly NPL elements consumed");
                                              }
                                            }
                                            cont << cpp_draft_line;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            // evaluate if-elif-else clause
                            {
                              bool cpp_found_match = false;
                              if (! cpp_found_match) {
                                if ((((((((aux_KPS_read == true)) && ((var_KPS_0d_int_Scalar)>(0)))))))) {
                                  // if statement evaluation
                                  cpp_found_match = true;

                                  for (int var_n_0d_int_Scalar = 1;
                                     var_n_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                    bool aux_n_read = true;
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , LPS , 1 / \n 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ] LIST";
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                    // read LIST record
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("LPS", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable LPS
                                    var_LPS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LPS", std::vector<int>({}), py::none()));
                                    aux_LPS_read = true;
                                    validate_vartype_consistency("LPS", SCALAR_INT, aux_last_type_read_for_LPS);
                                    aux_last_type_read_for_LPS = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 5, 1, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("LPS", std::vector<int>({}), py::none())), write_opts);
                                    cont << cpp_draft_line;
                                    {
                                      int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("LPS", std::vector<int>({}), py::none()));
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      // read LIST body
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                    cont << cpp_draft_line;
                                    // evaluate if-elif-else clause
                                    {
                                      bool cpp_found_match = false;
                                      if (! cpp_found_match) {
                                        if ((((((((aux_LPS_read == true)) && ((var_LPS_0d_int_Scalar)==(1)))))))) {
                                          // if statement evaluation
                                          cpp_found_match = true;
                                          cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / E / PSR ] TAB1 ( real_part [ n ] )";
                                          // read TAB1 record
                                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                          {
                                            py::dict cpp_parent_dict = cpp_current_dict;
                                            cpp_current_dict = cpp_index_shifter_store.get_value("real_part", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
                                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                                            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                                            cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                                            cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                                            cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                                            cont << cpp_draft_line;
                                            tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                                            tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("PSR", std::vector<int>({}), py::none()));
                                            tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                                            tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                                            write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                                            // variable declarations
                                            std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                                            bool aux_E_read = false;
                                            vartype aux_last_type_read_for_E = UNKNOWN;
                                            std::vector<EndfFloatCpp> var_PSR_0d_floatvec_Scalar;
                                            bool aux_PSR_read = false;
                                            vartype aux_last_type_read_for_PSR = UNKNOWN;
                                            std::vector<int> var_INT_0d_intvec_Scalar;
                                            bool aux_INT_read = false;
                                            vartype aux_last_type_read_for_INT = UNKNOWN;
                                            std::vector<int> var_NBT_0d_intvec_Scalar;
                                            bool aux_NBT_read = false;
                                            vartype aux_last_type_read_for_NBT = UNKNOWN;
                                            {
                                              Tab1Body tab_body = tab1_body;
                                              // assign expression to variable E
                                              var_E_0d_floatvec_Scalar = tab_body.X;
                                              aux_E_read = true;
                                              validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                                              aux_last_type_read_for_E = SCALAR_FLOATVEC;
                                              // assign expression to variable PSR
                                              var_PSR_0d_floatvec_Scalar = tab_body.Y;
                                              aux_PSR_read = true;
                                              validate_vartype_consistency("PSR", SCALAR_FLOATVEC, aux_last_type_read_for_PSR);
                                              aux_last_type_read_for_PSR = SCALAR_FLOATVEC;
                                              // assign expression to variable INT
                                              var_INT_0d_intvec_Scalar = tab_body.INT;
                                              aux_INT_read = true;
                                              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                              aux_last_type_read_for_INT = SCALAR_INTVEC;
                                              // assign expression to variable NBT
                                              var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                              aux_NBT_read = true;
                                              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                              aux_last_type_read_for_NBT = SCALAR_INTVEC;
                                            }
                                            cont << cpp_draft_line;
                                            cpp_current_dict = cpp_parent_dict;
                                          }
                                          cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / E / PSI ] TAB1 ( imag_part [ n ] )";
                                          // read TAB1 record
                                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                          {
                                            py::dict cpp_parent_dict = cpp_current_dict;
                                            cpp_current_dict = cpp_index_shifter_store.get_value("imag_part", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
                                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                                            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                                            cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                                            cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                                            cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                                            cont << cpp_draft_line;
                                            tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                                            tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("PSI", std::vector<int>({}), py::none()));
                                            tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                                            tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                                            write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                                            // variable declarations
                                            std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                                            bool aux_E_read = false;
                                            vartype aux_last_type_read_for_E = UNKNOWN;
                                            std::vector<EndfFloatCpp> var_PSI_0d_floatvec_Scalar;
                                            bool aux_PSI_read = false;
                                            vartype aux_last_type_read_for_PSI = UNKNOWN;
                                            std::vector<int> var_INT_0d_intvec_Scalar;
                                            bool aux_INT_read = false;
                                            vartype aux_last_type_read_for_INT = UNKNOWN;
                                            std::vector<int> var_NBT_0d_intvec_Scalar;
                                            bool aux_NBT_read = false;
                                            vartype aux_last_type_read_for_NBT = UNKNOWN;
                                            {
                                              Tab1Body tab_body = tab1_body;
                                              // assign expression to variable E
                                              var_E_0d_floatvec_Scalar = tab_body.X;
                                              aux_E_read = true;
                                              validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                                              aux_last_type_read_for_E = SCALAR_FLOATVEC;
                                              // assign expression to variable PSI
                                              var_PSI_0d_floatvec_Scalar = tab_body.Y;
                                              aux_PSI_read = true;
                                              validate_vartype_consistency("PSI", SCALAR_FLOATVEC, aux_last_type_read_for_PSI);
                                              aux_last_type_read_for_PSI = SCALAR_FLOATVEC;
                                              // assign expression to variable INT
                                              var_INT_0d_intvec_Scalar = tab_body.INT;
                                              aux_INT_read = true;
                                              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                              aux_last_type_read_for_INT = SCALAR_INTVEC;
                                              // assign expression to variable NBT
                                              var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                              aux_NBT_read = true;
                                              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                              aux_last_type_read_for_NBT = SCALAR_INTVEC;
                                            }
                                            cont << cpp_draft_line;
                                            cpp_current_dict = cpp_parent_dict;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            cpp_current_dict = cpp_parent_dict;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                if ((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(2)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  // evaluate if-elif-else clause
                  {
                    bool cpp_found_match = false;
                    if (! cpp_found_match) {
                      if (((((((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(0)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                              // read TAB1 record
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                              cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                              cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
                              cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                              cont << cpp_draft_line;
                              tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                              tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                              tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                              tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                              write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                              {
                                Tab1Body tab_body = tab1_body;
                                // assign expression to variable Eint
                                var_Eint_0d_floatvec_Scalar = tab_body.X;
                                aux_Eint_read = true;
                                validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                                aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                                if ((! (aux_AP_read == true))) {
                                  // assign expression to variable AP
                                  var_AP_0d_floatvec_Scalar = tab_body.Y;
                                  aux_AP_read = true;
                                  validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                  aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                                } else {
                                }
                                // assign expression to variable INT
                                var_INT_0d_intvec_Scalar = tab_body.INT;
                                aux_INT_read = true;
                                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                aux_last_type_read_for_INT = SCALAR_INTVEC;
                                // assign expression to variable NBT
                                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                aux_NBT_read = true;
                                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                aux_last_type_read_for_NBT = SCALAR_INTVEC;
                              }
                              cont << cpp_draft_line;
                            }
                          }
                        }
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , LSSF , 0 , NLS , 0 ] CONT";
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              // read CONT record
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                              if ((! (aux_SPI_read == true))) {
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              } else {
                              }
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LSSF", std::vector<int>({}), py::none())), write_opts);
                              // assign expression to variable LSSF
                              var_LSSF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LSSF", std::vector<int>({}), py::none()));
                              aux_LSSF_read = true;
                              validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                              aux_last_type_read_for_LSSF = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                              if ((! (aux_NLS_read == true))) {
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } else {
                              }
                              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                              cont << cpp_draft_line;
                            }
                          }
                          if (! cpp_found_match) {
                            cpp_template = "[ MAT , 2 , 151 / SPI , AP , LSSF , 0 , NLS , 0 ] CONT";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read CONT record
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                            if ((! (aux_SPI_read == true))) {
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                            } else {
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none())), write_opts);
                            if ((! (aux_AP_read == true))) {
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LSSF", std::vector<int>({}), py::none())), write_opts);
                            // assign expression to variable LSSF
                            var_LSSF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LSSF", std::vector<int>({}), py::none()));
                            aux_LSSF_read = true;
                            validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                            aux_last_type_read_for_LSSF = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                            if ((! (aux_NLS_read == true))) {
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                            cont << cpp_draft_line;
                          }
                        }

                        for (int var_p_0d_int_Scalar = 1;
                           var_p_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                          bool aux_p_read = true;
                          // open section l_group
                          {
                            py::dict cpp_parent_dict = cpp_current_dict;
                            cpp_current_dict = cpp_index_shifter_store.get_value("l_group", std::vector<int>({var_p_0d_int_Scalar}), py::dict());
                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                            // variable declarations
                            EndfFloatCpp var_AWRI_0d_double_Scalar;
                            bool aux_AWRI_read = false;
                            vartype aux_last_type_read_for_AWRI = UNKNOWN;
                            int var_L_0d_int_Scalar;
                            bool aux_L_read = false;
                            vartype aux_last_type_read_for_L = UNKNOWN;
                            int cpp_int_val;
                            bool aux_cpp_int_val_read = false;
                            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                            int var_NJS_0d_int_Scalar;
                            bool aux_NJS_read = false;
                            vartype aux_last_type_read_for_NJS = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_D_1d_double_NestedVector;
                            vartype aux_last_type_read_for_D = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                            vartype aux_last_type_read_for_AJ = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_AMUN_1d_double_NestedVector;
                            vartype aux_last_type_read_for_AMUN = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_GN0_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GN0 = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GG = UNKNOWN;
                            cpp_template = "[ MAT , 2 , 151 / AWRI , 0.0 , L , 0 , (6*NJS) , NJS / \n { D , AJ , AMUN , GN0 , GG , 0.0 } { m = 1 to NJS } ] LIST";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST record
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none())), write_opts);
                            // assign expression to variable AWRI
                            var_AWRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none()));
                            aux_AWRI_read = true;
                            validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                            aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none())), write_opts);
                            // assign expression to variable L
                            var_L_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none()));
                            aux_L_read = true;
                            validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                            aux_last_type_read_for_L = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none()))), write_opts);
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (6*py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none())));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NJS
                            var_NJS_0d_int_Scalar = (cpp_int_val/6);
                            aux_NJS_read = true;
                            validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                            aux_last_type_read_for_NJS = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none())), write_opts);
                            if ((! (aux_NJS_read == true))) {
                              // assign expression to variable NJS
                              var_NJS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none()));
                              aux_NJS_read = true;
                              validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                              aux_last_type_read_for_NJS = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none()))), write_opts);
                            cont << cpp_draft_line;
                            {
                              int cpp_npl = (6*py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none())));
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              // read LIST body

                              for (int var_m_0d_int_Scalar = 1;
                                 var_m_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                bool aux_m_read = true;
                                // read LIST body
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("D", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable D
                                var_D_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("D", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("D", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_D);
                                aux_last_type_read_for_D = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable AJ
                                var_AJ_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                                aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AMUN", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable AMUN
                                var_AMUN_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AMUN", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("AMUN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AMUN);
                                aux_last_type_read_for_AMUN = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN0", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable GN0
                                var_GN0_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN0", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("GN0", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN0);
                                aux_last_type_read_for_GN0 = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable GG
                                var_GG_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                                aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            cont << cpp_draft_line;
                            cpp_current_dict = cpp_parent_dict;
                          }
                        }
                      }
                    }
                    if (! cpp_found_match) {
                      if (! cpp_found_match) {
                        if (((((((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 2 , 151 / SPI , AP , LSSF , 0 , NE , NLS / \n { ES } { p = 1 to NE } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                          if ((! (aux_SPI_read == true))) {
                            // assign expression to variable SPI
                            var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                            aux_SPI_read = true;
                            validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                            aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                          } else {
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none())), write_opts);
                          if ((! (aux_AP_read == true))) {
                            // assign expression to variable AP
                            var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                            aux_AP_read = true;
                            validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                            aux_last_type_read_for_AP = SCALAR_DOUBLE;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LSSF", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LSSF
                          var_LSSF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LSSF", std::vector<int>({}), py::none()));
                          aux_LSSF_read = true;
                          validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                          aux_last_type_read_for_LSSF = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                          if ((! (aux_NLS_read == true))) {
                            // assign expression to variable NLS
                            var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                            aux_NLS_read = true;
                            validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                            aux_last_type_read_for_NLS = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body

                            for (int var_p_0d_int_Scalar = 1;
                               var_p_0d_int_Scalar <= var_NE_0d_int_Scalar; var_p_0d_int_Scalar++) {
                              bool aux_p_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_p_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable ES
                              var_ES_1d_double_NestedVector.set(var_p_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_p_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                              aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;

                          for (int var_p_0d_int_Scalar = 1;
                             var_p_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                            bool aux_p_read = true;
                            // open section j_group
                            {
                              py::dict cpp_parent_dict = cpp_current_dict;
                              cpp_current_dict = cpp_index_shifter_store.get_value("j_group", std::vector<int>({var_p_0d_int_Scalar}), py::dict());
                              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                              // variable declarations
                              EndfFloatCpp var_AWRI_0d_double_Scalar;
                              bool aux_AWRI_read = false;
                              vartype aux_last_type_read_for_AWRI = UNKNOWN;
                              int var_L_0d_int_Scalar;
                              bool aux_L_read = false;
                              vartype aux_last_type_read_for_L = UNKNOWN;
                              int var_NJS_0d_int_Scalar;
                              bool aux_NJS_read = false;
                              vartype aux_last_type_read_for_NJS = UNKNOWN;
                              cpp_template = "[ MAT , 2 , 151 / AWRI , 0.0 , L , 0 , NJS , 0 ] CONT";
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              // read CONT record
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none())), write_opts);
                              // assign expression to variable AWRI
                              var_AWRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none()));
                              aux_AWRI_read = true;
                              validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                              aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none())), write_opts);
                              // assign expression to variable L
                              var_L_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none()));
                              aux_L_read = true;
                              validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                              aux_last_type_read_for_L = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none())), write_opts);
                              // assign expression to variable NJS
                              var_NJS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none()));
                              aux_NJS_read = true;
                              validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                              aux_last_type_read_for_NJS = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                              cont << cpp_draft_line;

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // open section subsec
                                {
                                  py::dict cpp_parent_dict = cpp_current_dict;
                                  cpp_current_dict = cpp_index_shifter_store.get_value("subsec", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
                                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                                  // variable declarations
                                  int var_L_0d_int_Scalar;
                                  bool aux_L_read = false;
                                  vartype aux_last_type_read_for_L = UNKNOWN;
                                  int var_MUF_0d_int_Scalar;
                                  bool aux_MUF_read = false;
                                  vartype aux_last_type_read_for_MUF = UNKNOWN;
                                  int cpp_int_val;
                                  bool aux_cpp_int_val_read = false;
                                  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                  int var_NE_0d_int_Scalar;
                                  bool aux_NE_read = false;
                                  vartype aux_last_type_read_for_NE = UNKNOWN;
                                  EndfFloatCpp var_D_0d_double_Scalar;
                                  bool aux_D_read = false;
                                  vartype aux_last_type_read_for_D = UNKNOWN;
                                  EndfFloatCpp var_AJ_0d_double_Scalar;
                                  bool aux_AJ_read = false;
                                  vartype aux_last_type_read_for_AJ = UNKNOWN;
                                  EndfFloatCpp var_AMUN_0d_double_Scalar;
                                  bool aux_AMUN_read = false;
                                  vartype aux_last_type_read_for_AMUN = UNKNOWN;
                                  EndfFloatCpp var_GN0_0d_double_Scalar;
                                  bool aux_GN0_read = false;
                                  vartype aux_last_type_read_for_GN0 = UNKNOWN;
                                  EndfFloatCpp var_GG_0d_double_Scalar;
                                  bool aux_GG_read = false;
                                  vartype aux_last_type_read_for_GG = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GF = UNKNOWN;
                                  cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , L , MUF , (NE+6) , 0 / \n D , AJ , AMUN , GN0 , GG , 0.0 , \n { GF } { m = 1 to NE } ] LIST";
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  // read LIST record
                                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none())), write_opts);
                                  if ((! (aux_L_read == true))) {
                                    // assign expression to variable L
                                    var_L_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none()));
                                    aux_L_read = true;
                                    validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                                    aux_last_type_read_for_L = SCALAR_INT;
                                  } else {
                                  }
                                  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MUF", std::vector<int>({}), py::none())), write_opts);
                                  // assign expression to variable MUF
                                  var_MUF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MUF", std::vector<int>({}), py::none()));
                                  aux_MUF_read = true;
                                  validate_vartype_consistency("MUF", SCALAR_INT, aux_last_type_read_for_MUF);
                                  aux_last_type_read_for_MUF = SCALAR_INT;
                                  cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))+6), write_opts);
                                  if ((! (aux_NE_read == true))) {
                                    // assign expression to variable cpp_int_val
                                    cpp_int_val = (py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))+6);
                                    aux_cpp_int_val_read = true;
                                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                    // assign expression to variable NE
                                    var_NE_0d_int_Scalar = (cpp_int_val+(-6));
                                    aux_NE_read = true;
                                    validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                                    aux_last_type_read_for_NE = SCALAR_INT;
                                  } else {
                                  }
                                  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))+6), write_opts);
                                  cont << cpp_draft_line;
                                  {
                                    int cpp_npl = (py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))+6);
                                    int cpp_i = 0;
                                    int cpp_j = 0;
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                    // read LIST body
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("D", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable D
                                    var_D_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("D", std::vector<int>({}), py::none()));
                                    aux_D_read = true;
                                    validate_vartype_consistency("D", SCALAR_DOUBLE, aux_last_type_read_for_D);
                                    aux_last_type_read_for_D = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable AJ
                                    var_AJ_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({}), py::none()));
                                    aux_AJ_read = true;
                                    validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                                    aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AMUN", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable AMUN
                                    var_AMUN_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AMUN", std::vector<int>({}), py::none()));
                                    aux_AMUN_read = true;
                                    validate_vartype_consistency("AMUN", SCALAR_DOUBLE, aux_last_type_read_for_AMUN);
                                    aux_last_type_read_for_AMUN = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN0", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable GN0
                                    var_GN0_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN0", std::vector<int>({}), py::none()));
                                    aux_GN0_read = true;
                                    validate_vartype_consistency("GN0", SCALAR_DOUBLE, aux_last_type_read_for_GN0);
                                    aux_last_type_read_for_GN0 = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable GG
                                    var_GG_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({}), py::none()));
                                    aux_GG_read = true;
                                    validate_vartype_consistency("GG", SCALAR_DOUBLE, aux_last_type_read_for_GG);
                                    aux_last_type_read_for_GG = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }

                                    for (int var_m_0d_int_Scalar = 1;
                                       var_m_0d_int_Scalar <= var_NE_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                      bool aux_m_read = true;
                                      // read LIST body
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                                      // assign expression to variable GF
                                      var_GF_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                                      validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                                      aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                    }
                                    if (cpp_i != cpp_npl) {
                                      throw std::runtime_error("not exactly NPL elements consumed");
                                    }
                                  }
                                  cont << cpp_draft_line;
                                  cpp_current_dict = cpp_parent_dict;
                                }
                              }
                              cpp_current_dict = cpp_parent_dict;
                            }
                          }
                        }
                      }
                    }
                    if (! cpp_found_match) {
                      if (! cpp_found_match) {
                        if ((((((((((((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(0))))))||(((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(1)))))))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          // evaluate if-elif-else clause
                          {
                            bool cpp_found_match = false;
                            if (! cpp_found_match) {
                              if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                                // if statement evaluation
                                cpp_found_match = true;
                                cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                                // read TAB1 record
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                                cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                                cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
                                cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                                cont << cpp_draft_line;
                                tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                                tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                                tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                                tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                                write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                                {
                                  Tab1Body tab_body = tab1_body;
                                  // assign expression to variable Eint
                                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                                  aux_Eint_read = true;
                                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                                  if ((! (aux_AP_read == true))) {
                                    // assign expression to variable AP
                                    var_AP_0d_floatvec_Scalar = tab_body.Y;
                                    aux_AP_read = true;
                                    validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                    aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                                  } else {
                                  }
                                  // assign expression to variable INT
                                  var_INT_0d_intvec_Scalar = tab_body.INT;
                                  aux_INT_read = true;
                                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                                  // assign expression to variable NBT
                                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                  aux_NBT_read = true;
                                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                                }
                                cont << cpp_draft_line;
                              }
                            }
                          }
                          // evaluate if-elif-else clause
                          {
                            bool cpp_found_match = false;
                            if (! cpp_found_match) {
                              if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                                // if statement evaluation
                                cpp_found_match = true;
                                cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , LSSF , 0 , NLS , 0 ] CONT";
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                // read CONT record
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                                if ((! (aux_SPI_read == true))) {
                                  // assign expression to variable SPI
                                  var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                                  aux_SPI_read = true;
                                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                                } else {
                                }
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                                cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LSSF", std::vector<int>({}), py::none())), write_opts);
                                // assign expression to variable LSSF
                                var_LSSF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LSSF", std::vector<int>({}), py::none()));
                                aux_LSSF_read = true;
                                validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                                aux_last_type_read_for_LSSF = SCALAR_INT;
                                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                                if ((! (aux_NLS_read == true))) {
                                  // assign expression to variable NLS
                                  var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                                  aux_NLS_read = true;
                                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                  aux_last_type_read_for_NLS = SCALAR_INT;
                                } else {
                                }
                                cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                cont << cpp_draft_line;
                              }
                            }
                            if (! cpp_found_match) {
                              cpp_template = "[ MAT , 2 , 151 / SPI , AP , LSSF , 0 , NLS , 0 ] CONT";
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              // read CONT record
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                              if ((! (aux_SPI_read == true))) {
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              } else {
                              }
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none())), write_opts);
                              if ((! (aux_AP_read == true))) {
                                // assign expression to variable AP
                                var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                                aux_AP_read = true;
                                validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                                aux_last_type_read_for_AP = SCALAR_DOUBLE;
                              } else {
                              }
                              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LSSF", std::vector<int>({}), py::none())), write_opts);
                              // assign expression to variable LSSF
                              var_LSSF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LSSF", std::vector<int>({}), py::none()));
                              aux_LSSF_read = true;
                              validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                              aux_last_type_read_for_LSSF = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                              if ((! (aux_NLS_read == true))) {
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } else {
                              }
                              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                              cont << cpp_draft_line;
                            }
                          }

                          for (int var_p_0d_int_Scalar = 1;
                             var_p_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                            bool aux_p_read = true;
                            // open section l_group
                            {
                              py::dict cpp_parent_dict = cpp_current_dict;
                              cpp_current_dict = cpp_index_shifter_store.get_value("l_group", std::vector<int>({var_p_0d_int_Scalar}), py::dict());
                              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                              // variable declarations
                              EndfFloatCpp var_AWRI_0d_double_Scalar;
                              bool aux_AWRI_read = false;
                              vartype aux_last_type_read_for_AWRI = UNKNOWN;
                              int var_L_0d_int_Scalar;
                              bool aux_L_read = false;
                              vartype aux_last_type_read_for_L = UNKNOWN;
                              int var_NJS_0d_int_Scalar;
                              bool aux_NJS_read = false;
                              vartype aux_last_type_read_for_NJS = UNKNOWN;
                              cpp_template = "[ MAT , 2 , 151 / AWRI , 0.0 , L , 0 , NJS , 0 ] CONT";
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              // read CONT record
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none())), write_opts);
                              // assign expression to variable AWRI
                              var_AWRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none()));
                              aux_AWRI_read = true;
                              validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                              aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none())), write_opts);
                              // assign expression to variable L
                              var_L_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none()));
                              aux_L_read = true;
                              validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                              aux_last_type_read_for_L = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none())), write_opts);
                              // assign expression to variable NJS
                              var_NJS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none()));
                              aux_NJS_read = true;
                              validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                              aux_last_type_read_for_NJS = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                              cont << cpp_draft_line;

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // open section subsec
                                {
                                  py::dict cpp_parent_dict = cpp_current_dict;
                                  cpp_current_dict = cpp_index_shifter_store.get_value("subsec", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
                                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                                  // variable declarations
                                  EndfFloatCpp var_AJ_0d_double_Scalar;
                                  bool aux_AJ_read = false;
                                  vartype aux_last_type_read_for_AJ = UNKNOWN;
                                  int var_INT_0d_int_Scalar;
                                  bool aux_INT_read = false;
                                  vartype aux_last_type_read_for_INT = UNKNOWN;
                                  int cpp_int_val;
                                  bool aux_cpp_int_val_read = false;
                                  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                  int var_NE_0d_int_Scalar;
                                  bool aux_NE_read = false;
                                  vartype aux_last_type_read_for_NE = UNKNOWN;
                                  EndfFloatCpp var_AMUX_0d_double_Scalar;
                                  bool aux_AMUX_read = false;
                                  vartype aux_last_type_read_for_AMUX = UNKNOWN;
                                  EndfFloatCpp var_AMUN_0d_double_Scalar;
                                  bool aux_AMUN_read = false;
                                  vartype aux_last_type_read_for_AMUN = UNKNOWN;
                                  EndfFloatCpp var_AMUG_0d_double_Scalar;
                                  bool aux_AMUG_read = false;
                                  vartype aux_last_type_read_for_AMUG = UNKNOWN;
                                  EndfFloatCpp var_AMUF_0d_double_Scalar;
                                  bool aux_AMUF_read = false;
                                  vartype aux_last_type_read_for_AMUF = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_ES_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_ES = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_D_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_D = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_GX_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GX = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_GN0_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GN0 = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GG = UNKNOWN;
                                  NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GF = UNKNOWN;
                                  cpp_template = "[ MAT , 2 , 151 / AJ , 0.0 , INT , 0 , ((6*NE)+6) , NE / \n 0.0 , 0.0 , AMUX , AMUN , AMUG , AMUF , \n { ES , D , GX , GN0 , GG , GF } { m = 1 to NE } ] LIST";
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  // read LIST record
                                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({}), py::none())), write_opts);
                                  // assign expression to variable AJ
                                  var_AJ_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({}), py::none()));
                                  aux_AJ_read = true;
                                  validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                                  aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                                  if ((! (aux_INT_read == true))) {
                                    // assign expression to variable INT
                                    var_INT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                                    aux_INT_read = true;
                                    validate_vartype_consistency("INT", SCALAR_INT, aux_last_type_read_for_INT);
                                    aux_last_type_read_for_INT = SCALAR_INT;
                                  } else {
                                  }
                                  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 4, ((6*py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())))+6), write_opts);
                                  // assign expression to variable cpp_int_val
                                  cpp_int_val = ((6*py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())))+6);
                                  aux_cpp_int_val_read = true;
                                  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                  // assign expression to variable NE
                                  var_NE_0d_int_Scalar = ((cpp_int_val+(-6))/6);
                                  aux_NE_read = true;
                                  validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                                  aux_last_type_read_for_NE = SCALAR_INT;
                                  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
                                  if ((! (aux_NE_read == true))) {
                                    // assign expression to variable NE
                                    var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
                                    aux_NE_read = true;
                                    validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                                    aux_last_type_read_for_NE = SCALAR_INT;
                                  } else {
                                  }
                                  cpp_write_field<int>(cpp_draft_line, 4, ((6*py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())))+6), write_opts);
                                  cont << cpp_draft_line;
                                  {
                                    int cpp_npl = ((6*py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())))+6);
                                    int cpp_i = 0;
                                    int cpp_j = 0;
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                    // read LIST body
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AMUX", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable AMUX
                                    var_AMUX_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AMUX", std::vector<int>({}), py::none()));
                                    aux_AMUX_read = true;
                                    validate_vartype_consistency("AMUX", SCALAR_DOUBLE, aux_last_type_read_for_AMUX);
                                    aux_last_type_read_for_AMUX = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AMUN", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable AMUN
                                    var_AMUN_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AMUN", std::vector<int>({}), py::none()));
                                    aux_AMUN_read = true;
                                    validate_vartype_consistency("AMUN", SCALAR_DOUBLE, aux_last_type_read_for_AMUN);
                                    aux_last_type_read_for_AMUN = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AMUG", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable AMUG
                                    var_AMUG_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AMUG", std::vector<int>({}), py::none()));
                                    aux_AMUG_read = true;
                                    validate_vartype_consistency("AMUG", SCALAR_DOUBLE, aux_last_type_read_for_AMUG);
                                    aux_last_type_read_for_AMUG = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AMUF", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable AMUF
                                    var_AMUF_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AMUF", std::vector<int>({}), py::none()));
                                    aux_AMUF_read = true;
                                    validate_vartype_consistency("AMUF", SCALAR_DOUBLE, aux_last_type_read_for_AMUF);
                                    aux_last_type_read_for_AMUF = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }

                                    for (int var_m_0d_int_Scalar = 1;
                                       var_m_0d_int_Scalar <= var_NE_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                      bool aux_m_read = true;
                                      // read LIST body
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                                      // assign expression to variable ES
                                      var_ES_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                                      validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                                      aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("D", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                                      // assign expression to variable D
                                      var_D_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("D", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                                      validate_vartype_consistency("D", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_D);
                                      aux_last_type_read_for_D = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GX", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                                      // assign expression to variable GX
                                      var_GX_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GX", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                                      validate_vartype_consistency("GX", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GX);
                                      aux_last_type_read_for_GX = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN0", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                                      // assign expression to variable GN0
                                      var_GN0_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN0", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                                      validate_vartype_consistency("GN0", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN0);
                                      aux_last_type_read_for_GN0 = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                                      // assign expression to variable GG
                                      var_GG_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                                      validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                                      aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                                      // assign expression to variable GF
                                      var_GF_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                                      validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                                      aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                    }
                                    if (cpp_i != cpp_npl) {
                                      throw std::runtime_error("not exactly NPL elements consumed");
                                    }
                                  }
                                  cont << cpp_draft_line;
                                  cpp_current_dict = cpp_parent_dict;
                                }
                              }
                              cpp_current_dict = cpp_parent_dict;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: b060c9a10c5a2def7c0e13f02c35f9ae
// MD5 hash of the following function definition: c3910f2afd9f0d3274e500c26691a7dd
void write_mf3_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  EndfFloatCpp var_QM_0d_double_Scalar;
  bool aux_QM_read = false;
  vartype aux_last_type_read_for_QM = UNKNOWN;
  EndfFloatCpp var_QI_0d_double_Scalar;
  bool aux_QI_read = false;
  vartype aux_last_type_read_for_QI = UNKNOWN;
  int var_LR_0d_int_Scalar;
  bool aux_LR_read = false;
  vartype aux_last_type_read_for_LR = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 3;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 3;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 3 , MT / ZA , AWR , 0 , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 3 , MT / QM , QI , 0 , LR , NR , NP / E / xs ] TAB1 ( xstable )";
  // read TAB1 record
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QM", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable QM
  var_QM_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QM", std::vector<int>({}), py::none()));
  aux_QM_read = true;
  validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
  aux_last_type_read_for_QM = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QI", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable QI
  var_QI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QI", std::vector<int>({}), py::none()));
  aux_QI_read = true;
  validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
  aux_last_type_read_for_QI = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LR
  var_LR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LR", std::vector<int>({}), py::none()));
  aux_LR_read = true;
  validate_vartype_consistency("LR", SCALAR_INT, aux_last_type_read_for_LR);
  aux_last_type_read_for_LR = SCALAR_INT;
  {
    py::dict cpp_parent_dict = cpp_current_dict;
    cpp_current_dict = cpp_index_shifter_store.get_value("xstable", std::vector<int>({}), py::dict());
    IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
    cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
    cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
    cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
    cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
    cont << cpp_draft_line;
    tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
    tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("xs", std::vector<int>({}), py::none()));
    tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
    tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
    write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
    // variable declarations
    std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
    bool aux_E_read = false;
    vartype aux_last_type_read_for_E = UNKNOWN;
    std::vector<EndfFloatCpp> var_xs_0d_floatvec_Scalar;
    bool aux_xs_read = false;
    vartype aux_last_type_read_for_xs = UNKNOWN;
    std::vector<int> var_INT_0d_intvec_Scalar;
    bool aux_INT_read = false;
    vartype aux_last_type_read_for_INT = UNKNOWN;
    std::vector<int> var_NBT_0d_intvec_Scalar;
    bool aux_NBT_read = false;
    vartype aux_last_type_read_for_NBT = UNKNOWN;
    {
      Tab1Body tab_body = tab1_body;
      // assign expression to variable E
      var_E_0d_floatvec_Scalar = tab_body.X;
      aux_E_read = true;
      validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
      aux_last_type_read_for_E = SCALAR_FLOATVEC;
      // assign expression to variable xs
      var_xs_0d_floatvec_Scalar = tab_body.Y;
      aux_xs_read = true;
      validate_vartype_consistency("xs", SCALAR_FLOATVEC, aux_last_type_read_for_xs);
      aux_last_type_read_for_xs = SCALAR_FLOATVEC;
      // assign expression to variable INT
      var_INT_0d_intvec_Scalar = tab_body.INT;
      aux_INT_read = true;
      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
      aux_last_type_read_for_INT = SCALAR_INTVEC;
      // assign expression to variable NBT
      var_NBT_0d_intvec_Scalar = tab_body.NBT;
      aux_NBT_read = true;
      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
      aux_last_type_read_for_NBT = SCALAR_INTVEC;
    }
    cont << cpp_draft_line;
    cpp_current_dict = cpp_parent_dict;
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: c4d60855b8643a410283ef0c47845391
// MD5 hash of the following function definition: 0c94c41fde6dec2bb536aa22619f0cc3
void write_mf4_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LTT_0d_int_Scalar;
  bool aux_LTT_read = false;
  vartype aux_last_type_read_for_LTT = UNKNOWN;
  int var_LI_0d_int_Scalar;
  bool aux_LI_read = false;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_LCT_0d_int_Scalar;
  bool aux_LCT_read = false;
  vartype aux_last_type_read_for_LCT = UNKNOWN;
  int var_NM_0d_int_Scalar;
  bool aux_NM_read = false;
  vartype aux_last_type_read_for_NM = UNKNOWN;
  int var_NE_0d_int_Scalar;
  bool aux_NE_read = false;
  vartype aux_last_type_read_for_NE = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  EndfFloatCpp var_T_0d_double_Scalar;
  bool aux_T_read = false;
  vartype aux_last_type_read_for_T = UNKNOWN;
  NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  int var_LT_0d_int_Scalar;
  bool aux_LT_read = false;
  vartype aux_last_type_read_for_LT = UNKNOWN;
  NestedVector<int> var_NL_1d_int_NestedVector;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_a_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_a_2d_idx0;
  vartype aux_last_type_read_for_a = UNKNOWN;
  int var_NE1_0d_int_Scalar;
  bool aux_NE1_read = false;
  vartype aux_last_type_read_for_NE1 = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_al_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_al_2d_idx0;
  vartype aux_last_type_read_for_al = UNKNOWN;
  int var_NE2_0d_int_Scalar;
  bool aux_NE2_read = false;
  vartype aux_last_type_read_for_NE2 = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 4;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 4;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 4 , MT / ZA , AWR , 0 , LTT , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LTT", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LTT
  var_LTT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LTT", std::vector<int>({}), py::none()));
  aux_LTT_read = true;
  validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
  aux_last_type_read_for_LTT = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LTT_0d_int_Scalar = var_LTT_0d_int_Scalar;
          int var_LTT_0d_int_Scalar = glob_var_LTT_0d_int_Scalar;
          bool& glob_aux_LTT_read = aux_LTT_read;
          bool aux_LTT_read = glob_aux_LTT_read;
          vartype aux_last_type_read_for_LTT = UNKNOWN;
          int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
          int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
          bool& glob_aux_LI_read = aux_LI_read;
          bool aux_LI_read = glob_aux_LI_read;
          vartype aux_last_type_read_for_LI = UNKNOWN;
          int& glob_var_LCT_0d_int_Scalar = var_LCT_0d_int_Scalar;
          int var_LCT_0d_int_Scalar = glob_var_LCT_0d_int_Scalar;
          bool& glob_aux_LCT_read = aux_LCT_read;
          bool aux_LCT_read = glob_aux_LCT_read;
          vartype aux_last_type_read_for_LCT = UNKNOWN;
          int& glob_var_NM_0d_int_Scalar = var_NM_0d_int_Scalar;
          int var_NM_0d_int_Scalar = glob_var_NM_0d_int_Scalar;
          bool& glob_aux_NM_read = aux_NM_read;
          bool aux_NM_read = glob_aux_NM_read;
          vartype aux_last_type_read_for_NM = UNKNOWN;
          try {
            cpp_template = "[ MAT , 4 , MT / 0.0 , AWR , LI , LCT , 0 , NM ] CONT";
            // read CONT record
            if ((! (aux_AWR_read == true))) {
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::cast(-99999.9)));
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            } else {
            }
            // assign expression to variable LI
            var_LI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::cast(-99999)));
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            // assign expression to variable LCT
            var_LCT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCT", std::vector<int>({}), py::cast(-99999)));
            aux_LCT_read = true;
            validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
            aux_last_type_read_for_LCT = SCALAR_INT;
            // assign expression to variable NM
            var_NM_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NM", std::vector<int>({}), py::cast(-99999)));
            aux_NM_read = true;
            validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
            aux_last_type_read_for_NM = SCALAR_INT;
          } catch (const std::out_of_range& e) {
            // // accept failure in lookahead
          }
          if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(3)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
            cpp_found_match = true;
          }
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 4 , MT / 0.0 , AWR , LI , LCT , 0 , NM ] CONT";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read CONT record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
          if ((! (aux_AWR_read == true))) {
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          } else {
          }
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LI
          var_LI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none()));
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LCT", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LCT
          var_LCT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCT", std::vector<int>({}), py::none()));
          aux_LCT_read = true;
          validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
          aux_last_type_read_for_LCT = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NM", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NM
          var_NM_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NM", std::vector<int>({}), py::none()));
          aux_NM_read = true;
          validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
          aux_last_type_read_for_NM = SCALAR_INT;
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      cpp_template = "[ MAT , 4 , MT / 0.0 , AWR , LI , LCT , 0 , 0 ] CONT";
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      // read CONT record
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
      if ((! (aux_AWR_read == true))) {
        // assign expression to variable AWR
        var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
        aux_AWR_read = true;
        validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
        aux_last_type_read_for_AWR = SCALAR_DOUBLE;
      } else {
      }
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable LI
      var_LI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none()));
      aux_LI_read = true;
      validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
      aux_last_type_read_for_LI = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LCT", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable LCT
      var_LCT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCT", std::vector<int>({}), py::none()));
      aux_LCT_read = true;
      validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
      aux_last_type_read_for_LCT = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
      cont << cpp_draft_line;
    }
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(1)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
        // read TAB2 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
        // assign expression to variable NE
        var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
        aux_NE_read = true;
        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
        aux_last_type_read_for_NE = SCALAR_INT;
        cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
        cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
        cont << cpp_draft_line;
        tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
        tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
        write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
        {
          Tab2Body tab_body = tab2_body;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
        cont << cpp_draft_line;

        for (int var_i_0d_int_Scalar = 1;
           var_i_0d_int_Scalar <= var_NE_0d_int_Scalar; var_i_0d_int_Scalar++) {
          bool aux_i_read = true;
          cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NL , 0 / { a } { l = 1 to NL } ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read LIST record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable T
          var_T_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({}), py::none()));
          aux_T_read = true;
          validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
          aux_last_type_read_for_T = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
          // assign expression to variable E
          var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
          validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
          aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LT
          var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none()));
          aux_LT_read = true;
          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
          aux_last_type_read_for_LT = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
          // assign expression to variable NL
          var_NL_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
          validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
          aux_last_type_read_for_NL = NESTEDVECTOR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_i_0d_int_Scalar}), py::none()));
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST body
            ptr_a_2d_idx0 = var_a_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

            for (int var_l_0d_int_Scalar = 1;
               var_l_0d_int_Scalar <= var_NL_1d_int_NestedVector[var_i_0d_int_Scalar]; var_l_0d_int_Scalar++) {
              bool aux_l_read = true;
              // read LIST body
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("a", std::vector<int>({var_i_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable a
              ptr_a_2d_idx0->set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("a", std::vector<int>({var_i_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("a", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_a);
              aux_last_type_read_for_a = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(2)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2 ( energy_table )";
          // read TAB2 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NE
          var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
          aux_NE_read = true;
          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
          aux_last_type_read_for_NE = SCALAR_INT;
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.get_value("energy_table", std::vector<int>({}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
            cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
            cont << cpp_draft_line;
            tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
            tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
            write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
            // variable declarations
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab2Body tab_body = tab2_body;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            cont << cpp_draft_line;
            cpp_current_dict = cpp_parent_dict;
          }

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_NE_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NR , NP / mu / f ] TAB1 ( angtable [ i ] )";
            // read TAB1 record
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable T
            var_T_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({}), py::none()));
            aux_T_read = true;
            validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
            aux_last_type_read_for_T = SCALAR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LT
            var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none()));
            aux_LT_read = true;
            validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
            aux_last_type_read_for_LT = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.get_value("angtable", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
              cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("mu", std::vector<int>({}), py::none())), write_opts);
              cpp_np_val = py::len(cpp_index_shifter_store.get_value("mu", std::vector<int>({}), py::none()));
              cont << cpp_draft_line;
              tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("mu", std::vector<int>({}), py::none()));
              tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("f", std::vector<int>({}), py::none()));
              tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
              write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
              // variable declarations
              std::vector<EndfFloatCpp> var_mu_0d_floatvec_Scalar;
              bool aux_mu_read = false;
              vartype aux_last_type_read_for_mu = UNKNOWN;
              std::vector<EndfFloatCpp> var_f_0d_floatvec_Scalar;
              bool aux_f_read = false;
              vartype aux_last_type_read_for_f = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = tab1_body;
                // assign expression to variable mu
                var_mu_0d_floatvec_Scalar = tab_body.X;
                aux_mu_read = true;
                validate_vartype_consistency("mu", SCALAR_FLOATVEC, aux_last_type_read_for_mu);
                aux_last_type_read_for_mu = SCALAR_FLOATVEC;
                // assign expression to variable f
                var_f_0d_floatvec_Scalar = tab_body.Y;
                aux_f_read = true;
                validate_vartype_consistency("f", SCALAR_FLOATVEC, aux_last_type_read_for_f);
                aux_last_type_read_for_f = SCALAR_FLOATVEC;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              cont << cpp_draft_line;
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(3)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE1 / Eint ] TAB2 ( leg_int )";
          // read TAB2 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE1", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NE1
          var_NE1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE1", std::vector<int>({}), py::none()));
          aux_NE1_read = true;
          validate_vartype_consistency("NE1", SCALAR_INT, aux_last_type_read_for_NE1);
          aux_last_type_read_for_NE1 = SCALAR_INT;
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.get_value("leg_int", std::vector<int>({}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
            cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
            cont << cpp_draft_line;
            tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
            tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
            write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
            // variable declarations
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab2Body tab_body = tab2_body;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            cont << cpp_draft_line;
            cpp_current_dict = cpp_parent_dict;
          }

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_NE1_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NL , 0 / \n { al } { j = 1 to NL } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable T
            var_T_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({}), py::none()));
            aux_T_read = true;
            validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
            aux_last_type_read_for_T = SCALAR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LT
            var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none()));
            aux_LT_read = true;
            validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
            aux_last_type_read_for_LT = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
            // assign expression to variable NL
            var_NL_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
            validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
            aux_last_type_read_for_NL = NESTEDVECTOR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_i_0d_int_Scalar}), py::none()));
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read LIST body
              ptr_al_2d_idx0 = var_al_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NL_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                // read LIST body
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("al", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable al
                ptr_al_2d_idx0->set(var_j_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("al", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("al", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_al);
                aux_last_type_read_for_al = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
          }
          cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE2 / Eint ] TAB2 ( ang_int )";
          // read TAB2 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE2", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NE2
          var_NE2_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE2", std::vector<int>({}), py::none()));
          aux_NE2_read = true;
          validate_vartype_consistency("NE2", SCALAR_INT, aux_last_type_read_for_NE2);
          aux_last_type_read_for_NE2 = SCALAR_INT;
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.get_value("ang_int", std::vector<int>({}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
            cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
            cont << cpp_draft_line;
            tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
            tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
            write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
            // variable declarations
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab2Body tab_body = tab2_body;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            cont << cpp_draft_line;
            cpp_current_dict = cpp_parent_dict;
          }

          for (int var_i_0d_int_Scalar = var_NE1_0d_int_Scalar;
             var_i_0d_int_Scalar <= ((var_NE1_0d_int_Scalar+var_NE2_0d_int_Scalar)-1); var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NR , NP / mu / f ] TAB1 ( angtable [ i ] )";
            // read TAB1 record
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({}), py::none())), write_opts);
            if ((! (aux_T_read == true))) {
              // assign expression to variable T
              var_T_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({}), py::none()));
              aux_T_read = true;
              validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
              aux_last_type_read_for_T = SCALAR_DOUBLE;
            } else {
            }
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
            if ((! var_E_1d_double_NestedVector.contains(var_i_0d_int_Scalar))) {
              // assign expression to variable E
              var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            } else {
            }
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none())), write_opts);
            if ((! (aux_LT_read == true))) {
              // assign expression to variable LT
              var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none()));
              aux_LT_read = true;
              validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
              aux_last_type_read_for_LT = SCALAR_INT;
            } else {
            }
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.get_value("angtable", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
              cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("mu", std::vector<int>({}), py::none())), write_opts);
              cpp_np_val = py::len(cpp_index_shifter_store.get_value("mu", std::vector<int>({}), py::none()));
              cont << cpp_draft_line;
              tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("mu", std::vector<int>({}), py::none()));
              tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("f", std::vector<int>({}), py::none()));
              tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
              write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
              // variable declarations
              std::vector<EndfFloatCpp> var_mu_0d_floatvec_Scalar;
              bool aux_mu_read = false;
              vartype aux_last_type_read_for_mu = UNKNOWN;
              std::vector<EndfFloatCpp> var_f_0d_floatvec_Scalar;
              bool aux_f_read = false;
              vartype aux_last_type_read_for_f = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = tab1_body;
                // assign expression to variable mu
                var_mu_0d_floatvec_Scalar = tab_body.X;
                aux_mu_read = true;
                validate_vartype_consistency("mu", SCALAR_FLOATVEC, aux_last_type_read_for_mu);
                aux_last_type_read_for_mu = SCALAR_FLOATVEC;
                // assign expression to variable f
                var_f_0d_floatvec_Scalar = tab_body.Y;
                aux_f_read = true;
                validate_vartype_consistency("f", SCALAR_FLOATVEC, aux_last_type_read_for_f);
                aux_last_type_read_for_f = SCALAR_FLOATVEC;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              cont << cpp_draft_line;
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: ad114a6eab38d3e40a863ae76da18ca0
// MD5 hash of the following function definition: 5e6a6d1af38c5105ac3c2abdb74a79bf
void write_mf5_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 5;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 5;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 5 , MT / ZA , AWR , 0 , 0 , NK , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none()));
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section contribution
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.get_value("contribution", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      int var_LF_0d_int_Scalar;
      bool aux_LF_read = false;
      vartype aux_last_type_read_for_LF = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      EndfFloatCpp var_U_0d_double_Scalar;
      bool aux_U_read = false;
      vartype aux_last_type_read_for_U = UNKNOWN;
      std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
      bool aux_p_read = false;
      vartype aux_last_type_read_for_p = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      EndfFloatCpp var_EFL_0d_double_Scalar;
      bool aux_EFL_read = false;
      vartype aux_last_type_read_for_EFL = UNKNOWN;
      EndfFloatCpp var_EFH_0d_double_Scalar;
      bool aux_EFH_read = false;
      vartype aux_last_type_read_for_EFH = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            {
              // variable declarations
              int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
              int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
              bool& glob_aux_LF_read = aux_LF_read;
              bool aux_LF_read = glob_aux_LF_read;
              vartype aux_last_type_read_for_LF = UNKNOWN;
              try {
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::cast(-99999)));
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
              } catch (const std::out_of_range& e) {
                // // accept failure in lookahead
              }
              if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(1)))))))) {
                cpp_found_match = true;
              }
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
              // read TAB1 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable LF
              var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none()));
              aux_LF_read = true;
              validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
              aux_last_type_read_for_LF = SCALAR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.get_value("p_table", std::vector<int>({}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                cont << cpp_draft_line;
                tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("p", std::vector<int>({}), py::none()));
                tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                // variable declarations
                std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                bool aux_E_read = false;
                vartype aux_last_type_read_for_E = UNKNOWN;
                std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
                bool aux_p_read = false;
                vartype aux_last_type_read_for_p = UNKNOWN;
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab1Body tab_body = tab1_body;
                  // assign expression to variable E
                  var_E_0d_floatvec_Scalar = tab_body.X;
                  aux_E_read = true;
                  validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
                cpp_current_dict = cpp_parent_dict;
              }
              cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E ] TAB2 ( E_interp )";
              // read TAB2 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.get_value("E_interp", std::vector<int>({}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                cont << cpp_draft_line;
                tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
                // variable declarations
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab2Body tab_body = tab2_body;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
                cpp_current_dict = cpp_parent_dict;
              }

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NE_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                cpp_template = "[ MAT , 5 , MT / 0.0 , E , 0 , 0 , NR , NF / Eout / g ] TAB1 ( spectrum [ l ] )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_l_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_l_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.get_value("spectrum", std::vector<int>({var_l_0d_int_Scalar}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eout", std::vector<int>({}), py::none())), write_opts);
                  cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eout", std::vector<int>({}), py::none()));
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eout", std::vector<int>({}), py::none()));
                  tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("g", std::vector<int>({}), py::none()));
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_Eout_0d_floatvec_Scalar;
                  bool aux_Eout_read = false;
                  vartype aux_last_type_read_for_Eout = UNKNOWN;
                  std::vector<EndfFloatCpp> var_g_0d_floatvec_Scalar;
                  bool aux_g_read = false;
                  vartype aux_last_type_read_for_g = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable Eout
                    var_Eout_0d_floatvec_Scalar = tab_body.X;
                    aux_Eout_read = true;
                    validate_vartype_consistency("Eout", SCALAR_FLOATVEC, aux_last_type_read_for_Eout);
                    aux_last_type_read_for_Eout = SCALAR_FLOATVEC;
                    // assign expression to variable g
                    var_g_0d_floatvec_Scalar = tab_body.Y;
                    aux_g_read = true;
                    validate_vartype_consistency("g", SCALAR_FLOATVEC, aux_last_type_read_for_g);
                    aux_last_type_read_for_g = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              {
                // variable declarations
                EndfFloatCpp& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                EndfFloatCpp var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                try {
                  cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                  // read TAB1 record
                  // assign expression to variable U
                  var_U_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("U", std::vector<int>({}), py::cast(-99999.9)));
                  aux_U_read = true;
                  validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                  aux_last_type_read_for_U = SCALAR_DOUBLE;
                  // assign expression to variable LF
                  var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::cast(-99999)));
                  aux_LF_read = true;
                  validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                  aux_last_type_read_for_LF = SCALAR_INT;
                } catch (const std::out_of_range& e) {
                  // // accept failure in lookahead
                }
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(5)))))))) {
                  cpp_found_match = true;
                }
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("U", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("U", std::vector<int>({}), py::none()));
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none()));
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.get_value("p_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                  cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("p", std::vector<int>({}), py::none()));
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E / theta ] TAB1 ( theta_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.get_value("theta_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                  cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("theta", std::vector<int>({}), py::none()));
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_theta_0d_floatvec_Scalar;
                  bool aux_theta_read = false;
                  vartype aux_last_type_read_for_theta = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable theta
                    var_theta_0d_floatvec_Scalar = tab_body.Y;
                    aux_theta_read = true;
                    validate_vartype_consistency("theta", SCALAR_FLOATVEC, aux_last_type_read_for_theta);
                    aux_last_type_read_for_theta = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NF / x / g ] TAB1 ( g_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.get_value("g_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("x", std::vector<int>({}), py::none())), write_opts);
                  cpp_np_val = py::len(cpp_index_shifter_store.get_value("x", std::vector<int>({}), py::none()));
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("x", std::vector<int>({}), py::none()));
                  tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("g", std::vector<int>({}), py::none()));
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_x_0d_floatvec_Scalar;
                  bool aux_x_read = false;
                  vartype aux_last_type_read_for_x = UNKNOWN;
                  std::vector<EndfFloatCpp> var_g_0d_floatvec_Scalar;
                  bool aux_g_read = false;
                  vartype aux_last_type_read_for_g = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable x
                    var_x_0d_floatvec_Scalar = tab_body.X;
                    aux_x_read = true;
                    validate_vartype_consistency("x", SCALAR_FLOATVEC, aux_last_type_read_for_x);
                    aux_last_type_read_for_x = SCALAR_FLOATVEC;
                    // assign expression to variable g
                    var_g_0d_floatvec_Scalar = tab_body.Y;
                    aux_g_read = true;
                    validate_vartype_consistency("g", SCALAR_FLOATVEC, aux_last_type_read_for_g);
                    aux_last_type_read_for_g = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              {
                // variable declarations
                EndfFloatCpp& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                EndfFloatCpp var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                try {
                  cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                  // read TAB1 record
                  // assign expression to variable U
                  var_U_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("U", std::vector<int>({}), py::cast(-99999.9)));
                  aux_U_read = true;
                  validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                  aux_last_type_read_for_U = SCALAR_DOUBLE;
                  // assign expression to variable LF
                  var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::cast(-99999)));
                  aux_LF_read = true;
                  validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                  aux_last_type_read_for_LF = SCALAR_INT;
                } catch (const std::out_of_range& e) {
                  // // accept failure in lookahead
                }
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(7)))))))) {
                  cpp_found_match = true;
                }
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("U", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("U", std::vector<int>({}), py::none()));
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none()));
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.get_value("p_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                  cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("p", std::vector<int>({}), py::none()));
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E / theta ] TAB1 ( theta_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.get_value("theta_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                  cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("theta", std::vector<int>({}), py::none()));
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_theta_0d_floatvec_Scalar;
                  bool aux_theta_read = false;
                  vartype aux_last_type_read_for_theta = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable theta
                    var_theta_0d_floatvec_Scalar = tab_body.Y;
                    aux_theta_read = true;
                    validate_vartype_consistency("theta", SCALAR_FLOATVEC, aux_last_type_read_for_theta);
                    aux_last_type_read_for_theta = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              {
                // variable declarations
                EndfFloatCpp& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                EndfFloatCpp var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                try {
                  cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                  // read TAB1 record
                  // assign expression to variable U
                  var_U_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("U", std::vector<int>({}), py::cast(-99999.9)));
                  aux_U_read = true;
                  validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                  aux_last_type_read_for_U = SCALAR_DOUBLE;
                  // assign expression to variable LF
                  var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::cast(-99999)));
                  aux_LF_read = true;
                  validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                  aux_last_type_read_for_LF = SCALAR_INT;
                } catch (const std::out_of_range& e) {
                  // // accept failure in lookahead
                }
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(9)))))))) {
                  cpp_found_match = true;
                }
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("U", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("U", std::vector<int>({}), py::none()));
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none()));
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.get_value("p_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                  cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("p", std::vector<int>({}), py::none()));
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E / theta ] TAB1 ( theta_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.get_value("theta_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                  cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("theta", std::vector<int>({}), py::none()));
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_theta_0d_floatvec_Scalar;
                  bool aux_theta_read = false;
                  vartype aux_last_type_read_for_theta = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable theta
                    var_theta_0d_floatvec_Scalar = tab_body.Y;
                    aux_theta_read = true;
                    validate_vartype_consistency("theta", SCALAR_FLOATVEC, aux_last_type_read_for_theta);
                    aux_last_type_read_for_theta = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              {
                // variable declarations
                EndfFloatCpp& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                EndfFloatCpp var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                try {
                  cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1";
                  // read TAB1 record
                  // assign expression to variable U
                  var_U_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("U", std::vector<int>({}), py::cast(-99999.9)));
                  aux_U_read = true;
                  validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                  aux_last_type_read_for_U = SCALAR_DOUBLE;
                  // assign expression to variable LF
                  var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::cast(-99999)));
                  aux_LF_read = true;
                  validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                  aux_last_type_read_for_LF = SCALAR_INT;
                } catch (const std::out_of_range& e) {
                  // // accept failure in lookahead
                }
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(11)))))))) {
                  cpp_found_match = true;
                }
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("U", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("U", std::vector<int>({}), py::none()));
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none()));
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                cont << cpp_draft_line;
                tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("p", std::vector<int>({}), py::none()));
                tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                {
                  Tab1Body tab_body = tab1_body;
                  // assign expression to variable E
                  var_E_0d_floatvec_Scalar = tab_body.X;
                  aux_E_read = true;
                  validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
                throw std::runtime_error("Encountered STOP instruction in recipe: LF=11 case not implemented in ENDF recipe MF5");
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              {
                // variable declarations
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                try {
                  cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                  // read TAB1 record
                  // assign expression to variable LF
                  var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::cast(-99999)));
                  aux_LF_read = true;
                  validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                  aux_last_type_read_for_LF = SCALAR_INT;
                } catch (const std::out_of_range& e) {
                  // // accept failure in lookahead
                }
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(12)))))))) {
                  cpp_found_match = true;
                }
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none()));
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.get_value("p_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                  cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("p", std::vector<int>({}), py::none()));
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / EFL , EFH , 0 , 0 , NR , NE / E / TM ] TAB1 ( Tm_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EFL", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable EFL
                var_EFL_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EFL", std::vector<int>({}), py::none()));
                aux_EFL_read = true;
                validate_vartype_consistency("EFL", SCALAR_DOUBLE, aux_last_type_read_for_EFL);
                aux_last_type_read_for_EFL = SCALAR_DOUBLE;
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EFH", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable EFH
                var_EFH_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EFH", std::vector<int>({}), py::none()));
                aux_EFH_read = true;
                validate_vartype_consistency("EFH", SCALAR_DOUBLE, aux_last_type_read_for_EFH);
                aux_last_type_read_for_EFH = SCALAR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.get_value("Tm_table", std::vector<int>({}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
                  cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
                  tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("TM", std::vector<int>({}), py::none()));
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<EndfFloatCpp> var_TM_0d_floatvec_Scalar;
                  bool aux_TM_read = false;
                  vartype aux_last_type_read_for_TM = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable TM
                    var_TM_0d_floatvec_Scalar = tab_body.Y;
                    aux_TM_read = true;
                    validate_vartype_consistency("TM", SCALAR_FLOATVEC, aux_last_type_read_for_TM);
                    aux_last_type_read_for_TM = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: ca82cdd58bd8081afe9c01f911284492
// MD5 hash of the following function definition: 97e60725bfc5deeca4a7e1c3d73e7d4d
void write_mf6_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_JP_0d_int_Scalar;
  bool aux_JP_read = false;
  vartype aux_last_type_read_for_JP = UNKNOWN;
  int var_LCT_0d_int_Scalar;
  bool aux_LCT_read = false;
  vartype aux_last_type_read_for_LCT = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 6;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 6;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 6 , MT / ZA , AWR , JP , LCT , NK , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("JP", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable JP
  var_JP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("JP", std::vector<int>({}), py::none()));
  aux_JP_read = true;
  validate_vartype_consistency("JP", SCALAR_INT, aux_last_type_read_for_JP);
  aux_last_type_read_for_JP = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LCT", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LCT
  var_LCT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCT", std::vector<int>({}), py::none()));
  aux_LCT_read = true;
  validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
  aux_last_type_read_for_LCT = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none()));
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NK_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.get_value("subsection", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_ZAP_0d_double_Scalar;
      bool aux_ZAP_read = false;
      vartype aux_last_type_read_for_ZAP = UNKNOWN;
      EndfFloatCpp var_AWP_0d_double_Scalar;
      bool aux_AWP_read = false;
      vartype aux_last_type_read_for_AWP = UNKNOWN;
      int var_LIP_0d_int_Scalar;
      bool aux_LIP_read = false;
      vartype aux_last_type_read_for_LIP = UNKNOWN;
      int var_LAW_0d_int_Scalar;
      bool aux_LAW_read = false;
      vartype aux_last_type_read_for_LAW = UNKNOWN;
      int var_LANG_0d_int_Scalar;
      bool aux_LANG_read = false;
      vartype aux_last_type_read_for_LANG = UNKNOWN;
      int var_LEP_0d_int_Scalar;
      bool aux_LEP_read = false;
      vartype aux_last_type_read_for_LEP = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      NestedVector<int> var_ND_1d_int_NestedVector;
      vartype aux_last_type_read_for_ND = UNKNOWN;
      NestedVector<int> var_NA_1d_int_NestedVector;
      vartype aux_last_type_read_for_NA = UNKNOWN;
      int cpp_int_val;
      bool aux_cpp_int_val_read = false;
      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
      NestedVector<int> var_NEP_1d_int_NestedVector;
      vartype aux_last_type_read_for_NEP = UNKNOWN;
      NestedVector<NestedVector<EndfFloatCpp>> var_Ep_2d_double_NestedVector;
      NestedVector<EndfFloatCpp>* ptr_Ep_2d_idx0;
      vartype aux_last_type_read_for_Ep = UNKNOWN;
      NestedVector<NestedVector<NestedVector<EndfFloatCpp>>> var_b_3d_double_NestedVector;
      NestedVector<EndfFloatCpp>* ptr_b_3d_idx1;
      NestedVector<NestedVector<EndfFloatCpp>>* ptr_b_3d_idx0;
      vartype aux_last_type_read_for_b = UNKNOWN;
      NestedVector<int> var_NLW_1d_int_NestedVector;
      vartype aux_last_type_read_for_NLW = UNKNOWN;
      NestedVector<int> var_NL_1d_int_NestedVector;
      vartype aux_last_type_read_for_NL = UNKNOWN;
      NestedVector<NestedVector<EndfFloatCpp>> var_A_2d_double_NestedVector;
      NestedVector<EndfFloatCpp>* ptr_A_2d_idx0;
      vartype aux_last_type_read_for_A = UNKNOWN;
      EndfFloatCpp var_SPI_0d_double_Scalar;
      bool aux_SPI_read = false;
      vartype aux_last_type_read_for_SPI = UNKNOWN;
      int var_LIDP_0d_int_Scalar;
      bool aux_LIDP_read = false;
      vartype aux_last_type_read_for_LIDP = UNKNOWN;
      NestedVector<int> var_LTP_1d_int_NestedVector;
      vartype aux_last_type_read_for_LTP = UNKNOWN;
      NestedVector<int> var_NW_1d_int_NestedVector;
      vartype aux_last_type_read_for_NW = UNKNOWN;
      EndfFloatCpp var_APSX_0d_double_Scalar;
      bool aux_APSX_read = false;
      vartype aux_last_type_read_for_APSX = UNKNOWN;
      int var_NPSX_0d_int_Scalar;
      bool aux_NPSX_read = false;
      vartype aux_last_type_read_for_NPSX = UNKNOWN;
      NestedVector<int> var_NMU_1d_int_NestedVector;
      vartype aux_last_type_read_for_NMU = UNKNOWN;
      NestedVector<NestedVector<EndfFloatCpp>> var_mu_2d_double_NestedVector;
      NestedVector<EndfFloatCpp>* ptr_mu_2d_idx0;
      vartype aux_last_type_read_for_mu = UNKNOWN;
      cpp_template = "[ MAT , 6 , MT / ZAP , AWP , LIP , LAW , NR , NP / Eint / yi ] TAB1 ( yields )";
      // read TAB1 record
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAP", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable ZAP
      var_ZAP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAP", std::vector<int>({}), py::none()));
      aux_ZAP_read = true;
      validate_vartype_consistency("ZAP", SCALAR_DOUBLE, aux_last_type_read_for_ZAP);
      aux_last_type_read_for_ZAP = SCALAR_DOUBLE;
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWP", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable AWP
      var_AWP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWP", std::vector<int>({}), py::none()));
      aux_AWP_read = true;
      validate_vartype_consistency("AWP", SCALAR_DOUBLE, aux_last_type_read_for_AWP);
      aux_last_type_read_for_AWP = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LIP", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable LIP
      var_LIP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LIP", std::vector<int>({}), py::none()));
      aux_LIP_read = true;
      validate_vartype_consistency("LIP", SCALAR_INT, aux_last_type_read_for_LIP);
      aux_last_type_read_for_LIP = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LAW", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable LAW
      var_LAW_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LAW", std::vector<int>({}), py::none()));
      aux_LAW_read = true;
      validate_vartype_consistency("LAW", SCALAR_INT, aux_last_type_read_for_LAW);
      aux_last_type_read_for_LAW = SCALAR_INT;
      {
        py::dict cpp_parent_dict = cpp_current_dict;
        cpp_current_dict = cpp_index_shifter_store.get_value("yields", std::vector<int>({}), py::dict());
        IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
        cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
        cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
        cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
        cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
        cont << cpp_draft_line;
        tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
        tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("yi", std::vector<int>({}), py::none()));
        tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
        tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
        write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
        // variable declarations
        std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
        bool aux_Eint_read = false;
        vartype aux_last_type_read_for_Eint = UNKNOWN;
        std::vector<EndfFloatCpp> var_yi_0d_floatvec_Scalar;
        bool aux_yi_read = false;
        vartype aux_last_type_read_for_yi = UNKNOWN;
        std::vector<int> var_INT_0d_intvec_Scalar;
        bool aux_INT_read = false;
        vartype aux_last_type_read_for_INT = UNKNOWN;
        std::vector<int> var_NBT_0d_intvec_Scalar;
        bool aux_NBT_read = false;
        vartype aux_last_type_read_for_NBT = UNKNOWN;
        {
          Tab1Body tab_body = tab1_body;
          // assign expression to variable Eint
          var_Eint_0d_floatvec_Scalar = tab_body.X;
          aux_Eint_read = true;
          validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
          aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
          // assign expression to variable yi
          var_yi_0d_floatvec_Scalar = tab_body.Y;
          aux_yi_read = true;
          validate_vartype_consistency("yi", SCALAR_FLOATVEC, aux_last_type_read_for_yi);
          aux_last_type_read_for_yi = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
        cont << cpp_draft_line;
        cpp_current_dict = cpp_parent_dict;
      }
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(1)))))))) {
            // if statement evaluation
            cpp_found_match = true;
            cpp_template = "[ MAT , 6 , MT / 0.0 , 0.0 , LANG , LEP , NR , NE / Eint ] TAB2";
            // read TAB2 record
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LANG", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LANG
            var_LANG_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LANG", std::vector<int>({}), py::none()));
            aux_LANG_read = true;
            validate_vartype_consistency("LANG", SCALAR_INT, aux_last_type_read_for_LANG);
            aux_last_type_read_for_LANG = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LEP", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LEP
            var_LEP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LEP", std::vector<int>({}), py::none()));
            aux_LEP_read = true;
            validate_vartype_consistency("LEP", SCALAR_INT, aux_last_type_read_for_LEP);
            aux_last_type_read_for_LEP = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NE
            var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
            aux_NE_read = true;
            validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
            aux_last_type_read_for_NE = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
            cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
            cont << cpp_draft_line;
            tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
            tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
            write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
            {
              Tab2Body tab_body = tab2_body;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            cont << cpp_draft_line;

            for (int var_j_0d_int_Scalar = 1;
               var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
              bool aux_j_read = true;
              cpp_template = "[ MAT , 6 , MT / 0.0 , E , ND , NA , NW , NEP / \n { Ep , { b } { m = 0 to NA } } { k = 1 to NEP } ] LIST";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read LIST record
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable E
              var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("ND", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable ND
              var_ND_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("ND", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("ND", NESTEDVECTOR_INT, aux_last_type_read_for_ND);
              aux_last_type_read_for_ND = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("NA", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable NA
              var_NA_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NA", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("NA", NESTEDVECTOR_INT, aux_last_type_read_for_NA);
              aux_last_type_read_for_NA = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_index_shifter_store.get_value("NEP", std::vector<int>({var_j_0d_int_Scalar}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NA", std::vector<int>({var_j_0d_int_Scalar}), py::none()))+2)), write_opts);
              // assign expression to variable cpp_int_val
              cpp_int_val = (py::cast<int>(cpp_index_shifter_store.get_value("NEP", std::vector<int>({var_j_0d_int_Scalar}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NA", std::vector<int>({var_j_0d_int_Scalar}), py::none()))+2));
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NEP
              var_NEP_1d_int_NestedVector.set(var_j_0d_int_Scalar, (cpp_int_val/(var_NA_1d_int_NestedVector[var_j_0d_int_Scalar]+2)));
              validate_vartype_consistency("NEP", NESTEDVECTOR_INT, aux_last_type_read_for_NEP);
              aux_last_type_read_for_NEP = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NEP", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
              if ((! var_NEP_1d_int_NestedVector.contains(var_j_0d_int_Scalar))) {
                // assign expression to variable NEP
                var_NEP_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NEP", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("NEP", NESTEDVECTOR_INT, aux_last_type_read_for_NEP);
                aux_last_type_read_for_NEP = NESTEDVECTOR_INT;
              } else {
              }
              cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_index_shifter_store.get_value("NEP", std::vector<int>({var_j_0d_int_Scalar}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NA", std::vector<int>({var_j_0d_int_Scalar}), py::none()))+2)), write_opts);
              cont << cpp_draft_line;
              {
                int cpp_npl = (py::cast<int>(cpp_index_shifter_store.get_value("NEP", std::vector<int>({var_j_0d_int_Scalar}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NA", std::vector<int>({var_j_0d_int_Scalar}), py::none()))+2));
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                // read LIST body
                ptr_Ep_2d_idx0 = var_Ep_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);
                ptr_b_3d_idx0 = var_b_3d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                for (int var_k_0d_int_Scalar = 1;
                   var_k_0d_int_Scalar <= var_NEP_1d_int_NestedVector[var_j_0d_int_Scalar]; var_k_0d_int_Scalar++) {
                  bool aux_k_read = true;
                  // read LIST body
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Ep", std::vector<int>({var_j_0d_int_Scalar, var_k_0d_int_Scalar}), py::none())), write_opts);
                  // assign expression to variable Ep
                  ptr_Ep_2d_idx0->set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Ep", std::vector<int>({var_j_0d_int_Scalar, var_k_0d_int_Scalar}), py::none())));
                  validate_vartype_consistency("Ep", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ep);
                  aux_last_type_read_for_Ep = NESTEDVECTOR_DOUBLE;
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    cpp_j = 0;
                  }
                  ptr_b_3d_idx1 = ptr_b_3d_idx0->prepare(var_k_0d_int_Scalar);

                  for (int var_m_0d_int_Scalar = 0;
                     var_m_0d_int_Scalar <= var_NA_1d_int_NestedVector[var_j_0d_int_Scalar]; var_m_0d_int_Scalar++) {
                    bool aux_m_read = true;
                    // read LIST body
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("b", std::vector<int>({var_j_0d_int_Scalar, var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
                    // assign expression to variable b
                    ptr_b_3d_idx1->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("b", std::vector<int>({var_j_0d_int_Scalar, var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
                    validate_vartype_consistency("b", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_b);
                    aux_last_type_read_for_b = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cont << cpp_draft_line;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      cpp_j = 0;
                    }
                  }
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
              cont << cpp_draft_line;
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(2)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
              // read TAB2 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
              cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              cont << cpp_draft_line;
              tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
              write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
              {
                Tab2Body tab_body = tab2_body;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              cont << cpp_draft_line;

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                cpp_template = "[ MAT , 6 , MT / 0.0 , E , LANG , 0 , NLW , NL / { A } { l = 1 to NLW } ] LIST";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                // read LIST record
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LANG", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable LANG
                var_LANG_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LANG", std::vector<int>({}), py::none()));
                aux_LANG_read = true;
                validate_vartype_consistency("LANG", SCALAR_INT, aux_last_type_read_for_LANG);
                aux_last_type_read_for_LANG = SCALAR_INT;
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLW", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable NLW
                var_NLW_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NLW", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("NLW", NESTEDVECTOR_INT, aux_last_type_read_for_NLW);
                aux_last_type_read_for_NLW = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable NL
                var_NL_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLW", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
                cont << cpp_draft_line;
                {
                  int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NLW", std::vector<int>({var_j_0d_int_Scalar}), py::none()));
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  // read LIST body
                  ptr_A_2d_idx0 = var_A_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                  for (int var_l_0d_int_Scalar = 1;
                     var_l_0d_int_Scalar <= var_NLW_1d_int_NestedVector[var_j_0d_int_Scalar]; var_l_0d_int_Scalar++) {
                    bool aux_l_read = true;
                    // read LIST body
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("A", std::vector<int>({var_j_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())), write_opts);
                    // assign expression to variable A
                    ptr_A_2d_idx0->set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("A", std::vector<int>({var_j_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())));
                    validate_vartype_consistency("A", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_A);
                    aux_last_type_read_for_A = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cont << cpp_draft_line;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      cpp_j = 0;
                    }
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
                cont << cpp_draft_line;
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(5)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / SPI , 0.0 , LIDP , 0 , NR , NE / Eint ] TAB2";
              // read TAB2 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable SPI
              var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
              aux_SPI_read = true;
              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LIDP", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable LIDP
              var_LIDP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LIDP", std::vector<int>({}), py::none()));
              aux_LIDP_read = true;
              validate_vartype_consistency("LIDP", SCALAR_INT, aux_last_type_read_for_LIDP);
              aux_last_type_read_for_LIDP = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
              cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              cont << cpp_draft_line;
              tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
              write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
              {
                Tab2Body tab_body = tab2_body;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              cont << cpp_draft_line;

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                cpp_template = "[ MAT , 6 , MT / 0.0 , E , LTP , 0 , NW , NL / \n { A } { k = 1 to NW } ] LIST";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                // read LIST record
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LTP", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable LTP
                var_LTP_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("LTP", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("LTP", NESTEDVECTOR_INT, aux_last_type_read_for_LTP);
                aux_last_type_read_for_LTP = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NW", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable NW
                var_NW_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NW", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("NW", NESTEDVECTOR_INT, aux_last_type_read_for_NW);
                aux_last_type_read_for_NW = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable NL
                var_NL_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NW", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
                cont << cpp_draft_line;
                {
                  int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NW", std::vector<int>({var_j_0d_int_Scalar}), py::none()));
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  // read LIST body
                  ptr_A_2d_idx0 = var_A_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                  for (int var_k_0d_int_Scalar = 1;
                     var_k_0d_int_Scalar <= var_NW_1d_int_NestedVector[var_j_0d_int_Scalar]; var_k_0d_int_Scalar++) {
                    bool aux_k_read = true;
                    // read LIST body
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("A", std::vector<int>({var_j_0d_int_Scalar, var_k_0d_int_Scalar}), py::none())), write_opts);
                    // assign expression to variable A
                    ptr_A_2d_idx0->set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("A", std::vector<int>({var_j_0d_int_Scalar, var_k_0d_int_Scalar}), py::none())));
                    validate_vartype_consistency("A", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_A);
                    aux_last_type_read_for_A = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cont << cpp_draft_line;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      cpp_j = 0;
                    }
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
                cont << cpp_draft_line;
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(6)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / APSX , 0.0 , 0 , 0 , 0 , NPSX ] CONT";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read CONT record
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APSX", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable APSX
              var_APSX_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APSX", std::vector<int>({}), py::none()));
              aux_APSX_read = true;
              validate_vartype_consistency("APSX", SCALAR_DOUBLE, aux_last_type_read_for_APSX);
              aux_last_type_read_for_APSX = SCALAR_DOUBLE;
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NPSX", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable NPSX
              var_NPSX_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NPSX", std::vector<int>({}), py::none()));
              aux_NPSX_read = true;
              validate_vartype_consistency("NPSX", SCALAR_INT, aux_last_type_read_for_NPSX);
              aux_last_type_read_for_NPSX = SCALAR_INT;
              cont << cpp_draft_line;
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(7)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E ] TAB2 ( E_interpol )";
              // read TAB2 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.get_value("E_interpol", std::vector<int>({}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                cont << cpp_draft_line;
                tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
                // variable declarations
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab2Body tab_body = tab2_body;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
                cpp_current_dict = cpp_parent_dict;
              }

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                cpp_template = "[ MAT , 6 , MT / 0.0 , E , 0 , 0 , NRM , NMU / mu ] TAB2 ( mu_interpol [ j ] )";
                // read TAB2 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NMU", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable NMU
                var_NMU_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NMU", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("NMU", NESTEDVECTOR_INT, aux_last_type_read_for_NMU);
                aux_last_type_read_for_NMU = NESTEDVECTOR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.get_value("mu_interpol", std::vector<int>({var_j_0d_int_Scalar}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  cont << cpp_draft_line;
                  tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                  write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab2Body tab_body = tab2_body;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict;
                }

                for (int var_k_0d_int_Scalar = 1;
                   var_k_0d_int_Scalar <= var_NMU_1d_int_NestedVector[var_j_0d_int_Scalar]; var_k_0d_int_Scalar++) {
                  bool aux_k_read = true;
                  cpp_template = "[ MAT , 6 , MT / 0.0 , mu , 0 , 0 , NRP , NEP / Ep / f ] TAB1 ( table [ j , k ] )";
                  // read TAB1 record
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("mu", std::vector<int>({var_j_0d_int_Scalar, var_k_0d_int_Scalar}), py::none())), write_opts);
                  // assign expression to variable mu
                  ptr_mu_2d_idx0 = var_mu_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);
                  ptr_mu_2d_idx0->set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("mu", std::vector<int>({var_j_0d_int_Scalar, var_k_0d_int_Scalar}), py::none())));
                  validate_vartype_consistency("mu", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_mu);
                  aux_last_type_read_for_mu = NESTEDVECTOR_DOUBLE;
                  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                  {
                    py::dict cpp_parent_dict = cpp_current_dict;
                    cpp_current_dict = cpp_index_shifter_store.get_value("table", std::vector<int>({var_j_0d_int_Scalar, var_k_0d_int_Scalar}), py::dict());
                    IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                    cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                    cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                    cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Ep", std::vector<int>({}), py::none())), write_opts);
                    cpp_np_val = py::len(cpp_index_shifter_store.get_value("Ep", std::vector<int>({}), py::none()));
                    cont << cpp_draft_line;
                    tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Ep", std::vector<int>({}), py::none()));
                    tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("f", std::vector<int>({}), py::none()));
                    tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                    tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                    write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                    // variable declarations
                    std::vector<EndfFloatCpp> var_Ep_0d_floatvec_Scalar;
                    bool aux_Ep_read = false;
                    vartype aux_last_type_read_for_Ep = UNKNOWN;
                    std::vector<EndfFloatCpp> var_f_0d_floatvec_Scalar;
                    bool aux_f_read = false;
                    vartype aux_last_type_read_for_f = UNKNOWN;
                    std::vector<int> var_INT_0d_intvec_Scalar;
                    bool aux_INT_read = false;
                    vartype aux_last_type_read_for_INT = UNKNOWN;
                    std::vector<int> var_NBT_0d_intvec_Scalar;
                    bool aux_NBT_read = false;
                    vartype aux_last_type_read_for_NBT = UNKNOWN;
                    {
                      Tab1Body tab_body = tab1_body;
                      // assign expression to variable Ep
                      var_Ep_0d_floatvec_Scalar = tab_body.X;
                      aux_Ep_read = true;
                      validate_vartype_consistency("Ep", SCALAR_FLOATVEC, aux_last_type_read_for_Ep);
                      aux_last_type_read_for_Ep = SCALAR_FLOATVEC;
                      // assign expression to variable f
                      var_f_0d_floatvec_Scalar = tab_body.Y;
                      aux_f_read = true;
                      validate_vartype_consistency("f", SCALAR_FLOATVEC, aux_last_type_read_for_f);
                      aux_last_type_read_for_f = SCALAR_FLOATVEC;
                      // assign expression to variable INT
                      var_INT_0d_intvec_Scalar = tab_body.INT;
                      aux_INT_read = true;
                      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                      aux_last_type_read_for_INT = SCALAR_INTVEC;
                      // assign expression to variable NBT
                      var_NBT_0d_intvec_Scalar = tab_body.NBT;
                      aux_NBT_read = true;
                      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                      aux_last_type_read_for_NBT = SCALAR_INTVEC;
                    }
                    cont << cpp_draft_line;
                    cpp_current_dict = cpp_parent_dict;
                  }
                }
              }
            }
          }
        }
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: bd9c9da4de018928918c4acb82f32a0a
// MD5 hash of the following function definition: f92716fbc186e49feb8c8e2d625b0ee4
void write_mf7mt2_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LTHR_0d_int_Scalar;
  bool aux_LTHR_read = false;
  vartype aux_last_type_read_for_LTHR = UNKNOWN;
  EndfFloatCpp var_T0_0d_double_Scalar;
  bool aux_T0_read = false;
  vartype aux_last_type_read_for_T0 = UNKNOWN;
  int var_LT_0d_int_Scalar;
  bool aux_LT_read = false;
  vartype aux_last_type_read_for_LT = UNKNOWN;
  NestedVector<EndfFloatCpp> var_T_1d_double_NestedVector;
  vartype aux_last_type_read_for_T = UNKNOWN;
  int var_LI_0d_int_Scalar;
  bool aux_LI_read = false;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_NP_0d_int_Scalar;
  bool aux_NP_read = false;
  vartype aux_last_type_read_for_NP = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_S_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_S_2d_idx0;
  vartype aux_last_type_read_for_S = UNKNOWN;
  EndfFloatCpp var_SB_0d_double_Scalar;
  bool aux_SB_read = false;
  vartype aux_last_type_read_for_SB = UNKNOWN;
  std::vector<EndfFloatCpp> var_Tint_0d_floatvec_Scalar;
  bool aux_Tint_read = false;
  vartype aux_last_type_read_for_Tint = UNKNOWN;
  std::vector<EndfFloatCpp> var_Wp_0d_floatvec_Scalar;
  bool aux_Wp_read = false;
  vartype aux_last_type_read_for_Wp = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 7;
  int mt = 2;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 7;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 2;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 7 , 2 / ZA , AWR , LTHR , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LTHR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LTHR
  var_LTHR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LTHR", std::vector<int>({}), py::none()));
  aux_LTHR_read = true;
  validate_vartype_consistency("LTHR", SCALAR_INT, aux_last_type_read_for_LTHR);
  aux_last_type_read_for_LTHR = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_LTHR_read == true)) && ((var_LTHR_0d_int_Scalar)==(1)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 2 / T0 , 0.0 , LT , 0 , NR , NP / Eint / S ] TAB1 ( S_T0_table )";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T0", std::vector<int>({}), py::none())), write_opts);
        // assign expression to variable T0
        var_T0_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T0", std::vector<int>({}), py::none()));
        aux_T0_read = true;
        validate_vartype_consistency("T0", SCALAR_DOUBLE, aux_last_type_read_for_T0);
        aux_last_type_read_for_T0 = SCALAR_DOUBLE;
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none())), write_opts);
        // assign expression to variable LT
        var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none()));
        aux_LT_read = true;
        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
        aux_last_type_read_for_LT = SCALAR_INT;
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.get_value("S_T0_table", std::vector<int>({}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
          cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
          cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
          tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("S", std::vector<int>({}), py::none()));
          tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          // variable declarations
          std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
          bool aux_Eint_read = false;
          vartype aux_last_type_read_for_Eint = UNKNOWN;
          std::vector<EndfFloatCpp> var_S_0d_floatvec_Scalar;
          bool aux_S_read = false;
          vartype aux_last_type_read_for_S = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Eint
            var_Eint_0d_floatvec_Scalar = tab_body.X;
            aux_Eint_read = true;
            validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
            aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
            // assign expression to variable S
            var_S_0d_floatvec_Scalar = tab_body.Y;
            aux_S_read = true;
            validate_vartype_consistency("S", SCALAR_FLOATVEC, aux_last_type_read_for_S);
            aux_last_type_read_for_S = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
          cpp_current_dict = cpp_parent_dict;
        }

        for (int var_i_0d_int_Scalar = 1;
           var_i_0d_int_Scalar <= var_LT_0d_int_Scalar; var_i_0d_int_Scalar++) {
          bool aux_i_read = true;
          cpp_template = "[ MAT , 7 , 2 / T , 0.0 , LI , 0 , NP , 0 / \n { S } { q = 1 to NP } ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read LIST record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
          // assign expression to variable T
          var_T_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
          validate_vartype_consistency("T", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_T);
          aux_last_type_read_for_T = NESTEDVECTOR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LI
          var_LI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none()));
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NP
          var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()));
          aux_NP_read = true;
          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
          aux_last_type_read_for_NP = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())), write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()));
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST body

            for (int var_q_0d_int_Scalar = 1;
               var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
              bool aux_q_read = true;
              // read LIST body
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("S", std::vector<int>({var_q_0d_int_Scalar, var_i_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable S
              ptr_S_2d_idx0 = var_S_2d_double_NestedVector.prepare(var_q_0d_int_Scalar);
              ptr_S_2d_idx0->set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("S", std::vector<int>({var_q_0d_int_Scalar, var_i_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("S", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_S);
              aux_last_type_read_for_S = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LTHR_read == true)) && ((var_LTHR_0d_int_Scalar)==(2)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 7 , 2 / SB , 0.0 , 0 , 0 , NR , NP / Tint / Wp ] TAB1";
          // read TAB1 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SB", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable SB
          var_SB_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SB", std::vector<int>({}), py::none()));
          aux_SB_read = true;
          validate_vartype_consistency("SB", SCALAR_DOUBLE, aux_last_type_read_for_SB);
          aux_last_type_read_for_SB = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
          cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none())), write_opts);
          cpp_np_val = py::len(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none()));
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none()));
          tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Wp", std::vector<int>({}), py::none()));
          tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Wp
            var_Wp_0d_floatvec_Scalar = tab_body.Y;
            aux_Wp_read = true;
            validate_vartype_consistency("Wp", SCALAR_FLOATVEC, aux_last_type_read_for_Wp);
            aux_last_type_read_for_Wp = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LTHR_read == true)) && ((var_LTHR_0d_int_Scalar)==(3)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 7 , 2 / T0 , 0.0 , LT , 0 , NR , NP / Eint / S ] TAB1 ( S_T0_table )";
          // read TAB1 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T0", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable T0
          var_T0_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T0", std::vector<int>({}), py::none()));
          aux_T0_read = true;
          validate_vartype_consistency("T0", SCALAR_DOUBLE, aux_last_type_read_for_T0);
          aux_last_type_read_for_T0 = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LT
          var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none()));
          aux_LT_read = true;
          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
          aux_last_type_read_for_LT = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.get_value("S_T0_table", std::vector<int>({}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
            cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
            cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
            cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
            cont << cpp_draft_line;
            tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
            tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("S", std::vector<int>({}), py::none()));
            tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
            tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
            write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
            // variable declarations
            std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
            bool aux_Eint_read = false;
            vartype aux_last_type_read_for_Eint = UNKNOWN;
            std::vector<EndfFloatCpp> var_S_0d_floatvec_Scalar;
            bool aux_S_read = false;
            vartype aux_last_type_read_for_S = UNKNOWN;
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab1Body tab_body = tab1_body;
              // assign expression to variable Eint
              var_Eint_0d_floatvec_Scalar = tab_body.X;
              aux_Eint_read = true;
              validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
              aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
              // assign expression to variable S
              var_S_0d_floatvec_Scalar = tab_body.Y;
              aux_S_read = true;
              validate_vartype_consistency("S", SCALAR_FLOATVEC, aux_last_type_read_for_S);
              aux_last_type_read_for_S = SCALAR_FLOATVEC;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            cont << cpp_draft_line;
            cpp_current_dict = cpp_parent_dict;
          }

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_LT_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 7 , 2 / T , 0.0 , LI , 0 , NP , 0 / \n { S } { q = 1 to NP } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
            // assign expression to variable T
            var_T_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
            validate_vartype_consistency("T", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_T);
            aux_last_type_read_for_T = NESTEDVECTOR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LI
            var_LI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none()));
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NP
            var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()));
            aux_NP_read = true;
            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
            aux_last_type_read_for_NP = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()));
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read LIST body

              for (int var_q_0d_int_Scalar = 1;
                 var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
                bool aux_q_read = true;
                // read LIST body
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("S", std::vector<int>({var_q_0d_int_Scalar, var_i_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable S
                ptr_S_2d_idx0 = var_S_2d_double_NestedVector.prepare(var_q_0d_int_Scalar);
                ptr_S_2d_idx0->set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("S", std::vector<int>({var_q_0d_int_Scalar, var_i_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("S", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_S);
                aux_last_type_read_for_S = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
          }
          cpp_template = "[ MAT , 7 , 2 / SB , 0.0 , 0 , 0 , NR , NP / Tint / Wp ] TAB1";
          // read TAB1 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SB", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable SB
          var_SB_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SB", std::vector<int>({}), py::none()));
          aux_SB_read = true;
          validate_vartype_consistency("SB", SCALAR_DOUBLE, aux_last_type_read_for_SB);
          aux_last_type_read_for_SB = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
          cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none())), write_opts);
          cpp_np_val = py::len(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none()));
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none()));
          tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Wp", std::vector<int>({}), py::none()));
          tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Wp
            var_Wp_0d_floatvec_Scalar = tab_body.Y;
            aux_Wp_read = true;
            validate_vartype_consistency("Wp", SCALAR_FLOATVEC, aux_last_type_read_for_Wp);
            aux_last_type_read_for_Wp = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: a3934a161c54e232c57d90823e77ee29
// MD5 hash of the following function definition: 3325486181697aad594af72530c9eeb4
void write_mf7mt4_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LAT_0d_int_Scalar;
  bool aux_LAT_read = false;
  vartype aux_last_type_read_for_LAT = UNKNOWN;
  int var_LASYM_0d_int_Scalar;
  bool aux_LASYM_read = false;
  vartype aux_last_type_read_for_LASYM = UNKNOWN;
  int var_LLN_0d_int_Scalar;
  bool aux_LLN_read = false;
  vartype aux_last_type_read_for_LLN = UNKNOWN;
  int var_NI_0d_int_Scalar;
  bool aux_NI_read = false;
  vartype aux_last_type_read_for_NI = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  NestedVector<EndfFloatCpp> var_B_1d_double_NestedVector;
  vartype aux_last_type_read_for_B = UNKNOWN;
  int var_NB_0d_int_Scalar;
  bool aux_NB_read = false;
  vartype aux_last_type_read_for_NB = UNKNOWN;
  EndfFloatCpp var_T0_0d_double_Scalar;
  bool aux_T0_read = false;
  vartype aux_last_type_read_for_T0 = UNKNOWN;
  NestedVector<EndfFloatCpp> var_beta_1d_double_NestedVector;
  vartype aux_last_type_read_for_beta = UNKNOWN;
  NestedVector<int> var_LT_1d_int_NestedVector;
  vartype aux_last_type_read_for_LT = UNKNOWN;
  NestedVector<EndfFloatCpp> var_T_1d_double_NestedVector;
  vartype aux_last_type_read_for_T = UNKNOWN;
  NestedVector<int> var_LI_1d_int_NestedVector;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_NP_0d_int_Scalar;
  bool aux_NP_read = false;
  vartype aux_last_type_read_for_NP = UNKNOWN;
  NestedVector<NestedVector<NestedVector<EndfFloatCpp>>> var_S_3d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_S_3d_idx1;
  NestedVector<NestedVector<EndfFloatCpp>>* ptr_S_3d_idx0;
  vartype aux_last_type_read_for_S = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 7;
  int mt = 4;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 7;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 4;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 7 , 4 / ZA , AWR , 0 , LAT , LASYM , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LAT", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LAT
  var_LAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LAT", std::vector<int>({}), py::none()));
  aux_LAT_read = true;
  validate_vartype_consistency("LAT", SCALAR_INT, aux_last_type_read_for_LAT);
  aux_last_type_read_for_LAT = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("LASYM", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LASYM
  var_LASYM_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LASYM", std::vector<int>({}), py::none()));
  aux_LASYM_read = true;
  validate_vartype_consistency("LASYM", SCALAR_INT, aux_last_type_read_for_LASYM);
  aux_last_type_read_for_LASYM = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , LLN , 0 , NI , NS / { B } { n = 1 to NI } ] LIST";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read LIST record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LLN", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LLN
  var_LLN_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LLN", std::vector<int>({}), py::none()));
  aux_LLN_read = true;
  validate_vartype_consistency("LLN", SCALAR_INT, aux_last_type_read_for_LLN);
  aux_last_type_read_for_LLN = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NI
  var_NI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none()));
  aux_NI_read = true;
  validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
  aux_last_type_read_for_NI = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NS", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NS", std::vector<int>({}), py::none()));
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none())), write_opts);
  cont << cpp_draft_line;
  {
    int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none()));
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
    // read LIST body

    for (int var_n_0d_int_Scalar = 1;
       var_n_0d_int_Scalar <= var_NI_0d_int_Scalar; var_n_0d_int_Scalar++) {
      bool aux_n_read = true;
      // read LIST body
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("B", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
      // assign expression to variable B
      var_B_1d_double_NestedVector.set(var_n_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("B", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("B", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_B);
      aux_last_type_read_for_B = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NB / beta_int ] TAB2 ( beta_interp )";
  // read TAB2 record
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NB", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NB
  var_NB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NB", std::vector<int>({}), py::none()));
  aux_NB_read = true;
  validate_vartype_consistency("NB", SCALAR_INT, aux_last_type_read_for_NB);
  aux_last_type_read_for_NB = SCALAR_INT;
  {
    py::dict cpp_parent_dict = cpp_current_dict;
    cpp_current_dict = cpp_index_shifter_store.get_value("beta_interp", std::vector<int>({}), py::dict());
    IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
    cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
    cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
    cont << cpp_draft_line;
    tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
    tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
    write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
    // variable declarations
    std::vector<int> var_INT_0d_intvec_Scalar;
    bool aux_INT_read = false;
    vartype aux_last_type_read_for_INT = UNKNOWN;
    std::vector<int> var_NBT_0d_intvec_Scalar;
    bool aux_NBT_read = false;
    vartype aux_last_type_read_for_NBT = UNKNOWN;
    {
      Tab2Body tab_body = tab2_body;
      // assign expression to variable INT
      var_INT_0d_intvec_Scalar = tab_body.INT;
      aux_INT_read = true;
      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
      aux_last_type_read_for_INT = SCALAR_INTVEC;
      // assign expression to variable NBT
      var_NBT_0d_intvec_Scalar = tab_body.NBT;
      aux_NBT_read = true;
      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
      aux_last_type_read_for_NBT = SCALAR_INTVEC;
    }
    cont << cpp_draft_line;
    cpp_current_dict = cpp_parent_dict;
  }

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NB_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 7 , 4 / T0 , beta , LT , 0 , NR , NP / alpha / S ] TAB1 ( S_table [ i ] )";
    // read TAB1 record
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T0", std::vector<int>({}), py::none())), write_opts);
    // assign expression to variable T0
    var_T0_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T0", std::vector<int>({}), py::none()));
    aux_T0_read = true;
    validate_vartype_consistency("T0", SCALAR_DOUBLE, aux_last_type_read_for_T0);
    aux_last_type_read_for_T0 = SCALAR_DOUBLE;
    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("beta", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
    // assign expression to variable beta
    var_beta_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("beta", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
    validate_vartype_consistency("beta", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_beta);
    aux_last_type_read_for_beta = NESTEDVECTOR_DOUBLE;
    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
    // assign expression to variable LT
    var_LT_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
    validate_vartype_consistency("LT", NESTEDVECTOR_INT, aux_last_type_read_for_LT);
    aux_last_type_read_for_LT = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.get_value("S_table", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
      cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
      cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("alpha", std::vector<int>({}), py::none())), write_opts);
      cpp_np_val = py::len(cpp_index_shifter_store.get_value("alpha", std::vector<int>({}), py::none()));
      cont << cpp_draft_line;
      tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("alpha", std::vector<int>({}), py::none()));
      tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("S", std::vector<int>({}), py::none()));
      tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
      tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
      write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
      // variable declarations
      std::vector<EndfFloatCpp> var_alpha_0d_floatvec_Scalar;
      bool aux_alpha_read = false;
      vartype aux_last_type_read_for_alpha = UNKNOWN;
      std::vector<EndfFloatCpp> var_S_0d_floatvec_Scalar;
      bool aux_S_read = false;
      vartype aux_last_type_read_for_S = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      {
        Tab1Body tab_body = tab1_body;
        // assign expression to variable alpha
        var_alpha_0d_floatvec_Scalar = tab_body.X;
        aux_alpha_read = true;
        validate_vartype_consistency("alpha", SCALAR_FLOATVEC, aux_last_type_read_for_alpha);
        aux_last_type_read_for_alpha = SCALAR_FLOATVEC;
        // assign expression to variable S
        var_S_0d_floatvec_Scalar = tab_body.Y;
        aux_S_read = true;
        validate_vartype_consistency("S", SCALAR_FLOATVEC, aux_last_type_read_for_S);
        aux_last_type_read_for_S = SCALAR_FLOATVEC;
        // assign expression to variable INT
        var_INT_0d_intvec_Scalar = tab_body.INT;
        aux_INT_read = true;
        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
        aux_last_type_read_for_INT = SCALAR_INTVEC;
        // assign expression to variable NBT
        var_NBT_0d_intvec_Scalar = tab_body.NBT;
        aux_NBT_read = true;
        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
        aux_last_type_read_for_NBT = SCALAR_INTVEC;
      }
      cont << cpp_draft_line;
      cpp_current_dict = cpp_parent_dict;
    }

    for (int var_j_0d_int_Scalar = 1;
       var_j_0d_int_Scalar <= var_LT_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
      bool aux_j_read = true;
      cpp_template = "[ MAT , 7 , 4 / T , beta , LI , 0 , NP , 0 / { S } { q = 1 to NP } ] LIST";
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      // read LIST record
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
      // assign expression to variable T
      var_T_1d_double_NestedVector.set(var_j_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("T", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("T", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_T);
      aux_last_type_read_for_T = NESTEDVECTOR_DOUBLE;
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("beta", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
      if ((! var_beta_1d_double_NestedVector.contains(var_i_0d_int_Scalar))) {
        // assign expression to variable beta
        var_beta_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("beta", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
        validate_vartype_consistency("beta", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_beta);
        aux_last_type_read_for_beta = NESTEDVECTOR_DOUBLE;
      } else {
      }
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({var_j_0d_int_Scalar}), py::none())), write_opts);
      // assign expression to variable LI
      var_LI_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({var_j_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("LI", NESTEDVECTOR_INT, aux_last_type_read_for_LI);
      aux_last_type_read_for_LI = NESTEDVECTOR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable NP
      var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()));
      aux_NP_read = true;
      validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
      aux_last_type_read_for_NP = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())), write_opts);
      cont << cpp_draft_line;
      {
        int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()));
        int cpp_i = 0;
        int cpp_j = 0;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        // read LIST body

        for (int var_q_0d_int_Scalar = 1;
           var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
          bool aux_q_read = true;
          // read LIST body
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("S", std::vector<int>({var_q_0d_int_Scalar, var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())), write_opts);
          // assign expression to variable S
          ptr_S_3d_idx0 = var_S_3d_double_NestedVector.prepare(var_q_0d_int_Scalar);
          ptr_S_3d_idx1 = ptr_S_3d_idx0->prepare(var_i_0d_int_Scalar);
          ptr_S_3d_idx1->set(var_j_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("S", std::vector<int>({var_q_0d_int_Scalar, var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())));
          validate_vartype_consistency("S", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_S);
          aux_last_type_read_for_S = NESTEDVECTOR_DOUBLE;
          cpp_i++;
          cpp_j++;
          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
            cont << cpp_draft_line;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            cpp_j = 0;
          }
        }
        if (cpp_i != cpp_npl) {
          throw std::runtime_error("not exactly NPL elements consumed");
        }
      }
      cont << cpp_draft_line;
    }
  }
  cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff0 ] TAB1 ( teff0_table )";
  // read TAB1 record
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  {
    py::dict cpp_parent_dict = cpp_current_dict;
    cpp_current_dict = cpp_index_shifter_store.get_value("teff0_table", std::vector<int>({}), py::dict());
    IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
    cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
    cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
    cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none())), write_opts);
    cpp_np_val = py::len(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none()));
    cont << cpp_draft_line;
    tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none()));
    tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Teff0", std::vector<int>({}), py::none()));
    tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
    tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
    write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
    // variable declarations
    std::vector<EndfFloatCpp> var_Tint_0d_floatvec_Scalar;
    bool aux_Tint_read = false;
    vartype aux_last_type_read_for_Tint = UNKNOWN;
    std::vector<EndfFloatCpp> var_Teff0_0d_floatvec_Scalar;
    bool aux_Teff0_read = false;
    vartype aux_last_type_read_for_Teff0 = UNKNOWN;
    std::vector<int> var_INT_0d_intvec_Scalar;
    bool aux_INT_read = false;
    vartype aux_last_type_read_for_INT = UNKNOWN;
    std::vector<int> var_NBT_0d_intvec_Scalar;
    bool aux_NBT_read = false;
    vartype aux_last_type_read_for_NBT = UNKNOWN;
    {
      Tab1Body tab_body = tab1_body;
      // assign expression to variable Tint
      var_Tint_0d_floatvec_Scalar = tab_body.X;
      aux_Tint_read = true;
      validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
      aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
      // assign expression to variable Teff0
      var_Teff0_0d_floatvec_Scalar = tab_body.Y;
      aux_Teff0_read = true;
      validate_vartype_consistency("Teff0", SCALAR_FLOATVEC, aux_last_type_read_for_Teff0);
      aux_last_type_read_for_Teff0 = SCALAR_FLOATVEC;
      // assign expression to variable INT
      var_INT_0d_intvec_Scalar = tab_body.INT;
      aux_INT_read = true;
      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
      aux_last_type_read_for_INT = SCALAR_INTVEC;
      // assign expression to variable NBT
      var_NBT_0d_intvec_Scalar = tab_body.NBT;
      aux_NBT_read = true;
      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
      aux_last_type_read_for_NBT = SCALAR_INTVEC;
    }
    cont << cpp_draft_line;
    cpp_current_dict = cpp_parent_dict;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_NI_read == true)) && ((var_NI_0d_int_Scalar)>=(7)))))&&(((var_B_1d_double_NestedVector.contains(7)) && ((var_B_1d_double_NestedVector[7])==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff1 ] TAB1 ( teff1_table )";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.get_value("teff1_table", std::vector<int>({}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
          cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none())), write_opts);
          cpp_np_val = py::len(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none()));
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none()));
          tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Teff1", std::vector<int>({}), py::none()));
          tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          // variable declarations
          std::vector<EndfFloatCpp> var_Tint_0d_floatvec_Scalar;
          bool aux_Tint_read = false;
          vartype aux_last_type_read_for_Tint = UNKNOWN;
          std::vector<EndfFloatCpp> var_Teff1_0d_floatvec_Scalar;
          bool aux_Teff1_read = false;
          vartype aux_last_type_read_for_Teff1 = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Teff1
            var_Teff1_0d_floatvec_Scalar = tab_body.Y;
            aux_Teff1_read = true;
            validate_vartype_consistency("Teff1", SCALAR_FLOATVEC, aux_last_type_read_for_Teff1);
            aux_last_type_read_for_Teff1 = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
          cpp_current_dict = cpp_parent_dict;
        }
      }
    }
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_NI_read == true)) && ((var_NI_0d_int_Scalar)>=(13)))))&&(((var_B_1d_double_NestedVector.contains(13)) && ((var_B_1d_double_NestedVector[13])==(0.0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff2 ] TAB1 ( teff2_table )";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.get_value("teff2_table", std::vector<int>({}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
          cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none())), write_opts);
          cpp_np_val = py::len(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none()));
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none()));
          tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Teff2", std::vector<int>({}), py::none()));
          tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          // variable declarations
          std::vector<EndfFloatCpp> var_Tint_0d_floatvec_Scalar;
          bool aux_Tint_read = false;
          vartype aux_last_type_read_for_Tint = UNKNOWN;
          std::vector<EndfFloatCpp> var_Teff2_0d_floatvec_Scalar;
          bool aux_Teff2_read = false;
          vartype aux_last_type_read_for_Teff2 = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Teff2
            var_Teff2_0d_floatvec_Scalar = tab_body.Y;
            aux_Teff2_read = true;
            validate_vartype_consistency("Teff2", SCALAR_FLOATVEC, aux_last_type_read_for_Teff2);
            aux_last_type_read_for_Teff2 = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
          cpp_current_dict = cpp_parent_dict;
        }
      }
    }
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_NI_read == true)) && ((var_NI_0d_int_Scalar)>=(19)))))&&(((var_B_1d_double_NestedVector.contains(19)) && ((var_B_1d_double_NestedVector[19])==(0.0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff3 ] TAB1 ( teff3_table )";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.get_value("teff3_table", std::vector<int>({}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
          cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none())), write_opts);
          cpp_np_val = py::len(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none()));
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Tint", std::vector<int>({}), py::none()));
          tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Teff3", std::vector<int>({}), py::none()));
          tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          // variable declarations
          std::vector<EndfFloatCpp> var_Tint_0d_floatvec_Scalar;
          bool aux_Tint_read = false;
          vartype aux_last_type_read_for_Tint = UNKNOWN;
          std::vector<EndfFloatCpp> var_Teff3_0d_floatvec_Scalar;
          bool aux_Teff3_read = false;
          vartype aux_last_type_read_for_Teff3 = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Teff3
            var_Teff3_0d_floatvec_Scalar = tab_body.Y;
            aux_Teff3_read = true;
            validate_vartype_consistency("Teff3", SCALAR_FLOATVEC, aux_last_type_read_for_Teff3);
            aux_last_type_read_for_Teff3 = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
          cpp_current_dict = cpp_parent_dict;
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 0468c7052e96f983d6f680ae2b54c677
// MD5 hash of the following function definition: 2fe8c0e05c12c848fb2d4a4c01475db5
void write_mf7mt451_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NA_0d_int_Scalar;
  bool aux_NA_read = false;
  vartype aux_last_type_read_for_NA = UNKNOWN;
  int var_NAS_0d_int_Scalar;
  bool aux_NAS_read = false;
  vartype aux_last_type_read_for_NAS = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<int> var_NI_1d_int_NestedVector;
  vartype aux_last_type_read_for_NI = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_ZAI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_ZAI_2d_idx0;
  vartype aux_last_type_read_for_ZAI = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_LISI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_LISI_2d_idx0;
  vartype aux_last_type_read_for_LISI = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_AFI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_AFI_2d_idx0;
  vartype aux_last_type_read_for_AFI = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_AWRI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_AWRI_2d_idx0;
  vartype aux_last_type_read_for_AWRI = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_SFI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_SFI_2d_idx0;
  vartype aux_last_type_read_for_SFI = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 7;
  int mt = 451;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 7;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 451;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 7 , 451 / ZA , AWR , NA , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("NA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NA
  var_NA_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NA", std::vector<int>({}), py::none()));
  aux_NA_read = true;
  validate_vartype_consistency("NA", SCALAR_INT, aux_last_type_read_for_NA);
  aux_last_type_read_for_NA = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NA_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 7 , 451 / 0 , 0 , NAS , 0 , (6*NI) , NI / \n { ZAI , LISI , AFI , AWRI , SFI , 0 } { j = 1 to NI } ] LIST";
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
    // read LIST record
    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0, write_opts);
    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0, write_opts);
    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("NAS", std::vector<int>({}), py::none())), write_opts);
    // assign expression to variable NAS
    var_NAS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NAS", std::vector<int>({}), py::none()));
    aux_NAS_read = true;
    validate_vartype_consistency("NAS", SCALAR_INT, aux_last_type_read_for_NAS);
    aux_last_type_read_for_NAS = SCALAR_INT;
    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
    cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_i_0d_int_Scalar}), py::none()))), write_opts);
    // assign expression to variable cpp_int_val
    cpp_int_val = (6*py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
    aux_cpp_int_val_read = true;
    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
    // assign expression to variable NI
    var_NI_1d_int_NestedVector.set(var_i_0d_int_Scalar, (cpp_int_val/6));
    validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
    aux_last_type_read_for_NI = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
    if ((! var_NI_1d_int_NestedVector.contains(var_i_0d_int_Scalar))) {
      // assign expression to variable NI
      var_NI_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
      aux_last_type_read_for_NI = NESTEDVECTOR_INT;
    } else {
    }
    cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_i_0d_int_Scalar}), py::none()))), write_opts);
    cont << cpp_draft_line;
    {
      int cpp_npl = (6*py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
      int cpp_i = 0;
      int cpp_j = 0;
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      // read LIST body
      ptr_ZAI_2d_idx0 = var_ZAI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_LISI_2d_idx0 = var_LISI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_AFI_2d_idx0 = var_AFI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_AWRI_2d_idx0 = var_AWRI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_SFI_2d_idx0 = var_SFI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

      for (int var_j_0d_int_Scalar = 1;
         var_j_0d_int_Scalar <= var_NI_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
        bool aux_j_read = true;
        // read LIST body
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAI", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())), write_opts);
        // assign expression to variable ZAI
        ptr_ZAI_2d_idx0->set(var_j_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAI", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())));
        validate_vartype_consistency("ZAI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAI);
        aux_last_type_read_for_ZAI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("LISI", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())), write_opts);
        // assign expression to variable LISI
        ptr_LISI_2d_idx0->set(var_j_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("LISI", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())));
        validate_vartype_consistency("LISI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_LISI);
        aux_last_type_read_for_LISI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AFI", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())), write_opts);
        // assign expression to variable AFI
        ptr_AFI_2d_idx0->set(var_j_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AFI", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())));
        validate_vartype_consistency("AFI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AFI);
        aux_last_type_read_for_AFI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())), write_opts);
        // assign expression to variable AWRI
        ptr_AWRI_2d_idx0->set(var_j_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())));
        validate_vartype_consistency("AWRI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AWRI);
        aux_last_type_read_for_AWRI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SFI", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())), write_opts);
        // assign expression to variable SFI
        ptr_SFI_2d_idx0->set(var_j_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SFI", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())));
        validate_vartype_consistency("SFI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SFI);
        aux_last_type_read_for_SFI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0, write_opts);
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
      }
      if (cpp_i != cpp_npl) {
        throw std::runtime_error("not exactly NPL elements consumed");
      }
    }
    cont << cpp_draft_line;
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: e0fff507053b212e2ece7181a9f7fb15
// MD5 hash of the following function definition: a066a5c1623f66579b30159786deed9b
void write_mf8_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_LISO_0d_int_Scalar;
  bool aux_LISO_read = false;
  vartype aux_last_type_read_for_LISO = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  int var_NO_0d_int_Scalar;
  bool aux_NO_read = false;
  vartype aux_last_type_read_for_NO = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 8;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 8 , MT / ZA , AWR , LIS , LISO , NS , NO ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none()));
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LISO", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LISO
  var_LISO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LISO", std::vector<int>({}), py::none()));
  aux_LISO_read = true;
  validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
  aux_last_type_read_for_LISO = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NS", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NS", std::vector<int>({}), py::none()));
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NO", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NO
  var_NO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NO", std::vector<int>({}), py::none()));
  aux_NO_read = true;
  validate_vartype_consistency("NO", SCALAR_INT, aux_last_type_read_for_NO);
  aux_last_type_read_for_NO = SCALAR_INT;
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_NO_read == true)) && ((var_NO_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;

        for (int var_k_0d_int_Scalar = 1;
           var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
          bool aux_k_read = true;
          // open section subsection
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.get_value("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            // variable declarations
            EndfFloatCpp var_ZAP_0d_double_Scalar;
            bool aux_ZAP_read = false;
            vartype aux_last_type_read_for_ZAP = UNKNOWN;
            EndfFloatCpp var_ELFS_0d_double_Scalar;
            bool aux_ELFS_read = false;
            vartype aux_last_type_read_for_ELFS = UNKNOWN;
            int var_LMF_0d_int_Scalar;
            bool aux_LMF_read = false;
            vartype aux_last_type_read_for_LMF = UNKNOWN;
            int var_LFS_0d_int_Scalar;
            bool aux_LFS_read = false;
            vartype aux_last_type_read_for_LFS = UNKNOWN;
            int cpp_int_val;
            bool aux_cpp_int_val_read = false;
            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
            int var_ND_0d_int_Scalar;
            bool aux_ND_read = false;
            vartype aux_last_type_read_for_ND = UNKNOWN;
            NestedVector<EndfFloatCpp> var_HL_1d_double_NestedVector;
            vartype aux_last_type_read_for_HL = UNKNOWN;
            NestedVector<EndfFloatCpp> var_RTYP_1d_double_NestedVector;
            vartype aux_last_type_read_for_RTYP = UNKNOWN;
            NestedVector<EndfFloatCpp> var_ZAN_1d_double_NestedVector;
            vartype aux_last_type_read_for_ZAN = UNKNOWN;
            NestedVector<EndfFloatCpp> var_BR_1d_double_NestedVector;
            vartype aux_last_type_read_for_BR = UNKNOWN;
            NestedVector<EndfFloatCpp> var_END_1d_double_NestedVector;
            vartype aux_last_type_read_for_END = UNKNOWN;
            NestedVector<EndfFloatCpp> var_CT_1d_double_NestedVector;
            vartype aux_last_type_read_for_CT = UNKNOWN;
            cpp_template = "[ MAT , 8 , MT / ZAP , ELFS , LMF , LFS , (6*ND) , 0 / \n { HL , RTYP , ZAN , BR , END , CT } { l = 1 to ND } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAP", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable ZAP
            var_ZAP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAP", std::vector<int>({}), py::none()));
            aux_ZAP_read = true;
            validate_vartype_consistency("ZAP", SCALAR_DOUBLE, aux_last_type_read_for_ZAP);
            aux_last_type_read_for_ZAP = SCALAR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ELFS", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable ELFS
            var_ELFS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ELFS", std::vector<int>({}), py::none()));
            aux_ELFS_read = true;
            validate_vartype_consistency("ELFS", SCALAR_DOUBLE, aux_last_type_read_for_ELFS);
            aux_last_type_read_for_ELFS = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LMF", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LMF
            var_LMF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LMF", std::vector<int>({}), py::none()));
            aux_LMF_read = true;
            validate_vartype_consistency("LMF", SCALAR_INT, aux_last_type_read_for_LMF);
            aux_last_type_read_for_LMF = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LFS", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LFS
            var_LFS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFS", std::vector<int>({}), py::none()));
            aux_LFS_read = true;
            validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
            aux_last_type_read_for_LFS = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("ND", std::vector<int>({}), py::none()))), write_opts);
            // assign expression to variable cpp_int_val
            cpp_int_val = (6*py::cast<int>(cpp_index_shifter_store.get_value("ND", std::vector<int>({}), py::none())));
            aux_cpp_int_val_read = true;
            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
            // assign expression to variable ND
            var_ND_0d_int_Scalar = (cpp_int_val/6);
            aux_ND_read = true;
            validate_vartype_consistency("ND", SCALAR_INT, aux_last_type_read_for_ND);
            aux_last_type_read_for_ND = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("ND", std::vector<int>({}), py::none()))), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = (6*py::cast<int>(cpp_index_shifter_store.get_value("ND", std::vector<int>({}), py::none())));
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read LIST body

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_ND_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                // read LIST body
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("HL", std::vector<int>({var_l_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable HL
                var_HL_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("HL", std::vector<int>({var_l_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("HL", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_HL);
                aux_last_type_read_for_HL = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({var_l_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable RTYP
                var_RTYP_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({var_l_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("RTYP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_RTYP);
                aux_last_type_read_for_RTYP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAN", std::vector<int>({var_l_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable ZAN
                var_ZAN_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAN", std::vector<int>({var_l_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("ZAN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAN);
                aux_last_type_read_for_ZAN = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("BR", std::vector<int>({var_l_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable BR
                var_BR_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("BR", std::vector<int>({var_l_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("BR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BR);
                aux_last_type_read_for_BR = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("END", std::vector<int>({var_l_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable END
                var_END_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("END", std::vector<int>({var_l_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("END", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_END);
                aux_last_type_read_for_END = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("CT", std::vector<int>({var_l_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable CT
                var_CT_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("CT", std::vector<int>({var_l_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("CT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_CT);
                aux_last_type_read_for_CT = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
            cpp_current_dict = cpp_parent_dict;
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_NO_read == true)) && ((var_NO_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // open section subsection
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.get_value("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              // variable declarations
              EndfFloatCpp var_ZAP_0d_double_Scalar;
              bool aux_ZAP_read = false;
              vartype aux_last_type_read_for_ZAP = UNKNOWN;
              EndfFloatCpp var_ELFS_0d_double_Scalar;
              bool aux_ELFS_read = false;
              vartype aux_last_type_read_for_ELFS = UNKNOWN;
              int var_LMF_0d_int_Scalar;
              bool aux_LMF_read = false;
              vartype aux_last_type_read_for_LMF = UNKNOWN;
              int var_LFS_0d_int_Scalar;
              bool aux_LFS_read = false;
              vartype aux_last_type_read_for_LFS = UNKNOWN;
              cpp_template = "[ MAT , 8 , MT / ZAP , ELFS , LMF , LFS , 0 , 0 ] CONT";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read CONT record
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAP", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable ZAP
              var_ZAP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAP", std::vector<int>({}), py::none()));
              aux_ZAP_read = true;
              validate_vartype_consistency("ZAP", SCALAR_DOUBLE, aux_last_type_read_for_ZAP);
              aux_last_type_read_for_ZAP = SCALAR_DOUBLE;
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ELFS", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable ELFS
              var_ELFS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ELFS", std::vector<int>({}), py::none()));
              aux_ELFS_read = true;
              validate_vartype_consistency("ELFS", SCALAR_DOUBLE, aux_last_type_read_for_ELFS);
              aux_last_type_read_for_ELFS = SCALAR_DOUBLE;
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LMF", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable LMF
              var_LMF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LMF", std::vector<int>({}), py::none()));
              aux_LMF_read = true;
              validate_vartype_consistency("LMF", SCALAR_INT, aux_last_type_read_for_LMF);
              aux_last_type_read_for_LMF = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LFS", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable LFS
              var_LFS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFS", std::vector<int>({}), py::none()));
              aux_LFS_read = true;
              validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
              aux_last_type_read_for_LFS = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
              cont << cpp_draft_line;
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 2c946085e67d919e399440582cef277e
// MD5 hash of the following function definition: 95a1366bd5c595eb70353afbccf51693
void write_mf8mt454_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_LE_0d_int_Scalar;
  bool aux_LE_read = false;
  vartype aux_last_type_read_for_LE = UNKNOWN;
  NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<int> var_NN_1d_int_NestedVector;
  vartype aux_last_type_read_for_NN = UNKNOWN;
  NestedVector<int> var_NFP_1d_int_NestedVector;
  vartype aux_last_type_read_for_NFP = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_ZAFP_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_ZAFP_2d_idx0;
  vartype aux_last_type_read_for_ZAFP = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_FPS_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_FPS_2d_idx0;
  vartype aux_last_type_read_for_FPS = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_YI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_YI_2d_idx0;
  vartype aux_last_type_read_for_YI = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_DYI_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_DYI_2d_idx0;
  vartype aux_last_type_read_for_DYI = UNKNOWN;
  NestedVector<int> var_I_1d_int_NestedVector;
  vartype aux_last_type_read_for_I = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 8;
  int mt = 454;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 454;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 8 , MT / ZA , AWR , (LE+1) , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, (py::cast<int>(cpp_index_shifter_store.get_value("LE", std::vector<int>({}), py::none()))+1), write_opts);
  // assign expression to variable cpp_int_val
  cpp_int_val = (py::cast<int>(cpp_index_shifter_store.get_value("LE", std::vector<int>({}), py::none()))+1);
  aux_cpp_int_val_read = true;
  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
  // assign expression to variable LE
  var_LE_0d_int_Scalar = (cpp_int_val+(-1));
  aux_LE_read = true;
  validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
  aux_last_type_read_for_LE = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 8 , MT / E , 0.0 , LE , 0 , NN , NFP / \n { ZAFP , FPS , YI , DYI } { m = 1 to NFP } ] LIST";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read LIST record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({0}), py::none())), write_opts);
  // assign expression to variable E
  var_E_1d_double_NestedVector.set(0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({0}), py::none())));
  validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
  aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LE", std::vector<int>({}), py::none())), write_opts);
  if ((! (aux_LE_read == true))) {
    // assign expression to variable LE
    var_LE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LE", std::vector<int>({}), py::none()));
    aux_LE_read = true;
    validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
    aux_last_type_read_for_LE = SCALAR_INT;
  } else {
  }
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({0}), py::none())), write_opts);
  // assign expression to variable NN
  var_NN_1d_int_NestedVector.set(0, py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({0}), py::none())));
  validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
  aux_last_type_read_for_NN = NESTEDVECTOR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NFP", std::vector<int>({0}), py::none())), write_opts);
  // assign expression to variable NFP
  var_NFP_1d_int_NestedVector.set(0, py::cast<int>(cpp_index_shifter_store.get_value("NFP", std::vector<int>({0}), py::none())));
  validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
  aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({0}), py::none())), write_opts);
  cont << cpp_draft_line;
  {
    int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({0}), py::none()));
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
    // read LIST body
    ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(0);
    ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(0);
    ptr_YI_2d_idx0 = var_YI_2d_double_NestedVector.prepare(0);
    ptr_DYI_2d_idx0 = var_DYI_2d_double_NestedVector.prepare(0);

    for (int var_m_0d_int_Scalar = 1;
       var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[0]; var_m_0d_int_Scalar++) {
      bool aux_m_read = true;
      // read LIST body
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAFP", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())), write_opts);
      // assign expression to variable ZAFP
      ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAFP", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
      aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_j = 0;
      }
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("FPS", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())), write_opts);
      // assign expression to variable FPS
      ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("FPS", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
      aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_j = 0;
      }
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("YI", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())), write_opts);
      // assign expression to variable YI
      ptr_YI_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("YI", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("YI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YI);
      aux_last_type_read_for_YI = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_j = 0;
      }
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DYI", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())), write_opts);
      // assign expression to variable DYI
      ptr_DYI_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DYI", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("DYI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYI);
      aux_last_type_read_for_DYI = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_LE_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    cpp_template = "[ MAT , 8 , MT / E , 0.0 , I , 0 , NN , NFP / \n { ZAFP , FPS , YI , DYI } { m = 1 to NFP } ] LIST";
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
    // read LIST record
    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
    if ((! var_E_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable E
      var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
      aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
    } else {
    }
    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("I", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
    // assign expression to variable I
    var_I_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("I", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
    validate_vartype_consistency("I", NESTEDVECTOR_INT, aux_last_type_read_for_I);
    aux_last_type_read_for_I = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
    if ((! var_NN_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NN
      var_NN_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
      aux_last_type_read_for_NN = NESTEDVECTOR_INT;
    } else {
    }
    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NFP", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
    if ((! var_NFP_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NFP
      var_NFP_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NFP", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
      aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
    } else {
    }
    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
    cont << cpp_draft_line;
    {
      int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({var_k_0d_int_Scalar}), py::none()));
      int cpp_i = 0;
      int cpp_j = 0;
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      // read LIST body
      ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_YI_2d_idx0 = var_YI_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_DYI_2d_idx0 = var_DYI_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

      for (int var_m_0d_int_Scalar = 1;
         var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[var_k_0d_int_Scalar]; var_m_0d_int_Scalar++) {
        bool aux_m_read = true;
        // read LIST body
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAFP", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
        if ((! (var_ZAFP_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_ZAFP_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable ZAFP
          ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAFP", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
          validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
          aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("FPS", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
        if ((! (var_FPS_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_FPS_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable FPS
          ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("FPS", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
          validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
          aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("YI", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
        if ((! (var_YI_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_YI_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable YI
          ptr_YI_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("YI", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
          validate_vartype_consistency("YI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YI);
          aux_last_type_read_for_YI = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DYI", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
        if ((! (var_DYI_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_DYI_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable DYI
          ptr_DYI_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DYI", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
          validate_vartype_consistency("DYI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYI);
          aux_last_type_read_for_DYI = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
      }
      if (cpp_i != cpp_npl) {
        throw std::runtime_error("not exactly NPL elements consumed");
      }
    }
    cont << cpp_draft_line;
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 938fd3d870f297fe0f3b2ca86b863542
// MD5 hash of the following function definition: ddba5776d6c613e74dd459272d63bbbe
void write_mf8mt457_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_LISO_0d_int_Scalar;
  bool aux_LISO_read = false;
  vartype aux_last_type_read_for_LISO = UNKNOWN;
  int var_NST_0d_int_Scalar;
  bool aux_NST_read = false;
  vartype aux_last_type_read_for_NST = UNKNOWN;
  int var_NSP_0d_int_Scalar;
  bool aux_NSP_read = false;
  vartype aux_last_type_read_for_NSP = UNKNOWN;
  EndfFloatCpp var_Thalf_0d_double_Scalar;
  bool aux_Thalf_read = false;
  vartype aux_last_type_read_for_Thalf = UNKNOWN;
  EndfFloatCpp var_dThalf_0d_double_Scalar;
  bool aux_dThalf_read = false;
  vartype aux_last_type_read_for_dThalf = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  NestedVector<EndfFloatCpp> var_Ebar_x_1d_double_NestedVector;
  vartype aux_last_type_read_for_Ebar_x = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dEbar_x_1d_double_NestedVector;
  vartype aux_last_type_read_for_dEbar_x = UNKNOWN;
  EndfFloatCpp var_SPI_0d_double_Scalar;
  bool aux_SPI_read = false;
  vartype aux_last_type_read_for_SPI = UNKNOWN;
  EndfFloatCpp var_PAR_0d_double_Scalar;
  bool aux_PAR_read = false;
  vartype aux_last_type_read_for_PAR = UNKNOWN;
  int var_NDK_0d_int_Scalar;
  bool aux_NDK_read = false;
  vartype aux_last_type_read_for_NDK = UNKNOWN;
  NestedVector<EndfFloatCpp> var_RTYP_1d_double_NestedVector;
  vartype aux_last_type_read_for_RTYP = UNKNOWN;
  NestedVector<EndfFloatCpp> var_RFS_1d_double_NestedVector;
  vartype aux_last_type_read_for_RFS = UNKNOWN;
  NestedVector<EndfFloatCpp> var_Q_1d_double_NestedVector;
  vartype aux_last_type_read_for_Q = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dQ_1d_double_NestedVector;
  vartype aux_last_type_read_for_dQ = UNKNOWN;
  NestedVector<EndfFloatCpp> var_BR_1d_double_NestedVector;
  vartype aux_last_type_read_for_BR = UNKNOWN;
  NestedVector<EndfFloatCpp> var_dBR_1d_double_NestedVector;
  vartype aux_last_type_read_for_dBR = UNKNOWN;
  int var_JENDL_LIST_NPL_0d_int_Scalar;
  bool aux_JENDL_LIST_NPL_read = false;
  vartype aux_last_type_read_for_JENDL_LIST_NPL = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 8;
  int mt = 457;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 457;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LIS_0d_int_Scalar = var_LIS_0d_int_Scalar;
          int var_LIS_0d_int_Scalar = glob_var_LIS_0d_int_Scalar;
          bool& glob_aux_LIS_read = aux_LIS_read;
          bool aux_LIS_read = glob_aux_LIS_read;
          vartype aux_last_type_read_for_LIS = UNKNOWN;
          int& glob_var_LISO_0d_int_Scalar = var_LISO_0d_int_Scalar;
          int var_LISO_0d_int_Scalar = glob_var_LISO_0d_int_Scalar;
          bool& glob_aux_LISO_read = aux_LISO_read;
          bool aux_LISO_read = glob_aux_LISO_read;
          vartype aux_last_type_read_for_LISO = UNKNOWN;
          int& glob_var_NST_0d_int_Scalar = var_NST_0d_int_Scalar;
          int var_NST_0d_int_Scalar = glob_var_NST_0d_int_Scalar;
          bool& glob_aux_NST_read = aux_NST_read;
          bool aux_NST_read = glob_aux_NST_read;
          vartype aux_last_type_read_for_NST = UNKNOWN;
          int& glob_var_NSP_0d_int_Scalar = var_NSP_0d_int_Scalar;
          int var_NSP_0d_int_Scalar = glob_var_NSP_0d_int_Scalar;
          bool& glob_aux_NSP_read = aux_NSP_read;
          bool aux_NSP_read = glob_aux_NSP_read;
          vartype aux_last_type_read_for_NSP = UNKNOWN;
          try {
            cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , NSP ] HEAD";
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::cast(-99999.9)));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::cast(-99999.9)));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LIS
            var_LIS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::cast(-99999)));
            aux_LIS_read = true;
            validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
            aux_last_type_read_for_LIS = SCALAR_INT;
            // assign expression to variable LISO
            var_LISO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LISO", std::vector<int>({}), py::cast(-99999)));
            aux_LISO_read = true;
            validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
            aux_last_type_read_for_LISO = SCALAR_INT;
            // assign expression to variable NST
            var_NST_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NST", std::vector<int>({}), py::cast(-99999)));
            aux_NST_read = true;
            validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
            aux_last_type_read_for_NST = SCALAR_INT;
            // assign expression to variable NSP
            var_NSP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NSP", std::vector<int>({}), py::cast(-99999)));
            aux_NSP_read = true;
            validate_vartype_consistency("NSP", SCALAR_INT, aux_last_type_read_for_NSP);
            aux_last_type_read_for_NSP = SCALAR_INT;
          } catch (const std::out_of_range& e) {
            // // accept failure in lookahead
          }
          if ((((((((aux_NST_read == true)) && ((var_NST_0d_int_Scalar)==(0)))))))) {
            cpp_found_match = true;
          }
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , NSP ] HEAD";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read CONT record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LIS
          var_LIS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none()));
          aux_LIS_read = true;
          validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
          aux_last_type_read_for_LIS = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LISO", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LISO
          var_LISO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LISO", std::vector<int>({}), py::none()));
          aux_LISO_read = true;
          validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
          aux_last_type_read_for_LISO = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NST", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NST
          var_NST_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NST", std::vector<int>({}), py::none()));
          aux_NST_read = true;
          validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
          aux_last_type_read_for_NST = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NSP", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NSP
          var_NSP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NSP", std::vector<int>({}), py::none()));
          aux_NSP_read = true;
          validate_vartype_consistency("NSP", SCALAR_INT, aux_last_type_read_for_NSP);
          aux_last_type_read_for_NSP = SCALAR_INT;
          cont << cpp_draft_line;
          cpp_template = "[ MAT , 8 , 457 / Thalf , dThalf , 0 , 0 , (2*NC) , 0 / \n { Ebar_x , dEbar_x } { k = 1 to NC } ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read LIST record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Thalf", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable Thalf
          var_Thalf_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Thalf", std::vector<int>({}), py::none()));
          aux_Thalf_read = true;
          validate_vartype_consistency("Thalf", SCALAR_DOUBLE, aux_last_type_read_for_Thalf);
          aux_last_type_read_for_Thalf = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dThalf", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable dThalf
          var_dThalf_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dThalf", std::vector<int>({}), py::none()));
          aux_dThalf_read = true;
          validate_vartype_consistency("dThalf", SCALAR_DOUBLE, aux_last_type_read_for_dThalf);
          aux_last_type_read_for_dThalf = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none()))), write_opts);
          // assign expression to variable cpp_int_val
          cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none())));
          aux_cpp_int_val_read = true;
          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
          // assign expression to variable NC
          var_NC_0d_int_Scalar = (cpp_int_val/2);
          aux_NC_read = true;
          validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
          aux_last_type_read_for_NC = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none()))), write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = (2*py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none())));
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NC_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Ebar_x", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable Ebar_x
              var_Ebar_x_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Ebar_x", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("Ebar_x", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ebar_x);
              aux_last_type_read_for_Ebar_x = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEbar_x", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable dEbar_x
              var_dEbar_x_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dEbar_x", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("dEbar_x", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dEbar_x);
              aux_last_type_read_for_dEbar_x = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
          cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , (6*NDK) , NDK / \n { RTYP , RFS , Q , dQ , BR , dBR } { k = 1 to NDK } ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read LIST record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable SPI
          var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
          aux_SPI_read = true;
          validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
          aux_last_type_read_for_SPI = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PAR", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable PAR
          var_PAR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PAR", std::vector<int>({}), py::none()));
          aux_PAR_read = true;
          validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
          aux_last_type_read_for_PAR = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NDK", std::vector<int>({}), py::none()))), write_opts);
          // assign expression to variable cpp_int_val
          cpp_int_val = (6*py::cast<int>(cpp_index_shifter_store.get_value("NDK", std::vector<int>({}), py::none())));
          aux_cpp_int_val_read = true;
          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
          // assign expression to variable NDK
          var_NDK_0d_int_Scalar = (cpp_int_val/6);
          aux_NDK_read = true;
          validate_vartype_consistency("NDK", SCALAR_INT, aux_last_type_read_for_NDK);
          aux_last_type_read_for_NDK = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NDK", std::vector<int>({}), py::none())), write_opts);
          if ((! (aux_NDK_read == true))) {
            // assign expression to variable NDK
            var_NDK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NDK", std::vector<int>({}), py::none()));
            aux_NDK_read = true;
            validate_vartype_consistency("NDK", SCALAR_INT, aux_last_type_read_for_NDK);
            aux_last_type_read_for_NDK = SCALAR_INT;
          } else {
          }
          cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NDK", std::vector<int>({}), py::none()))), write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = (6*py::cast<int>(cpp_index_shifter_store.get_value("NDK", std::vector<int>({}), py::none())));
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NDK_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable RTYP
              var_RTYP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("RTYP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_RTYP);
              aux_last_type_read_for_RTYP = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RFS", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable RFS
              var_RFS_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RFS", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("RFS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_RFS);
              aux_last_type_read_for_RFS = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Q", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable Q
              var_Q_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Q", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("Q", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Q);
              aux_last_type_read_for_Q = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dQ", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable dQ
              var_dQ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dQ", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("dQ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dQ);
              aux_last_type_read_for_dQ = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("BR", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable BR
              var_BR_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("BR", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("BR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BR);
              aux_last_type_read_for_BR = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dBR", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable dBR
              var_dBR_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dBR", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("dBR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dBR);
              aux_last_type_read_for_dBR = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NSP_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // open section spectrum
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.get_value("spectrum", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              // variable declarations
              EndfFloatCpp var_STYP_0d_double_Scalar;
              bool aux_STYP_read = false;
              vartype aux_last_type_read_for_STYP = UNKNOWN;
              int var_LCON_0d_int_Scalar;
              bool aux_LCON_read = false;
              vartype aux_last_type_read_for_LCON = UNKNOWN;
              int var_LCOV_0d_int_Scalar;
              bool aux_LCOV_read = false;
              vartype aux_last_type_read_for_LCOV = UNKNOWN;
              int var_NER_0d_int_Scalar;
              bool aux_NER_read = false;
              vartype aux_last_type_read_for_NER = UNKNOWN;
              EndfFloatCpp var_FD_0d_double_Scalar;
              bool aux_FD_read = false;
              vartype aux_last_type_read_for_FD = UNKNOWN;
              EndfFloatCpp var_dFD_0d_double_Scalar;
              bool aux_dFD_read = false;
              vartype aux_last_type_read_for_dFD = UNKNOWN;
              EndfFloatCpp var_ERAV_0d_double_Scalar;
              bool aux_ERAV_read = false;
              vartype aux_last_type_read_for_ERAV = UNKNOWN;
              EndfFloatCpp var_dERAV_0d_double_Scalar;
              bool aux_dERAV_read = false;
              vartype aux_last_type_read_for_dERAV = UNKNOWN;
              EndfFloatCpp var_FC_0d_double_Scalar;
              bool aux_FC_read = false;
              vartype aux_last_type_read_for_FC = UNKNOWN;
              EndfFloatCpp var_dFC_0d_double_Scalar;
              bool aux_dFC_read = false;
              vartype aux_last_type_read_for_dFC = UNKNOWN;
              cpp_template = "[ MAT , 8 , 457 / 0.0 , STYP , LCON , LCOV , 6 , NER / \n FD , dFD , ERAV , dERAV , FC , dFC ] LIST";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read LIST record
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("STYP", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable STYP
              var_STYP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("STYP", std::vector<int>({}), py::none()));
              aux_STYP_read = true;
              validate_vartype_consistency("STYP", SCALAR_DOUBLE, aux_last_type_read_for_STYP);
              aux_last_type_read_for_STYP = SCALAR_DOUBLE;
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LCON", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable LCON
              var_LCON_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCON", std::vector<int>({}), py::none()));
              aux_LCON_read = true;
              validate_vartype_consistency("LCON", SCALAR_INT, aux_last_type_read_for_LCON);
              aux_last_type_read_for_LCON = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LCOV", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable LCOV
              var_LCOV_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOV", std::vector<int>({}), py::none()));
              aux_LCOV_read = true;
              validate_vartype_consistency("LCOV", SCALAR_INT, aux_last_type_read_for_LCOV);
              aux_last_type_read_for_LCOV = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, 6, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable NER
              var_NER_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()));
              aux_NER_read = true;
              validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
              aux_last_type_read_for_NER = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, 6, write_opts);
              cont << cpp_draft_line;
              {
                int cpp_npl = 6;
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                // read LIST body
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("FD", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable FD
                var_FD_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("FD", std::vector<int>({}), py::none()));
                aux_FD_read = true;
                validate_vartype_consistency("FD", SCALAR_DOUBLE, aux_last_type_read_for_FD);
                aux_last_type_read_for_FD = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dFD", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable dFD
                var_dFD_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dFD", std::vector<int>({}), py::none()));
                aux_dFD_read = true;
                validate_vartype_consistency("dFD", SCALAR_DOUBLE, aux_last_type_read_for_dFD);
                aux_last_type_read_for_dFD = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ERAV", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable ERAV
                var_ERAV_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ERAV", std::vector<int>({}), py::none()));
                aux_ERAV_read = true;
                validate_vartype_consistency("ERAV", SCALAR_DOUBLE, aux_last_type_read_for_ERAV);
                aux_last_type_read_for_ERAV = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dERAV", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable dERAV
                var_dERAV_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dERAV", std::vector<int>({}), py::none()));
                aux_dERAV_read = true;
                validate_vartype_consistency("dERAV", SCALAR_DOUBLE, aux_last_type_read_for_dERAV);
                aux_last_type_read_for_dERAV = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("FC", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable FC
                var_FC_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("FC", std::vector<int>({}), py::none()));
                aux_FC_read = true;
                validate_vartype_consistency("FC", SCALAR_DOUBLE, aux_last_type_read_for_FC);
                aux_last_type_read_for_FC = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dFC", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable dFC
                var_dFC_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dFC", std::vector<int>({}), py::none()));
                aux_dFC_read = true;
                validate_vartype_consistency("dFC", SCALAR_DOUBLE, aux_last_type_read_for_dFC);
                aux_last_type_read_for_dFC = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  cpp_j = 0;
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
              cont << cpp_draft_line;
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if ((((((((aux_LCON_read == true)) && ((var_LCON_0d_int_Scalar)!=(1)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section discrete
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      cpp_current_dict = cpp_index_shifter_store.get_value("discrete", std::vector<int>({}), py::dict());
                      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                      // variable declarations

                      for (int var_i_0d_int_Scalar = 1;
                         var_i_0d_int_Scalar <= var_NER_0d_int_Scalar; var_i_0d_int_Scalar++) {
                        bool aux_i_read = true;
                        // open section energysec
                        {
                          py::dict cpp_parent_dict = cpp_current_dict;
                          cpp_current_dict = cpp_index_shifter_store.get_value("energysec", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
                          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                          // variable declarations
                          EndfFloatCpp var_ER_0d_double_Scalar;
                          bool aux_ER_read = false;
                          vartype aux_last_type_read_for_ER = UNKNOWN;
                          EndfFloatCpp var_dER_0d_double_Scalar;
                          bool aux_dER_read = false;
                          vartype aux_last_type_read_for_dER = UNKNOWN;
                          int var_NT_0d_int_Scalar;
                          bool aux_NT_read = false;
                          vartype aux_last_type_read_for_NT = UNKNOWN;
                          EndfFloatCpp var_RTYP_0d_double_Scalar;
                          bool aux_RTYP_read = false;
                          vartype aux_last_type_read_for_RTYP = UNKNOWN;
                          EndfFloatCpp var_TYPE_0d_double_Scalar;
                          bool aux_TYPE_read = false;
                          vartype aux_last_type_read_for_TYPE = UNKNOWN;
                          EndfFloatCpp var_RI_0d_double_Scalar;
                          bool aux_RI_read = false;
                          vartype aux_last_type_read_for_RI = UNKNOWN;
                          EndfFloatCpp var_dRI_0d_double_Scalar;
                          bool aux_dRI_read = false;
                          vartype aux_last_type_read_for_dRI = UNKNOWN;
                          EndfFloatCpp var_RIS_0d_double_Scalar;
                          bool aux_RIS_read = false;
                          vartype aux_last_type_read_for_RIS = UNKNOWN;
                          EndfFloatCpp var_dRIS_0d_double_Scalar;
                          bool aux_dRIS_read = false;
                          vartype aux_last_type_read_for_dRIS = UNKNOWN;
                          EndfFloatCpp var_RICC_0d_double_Scalar;
                          bool aux_RICC_read = false;
                          vartype aux_last_type_read_for_RICC = UNKNOWN;
                          EndfFloatCpp var_dRICC_0d_double_Scalar;
                          bool aux_dRICC_read = false;
                          vartype aux_last_type_read_for_dRICC = UNKNOWN;
                          EndfFloatCpp var_RICK_0d_double_Scalar;
                          bool aux_RICK_read = false;
                          vartype aux_last_type_read_for_RICK = UNKNOWN;
                          EndfFloatCpp var_dRICK_0d_double_Scalar;
                          bool aux_dRICK_read = false;
                          vartype aux_last_type_read_for_dRICK = UNKNOWN;
                          EndfFloatCpp var_RICL_0d_double_Scalar;
                          bool aux_RICL_read = false;
                          vartype aux_last_type_read_for_RICL = UNKNOWN;
                          EndfFloatCpp var_dRICL_0d_double_Scalar;
                          bool aux_dRICL_read = false;
                          vartype aux_last_type_read_for_dRICL = UNKNOWN;
                          // evaluate if-elif-else clause
                          {
                            bool cpp_found_match = false;
                            if (! cpp_found_match) {
                              // if statement evaluation with lookahead
                              {
                                {
                                  // variable declarations
                                  EndfFloatCpp& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                  EndfFloatCpp var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                  bool& glob_aux_ER_read = aux_ER_read;
                                  bool aux_ER_read = glob_aux_ER_read;
                                  vartype aux_last_type_read_for_ER = UNKNOWN;
                                  EndfFloatCpp& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                  EndfFloatCpp var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                  bool& glob_aux_dER_read = aux_dER_read;
                                  bool aux_dER_read = glob_aux_dER_read;
                                  vartype aux_last_type_read_for_dER = UNKNOWN;
                                  int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                  int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                  bool& glob_aux_NT_read = aux_NT_read;
                                  bool aux_NT_read = glob_aux_NT_read;
                                  vartype aux_last_type_read_for_NT = UNKNOWN;
                                  try {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI ] LIST";
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::cast(-99999.9)));
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::cast(-99999.9)));
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::cast(-99999)));
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                  } catch (const std::out_of_range& e) {
                                    // // accept failure in lookahead
                                  }
                                  if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(4)))))))) {
                                    cpp_found_match = true;
                                  }
                                }
                                if (cpp_found_match) {
                                  cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI ] LIST";
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  // read LIST record
                                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none())), write_opts);
                                  // assign expression to variable ER
                                  var_ER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none()));
                                  aux_ER_read = true;
                                  validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                  aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none())), write_opts);
                                  // assign expression to variable dER
                                  var_dER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none()));
                                  aux_dER_read = true;
                                  validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                  aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                                  // assign expression to variable NT
                                  var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                                  aux_NT_read = true;
                                  validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                  aux_last_type_read_for_NT = SCALAR_INT;
                                  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                                  cont << cpp_draft_line;
                                  {
                                    int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                                    int cpp_i = 0;
                                    int cpp_j = 0;
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                    // read LIST body
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable RTYP
                                    var_RTYP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({}), py::none()));
                                    aux_RTYP_read = true;
                                    validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                    aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TYPE", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable TYPE
                                    var_TYPE_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TYPE", std::vector<int>({}), py::none()));
                                    aux_TYPE_read = true;
                                    validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                    aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RI", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable RI
                                    var_RI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RI", std::vector<int>({}), py::none()));
                                    aux_RI_read = true;
                                    validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                    aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRI", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable dRI
                                    var_dRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRI", std::vector<int>({}), py::none()));
                                    aux_dRI_read = true;
                                    validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                    aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      cpp_j = 0;
                                    }
                                    if (cpp_i != cpp_npl) {
                                      throw std::runtime_error("not exactly NPL elements consumed");
                                    }
                                  }
                                  cont << cpp_draft_line;
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  {
                                    // variable declarations
                                    EndfFloatCpp& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    EndfFloatCpp var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    EndfFloatCpp& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    EndfFloatCpp var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    try {
                                      cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS ] LIST";
                                      // read LIST record
                                      // assign expression to variable ER
                                      var_ER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::cast(-99999.9)));
                                      aux_ER_read = true;
                                      validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                      aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                      // assign expression to variable dER
                                      var_dER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::cast(-99999.9)));
                                      aux_dER_read = true;
                                      validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                      aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                      // assign expression to variable NT
                                      var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::cast(-99999)));
                                      aux_NT_read = true;
                                      validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                      aux_last_type_read_for_NT = SCALAR_INT;
                                    } catch (const std::out_of_range& e) {
                                      // // accept failure in lookahead
                                    }
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(6)))))))) {
                                      cpp_found_match = true;
                                    }
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS ] LIST";
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                    // read LIST record
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none()));
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none()));
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                                    cont << cpp_draft_line;
                                    {
                                      int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      // read LIST body
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({}), py::none()));
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TYPE", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TYPE", std::vector<int>({}), py::none()));
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RI", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RI", std::vector<int>({}), py::none()));
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRI", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRI", std::vector<int>({}), py::none()));
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RIS", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RIS", std::vector<int>({}), py::none()));
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRIS", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRIS", std::vector<int>({}), py::none()));
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                    cont << cpp_draft_line;
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  {
                                    // variable declarations
                                    EndfFloatCpp& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    EndfFloatCpp var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    EndfFloatCpp& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    EndfFloatCpp var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    try {
                                      cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC ] LIST";
                                      // read LIST record
                                      // assign expression to variable ER
                                      var_ER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::cast(-99999.9)));
                                      aux_ER_read = true;
                                      validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                      aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                      // assign expression to variable dER
                                      var_dER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::cast(-99999.9)));
                                      aux_dER_read = true;
                                      validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                      aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                      // assign expression to variable NT
                                      var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::cast(-99999)));
                                      aux_NT_read = true;
                                      validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                      aux_last_type_read_for_NT = SCALAR_INT;
                                    } catch (const std::out_of_range& e) {
                                      // // accept failure in lookahead
                                    }
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(8)))))))) {
                                      cpp_found_match = true;
                                    }
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC ] LIST";
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                    // read LIST record
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none()));
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none()));
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                                    cont << cpp_draft_line;
                                    {
                                      int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      // read LIST body
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({}), py::none()));
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TYPE", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TYPE", std::vector<int>({}), py::none()));
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RI", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RI", std::vector<int>({}), py::none()));
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRI", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRI", std::vector<int>({}), py::none()));
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RIS", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RIS", std::vector<int>({}), py::none()));
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRIS", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRIS", std::vector<int>({}), py::none()));
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RICC", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RICC
                                      var_RICC_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RICC", std::vector<int>({}), py::none()));
                                      aux_RICC_read = true;
                                      validate_vartype_consistency("RICC", SCALAR_DOUBLE, aux_last_type_read_for_RICC);
                                      aux_last_type_read_for_RICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRICC", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRICC
                                      var_dRICC_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRICC", std::vector<int>({}), py::none()));
                                      aux_dRICC_read = true;
                                      validate_vartype_consistency("dRICC", SCALAR_DOUBLE, aux_last_type_read_for_dRICC);
                                      aux_last_type_read_for_dRICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                    cont << cpp_draft_line;
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  {
                                    // variable declarations
                                    EndfFloatCpp& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    EndfFloatCpp var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    EndfFloatCpp& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    EndfFloatCpp var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    try {
                                      cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK ] LIST";
                                      // read LIST record
                                      // assign expression to variable ER
                                      var_ER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::cast(-99999.9)));
                                      aux_ER_read = true;
                                      validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                      aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                      // assign expression to variable dER
                                      var_dER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::cast(-99999.9)));
                                      aux_dER_read = true;
                                      validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                      aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                      // assign expression to variable NT
                                      var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::cast(-99999)));
                                      aux_NT_read = true;
                                      validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                      aux_last_type_read_for_NT = SCALAR_INT;
                                    } catch (const std::out_of_range& e) {
                                      // // accept failure in lookahead
                                    }
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(10)))))))) {
                                      cpp_found_match = true;
                                    }
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK ] LIST";
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                    // read LIST record
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none()));
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none()));
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                                    cont << cpp_draft_line;
                                    {
                                      int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      // read LIST body
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({}), py::none()));
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TYPE", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TYPE", std::vector<int>({}), py::none()));
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RI", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RI", std::vector<int>({}), py::none()));
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRI", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRI", std::vector<int>({}), py::none()));
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RIS", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RIS", std::vector<int>({}), py::none()));
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRIS", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRIS", std::vector<int>({}), py::none()));
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RICC", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RICC
                                      var_RICC_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RICC", std::vector<int>({}), py::none()));
                                      aux_RICC_read = true;
                                      validate_vartype_consistency("RICC", SCALAR_DOUBLE, aux_last_type_read_for_RICC);
                                      aux_last_type_read_for_RICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRICC", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRICC
                                      var_dRICC_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRICC", std::vector<int>({}), py::none()));
                                      aux_dRICC_read = true;
                                      validate_vartype_consistency("dRICC", SCALAR_DOUBLE, aux_last_type_read_for_dRICC);
                                      aux_last_type_read_for_dRICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RICK", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RICK
                                      var_RICK_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RICK", std::vector<int>({}), py::none()));
                                      aux_RICK_read = true;
                                      validate_vartype_consistency("RICK", SCALAR_DOUBLE, aux_last_type_read_for_RICK);
                                      aux_last_type_read_for_RICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRICK", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRICK
                                      var_dRICK_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRICK", std::vector<int>({}), py::none()));
                                      aux_dRICK_read = true;
                                      validate_vartype_consistency("dRICK", SCALAR_DOUBLE, aux_last_type_read_for_dRICK);
                                      aux_last_type_read_for_dRICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                    cont << cpp_draft_line;
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  {
                                    // variable declarations
                                    EndfFloatCpp& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    EndfFloatCpp var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    EndfFloatCpp& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    EndfFloatCpp var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    try {
                                      cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK , RICL , dRICL ] LIST";
                                      // read LIST record
                                      // assign expression to variable ER
                                      var_ER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::cast(-99999.9)));
                                      aux_ER_read = true;
                                      validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                      aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                      // assign expression to variable dER
                                      var_dER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::cast(-99999.9)));
                                      aux_dER_read = true;
                                      validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                      aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                      // assign expression to variable NT
                                      var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::cast(-99999)));
                                      aux_NT_read = true;
                                      validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                      aux_last_type_read_for_NT = SCALAR_INT;
                                    } catch (const std::out_of_range& e) {
                                      // // accept failure in lookahead
                                    }
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(12)))))))) {
                                      cpp_found_match = true;
                                    }
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK , RICL , dRICL ] LIST";
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                    // read LIST record
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({}), py::none()));
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dER", std::vector<int>({}), py::none()));
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                                    cont << cpp_draft_line;
                                    {
                                      int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                      // read LIST body
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({}), py::none()));
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TYPE", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TYPE", std::vector<int>({}), py::none()));
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RI", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RI", std::vector<int>({}), py::none()));
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRI", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRI", std::vector<int>({}), py::none()));
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RIS", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RIS", std::vector<int>({}), py::none()));
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRIS", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRIS", std::vector<int>({}), py::none()));
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RICC", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RICC
                                      var_RICC_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RICC", std::vector<int>({}), py::none()));
                                      aux_RICC_read = true;
                                      validate_vartype_consistency("RICC", SCALAR_DOUBLE, aux_last_type_read_for_RICC);
                                      aux_last_type_read_for_RICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRICC", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRICC
                                      var_dRICC_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRICC", std::vector<int>({}), py::none()));
                                      aux_dRICC_read = true;
                                      validate_vartype_consistency("dRICC", SCALAR_DOUBLE, aux_last_type_read_for_dRICC);
                                      aux_last_type_read_for_dRICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RICK", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RICK
                                      var_RICK_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RICK", std::vector<int>({}), py::none()));
                                      aux_RICK_read = true;
                                      validate_vartype_consistency("RICK", SCALAR_DOUBLE, aux_last_type_read_for_RICK);
                                      aux_last_type_read_for_RICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRICK", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRICK
                                      var_dRICK_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRICK", std::vector<int>({}), py::none()));
                                      aux_dRICK_read = true;
                                      validate_vartype_consistency("dRICK", SCALAR_DOUBLE, aux_last_type_read_for_dRICK);
                                      aux_last_type_read_for_dRICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RICL", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable RICL
                                      var_RICL_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RICL", std::vector<int>({}), py::none()));
                                      aux_RICL_read = true;
                                      validate_vartype_consistency("RICL", SCALAR_DOUBLE, aux_last_type_read_for_RICL);
                                      aux_last_type_read_for_RICL = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRICL", std::vector<int>({}), py::none())), write_opts);
                                      // assign expression to variable dRICL
                                      var_dRICL_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("dRICL", std::vector<int>({}), py::none()));
                                      aux_dRICL_read = true;
                                      validate_vartype_consistency("dRICL", SCALAR_DOUBLE, aux_last_type_read_for_dRICL);
                                      aux_last_type_read_for_dRICL = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                    cont << cpp_draft_line;
                                  }
                                }
                              }
                            }
                          }
                          cpp_current_dict = cpp_parent_dict;
                        }
                      }
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if ((((((((aux_LCON_read == true)) && ((var_LCON_0d_int_Scalar)!=(0)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section continuous
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      cpp_current_dict = cpp_index_shifter_store.get_value("continuous", std::vector<int>({}), py::dict());
                      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                      // variable declarations
                      EndfFloatCpp var_RTYP_0d_double_Scalar;
                      bool aux_RTYP_read = false;
                      vartype aux_last_type_read_for_RTYP = UNKNOWN;
                      std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
                      bool aux_Eint_read = false;
                      vartype aux_last_type_read_for_Eint = UNKNOWN;
                      std::vector<EndfFloatCpp> var_RP_0d_floatvec_Scalar;
                      bool aux_RP_read = false;
                      vartype aux_last_type_read_for_RP = UNKNOWN;
                      std::vector<int> var_INT_0d_intvec_Scalar;
                      bool aux_INT_read = false;
                      vartype aux_last_type_read_for_INT = UNKNOWN;
                      std::vector<int> var_NBT_0d_intvec_Scalar;
                      bool aux_NBT_read = false;
                      vartype aux_last_type_read_for_NBT = UNKNOWN;
                      cpp_template = "[ MAT , 8 , 457 / RTYP , 0.0 , 0 , 0 , NR , NP / Eint / RP ] TAB1";
                      // read TAB1 record
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable RTYP
                      var_RTYP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RTYP", std::vector<int>({}), py::none()));
                      aux_RTYP_read = true;
                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                      cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                      cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
                      cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                      cont << cpp_draft_line;
                      tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                      tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("RP", std::vector<int>({}), py::none()));
                      tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                      tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                      write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                      {
                        Tab1Body tab_body = tab1_body;
                        // assign expression to variable Eint
                        var_Eint_0d_floatvec_Scalar = tab_body.X;
                        aux_Eint_read = true;
                        validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                        aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                        // assign expression to variable RP
                        var_RP_0d_floatvec_Scalar = tab_body.Y;
                        aux_RP_read = true;
                        validate_vartype_consistency("RP", SCALAR_FLOATVEC, aux_last_type_read_for_RP);
                        aux_last_type_read_for_RP = SCALAR_FLOATVEC;
                        // assign expression to variable INT
                        var_INT_0d_intvec_Scalar = tab_body.INT;
                        aux_INT_read = true;
                        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                        aux_last_type_read_for_INT = SCALAR_INTVEC;
                        // assign expression to variable NBT
                        var_NBT_0d_intvec_Scalar = tab_body.NBT;
                        aux_NBT_read = true;
                        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                        aux_last_type_read_for_NBT = SCALAR_INTVEC;
                      }
                      cont << cpp_draft_line;
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if ((((((((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(0)))))&&((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(2)))))&&((((aux_LCON_read == true)) && ((var_LCON_0d_int_Scalar)!=(0)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section continuous
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      cpp_current_dict = cpp_index_shifter_store.get_value("continuous", std::vector<int>({}), py::dict());
                      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                      // variable declarations
                      int cpp_int_val;
                      bool aux_cpp_int_val_read = false;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int var_NPP_0d_int_Scalar;
                      bool aux_NPP_read = false;
                      vartype aux_last_type_read_for_NPP = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
                      vartype aux_last_type_read_for_E = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_F_1d_double_NestedVector;
                      vartype aux_last_type_read_for_F = UNKNOWN;
                      cpp_template = "[ MAT , 8 , 457 / 0.0 , 0.0 , 0 , 2 , (2*NPP) , NPP / { E , F } { m = 1 to NPP } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read LIST record
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 3, 2, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none()))), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none())));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NPP
                      var_NPP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NPP_read = true;
                      validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                      aux_last_type_read_for_NPP = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none())), write_opts);
                      if ((! (aux_NPP_read == true))) {
                        // assign expression to variable NPP
                        var_NPP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none()));
                        aux_NPP_read = true;
                        validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                        aux_last_type_read_for_NPP = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none()))), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (2*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none())));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST body

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NPP_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // read LIST body
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable E
                          var_E_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                          aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable F
                          var_F_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                          aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if (((((((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(0)))))&&((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(1)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section discrete
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      cpp_current_dict = cpp_index_shifter_store.get_value("discrete", std::vector<int>({}), py::dict());
                      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                      // variable declarations
                      // open section cov
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        cpp_current_dict = cpp_index_shifter_store.get_value("cov", std::vector<int>({}), py::dict());
                        IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                        // variable declarations
                        int var_LS_0d_int_Scalar;
                        bool aux_LS_read = false;
                        vartype aux_last_type_read_for_LS = UNKNOWN;
                        int var_NE_0d_int_Scalar;
                        bool aux_NE_read = false;
                        vartype aux_last_type_read_for_NE = UNKNOWN;
                        int var_NERP_0d_int_Scalar;
                        bool aux_NERP_read = false;
                        vartype aux_last_type_read_for_NERP = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
                        vartype aux_last_type_read_for_E = UNKNOWN;
                        Matrix2d<EndfFloatCpp> var_F_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_F = UNKNOWN;
                        cpp_template = "[ MAT , 8 , 457 / 0.0 , 0.0 , LS , 5 , NE , NERP / \n { E } { m = 1 to NERP } , { { F } { n = m to (NERP-2) } } { m = 1 to (NERP-2) } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none()));
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, 5, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NERP", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NERP
                        var_NERP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NERP", std::vector<int>({}), py::none()));
                        aux_NERP_read = true;
                        validate_vartype_consistency("NERP", SCALAR_INT, aux_last_type_read_for_NERP);
                        aux_last_type_read_for_NERP = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= var_NERP_0d_int_Scalar; var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NERP_0d_int_Scalar-2), 1, (var_NERP_0d_int_Scalar-2), true, false);

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= (var_NERP_0d_int_Scalar-2); var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body

                            for (int var_n_0d_int_Scalar = var_m_0d_int_Scalar;
                               var_n_0d_int_Scalar <= (var_NERP_0d_int_Scalar-2); var_n_0d_int_Scalar++) {
                              bool aux_n_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_m_0d_int_Scalar, var_n_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_m_0d_int_Scalar, var_n_0d_int_Scalar}), py::none()));
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                        cpp_current_dict = cpp_parent_dict;
                      }
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LIS_0d_int_Scalar = var_LIS_0d_int_Scalar;
            int var_LIS_0d_int_Scalar = glob_var_LIS_0d_int_Scalar;
            bool& glob_aux_LIS_read = aux_LIS_read;
            bool aux_LIS_read = glob_aux_LIS_read;
            vartype aux_last_type_read_for_LIS = UNKNOWN;
            int& glob_var_LISO_0d_int_Scalar = var_LISO_0d_int_Scalar;
            int var_LISO_0d_int_Scalar = glob_var_LISO_0d_int_Scalar;
            bool& glob_aux_LISO_read = aux_LISO_read;
            bool aux_LISO_read = glob_aux_LISO_read;
            vartype aux_last_type_read_for_LISO = UNKNOWN;
            int& glob_var_NST_0d_int_Scalar = var_NST_0d_int_Scalar;
            int var_NST_0d_int_Scalar = glob_var_NST_0d_int_Scalar;
            bool& glob_aux_NST_read = aux_NST_read;
            bool aux_NST_read = glob_aux_NST_read;
            vartype aux_last_type_read_for_NST = UNKNOWN;
            try {
              cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , 0 ] HEAD";
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::cast(-99999.9)));
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::cast(-99999.9)));
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LIS
              var_LIS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::cast(-99999)));
              aux_LIS_read = true;
              validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
              aux_last_type_read_for_LIS = SCALAR_INT;
              // assign expression to variable LISO
              var_LISO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LISO", std::vector<int>({}), py::cast(-99999)));
              aux_LISO_read = true;
              validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
              aux_last_type_read_for_LISO = SCALAR_INT;
              // assign expression to variable NST
              var_NST_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NST", std::vector<int>({}), py::cast(-99999)));
              aux_NST_read = true;
              validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
              aux_last_type_read_for_NST = SCALAR_INT;
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if ((((((((aux_NST_read == true)) && ((var_NST_0d_int_Scalar)==(1)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , 0 ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read CONT record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LIS
            var_LIS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none()));
            aux_LIS_read = true;
            validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
            aux_last_type_read_for_LIS = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LISO", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LISO
            var_LISO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LISO", std::vector<int>({}), py::none()));
            aux_LISO_read = true;
            validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
            aux_last_type_read_for_LISO = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NST", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NST
            var_NST_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NST", std::vector<int>({}), py::none()));
            aux_NST_read = true;
            validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
            aux_last_type_read_for_NST = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cont << cpp_draft_line;
            cpp_template = "[ MAT , 8 , 457 / 0.0 , 0.0 , 0 , 0 , 6 , 0 / \n 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read LIST record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, 6, write_opts);
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, 6, write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = 6;
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read LIST body
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_j = 0;
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
            // evaluate if-elif-else clause
            {
              bool cpp_found_match = false;
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
                    int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
                    bool& glob_aux_MAT_read = aux_MAT_read;
                    bool aux_MAT_read = glob_aux_MAT_read;
                    vartype aux_last_type_read_for_MAT = UNKNOWN;
                    int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
                    int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
                    bool& glob_aux_MF_read = aux_MF_read;
                    bool aux_MF_read = glob_aux_MF_read;
                    vartype aux_last_type_read_for_MF = UNKNOWN;
                    int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
                    int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
                    bool& glob_aux_MT_read = aux_MT_read;
                    bool aux_MT_read = glob_aux_MT_read;
                    vartype aux_last_type_read_for_MT = UNKNOWN;
                    EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
                    EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
                    bool& glob_aux_ZA_read = aux_ZA_read;
                    bool aux_ZA_read = glob_aux_ZA_read;
                    vartype aux_last_type_read_for_ZA = UNKNOWN;
                    EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
                    EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
                    bool& glob_aux_AWR_read = aux_AWR_read;
                    bool aux_AWR_read = glob_aux_AWR_read;
                    vartype aux_last_type_read_for_AWR = UNKNOWN;
                    int& glob_var_LIS_0d_int_Scalar = var_LIS_0d_int_Scalar;
                    int var_LIS_0d_int_Scalar = glob_var_LIS_0d_int_Scalar;
                    bool& glob_aux_LIS_read = aux_LIS_read;
                    bool aux_LIS_read = glob_aux_LIS_read;
                    vartype aux_last_type_read_for_LIS = UNKNOWN;
                    int& glob_var_LISO_0d_int_Scalar = var_LISO_0d_int_Scalar;
                    int var_LISO_0d_int_Scalar = glob_var_LISO_0d_int_Scalar;
                    bool& glob_aux_LISO_read = aux_LISO_read;
                    bool aux_LISO_read = glob_aux_LISO_read;
                    vartype aux_last_type_read_for_LISO = UNKNOWN;
                    int& glob_var_NST_0d_int_Scalar = var_NST_0d_int_Scalar;
                    int var_NST_0d_int_Scalar = glob_var_NST_0d_int_Scalar;
                    bool& glob_aux_NST_read = aux_NST_read;
                    bool aux_NST_read = glob_aux_NST_read;
                    vartype aux_last_type_read_for_NST = UNKNOWN;
                    EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    EndfFloatCpp& glob_var_PAR_0d_double_Scalar = var_PAR_0d_double_Scalar;
                    EndfFloatCpp var_PAR_0d_double_Scalar = glob_var_PAR_0d_double_Scalar;
                    bool& glob_aux_PAR_read = aux_PAR_read;
                    bool aux_PAR_read = glob_aux_PAR_read;
                    vartype aux_last_type_read_for_PAR = UNKNOWN;
                    int& glob_var_JENDL_LIST_NPL_0d_int_Scalar = var_JENDL_LIST_NPL_0d_int_Scalar;
                    int var_JENDL_LIST_NPL_0d_int_Scalar = glob_var_JENDL_LIST_NPL_0d_int_Scalar;
                    bool& glob_aux_JENDL_LIST_NPL_read = aux_JENDL_LIST_NPL_read;
                    bool aux_JENDL_LIST_NPL_read = glob_aux_JENDL_LIST_NPL_read;
                    vartype aux_last_type_read_for_JENDL_LIST_NPL = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , JENDL_LIST_NPL , 0 / \n { 0.0 } { k = 1 to JENDL_LIST_NPL } ] LIST";
                      // read LIST record
                      // assign expression to variable SPI
                      var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::cast(-99999.9)));
                      aux_SPI_read = true;
                      validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                      aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                      // assign expression to variable PAR
                      var_PAR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PAR", std::vector<int>({}), py::cast(-99999.9)));
                      aux_PAR_read = true;
                      validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
                      aux_last_type_read_for_PAR = SCALAR_DOUBLE;
                      // assign expression to variable JENDL_LIST_NPL
                      var_JENDL_LIST_NPL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("JENDL_LIST_NPL", std::vector<int>({}), py::cast(-99999)));
                      aux_JENDL_LIST_NPL_read = true;
                      validate_vartype_consistency("JENDL_LIST_NPL", SCALAR_INT, aux_last_type_read_for_JENDL_LIST_NPL);
                      aux_last_type_read_for_JENDL_LIST_NPL = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((aux_JENDL_LIST_NPL_read == true)) && ((var_JENDL_LIST_NPL_0d_int_Scalar)!=(6)))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , JENDL_LIST_NPL , 0 / \n { 0.0 } { k = 1 to JENDL_LIST_NPL } ] LIST";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read LIST record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PAR", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable PAR
                    var_PAR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PAR", std::vector<int>({}), py::none()));
                    aux_PAR_read = true;
                    validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
                    aux_last_type_read_for_PAR = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("JENDL_LIST_NPL", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable JENDL_LIST_NPL
                    var_JENDL_LIST_NPL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("JENDL_LIST_NPL", std::vector<int>({}), py::none()));
                    aux_JENDL_LIST_NPL_read = true;
                    validate_vartype_consistency("JENDL_LIST_NPL", SCALAR_INT, aux_last_type_read_for_JENDL_LIST_NPL);
                    aux_last_type_read_for_JENDL_LIST_NPL = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("JENDL_LIST_NPL", std::vector<int>({}), py::none())), write_opts);
                    cont << cpp_draft_line;
                    {
                      int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("JENDL_LIST_NPL", std::vector<int>({}), py::none()));
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_JENDL_LIST_NPL_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cont << cpp_draft_line;
                  }
                }
              }
              if (! cpp_found_match) {
                cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , 6 , 0 / \n 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ] LIST";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                // read LIST record
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable SPI
                var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                aux_SPI_read = true;
                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PAR", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable PAR
                var_PAR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PAR", std::vector<int>({}), py::none()));
                aux_PAR_read = true;
                validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
                aux_last_type_read_for_PAR = SCALAR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, 6, write_opts);
                cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, 6, write_opts);
                cont << cpp_draft_line;
                {
                  int cpp_npl = 6;
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  // read LIST body
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    cpp_j = 0;
                  }
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    cpp_j = 0;
                  }
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    cpp_j = 0;
                  }
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    cpp_j = 0;
                  }
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    cpp_j = 0;
                  }
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    cpp_j = 0;
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
                cont << cpp_draft_line;
              }
            }
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 9b44a8a45cec90ea92aa701b596f413f
// MD5 hash of the following function definition: dd31e8be912652620d4e83a828cb0b02
void write_mf8mt459_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_LE_0d_int_Scalar;
  bool aux_LE_read = false;
  vartype aux_last_type_read_for_LE = UNKNOWN;
  NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<int> var_NN_1d_int_NestedVector;
  vartype aux_last_type_read_for_NN = UNKNOWN;
  NestedVector<int> var_NFP_1d_int_NestedVector;
  vartype aux_last_type_read_for_NFP = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_ZAFP_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_ZAFP_2d_idx0;
  vartype aux_last_type_read_for_ZAFP = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_FPS_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_FPS_2d_idx0;
  vartype aux_last_type_read_for_FPS = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_YC_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_YC_2d_idx0;
  vartype aux_last_type_read_for_YC = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_DYC_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_DYC_2d_idx0;
  vartype aux_last_type_read_for_DYC = UNKNOWN;
  NestedVector<int> var_I_1d_int_NestedVector;
  vartype aux_last_type_read_for_I = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 8;
  int mt = 459;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 459;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 8 , MT / ZA , AWR , (LE+1) , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, (py::cast<int>(cpp_index_shifter_store.get_value("LE", std::vector<int>({}), py::none()))+1), write_opts);
  // assign expression to variable cpp_int_val
  cpp_int_val = (py::cast<int>(cpp_index_shifter_store.get_value("LE", std::vector<int>({}), py::none()))+1);
  aux_cpp_int_val_read = true;
  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
  // assign expression to variable LE
  var_LE_0d_int_Scalar = (cpp_int_val+(-1));
  aux_LE_read = true;
  validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
  aux_last_type_read_for_LE = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 8 , MT / E , 0.0 , LE , 0 , NN , NFP / \n { ZAFP , FPS , YC , DYC } { m = 1 to NFP } ] LIST";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read LIST record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({0}), py::none())), write_opts);
  // assign expression to variable E
  var_E_1d_double_NestedVector.set(0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({0}), py::none())));
  validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
  aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LE", std::vector<int>({}), py::none())), write_opts);
  if ((! (aux_LE_read == true))) {
    // assign expression to variable LE
    var_LE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LE", std::vector<int>({}), py::none()));
    aux_LE_read = true;
    validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
    aux_last_type_read_for_LE = SCALAR_INT;
  } else {
  }
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({0}), py::none())), write_opts);
  // assign expression to variable NN
  var_NN_1d_int_NestedVector.set(0, py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({0}), py::none())));
  validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
  aux_last_type_read_for_NN = NESTEDVECTOR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NFP", std::vector<int>({0}), py::none())), write_opts);
  // assign expression to variable NFP
  var_NFP_1d_int_NestedVector.set(0, py::cast<int>(cpp_index_shifter_store.get_value("NFP", std::vector<int>({0}), py::none())));
  validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
  aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({0}), py::none())), write_opts);
  cont << cpp_draft_line;
  {
    int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({0}), py::none()));
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
    // read LIST body
    ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(0);
    ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(0);
    ptr_YC_2d_idx0 = var_YC_2d_double_NestedVector.prepare(0);
    ptr_DYC_2d_idx0 = var_DYC_2d_double_NestedVector.prepare(0);

    for (int var_m_0d_int_Scalar = 1;
       var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[0]; var_m_0d_int_Scalar++) {
      bool aux_m_read = true;
      // read LIST body
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAFP", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())), write_opts);
      // assign expression to variable ZAFP
      ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAFP", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
      aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_j = 0;
      }
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("FPS", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())), write_opts);
      // assign expression to variable FPS
      ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("FPS", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
      aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_j = 0;
      }
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("YC", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())), write_opts);
      // assign expression to variable YC
      ptr_YC_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("YC", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("YC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YC);
      aux_last_type_read_for_YC = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_j = 0;
      }
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DYC", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())), write_opts);
      // assign expression to variable DYC
      ptr_DYC_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DYC", std::vector<int>({0, var_m_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("DYC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYC);
      aux_last_type_read_for_DYC = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_LE_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    cpp_template = "[ MAT , 8 , MT / E , 0.0 , I , 0 , NN , NFP / \n { ZAFP , FPS , YC , DYC } { m = 1 to NFP } ] LIST";
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
    // read LIST record
    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
    if ((! var_E_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable E
      var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
      aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
    } else {
    }
    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("I", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
    // assign expression to variable I
    var_I_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("I", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
    validate_vartype_consistency("I", NESTEDVECTOR_INT, aux_last_type_read_for_I);
    aux_last_type_read_for_I = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
    if ((! var_NN_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NN
      var_NN_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
      aux_last_type_read_for_NN = NESTEDVECTOR_INT;
    } else {
    }
    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NFP", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
    if ((! var_NFP_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NFP
      var_NFP_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NFP", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
      validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
      aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
    } else {
    }
    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
    cont << cpp_draft_line;
    {
      int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NN", std::vector<int>({var_k_0d_int_Scalar}), py::none()));
      int cpp_i = 0;
      int cpp_j = 0;
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      // read LIST body
      ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_YC_2d_idx0 = var_YC_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_DYC_2d_idx0 = var_DYC_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

      for (int var_m_0d_int_Scalar = 1;
         var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[var_k_0d_int_Scalar]; var_m_0d_int_Scalar++) {
        bool aux_m_read = true;
        // read LIST body
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAFP", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
        if ((! (var_ZAFP_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_ZAFP_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable ZAFP
          ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAFP", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
          validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
          aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("FPS", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
        if ((! (var_FPS_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_FPS_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable FPS
          ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("FPS", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
          validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
          aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("YC", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
        if ((! (var_YC_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_YC_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable YC
          ptr_YC_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("YC", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
          validate_vartype_consistency("YC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YC);
          aux_last_type_read_for_YC = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DYC", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
        if ((! (var_DYC_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_DYC_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable DYC
          ptr_DYC_2d_idx0->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DYC", std::vector<int>({var_k_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
          validate_vartype_consistency("DYC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYC);
          aux_last_type_read_for_DYC = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          cpp_j = 0;
        }
      }
      if (cpp_i != cpp_npl) {
        throw std::runtime_error("not exactly NPL elements consumed");
      }
    }
    cont << cpp_draft_line;
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 1db3e473b7f130d4f0683e6401196b22
// MD5 hash of the following function definition: 415617b40737ffd7bec007038c9a9150
void write_mf9_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 9;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 9;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 9 , MT / ZA , AWR , LIS , 0 , NS , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none()));
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NS", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NS", std::vector<int>({}), py::none()));
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.get_value("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_QM_0d_double_Scalar;
      bool aux_QM_read = false;
      vartype aux_last_type_read_for_QM = UNKNOWN;
      EndfFloatCpp var_QI_0d_double_Scalar;
      bool aux_QI_read = false;
      vartype aux_last_type_read_for_QI = UNKNOWN;
      int var_IZAP_0d_int_Scalar;
      bool aux_IZAP_read = false;
      vartype aux_last_type_read_for_IZAP = UNKNOWN;
      int var_LFS_0d_int_Scalar;
      bool aux_LFS_read = false;
      vartype aux_last_type_read_for_LFS = UNKNOWN;
      std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      vartype aux_last_type_read_for_E = UNKNOWN;
      std::vector<EndfFloatCpp> var_Y_0d_floatvec_Scalar;
      bool aux_Y_read = false;
      vartype aux_last_type_read_for_Y = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      cpp_template = "[ MAT , 9 , MT / QM , QI , IZAP , LFS , NR , NP / E / Y ] TAB1";
      // read TAB1 record
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QM", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable QM
      var_QM_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QM", std::vector<int>({}), py::none()));
      aux_QM_read = true;
      validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
      aux_last_type_read_for_QM = SCALAR_DOUBLE;
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QI", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable QI
      var_QI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QI", std::vector<int>({}), py::none()));
      aux_QI_read = true;
      validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
      aux_last_type_read_for_QI = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("IZAP", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable IZAP
      var_IZAP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("IZAP", std::vector<int>({}), py::none()));
      aux_IZAP_read = true;
      validate_vartype_consistency("IZAP", SCALAR_INT, aux_last_type_read_for_IZAP);
      aux_last_type_read_for_IZAP = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LFS", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable LFS
      var_LFS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFS", std::vector<int>({}), py::none()));
      aux_LFS_read = true;
      validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
      aux_last_type_read_for_LFS = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
      cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
      cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
      cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
      cont << cpp_draft_line;
      tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
      tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Y", std::vector<int>({}), py::none()));
      tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
      tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
      write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
      {
        Tab1Body tab_body = tab1_body;
        // assign expression to variable E
        var_E_0d_floatvec_Scalar = tab_body.X;
        aux_E_read = true;
        validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
        aux_last_type_read_for_E = SCALAR_FLOATVEC;
        // assign expression to variable Y
        var_Y_0d_floatvec_Scalar = tab_body.Y;
        aux_Y_read = true;
        validate_vartype_consistency("Y", SCALAR_FLOATVEC, aux_last_type_read_for_Y);
        aux_last_type_read_for_Y = SCALAR_FLOATVEC;
        // assign expression to variable INT
        var_INT_0d_intvec_Scalar = tab_body.INT;
        aux_INT_read = true;
        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
        aux_last_type_read_for_INT = SCALAR_INTVEC;
        // assign expression to variable NBT
        var_NBT_0d_intvec_Scalar = tab_body.NBT;
        aux_NBT_read = true;
        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
        aux_last_type_read_for_NBT = SCALAR_INTVEC;
      }
      cont << cpp_draft_line;
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: b5ce883fcd2a78e1dee22fd8e5f23c84
// MD5 hash of the following function definition: e70e375c956996d074eaa8f095823fdd
void write_mf10_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 10;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 10;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 10 , MT / ZA , AWR , LIS , 0 , NS , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none()));
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NS", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NS", std::vector<int>({}), py::none()));
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.get_value("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_QM_0d_double_Scalar;
      bool aux_QM_read = false;
      vartype aux_last_type_read_for_QM = UNKNOWN;
      EndfFloatCpp var_QI_0d_double_Scalar;
      bool aux_QI_read = false;
      vartype aux_last_type_read_for_QI = UNKNOWN;
      int var_IZAP_0d_int_Scalar;
      bool aux_IZAP_read = false;
      vartype aux_last_type_read_for_IZAP = UNKNOWN;
      int var_LFS_0d_int_Scalar;
      bool aux_LFS_read = false;
      vartype aux_last_type_read_for_LFS = UNKNOWN;
      std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      vartype aux_last_type_read_for_E = UNKNOWN;
      std::vector<EndfFloatCpp> var_sigma_0d_floatvec_Scalar;
      bool aux_sigma_read = false;
      vartype aux_last_type_read_for_sigma = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      cpp_template = "[ MAT , 10 , MT / QM , QI , IZAP , LFS , NR , NP / E / sigma ] TAB1";
      // read TAB1 record
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QM", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable QM
      var_QM_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QM", std::vector<int>({}), py::none()));
      aux_QM_read = true;
      validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
      aux_last_type_read_for_QM = SCALAR_DOUBLE;
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QI", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable QI
      var_QI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QI", std::vector<int>({}), py::none()));
      aux_QI_read = true;
      validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
      aux_last_type_read_for_QI = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("IZAP", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable IZAP
      var_IZAP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("IZAP", std::vector<int>({}), py::none()));
      aux_IZAP_read = true;
      validate_vartype_consistency("IZAP", SCALAR_INT, aux_last_type_read_for_IZAP);
      aux_last_type_read_for_IZAP = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LFS", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable LFS
      var_LFS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFS", std::vector<int>({}), py::none()));
      aux_LFS_read = true;
      validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
      aux_last_type_read_for_LFS = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
      cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
      cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
      cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
      cont << cpp_draft_line;
      tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
      tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("sigma", std::vector<int>({}), py::none()));
      tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
      tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
      write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
      {
        Tab1Body tab_body = tab1_body;
        // assign expression to variable E
        var_E_0d_floatvec_Scalar = tab_body.X;
        aux_E_read = true;
        validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
        aux_last_type_read_for_E = SCALAR_FLOATVEC;
        // assign expression to variable sigma
        var_sigma_0d_floatvec_Scalar = tab_body.Y;
        aux_sigma_read = true;
        validate_vartype_consistency("sigma", SCALAR_FLOATVEC, aux_last_type_read_for_sigma);
        aux_last_type_read_for_sigma = SCALAR_FLOATVEC;
        // assign expression to variable INT
        var_INT_0d_intvec_Scalar = tab_body.INT;
        aux_INT_read = true;
        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
        aux_last_type_read_for_INT = SCALAR_INTVEC;
        // assign expression to variable NBT
        var_NBT_0d_intvec_Scalar = tab_body.NBT;
        aux_NBT_read = true;
        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
        aux_last_type_read_for_NBT = SCALAR_INTVEC;
      }
      cont << cpp_draft_line;
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: e54487563cbd4b212af001ef1d061333
// MD5 hash of the following function definition: d519777bbf25439a88efa069e76a5136
void write_mf12_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LO_0d_int_Scalar;
  bool aux_LO_read = false;
  vartype aux_last_type_read_for_LO = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<EndfFloatCpp> var_Y_0d_floatvec_Scalar;
  bool aux_Y_read = false;
  vartype aux_last_type_read_for_Y = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  NestedVector<EndfFloatCpp> var_Eg_1d_double_NestedVector;
  vartype aux_last_type_read_for_Eg = UNKNOWN;
  NestedVector<EndfFloatCpp> var_ES_1d_double_NestedVector;
  vartype aux_last_type_read_for_ES = UNKNOWN;
  NestedVector<int> var_LP_1d_int_NestedVector;
  vartype aux_last_type_read_for_LP = UNKNOWN;
  NestedVector<int> var_LF_1d_int_NestedVector;
  vartype aux_last_type_read_for_LF = UNKNOWN;
  int var_LG_0d_int_Scalar;
  bool aux_LG_read = false;
  vartype aux_last_type_read_for_LG = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  EndfFloatCpp var_ES_NS_0d_double_Scalar;
  bool aux_ES_NS_read = false;
  vartype aux_last_type_read_for_ES_NS = UNKNOWN;
  int var_LP_0d_int_Scalar;
  bool aux_LP_read = false;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_NT_0d_int_Scalar;
  bool aux_NT_read = false;
  vartype aux_last_type_read_for_NT = UNKNOWN;
  NestedVector<EndfFloatCpp> var_TP_1d_double_NestedVector;
  vartype aux_last_type_read_for_TP = UNKNOWN;
  NestedVector<EndfFloatCpp> var_GP_1d_double_NestedVector;
  vartype aux_last_type_read_for_GP = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 12;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 12;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
          int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
          bool& glob_aux_LO_read = aux_LO_read;
          bool aux_LO_read = glob_aux_LO_read;
          vartype aux_last_type_read_for_LO = UNKNOWN;
          int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
          int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
          bool& glob_aux_NK_read = aux_NK_read;
          bool aux_NK_read = glob_aux_NK_read;
          vartype aux_last_type_read_for_NK = UNKNOWN;
          try {
            cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , 0 , NK , 0 ] HEAD";
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::cast(-99999.9)));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::cast(-99999.9)));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LO
            var_LO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LO", std::vector<int>({}), py::cast(-99999)));
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            // assign expression to variable NK
            var_NK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::cast(-99999)));
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
          } catch (const std::out_of_range& e) {
            // // accept failure in lookahead
          }
          if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(1)))))))) {
            cpp_found_match = true;
          }
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , 0 , NK , 0 ] HEAD";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read CONT record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LO", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LO
          var_LO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LO", std::vector<int>({}), py::none()));
          aux_LO_read = true;
          validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
          aux_last_type_read_for_LO = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NK
          var_NK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none()));
          aux_NK_read = true;
          validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
          aux_last_type_read_for_NK = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cont << cpp_draft_line;
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((aux_NK_read == true)) && ((var_NK_0d_int_Scalar)>(1)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                cpp_template = "[ MAT , 12 , MT / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / Y ] TAB1";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
                cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                cont << cpp_draft_line;
                tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Y", std::vector<int>({}), py::none()));
                tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                {
                  Tab1Body tab_body = tab1_body;
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                  // assign expression to variable Y
                  var_Y_0d_floatvec_Scalar = tab_body.Y;
                  aux_Y_read = true;
                  validate_vartype_consistency("Y", SCALAR_FLOATVEC, aux_last_type_read_for_Y);
                  aux_last_type_read_for_Y = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
              }
            }
          }

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            cpp_template = "[ MAT , 12 , MT / Eg , ES , LP , LF , NR , NP / Eint / y ] TAB1 ( table [ k ] )";
            // read TAB1 record
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Eg", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
            // assign expression to variable Eg
            var_Eg_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Eg", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
            validate_vartype_consistency("Eg", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Eg);
            aux_last_type_read_for_Eg = NESTEDVECTOR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
            // assign expression to variable ES
            var_ES_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
            validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
            aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LP", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
            // assign expression to variable LP
            var_LP_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("LP", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
            validate_vartype_consistency("LP", NESTEDVECTOR_INT, aux_last_type_read_for_LP);
            aux_last_type_read_for_LP = NESTEDVECTOR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
            // assign expression to variable LF
            var_LF_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
            validate_vartype_consistency("LF", NESTEDVECTOR_INT, aux_last_type_read_for_LF);
            aux_last_type_read_for_LF = NESTEDVECTOR_INT;
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.get_value("table", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
              cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
              cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
              cont << cpp_draft_line;
              tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
              tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("y", std::vector<int>({}), py::none()));
              tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
              write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
              // variable declarations
              std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
              bool aux_Eint_read = false;
              vartype aux_last_type_read_for_Eint = UNKNOWN;
              std::vector<EndfFloatCpp> var_y_0d_floatvec_Scalar;
              bool aux_y_read = false;
              vartype aux_last_type_read_for_y = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = tab1_body;
                if ((! (aux_Eint_read == true))) {
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                } else {
                }
                // assign expression to variable y
                var_y_0d_floatvec_Scalar = tab_body.Y;
                aux_y_read = true;
                validate_vartype_consistency("y", SCALAR_FLOATVEC, aux_last_type_read_for_y);
                aux_last_type_read_for_y = SCALAR_FLOATVEC;
                if ((! (aux_INT_read == true))) {
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                } else {
                }
                if ((! (aux_NBT_read == true))) {
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                } else {
                }
              }
              cont << cpp_draft_line;
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
            int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
            bool& glob_aux_LO_read = aux_LO_read;
            bool aux_LO_read = glob_aux_LO_read;
            vartype aux_last_type_read_for_LO = UNKNOWN;
            int& glob_var_LG_0d_int_Scalar = var_LG_0d_int_Scalar;
            int var_LG_0d_int_Scalar = glob_var_LG_0d_int_Scalar;
            bool& glob_aux_LG_read = aux_LG_read;
            bool aux_LG_read = glob_aux_LG_read;
            vartype aux_last_type_read_for_LG = UNKNOWN;
            int& glob_var_NS_0d_int_Scalar = var_NS_0d_int_Scalar;
            int var_NS_0d_int_Scalar = glob_var_NS_0d_int_Scalar;
            bool& glob_aux_NS_read = aux_NS_read;
            bool aux_NS_read = glob_aux_NS_read;
            vartype aux_last_type_read_for_NS = UNKNOWN;
            try {
              cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , LG , NS , 0 ] HEAD";
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::cast(-99999.9)));
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::cast(-99999.9)));
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LO
              var_LO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LO", std::vector<int>({}), py::cast(-99999)));
              aux_LO_read = true;
              validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
              aux_last_type_read_for_LO = SCALAR_INT;
              // assign expression to variable LG
              var_LG_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LG", std::vector<int>({}), py::cast(-99999)));
              aux_LG_read = true;
              validate_vartype_consistency("LG", SCALAR_INT, aux_last_type_read_for_LG);
              aux_last_type_read_for_LG = SCALAR_INT;
              // assign expression to variable NS
              var_NS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NS", std::vector<int>({}), py::cast(-99999)));
              aux_NS_read = true;
              validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
              aux_last_type_read_for_NS = SCALAR_INT;
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(2)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , LG , NS , 0 ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read CONT record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LO", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LO
            var_LO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LO", std::vector<int>({}), py::none()));
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LG", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LG
            var_LG_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LG", std::vector<int>({}), py::none()));
            aux_LG_read = true;
            validate_vartype_consistency("LG", SCALAR_INT, aux_last_type_read_for_LG);
            aux_last_type_read_for_LG = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NS", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NS
            var_NS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NS", std::vector<int>({}), py::none()));
            aux_NS_read = true;
            validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
            aux_last_type_read_for_NS = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cont << cpp_draft_line;
            // evaluate if-elif-else clause
            {
              bool cpp_found_match = false;
              if (! cpp_found_match) {
                if ((((((((aux_LG_read == true)) && ((var_LG_0d_int_Scalar)==(1)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  cpp_template = "[ MAT , 12 , MT / ES_NS , 0.0 , LP , 0 , (2*NT) , NT / \n { ES , TP } { i = 1 to NT } ] LIST";
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  // read LIST record
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES_NS", std::vector<int>({}), py::none())), write_opts);
                  // assign expression to variable ES_NS
                  var_ES_NS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES_NS", std::vector<int>({}), py::none()));
                  aux_ES_NS_read = true;
                  validate_vartype_consistency("ES_NS", SCALAR_DOUBLE, aux_last_type_read_for_ES_NS);
                  aux_last_type_read_for_ES_NS = SCALAR_DOUBLE;
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LP", std::vector<int>({}), py::none())), write_opts);
                  // assign expression to variable LP
                  var_LP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LP", std::vector<int>({}), py::none()));
                  aux_LP_read = true;
                  validate_vartype_consistency("LP", SCALAR_INT, aux_last_type_read_for_LP);
                  aux_last_type_read_for_LP = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()))), write_opts);
                  // assign expression to variable cpp_int_val
                  cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())));
                  aux_cpp_int_val_read = true;
                  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                  // assign expression to variable NT
                  var_NT_0d_int_Scalar = (cpp_int_val/2);
                  aux_NT_read = true;
                  validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                  aux_last_type_read_for_NT = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                  if ((! (aux_NT_read == true))) {
                    // assign expression to variable NT
                    var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                    aux_NT_read = true;
                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                    aux_last_type_read_for_NT = SCALAR_INT;
                  } else {
                  }
                  cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()))), write_opts);
                  cont << cpp_draft_line;
                  {
                    int cpp_npl = (2*py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())));
                    int cpp_i = 0;
                    int cpp_j = 0;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read LIST body

                    for (int var_i_0d_int_Scalar = 1;
                       var_i_0d_int_Scalar <= var_NT_0d_int_Scalar; var_i_0d_int_Scalar++) {
                      bool aux_i_read = true;
                      // read LIST body
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                      // assign expression to variable ES
                      var_ES_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                      validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                      aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                      cpp_i++;
                      cpp_j++;
                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                        cont << cpp_draft_line;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        cpp_j = 0;
                      }
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TP", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                      // assign expression to variable TP
                      var_TP_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TP", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                      validate_vartype_consistency("TP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_TP);
                      aux_last_type_read_for_TP = NESTEDVECTOR_DOUBLE;
                      cpp_i++;
                      cpp_j++;
                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                        cont << cpp_draft_line;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        cpp_j = 0;
                      }
                    }
                    if (cpp_i != cpp_npl) {
                      throw std::runtime_error("not exactly NPL elements consumed");
                    }
                  }
                  cont << cpp_draft_line;
                }
              }
              if (! cpp_found_match) {
                if (! cpp_found_match) {
                  if ((((((((aux_LG_read == true)) && ((var_LG_0d_int_Scalar)==(2)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    cpp_template = "[ MAT , 12 , MT / ES_NS , 0.0 , LP , 0 , ((LG+1)*NT) , NT / \n { ES , TP , GP } { i = 1 to NT } ] LIST";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read LIST record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES_NS", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable ES_NS
                    var_ES_NS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES_NS", std::vector<int>({}), py::none()));
                    aux_ES_NS_read = true;
                    validate_vartype_consistency("ES_NS", SCALAR_DOUBLE, aux_last_type_read_for_ES_NS);
                    aux_last_type_read_for_ES_NS = SCALAR_DOUBLE;
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LP", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable LP
                    var_LP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LP", std::vector<int>({}), py::none()));
                    aux_LP_read = true;
                    validate_vartype_consistency("LP", SCALAR_INT, aux_last_type_read_for_LP);
                    aux_last_type_read_for_LP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_index_shifter_store.get_value("LG", std::vector<int>({}), py::none()))+1)*py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()))), write_opts);
                    // assign expression to variable cpp_int_val
                    cpp_int_val = ((py::cast<int>(cpp_index_shifter_store.get_value("LG", std::vector<int>({}), py::none()))+1)*py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())));
                    aux_cpp_int_val_read = true;
                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                    // assign expression to variable NT
                    var_NT_0d_int_Scalar = (cpp_int_val/(var_LG_0d_int_Scalar+1));
                    aux_NT_read = true;
                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                    aux_last_type_read_for_NT = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                    if ((! (aux_NT_read == true))) {
                      // assign expression to variable NT
                      var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                      aux_NT_read = true;
                      validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                      aux_last_type_read_for_NT = SCALAR_INT;
                    } else {
                    }
                    cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_index_shifter_store.get_value("LG", std::vector<int>({}), py::none()))+1)*py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()))), write_opts);
                    cont << cpp_draft_line;
                    {
                      int cpp_npl = ((py::cast<int>(cpp_index_shifter_store.get_value("LG", std::vector<int>({}), py::none()))+1)*py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())));
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read LIST body

                      for (int var_i_0d_int_Scalar = 1;
                         var_i_0d_int_Scalar <= var_NT_0d_int_Scalar; var_i_0d_int_Scalar++) {
                        bool aux_i_read = true;
                        // read LIST body
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable ES
                        var_ES_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                        aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TP", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable TP
                        var_TP_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("TP", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("TP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_TP);
                        aux_last_type_read_for_TP = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GP", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable GP
                        var_GP_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GP", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("GP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GP);
                        aux_last_type_read_for_GP = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cont << cpp_draft_line;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 0244722dd783f7feb5112a1d869b898f
// MD5 hash of the following function definition: b0d909cf2fa9b54bbf374cecce1f2f5c
void write_mf13_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
  bool aux_E_read = false;
  vartype aux_last_type_read_for_E = UNKNOWN;
  std::vector<EndfFloatCpp> var_sigma_tot_0d_floatvec_Scalar;
  bool aux_sigma_tot_read = false;
  vartype aux_last_type_read_for_sigma_tot = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 13;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 13;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 13 , MT / ZA , AWR , 0 , 0 , NK , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none()));
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_NK_read == true)) && ((var_NK_0d_int_Scalar)>(1)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 13 , MT / 0.0 , 0.0 , 0 , 0 , NR , NP / E / sigma_tot ] TAB1";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
        cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
        cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
        cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
        cont << cpp_draft_line;
        tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
        tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("sigma_tot", std::vector<int>({}), py::none()));
        tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
        tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
        write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
        {
          Tab1Body tab_body = tab1_body;
          // assign expression to variable E
          var_E_0d_floatvec_Scalar = tab_body.X;
          aux_E_read = true;
          validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
          aux_last_type_read_for_E = SCALAR_FLOATVEC;
          // assign expression to variable sigma_tot
          var_sigma_tot_0d_floatvec_Scalar = tab_body.Y;
          aux_sigma_tot_read = true;
          validate_vartype_consistency("sigma_tot", SCALAR_FLOATVEC, aux_last_type_read_for_sigma_tot);
          aux_last_type_read_for_sigma_tot = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
        cont << cpp_draft_line;
      }
    }
  }

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.get_value("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_EG_0d_double_Scalar;
      bool aux_EG_read = false;
      vartype aux_last_type_read_for_EG = UNKNOWN;
      EndfFloatCpp var_ES_0d_double_Scalar;
      bool aux_ES_read = false;
      vartype aux_last_type_read_for_ES = UNKNOWN;
      int var_LP_0d_int_Scalar;
      bool aux_LP_read = false;
      vartype aux_last_type_read_for_LP = UNKNOWN;
      int var_LF_0d_int_Scalar;
      bool aux_LF_read = false;
      vartype aux_last_type_read_for_LF = UNKNOWN;
      std::vector<EndfFloatCpp> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      vartype aux_last_type_read_for_E = UNKNOWN;
      std::vector<EndfFloatCpp> var_sigma_0d_floatvec_Scalar;
      bool aux_sigma_read = false;
      vartype aux_last_type_read_for_sigma = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      cpp_template = "[ MAT , 13 , MT / EG , ES , LP , LF , NR , NP / E / sigma ] TAB1";
      // read TAB1 record
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EG", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable EG
      var_EG_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EG", std::vector<int>({}), py::none()));
      aux_EG_read = true;
      validate_vartype_consistency("EG", SCALAR_DOUBLE, aux_last_type_read_for_EG);
      aux_last_type_read_for_EG = SCALAR_DOUBLE;
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable ES
      var_ES_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({}), py::none()));
      aux_ES_read = true;
      validate_vartype_consistency("ES", SCALAR_DOUBLE, aux_last_type_read_for_ES);
      aux_last_type_read_for_ES = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LP", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable LP
      var_LP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LP", std::vector<int>({}), py::none()));
      aux_LP_read = true;
      validate_vartype_consistency("LP", SCALAR_INT, aux_last_type_read_for_LP);
      aux_last_type_read_for_LP = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable LF
      var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none()));
      aux_LF_read = true;
      validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
      aux_last_type_read_for_LF = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
      cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
      cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none())), write_opts);
      cpp_np_val = py::len(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
      cont << cpp_draft_line;
      tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("E", std::vector<int>({}), py::none()));
      tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("sigma", std::vector<int>({}), py::none()));
      tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
      tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
      write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
      {
        Tab1Body tab_body = tab1_body;
        if ((! (aux_E_read == true))) {
          // assign expression to variable E
          var_E_0d_floatvec_Scalar = tab_body.X;
          aux_E_read = true;
          validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
          aux_last_type_read_for_E = SCALAR_FLOATVEC;
        } else {
        }
        // assign expression to variable sigma
        var_sigma_0d_floatvec_Scalar = tab_body.Y;
        aux_sigma_read = true;
        validate_vartype_consistency("sigma", SCALAR_FLOATVEC, aux_last_type_read_for_sigma);
        aux_last_type_read_for_sigma = SCALAR_FLOATVEC;
        if ((! (aux_INT_read == true))) {
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
        } else {
        }
        if ((! (aux_NBT_read == true))) {
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        } else {
        }
      }
      cont << cpp_draft_line;
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: cbb953767d4afb465ff9cee335ea03ef
// MD5 hash of the following function definition: 0cb81981a6c347bda9ef35afbfd4e7ce
void write_mf14_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LI_0d_int_Scalar;
  bool aux_LI_read = false;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  int var_LTT_0d_int_Scalar;
  bool aux_LTT_read = false;
  vartype aux_last_type_read_for_LTT = UNKNOWN;
  int var_NI_0d_int_Scalar;
  bool aux_NI_read = false;
  vartype aux_last_type_read_for_NI = UNKNOWN;
  NestedVector<EndfFloatCpp> var_EG_1d_double_NestedVector;
  vartype aux_last_type_read_for_EG = UNKNOWN;
  NestedVector<EndfFloatCpp> var_ES_1d_double_NestedVector;
  vartype aux_last_type_read_for_ES = UNKNOWN;
  NestedVector<int> var_NE_1d_int_NestedVector;
  vartype aux_last_type_read_for_NE = UNKNOWN;
  NestedVector<NestedVector<EndfFloatCpp>> var_E_2d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_E_2d_idx0;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<NestedVector<int>> var_NL_2d_int_NestedVector;
  NestedVector<int>* ptr_NL_2d_idx0;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  NestedVector<NestedVector<NestedVector<EndfFloatCpp>>> var_a_3d_double_NestedVector;
  NestedVector<EndfFloatCpp>* ptr_a_3d_idx1;
  NestedVector<NestedVector<EndfFloatCpp>>* ptr_a_3d_idx0;
  vartype aux_last_type_read_for_a = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 14;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 14;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
          int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
          bool& glob_aux_LI_read = aux_LI_read;
          bool aux_LI_read = glob_aux_LI_read;
          vartype aux_last_type_read_for_LI = UNKNOWN;
          int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
          int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
          bool& glob_aux_NK_read = aux_NK_read;
          bool aux_NK_read = glob_aux_NK_read;
          vartype aux_last_type_read_for_NK = UNKNOWN;
          try {
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , 0 , NK , 0 ] HEAD";
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::cast(-99999.9)));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::cast(-99999.9)));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LI
            var_LI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::cast(-99999)));
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            // assign expression to variable NK
            var_NK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::cast(-99999)));
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
          } catch (const std::out_of_range& e) {
            // // accept failure in lookahead
          }
          if ((((((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(1)))))))) {
            cpp_found_match = true;
          }
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , 0 , NK , 0 ] HEAD";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read CONT record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LI
          var_LI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none()));
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NK
          var_NK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none()));
          aux_NK_read = true;
          validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
          aux_last_type_read_for_NK = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
            int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
            bool& glob_aux_LI_read = aux_LI_read;
            bool aux_LI_read = glob_aux_LI_read;
            vartype aux_last_type_read_for_LI = UNKNOWN;
            int& glob_var_LTT_0d_int_Scalar = var_LTT_0d_int_Scalar;
            int var_LTT_0d_int_Scalar = glob_var_LTT_0d_int_Scalar;
            bool& glob_aux_LTT_read = aux_LTT_read;
            bool aux_LTT_read = glob_aux_LTT_read;
            vartype aux_last_type_read_for_LTT = UNKNOWN;
            int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
            int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
            bool& glob_aux_NK_read = aux_NK_read;
            bool aux_NK_read = glob_aux_NK_read;
            vartype aux_last_type_read_for_NK = UNKNOWN;
            int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
            int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
            bool& glob_aux_NI_read = aux_NI_read;
            bool aux_NI_read = glob_aux_NI_read;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            try {
              cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::cast(-99999.9)));
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::cast(-99999.9)));
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LI
              var_LI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::cast(-99999)));
              aux_LI_read = true;
              validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
              aux_last_type_read_for_LI = SCALAR_INT;
              // assign expression to variable LTT
              var_LTT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LTT", std::vector<int>({}), py::cast(-99999)));
              aux_LTT_read = true;
              validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
              aux_last_type_read_for_LTT = SCALAR_INT;
              // assign expression to variable NK
              var_NK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::cast(-99999)));
              aux_NK_read = true;
              validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
              aux_last_type_read_for_NK = SCALAR_INT;
              // assign expression to variable NI
              var_NI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::cast(-99999)));
              aux_NI_read = true;
              validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
              aux_last_type_read_for_NI = SCALAR_INT;
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if (((((((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))&&((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(1)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read CONT record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LI
            var_LI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none()));
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LTT", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LTT
            var_LTT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LTT", std::vector<int>({}), py::none()));
            aux_LTT_read = true;
            validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
            aux_last_type_read_for_LTT = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NK
            var_NK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none()));
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NI
            var_NI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none()));
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
            cont << cpp_draft_line;

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NI_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              cpp_template = "[ MAT , 14 , MT / EG , ES , 0 , 0 , 0 , 0 ] CONT";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read CONT record
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EG", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable EG
              var_EG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EG", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("EG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EG);
              aux_last_type_read_for_EG = NESTEDVECTOR_DOUBLE;
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable ES
              var_ES_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
              aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
              cont << cpp_draft_line;
            }

            for (int var_k_0d_int_Scalar = (var_NI_0d_int_Scalar+1);
               var_k_0d_int_Scalar <= (var_NI_0d_int_Scalar+(var_NK_0d_int_Scalar-var_NI_0d_int_Scalar)); var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              cpp_template = "[ MAT , 14 , MT / EG , ES , 0 , 0 , NR , NE / E ] TAB2 ( E_interpol [ k ] )";
              // read TAB2 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EG", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              if ((! var_EG_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
                // assign expression to variable EG
                var_EG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EG", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("EG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EG);
                aux_last_type_read_for_EG = NESTEDVECTOR_DOUBLE;
              } else {
              }
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              if ((! var_ES_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
                // assign expression to variable ES
                var_ES_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ES", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
              } else {
              }
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable NE
              var_NE_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("NE", NESTEDVECTOR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = NESTEDVECTOR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.get_value("E_interpol", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                cont << cpp_draft_line;
                tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
                // variable declarations
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab2Body tab_body = tab2_body;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
                cpp_current_dict = cpp_parent_dict;
              }
              ptr_E_2d_idx0 = var_E_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
              ptr_a_3d_idx0 = var_a_3d_double_NestedVector.prepare(var_k_0d_int_Scalar);

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NE_1d_int_NestedVector[var_k_0d_int_Scalar]; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                cpp_template = "[ MAT , 14 , MT / 0.0 , E , 0 , 0 , NL , 0 / \n { a } { m = 1 to NL } ] LIST";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                // read LIST record
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable E
                ptr_E_2d_idx0->set(var_l_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable NL
                ptr_NL_2d_idx0 = var_NL_2d_int_NestedVector.prepare(var_k_0d_int_Scalar);
                ptr_NL_2d_idx0->set(var_l_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())), write_opts);
                cont << cpp_draft_line;
                {
                  int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none()));
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  // read LIST body
                  ptr_a_3d_idx1 = ptr_a_3d_idx0->prepare(var_l_0d_int_Scalar);

                  for (int var_m_0d_int_Scalar = 1;
                     var_m_0d_int_Scalar <= var_NL_2d_int_NestedVector[var_k_0d_int_Scalar][var_l_0d_int_Scalar]; var_m_0d_int_Scalar++) {
                    bool aux_m_read = true;
                    // read LIST body
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("a", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
                    // assign expression to variable a
                    ptr_a_3d_idx1->set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("a", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
                    validate_vartype_consistency("a", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_a);
                    aux_last_type_read_for_a = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cont << cpp_draft_line;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      cpp_j = 0;
                    }
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
                cont << cpp_draft_line;
              }
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            EndfFloatCpp& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            EndfFloatCpp var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            EndfFloatCpp& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            EndfFloatCpp var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
            int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
            bool& glob_aux_LI_read = aux_LI_read;
            bool aux_LI_read = glob_aux_LI_read;
            vartype aux_last_type_read_for_LI = UNKNOWN;
            int& glob_var_LTT_0d_int_Scalar = var_LTT_0d_int_Scalar;
            int var_LTT_0d_int_Scalar = glob_var_LTT_0d_int_Scalar;
            bool& glob_aux_LTT_read = aux_LTT_read;
            bool aux_LTT_read = glob_aux_LTT_read;
            vartype aux_last_type_read_for_LTT = UNKNOWN;
            int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
            int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
            bool& glob_aux_NK_read = aux_NK_read;
            bool aux_NK_read = glob_aux_NK_read;
            vartype aux_last_type_read_for_NK = UNKNOWN;
            int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
            int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
            bool& glob_aux_NI_read = aux_NI_read;
            bool aux_NI_read = glob_aux_NI_read;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            try {
              cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
              // read CONT record
              // assign expression to variable ZA
              var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::cast(-99999.9)));
              aux_ZA_read = true;
              validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
              aux_last_type_read_for_ZA = SCALAR_DOUBLE;
              // assign expression to variable AWR
              var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::cast(-99999.9)));
              aux_AWR_read = true;
              validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
              aux_last_type_read_for_AWR = SCALAR_DOUBLE;
              // assign expression to variable LI
              var_LI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::cast(-99999)));
              aux_LI_read = true;
              validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
              aux_last_type_read_for_LI = SCALAR_INT;
              // assign expression to variable LTT
              var_LTT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LTT", std::vector<int>({}), py::cast(-99999)));
              aux_LTT_read = true;
              validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
              aux_last_type_read_for_LTT = SCALAR_INT;
              // assign expression to variable NK
              var_NK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::cast(-99999)));
              aux_NK_read = true;
              validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
              aux_last_type_read_for_NK = SCALAR_INT;
              // assign expression to variable NI
              var_NI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::cast(-99999)));
              aux_NI_read = true;
              validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
              aux_last_type_read_for_NI = SCALAR_INT;
            } catch (const std::out_of_range& e) {
              // // accept failure in lookahead
            }
            if (((((((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))&&((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(2)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read CONT record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LI
            var_LI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LI", std::vector<int>({}), py::none()));
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LTT", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable LTT
            var_LTT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LTT", std::vector<int>({}), py::none()));
            aux_LTT_read = true;
            validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
            aux_last_type_read_for_LTT = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NK
            var_NK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none()));
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NI
            var_NI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none()));
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
            cont << cpp_draft_line;
            throw std::runtime_error("Encountered STOP instruction in recipe: Case LI=0, LTT=2 not implemented in ENDF recipe for MF14");
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: d686a05ea85d12021bed42716983796f
// MD5 hash of the following function definition: 980261bbedd714a182b591457e398f50
void write_mf15_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 15;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 15;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 15 , MT / ZA , AWR , 0 , 0 , NC , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NC
  var_NC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none()));
  aux_NC_read = true;
  validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
  aux_last_type_read_for_NC = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_j_0d_int_Scalar = 1;
     var_j_0d_int_Scalar <= var_NC_0d_int_Scalar; var_j_0d_int_Scalar++) {
    bool aux_j_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.get_value("subsection", std::vector<int>({var_j_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      int var_LF_0d_int_Scalar;
      bool aux_LF_read = false;
      vartype aux_last_type_read_for_LF = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            {
              // variable declarations
              int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
              int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
              bool& glob_aux_LF_read = aux_LF_read;
              bool aux_LF_read = glob_aux_LF_read;
              vartype aux_last_type_read_for_LF = UNKNOWN;
              try {
                cpp_template = "[ MAT , 15 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / Eint / p ] TAB1 ( rtfm_tab1 )";
                // read TAB1 record
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::cast(-99999)));
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
              } catch (const std::out_of_range& e) {
                // // accept failure in lookahead
              }
              if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(1)))))))) {
                cpp_found_match = true;
              }
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 15 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / Eint / p ] TAB1 ( rtfm_tab1 )";
              // read TAB1 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable LF
              var_LF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LF", std::vector<int>({}), py::none()));
              aux_LF_read = true;
              validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
              aux_last_type_read_for_LF = SCALAR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.get_value("rtfm_tab1", std::vector<int>({}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
                cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                cont << cpp_draft_line;
                tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
                tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("p", std::vector<int>({}), py::none()));
                tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                // variable declarations
                std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
                bool aux_Eint_read = false;
                vartype aux_last_type_read_for_Eint = UNKNOWN;
                std::vector<EndfFloatCpp> var_p_0d_floatvec_Scalar;
                bool aux_p_read = false;
                vartype aux_last_type_read_for_p = UNKNOWN;
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab1Body tab_body = tab1_body;
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
                cpp_current_dict = cpp_parent_dict;
              }
              cpp_template = "[ MAT , 15 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
              // read TAB2 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
              cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              cont << cpp_draft_line;
              tab2_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
              tab2_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
              write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
              {
                Tab2Body tab_body = tab2_body;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              cont << cpp_draft_line;

              for (int var_k_0d_int_Scalar = 1;
                 var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                bool aux_k_read = true;
                cpp_template = "[ MAT , 15 , MT / 0.0 , E , 0 , 0 , NR , NP / Egamma / g ] TAB1 ( rtfm1_tab [ k ] )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  cpp_current_dict = cpp_index_shifter_store.get_value("rtfm1_tab", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
                  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
                  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Egamma", std::vector<int>({}), py::none())), write_opts);
                  cpp_np_val = py::len(cpp_index_shifter_store.get_value("Egamma", std::vector<int>({}), py::none()));
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Egamma", std::vector<int>({}), py::none()));
                  tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("g", std::vector<int>({}), py::none()));
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<EndfFloatCpp> var_Egamma_0d_floatvec_Scalar;
                  bool aux_Egamma_read = false;
                  vartype aux_last_type_read_for_Egamma = UNKNOWN;
                  std::vector<EndfFloatCpp> var_g_0d_floatvec_Scalar;
                  bool aux_g_read = false;
                  vartype aux_last_type_read_for_g = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable Egamma
                    var_Egamma_0d_floatvec_Scalar = tab_body.X;
                    aux_Egamma_read = true;
                    validate_vartype_consistency("Egamma", SCALAR_FLOATVEC, aux_last_type_read_for_Egamma);
                    aux_last_type_read_for_Egamma = SCALAR_FLOATVEC;
                    // assign expression to variable g
                    var_g_0d_floatvec_Scalar = tab_body.Y;
                    aux_g_read = true;
                    validate_vartype_consistency("g", SCALAR_FLOATVEC, aux_last_type_read_for_g);
                    aux_last_type_read_for_g = SCALAR_FLOATVEC;
                    if ((! (aux_INT_read == true))) {
                      // assign expression to variable INT
                      var_INT_0d_intvec_Scalar = tab_body.INT;
                      aux_INT_read = true;
                      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                      aux_last_type_read_for_INT = SCALAR_INTVEC;
                    } else {
                    }
                    if ((! (aux_NBT_read == true))) {
                      // assign expression to variable NBT
                      var_NBT_0d_intvec_Scalar = tab_body.NBT;
                      aux_NBT_read = true;
                      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                      aux_last_type_read_for_NBT = SCALAR_INTVEC;
                    } else {
                    }
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 5557baba7f951e2762c63f317ba874b9
// MD5 hash of the following function definition: 7df5df522739239372d7222827c8681f
void write_mf23_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  EndfFloatCpp var_EPE_0d_double_Scalar;
  bool aux_EPE_read = false;
  vartype aux_last_type_read_for_EPE = UNKNOWN;
  EndfFloatCpp var_EFL_0d_double_Scalar;
  bool aux_EFL_read = false;
  vartype aux_last_type_read_for_EFL = UNKNOWN;
  std::vector<EndfFloatCpp> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<EndfFloatCpp> var_sigma_0d_floatvec_Scalar;
  bool aux_sigma_read = false;
  vartype aux_last_type_read_for_sigma = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 23;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 23;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 23 , MT / ZA , AWR , 0 , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 23 , MT / EPE , EFL , 0 , 0 , NR , NP / Eint / sigma ] TAB1";
  // read TAB1 record
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EPE", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable EPE
  var_EPE_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EPE", std::vector<int>({}), py::none()));
  aux_EPE_read = true;
  validate_vartype_consistency("EPE", SCALAR_DOUBLE, aux_last_type_read_for_EPE);
  aux_last_type_read_for_EPE = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EFL", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable EFL
  var_EFL_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EFL", std::vector<int>({}), py::none()));
  aux_EFL_read = true;
  validate_vartype_consistency("EFL", SCALAR_DOUBLE, aux_last_type_read_for_EFL);
  aux_last_type_read_for_EFL = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none())), write_opts);
  cpp_np_val = py::len(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
  cont << cpp_draft_line;
  tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("Eint", std::vector<int>({}), py::none()));
  tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("sigma", std::vector<int>({}), py::none()));
  tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
  tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
  {
    Tab1Body tab_body = tab1_body;
    // assign expression to variable Eint
    var_Eint_0d_floatvec_Scalar = tab_body.X;
    aux_Eint_read = true;
    validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
    aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
    // assign expression to variable sigma
    var_sigma_0d_floatvec_Scalar = tab_body.Y;
    aux_sigma_read = true;
    validate_vartype_consistency("sigma", SCALAR_FLOATVEC, aux_last_type_read_for_sigma);
    aux_last_type_read_for_sigma = SCALAR_FLOATVEC;
    // assign expression to variable INT
    var_INT_0d_intvec_Scalar = tab_body.INT;
    aux_INT_read = true;
    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
    aux_last_type_read_for_INT = SCALAR_INTVEC;
    // assign expression to variable NBT
    var_NBT_0d_intvec_Scalar = tab_body.NBT;
    aux_NBT_read = true;
    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
    aux_last_type_read_for_NBT = SCALAR_INTVEC;
  }
  cont << cpp_draft_line;
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 3f70d967823f46b1bb1f3b072c33eced
// MD5 hash of the following function definition: 944d6499ac88da9429725e21965475d4
void write_mf26_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 26;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 26;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  throw std::runtime_error("Encountered STOP instruction in recipe: ENDF recipe for MF26 is not implemented");
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 20ce9f620fd87cc4c048529da1906a0e
// MD5 hash of the following function definition: a221fb9f4327335505ef8039ea726c95
void write_mf27_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  EndfFloatCpp var_Z_0d_double_Scalar;
  bool aux_Z_read = false;
  vartype aux_last_type_read_for_Z = UNKNOWN;
  std::vector<EndfFloatCpp> var_xint_0d_floatvec_Scalar;
  bool aux_xint_read = false;
  vartype aux_last_type_read_for_xint = UNKNOWN;
  std::vector<EndfFloatCpp> var_H_0d_floatvec_Scalar;
  bool aux_H_read = false;
  vartype aux_last_type_read_for_H = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 27;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 27;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 27 , MT / ZA , AWR , 0 , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 27 , MT / 0.0 , Z , 0 , 0 , NR , NP / xint / H ] TAB1";
  // read TAB1 record
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Z", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable Z
  var_Z_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Z", std::vector<int>({}), py::none()));
  aux_Z_read = true;
  validate_vartype_consistency("Z", SCALAR_DOUBLE, aux_last_type_read_for_Z);
  aux_last_type_read_for_Z = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none())), write_opts);
  cpp_nr_val = py::len(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_index_shifter_store.get_value("xint", std::vector<int>({}), py::none())), write_opts);
  cpp_np_val = py::len(cpp_index_shifter_store.get_value("xint", std::vector<int>({}), py::none()));
  cont << cpp_draft_line;
  tab1_body.X = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("xint", std::vector<int>({}), py::none()));
  tab1_body.Y = py::cast<std::vector<EndfFloatCpp>>(cpp_index_shifter_store.get_value("H", std::vector<int>({}), py::none()));
  tab1_body.INT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("INT", std::vector<int>({}), py::none()));
  tab1_body.NBT = py::cast<std::vector<int>>(cpp_index_shifter_store.get_value("NBT", std::vector<int>({}), py::none()));
  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
  {
    Tab1Body tab_body = tab1_body;
    // assign expression to variable xint
    var_xint_0d_floatvec_Scalar = tab_body.X;
    aux_xint_read = true;
    validate_vartype_consistency("xint", SCALAR_FLOATVEC, aux_last_type_read_for_xint);
    aux_last_type_read_for_xint = SCALAR_FLOATVEC;
    // assign expression to variable H
    var_H_0d_floatvec_Scalar = tab_body.Y;
    aux_H_read = true;
    validate_vartype_consistency("H", SCALAR_FLOATVEC, aux_last_type_read_for_H);
    aux_last_type_read_for_H = SCALAR_FLOATVEC;
    // assign expression to variable INT
    var_INT_0d_intvec_Scalar = tab_body.INT;
    aux_INT_read = true;
    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
    aux_last_type_read_for_INT = SCALAR_INTVEC;
    // assign expression to variable NBT
    var_NBT_0d_intvec_Scalar = tab_body.NBT;
    aux_NBT_read = true;
    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
    aux_last_type_read_for_NBT = SCALAR_INTVEC;
  }
  cont << cpp_draft_line;
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 04f3c92d2aa669d9b265ca0bc15b6e1f
// MD5 hash of the following function definition: 6c46a489b7503845cba5fd29eaf3cdf0
void write_mf28_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 28;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 28;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  throw std::runtime_error("Encountered STOP instruction in recipe: ENDF recipe for MF28 not implemented");
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 485a4917898fb80f8e6522571893a9e5
// MD5 hash of the following function definition: 7e714fec8832ed216de1594d9964aa47
void write_mf31_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_MTL_0d_int_Scalar;
  bool aux_MTL_read = false;
  vartype aux_last_type_read_for_MTL = UNKNOWN;
  int var_NL_0d_int_Scalar;
  bool aux_NL_read = false;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 31;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 31;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 31 , MT / ZA , AWR , 0 , MTL , 0 , NL ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MTL", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable MTL
  var_MTL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MTL", std::vector<int>({}), py::none()));
  aux_MTL_read = true;
  validate_vartype_consistency("MTL", SCALAR_INT, aux_last_type_read_for_MTL);
  aux_last_type_read_for_MTL = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NL
  var_NL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::none()));
  aux_NL_read = true;
  validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
  aux_last_type_read_for_NL = SCALAR_INT;
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_MTL_read == true)) && ((var_MTL_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;

        for (int var_n_0d_int_Scalar = 1;
           var_n_0d_int_Scalar <= var_NL_0d_int_Scalar; var_n_0d_int_Scalar++) {
          bool aux_n_read = true;
          // open section subsection
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.get_value("subsection", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            // variable declarations
            EndfFloatCpp var_XMF1_0d_double_Scalar;
            bool aux_XMF1_read = false;
            vartype aux_last_type_read_for_XMF1 = UNKNOWN;
            EndfFloatCpp var_XLFS1_0d_double_Scalar;
            bool aux_XLFS1_read = false;
            vartype aux_last_type_read_for_XLFS1 = UNKNOWN;
            int var_MAT1_0d_int_Scalar;
            bool aux_MAT1_read = false;
            vartype aux_last_type_read_for_MAT1 = UNKNOWN;
            int var_MT1_0d_int_Scalar;
            bool aux_MT1_read = false;
            vartype aux_last_type_read_for_MT1 = UNKNOWN;
            int var_NC_0d_int_Scalar;
            bool aux_NC_read = false;
            vartype aux_last_type_read_for_NC = UNKNOWN;
            int var_NI_0d_int_Scalar;
            bool aux_NI_read = false;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            cpp_template = "[ MAT , 31 , MT / XMF1 , XLFS1 , MAT1 , MT1 , NC , NI ] CONT";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read CONT record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMF1", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable XMF1
            var_XMF1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMF1", std::vector<int>({}), py::none()));
            aux_XMF1_read = true;
            validate_vartype_consistency("XMF1", SCALAR_DOUBLE, aux_last_type_read_for_XMF1);
            aux_last_type_read_for_XMF1 = SCALAR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XLFS1", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable XLFS1
            var_XLFS1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XLFS1", std::vector<int>({}), py::none()));
            aux_XLFS1_read = true;
            validate_vartype_consistency("XLFS1", SCALAR_DOUBLE, aux_last_type_read_for_XLFS1);
            aux_last_type_read_for_XLFS1 = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("MAT1", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable MAT1
            var_MAT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT1", std::vector<int>({}), py::none()));
            aux_MAT1_read = true;
            validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
            aux_last_type_read_for_MAT1 = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MT1", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable MT1
            var_MT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT1", std::vector<int>({}), py::none()));
            aux_MT1_read = true;
            validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
            aux_last_type_read_for_MT1 = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NC
            var_NC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none()));
            aux_NC_read = true;
            validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
            aux_last_type_read_for_NC = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NI
            var_NI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none()));
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
            cont << cpp_draft_line;

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NC_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section nc_subsection
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.get_value("nc_subsection", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                // variable declarations
                int var_LTY_0d_int_Scalar;
                bool aux_LTY_read = false;
                vartype aux_last_type_read_for_LTY = UNKNOWN;
                EndfFloatCpp var_E1_0d_double_Scalar;
                bool aux_E1_read = false;
                vartype aux_last_type_read_for_E1 = UNKNOWN;
                EndfFloatCpp var_E2_0d_double_Scalar;
                bool aux_E2_read = false;
                vartype aux_last_type_read_for_E2 = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NCI_0d_int_Scalar;
                bool aux_NCI_read = false;
                vartype aux_last_type_read_for_NCI = UNKNOWN;
                NestedVector<EndfFloatCpp> var_C_1d_double_NestedVector;
                vartype aux_last_type_read_for_C = UNKNOWN;
                NestedVector<EndfFloatCpp> var_XMT_1d_double_NestedVector;
                vartype aux_last_type_read_for_XMT = UNKNOWN;
                int var_MATS_0d_int_Scalar;
                bool aux_MATS_read = false;
                vartype aux_last_type_read_for_MATS = UNKNOWN;
                int var_MTS_0d_int_Scalar;
                bool aux_MTS_read = false;
                vartype aux_last_type_read_for_MTS = UNKNOWN;
                int var_NEI_0d_int_Scalar;
                bool aux_NEI_read = false;
                vartype aux_last_type_read_for_NEI = UNKNOWN;
                EndfFloatCpp var_XMFS_0d_double_Scalar;
                bool aux_XMFS_read = false;
                vartype aux_last_type_read_for_XMFS = UNKNOWN;
                EndfFloatCpp var_XLFSS_0d_double_Scalar;
                bool aux_XLFSS_read = false;
                vartype aux_last_type_read_for_XLFSS = UNKNOWN;
                NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                NestedVector<EndfFloatCpp> var_WE_1d_double_NestedVector;
                vartype aux_last_type_read_for_WE = UNKNOWN;
                cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                // read CONT record
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LTY", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable LTY
                var_LTY_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LTY", std::vector<int>({}), py::none()));
                aux_LTY_read = true;
                validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                aux_last_type_read_for_LTY = SCALAR_INT;
                cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                cont << cpp_draft_line;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if ((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(0)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      cpp_template = "[ MAT , 31 , MT / E1 , E2 , 0 , 0 , (2*NCI) , NCI / \n { C , XMT } { i = 1 to NCI } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read LIST record
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable E1
                      var_E1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none()));
                      aux_E1_read = true;
                      validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                      aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable E2
                      var_E2_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none()));
                      aux_E2_read = true;
                      validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                      aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none()))), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none())));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NCI
                      var_NCI_0d_int_Scalar = (cpp_int_val/2);
                      aux_NCI_read = true;
                      validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                      aux_last_type_read_for_NCI = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none())), write_opts);
                      if ((! (aux_NCI_read == true))) {
                        // assign expression to variable NCI
                        var_NCI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none()));
                        aux_NCI_read = true;
                        validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                        aux_last_type_read_for_NCI = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none()))), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (2*py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none())));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST body

                        for (int var_i_0d_int_Scalar = 1;
                           var_i_0d_int_Scalar <= var_NCI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                          bool aux_i_read = true;
                          // read LIST body
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("C", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable C
                          var_C_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("C", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
                          aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMT", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable XMT
                          var_XMT_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMT", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("XMT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_XMT);
                          aux_last_type_read_for_XMT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if (((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)>=(1)))))&&((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)<=(3)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 31 , MT / E1 , E2 , MATS , MTS , ((2*NEI)+2) , NEI / \n XMFS , XLFSS , { E , WE } { i = 1 to NEI } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable E1
                        var_E1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none()));
                        aux_E1_read = true;
                        validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                        aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable E2
                        var_E2_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none()));
                        aux_E2_read = true;
                        validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                        aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("MATS", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable MATS
                        var_MATS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MATS", std::vector<int>({}), py::none()));
                        aux_MATS_read = true;
                        validate_vartype_consistency("MATS", SCALAR_INT, aux_last_type_read_for_MATS);
                        aux_last_type_read_for_MATS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MTS", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable MTS
                        var_MTS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MTS", std::vector<int>({}), py::none()));
                        aux_MTS_read = true;
                        validate_vartype_consistency("MTS", SCALAR_INT, aux_last_type_read_for_MTS);
                        aux_last_type_read_for_MTS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, ((2*py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())))+2), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = ((2*py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())))+2);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NEI
                        var_NEI_0d_int_Scalar = ((cpp_int_val+(-2))/2);
                        aux_NEI_read = true;
                        validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                        aux_last_type_read_for_NEI = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())), write_opts);
                        if ((! (aux_NEI_read == true))) {
                          // assign expression to variable NEI
                          var_NEI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none()));
                          aux_NEI_read = true;
                          validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                          aux_last_type_read_for_NEI = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, ((2*py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())))+2), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = ((2*py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())))+2);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMFS", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable XMFS
                          var_XMFS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMFS", std::vector<int>({}), py::none()));
                          aux_XMFS_read = true;
                          validate_vartype_consistency("XMFS", SCALAR_DOUBLE, aux_last_type_read_for_XMFS);
                          aux_last_type_read_for_XMFS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XLFSS", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable XLFSS
                          var_XLFSS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XLFSS", std::vector<int>({}), py::none()));
                          aux_XLFSS_read = true;
                          validate_vartype_consistency("XLFSS", SCALAR_DOUBLE, aux_last_type_read_for_XLFSS);
                          aux_last_type_read_for_XLFSS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }

                          for (int var_i_0d_int_Scalar = 1;
                             var_i_0d_int_Scalar <= var_NEI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                            bool aux_i_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("WE", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable WE
                            var_WE_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("WE", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("WE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_WE);
                            aux_last_type_read_for_WE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NI_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section ni_subsection
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.get_value("ni_subsection", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                // variable declarations
                int var_LT_0d_int_Scalar;
                bool aux_LT_read = false;
                vartype aux_last_type_read_for_LT = UNKNOWN;
                int var_LB_0d_int_Scalar;
                bool aux_LB_read = false;
                vartype aux_last_type_read_for_LB = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NP_0d_int_Scalar;
                bool aux_NP_read = false;
                vartype aux_last_type_read_for_NP = UNKNOWN;
                NestedVector<EndfFloatCpp> var_Ek_1d_double_NestedVector;
                vartype aux_last_type_read_for_Ek = UNKNOWN;
                NestedVector<EndfFloatCpp> var_Fk_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fk = UNKNOWN;
                NestedVector<EndfFloatCpp> var_El_1d_double_NestedVector;
                vartype aux_last_type_read_for_El = UNKNOWN;
                NestedVector<EndfFloatCpp> var_Fl_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fl = UNKNOWN;
                int var_LS_0d_int_Scalar;
                bool aux_LS_read = false;
                vartype aux_last_type_read_for_LS = UNKNOWN;
                int var_NE_0d_int_Scalar;
                bool aux_NE_read = false;
                vartype aux_last_type_read_for_NE = UNKNOWN;
                NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                Matrix2d<EndfFloatCpp> var_F_2d_double_Matrix2d;
                vartype aux_last_type_read_for_F = UNKNOWN;
                int var_NER_0d_int_Scalar;
                bool aux_NER_read = false;
                vartype aux_last_type_read_for_NER = UNKNOWN;
                int var_NEC_0d_int_Scalar;
                bool aux_NEC_read = false;
                vartype aux_last_type_read_for_NEC = UNKNOWN;
                NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                vartype aux_last_type_read_for_ER = UNKNOWN;
                NestedVector<EndfFloatCpp> var_EC_1d_double_NestedVector;
                vartype aux_last_type_read_for_EC = UNKNOWN;
                NestedVector<EndfFloatCpp> var_F_1d_double_NestedVector;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                        int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                        bool& glob_aux_LT_read = aux_LT_read;
                        bool aux_LT_read = glob_aux_LT_read;
                        vartype aux_last_type_read_for_LT = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_cpp_int_val = cpp_int_val;
                        int cpp_int_val = glob_cpp_int_val;
                        bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                        bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                        int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                        bool& glob_aux_NP_read = aux_NP_read;
                        bool aux_NP_read = glob_aux_NP_read;
                        vartype aux_last_type_read_for_NP = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                          // read LIST record
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::cast(-99999)));
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::cast(-99999))));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::cast(-99999)));
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)>=(0)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)<=(4)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none()));
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()))), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())));
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())), write_opts);
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()));
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()))), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= (var_NP_0d_int_Scalar-var_LT_0d_int_Scalar); var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Ek", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable Ek
                            var_Ek_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Ek", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("Ek", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ek);
                            aux_last_type_read_for_Ek = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Fk", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable Fk
                            var_Fk_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Fk", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("Fk", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fk);
                            aux_last_type_read_for_Fk = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_LT_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("El", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable El
                            var_El_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("El", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("El", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_El);
                            aux_last_type_read_for_El = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Fl", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable Fl
                            var_Fl_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Fl", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("Fl", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fl);
                            aux_last_type_read_for_Fl = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                            // read LIST record
                            // assign expression to variable LS
                            var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::cast(-99999)));
                            aux_LS_read = true;
                            validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                            aux_last_type_read_for_LS = SCALAR_INT;
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable NE
                            var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::cast(-99999)));
                            aux_NE_read = true;
                            validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                            aux_last_type_read_for_NE = SCALAR_INT;
                            if ((! (aux_NE_read == true))) {
                              throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE-1))+1) , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none()));
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))-1))+1), write_opts);
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))-1))+1), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = ((py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))-1))+1);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = 1;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar, var_kp_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar, var_kp_0d_int_Scalar}), py::none()));
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                            // read LIST record
                            // assign expression to variable LS
                            var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::cast(-99999)));
                            aux_LS_read = true;
                            validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                            aux_last_type_read_for_LS = SCALAR_INT;
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable NE
                            var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::cast(-99999)));
                            aux_NE_read = true;
                            validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                            aux_last_type_read_for_NE = SCALAR_INT;
                            if ((! (aux_NE_read == true))) {
                              throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE+1))/2) , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none()));
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))+1))/2), write_opts);
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))+1))/2), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = ((py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))+1))/2);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = var_k_0d_int_Scalar;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar, var_kp_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar, var_kp_0d_int_Scalar}), py::none()));
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NER_0d_int_Scalar = var_NER_0d_int_Scalar;
                          int var_NER_0d_int_Scalar = glob_var_NER_0d_int_Scalar;
                          bool& glob_aux_NER_read = aux_NER_read;
                          bool aux_NER_read = glob_aux_NER_read;
                          vartype aux_last_type_read_for_NER = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NEC_0d_int_Scalar = var_NEC_0d_int_Scalar;
                          int var_NEC_0d_int_Scalar = glob_var_NEC_0d_int_Scalar;
                          bool& glob_aux_NEC_read = aux_NEC_read;
                          bool aux_NEC_read = glob_aux_NEC_read;
                          vartype aux_last_type_read_for_NEC = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                            // read LIST record
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::cast(-99999)));
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::cast(-99999)))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::cast(-99999)))));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NEC
                            var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                            aux_NEC_read = true;
                            validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                            aux_last_type_read_for_NEC = SCALAR_INT;
                            if ((! (aux_NER_read == true))) {
                              // assign expression to variable cpp_int_val
                              cpp_int_val = (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::cast(-99999)))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::cast(-99999)))));
                              aux_cpp_int_val_read = true;
                              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                              // assign expression to variable NER
                              var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                              aux_NER_read = true;
                              validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                              aux_last_type_read_for_NER = SCALAR_INT;
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if ((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(6)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , 0 , LB , (1+(NER*NEC)) , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()));
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::none())))), write_opts);
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::none()))));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NEC
                          var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                          aux_NEC_read = true;
                          validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                          aux_last_type_read_for_NEC = SCALAR_INT;
                          if ((! (aux_NER_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::none()))));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::none())))), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::none()))));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NER_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable ER
                              var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                              aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NEC_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EC", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable EC
                              var_EC_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EC", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("EC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EC);
                              aux_last_type_read_for_EC = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NER_0d_int_Scalar-1), 1, (var_NEC_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NER_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_l_0d_int_Scalar = 1;
                                 var_l_0d_int_Scalar <= (var_NEC_0d_int_Scalar-1); var_l_0d_int_Scalar++) {
                                bool aux_l_read = true;
                                // read LIST body
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_l_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none()));
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                          int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                          bool& glob_aux_LT_read = aux_LT_read;
                          bool aux_LT_read = glob_aux_LT_read;
                          vartype aux_last_type_read_for_LT = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                          int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                          bool& glob_aux_NP_read = aux_NP_read;
                          bool aux_NP_read = glob_aux_NP_read;
                          vartype aux_last_type_read_for_NP = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                            // read LIST record
                            // assign expression to variable LT
                            var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::cast(-99999)));
                            aux_LT_read = true;
                            validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                            aux_last_type_read_for_LT = SCALAR_INT;
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::cast(-99999))));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = (cpp_int_val/2);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                            if ((! (aux_NP_read == true))) {
                              // assign expression to variable NP
                              var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::cast(-99999)));
                              aux_NP_read = true;
                              validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                              aux_last_type_read_for_NP = SCALAR_INT;
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if ((((((((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(8))))))||(((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(9)))))))))&&((((aux_LT_read == true)) && ((var_LT_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none()));
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()))), write_opts);
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())), write_opts);
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()));
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()))), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable F
                              var_F_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }
            cpp_current_dict = cpp_parent_dict;
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 89a763d6f809f216a36f99ade3a07a08
// MD5 hash of the following function definition: c0f457c76c2c53d02ac184ea66e49bc6
void write_mf32_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NIS_0d_int_Scalar;
  bool aux_NIS_read = false;
  vartype aux_last_type_read_for_NIS = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 32;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 32;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 32 , 151 / ZA , AWR , 0 , 0 , NIS , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NIS", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NIS
  var_NIS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NIS", std::vector<int>({}), py::none()));
  aux_NIS_read = true;
  validate_vartype_consistency("NIS", SCALAR_INT, aux_last_type_read_for_NIS);
  aux_last_type_read_for_NIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NIS_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    // open section isotope
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.get_value("isotope", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_ZAI_0d_double_Scalar;
      bool aux_ZAI_read = false;
      vartype aux_last_type_read_for_ZAI = UNKNOWN;
      EndfFloatCpp var_ABN_0d_double_Scalar;
      bool aux_ABN_read = false;
      vartype aux_last_type_read_for_ABN = UNKNOWN;
      int var_LFW_0d_int_Scalar;
      bool aux_LFW_read = false;
      vartype aux_last_type_read_for_LFW = UNKNOWN;
      int var_NER_0d_int_Scalar;
      bool aux_NER_read = false;
      vartype aux_last_type_read_for_NER = UNKNOWN;
      cpp_template = "[ MAT , 32 , 151 / ZAI , ABN , 0 , LFW , NER , 0 ] CONT";
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      // read CONT record
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAI", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable ZAI
      var_ZAI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZAI", std::vector<int>({}), py::none()));
      aux_ZAI_read = true;
      validate_vartype_consistency("ZAI", SCALAR_DOUBLE, aux_last_type_read_for_ZAI);
      aux_last_type_read_for_ZAI = SCALAR_DOUBLE;
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ABN", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable ABN
      var_ABN_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ABN", std::vector<int>({}), py::none()));
      aux_ABN_read = true;
      validate_vartype_consistency("ABN", SCALAR_DOUBLE, aux_last_type_read_for_ABN);
      aux_last_type_read_for_ABN = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LFW", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable LFW
      var_LFW_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFW", std::vector<int>({}), py::none()));
      aux_LFW_read = true;
      validate_vartype_consistency("LFW", SCALAR_INT, aux_last_type_read_for_LFW);
      aux_last_type_read_for_LFW = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable NER
      var_NER_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()));
      aux_NER_read = true;
      validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
      aux_last_type_read_for_NER = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
      cont << cpp_draft_line;

      for (int var_j_0d_int_Scalar = 1;
         var_j_0d_int_Scalar <= var_NER_0d_int_Scalar; var_j_0d_int_Scalar++) {
        bool aux_j_read = true;
        // open section range
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.get_value("range", std::vector<int>({var_j_0d_int_Scalar}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          // variable declarations
          EndfFloatCpp var_EL_0d_double_Scalar;
          bool aux_EL_read = false;
          vartype aux_last_type_read_for_EL = UNKNOWN;
          EndfFloatCpp var_EH_0d_double_Scalar;
          bool aux_EH_read = false;
          vartype aux_last_type_read_for_EH = UNKNOWN;
          int var_LRU_0d_int_Scalar;
          bool aux_LRU_read = false;
          vartype aux_last_type_read_for_LRU = UNKNOWN;
          int var_LRF_0d_int_Scalar;
          bool aux_LRF_read = false;
          vartype aux_last_type_read_for_LRF = UNKNOWN;
          int var_NRO_0d_int_Scalar;
          bool aux_NRO_read = false;
          vartype aux_last_type_read_for_NRO = UNKNOWN;
          int var_NAPS_0d_int_Scalar;
          bool aux_NAPS_read = false;
          vartype aux_last_type_read_for_NAPS = UNKNOWN;
          int var_NI_0d_int_Scalar;
          bool aux_NI_read = false;
          vartype aux_last_type_read_for_NI = UNKNOWN;
          EndfFloatCpp var_SPI_0d_double_Scalar;
          bool aux_SPI_read = false;
          vartype aux_last_type_read_for_SPI = UNKNOWN;
          EndfFloatCpp var_AP_0d_double_Scalar;
          bool aux_AP_read = false;
          vartype aux_last_type_read_for_AP = UNKNOWN;
          int var_LCOMP_0d_int_Scalar;
          bool aux_LCOMP_read = false;
          vartype aux_last_type_read_for_LCOMP = UNKNOWN;
          int var_NLS_0d_int_Scalar;
          bool aux_NLS_read = false;
          vartype aux_last_type_read_for_NLS = UNKNOWN;
          int var_ISR_0d_int_Scalar;
          bool aux_ISR_read = false;
          vartype aux_last_type_read_for_ISR = UNKNOWN;
          EndfFloatCpp var_DAP_0d_double_Scalar;
          bool aux_DAP_read = false;
          vartype aux_last_type_read_for_DAP = UNKNOWN;
          EndfFloatCpp var_AWRI_0d_double_Scalar;
          bool aux_AWRI_read = false;
          vartype aux_last_type_read_for_AWRI = UNKNOWN;
          int var_NSRS_0d_int_Scalar;
          bool aux_NSRS_read = false;
          vartype aux_last_type_read_for_NSRS = UNKNOWN;
          int var_NLRS_0d_int_Scalar;
          bool aux_NLRS_read = false;
          vartype aux_last_type_read_for_NLRS = UNKNOWN;
          int var_MLS_0d_int_Scalar;
          bool aux_MLS_read = false;
          vartype aux_last_type_read_for_MLS = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DAP_1d_double_NestedVector;
          int var_JCH_0d_int_Scalar;
          bool aux_JCH_read = false;
          vartype aux_last_type_read_for_JCH = UNKNOWN;
          int cpp_int_val;
          bool aux_cpp_int_val_read = false;
          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
          int var_NCH_0d_int_Scalar;
          bool aux_NCH_read = false;
          vartype aux_last_type_read_for_NCH = UNKNOWN;
          Matrix2d<EndfFloatCpp> var_DAP_2d_double_Matrix2d;
          EndfFloatCpp var_QX_0d_double_Scalar;
          bool aux_QX_read = false;
          vartype aux_last_type_read_for_QX = UNKNOWN;
          int var_LRX_0d_int_Scalar;
          bool aux_LRX_read = false;
          vartype aux_last_type_read_for_LRX = UNKNOWN;
          int var_NRSA_0d_int_Scalar;
          bool aux_NRSA_read = false;
          vartype aux_last_type_read_for_NRSA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
          vartype aux_last_type_read_for_ER = UNKNOWN;
          NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
          vartype aux_last_type_read_for_AJ = UNKNOWN;
          NestedVector<EndfFloatCpp> var_GT_1d_double_NestedVector;
          vartype aux_last_type_read_for_GT = UNKNOWN;
          NestedVector<EndfFloatCpp> var_GN_1d_double_NestedVector;
          vartype aux_last_type_read_for_GN = UNKNOWN;
          NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
          vartype aux_last_type_read_for_GG = UNKNOWN;
          NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
          vartype aux_last_type_read_for_GF = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DER_1d_double_NestedVector;
          vartype aux_last_type_read_for_DER = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DGN_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGN = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DGG_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGG = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DGF_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGF = UNKNOWN;
          int var_NDIGIT_0d_int_Scalar;
          bool aux_NDIGIT_read = false;
          vartype aux_last_type_read_for_NDIGIT = UNKNOWN;
          int var_NNN_0d_int_Scalar;
          bool aux_NNN_read = false;
          vartype aux_last_type_read_for_NNN = UNKNOWN;
          int var_NM_0d_int_Scalar;
          bool aux_NM_read = false;
          vartype aux_last_type_read_for_NM = UNKNOWN;
          NestedVector<int> var_II_1d_int_NestedVector;
          vartype aux_last_type_read_for_II = UNKNOWN;
          NestedVector<int> var_JJ_1d_int_NestedVector;
          vartype aux_last_type_read_for_JJ = UNKNOWN;
          NestedVector<std::vector<int>> var_KIJ_1d_intvec_NestedVector;
          vartype aux_last_type_read_for_KIJ = UNKNOWN;
          int var_LAD_0d_int_Scalar;
          bool aux_LAD_read = false;
          vartype aux_last_type_read_for_LAD = UNKNOWN;
          EndfFloatCpp var_APL_0d_double_Scalar;
          bool aux_APL_read = false;
          vartype aux_last_type_read_for_APL = UNKNOWN;
          NestedVector<EndfFloatCpp> var_GFA_1d_double_NestedVector;
          vartype aux_last_type_read_for_GFA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_GFB_1d_double_NestedVector;
          vartype aux_last_type_read_for_GFB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DGFA_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGFA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_DGFB_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGFB = UNKNOWN;
          int var_IFG_0d_int_Scalar;
          bool aux_IFG_read = false;
          vartype aux_last_type_read_for_IFG = UNKNOWN;
          int var_NJS_0d_int_Scalar;
          bool aux_NJS_read = false;
          vartype aux_last_type_read_for_NJS = UNKNOWN;
          int var_NJCH_0d_int_Scalar;
          bool aux_NJCH_read = false;
          vartype aux_last_type_read_for_NJCH = UNKNOWN;
          int var_NPP_0d_int_Scalar;
          bool aux_NPP_read = false;
          vartype aux_last_type_read_for_NPP = UNKNOWN;
          int var_NJSX_0d_int_Scalar;
          bool aux_NJSX_read = false;
          vartype aux_last_type_read_for_NJSX = UNKNOWN;
          NestedVector<EndfFloatCpp> var_MA_1d_double_NestedVector;
          vartype aux_last_type_read_for_MA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_MB_1d_double_NestedVector;
          vartype aux_last_type_read_for_MB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_ZA_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_ZB_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_IA_1d_double_NestedVector;
          vartype aux_last_type_read_for_IA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_IB_1d_double_NestedVector;
          vartype aux_last_type_read_for_IB = UNKNOWN;
          NestedVector<EndfFloatCpp> var_Q_1d_double_NestedVector;
          vartype aux_last_type_read_for_Q = UNKNOWN;
          NestedVector<EndfFloatCpp> var_PNT_1d_double_NestedVector;
          vartype aux_last_type_read_for_PNT = UNKNOWN;
          NestedVector<EndfFloatCpp> var_SHF_1d_double_NestedVector;
          vartype aux_last_type_read_for_SHF = UNKNOWN;
          NestedVector<EndfFloatCpp> var_MT_1d_double_NestedVector;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          NestedVector<EndfFloatCpp> var_PA_1d_double_NestedVector;
          vartype aux_last_type_read_for_PA = UNKNOWN;
          NestedVector<EndfFloatCpp> var_PB_1d_double_NestedVector;
          vartype aux_last_type_read_for_PB = UNKNOWN;
          int var_MPAR_0d_int_Scalar;
          bool aux_MPAR_read = false;
          vartype aux_last_type_read_for_MPAR = UNKNOWN;
          int var_NPAR_0d_int_Scalar;
          bool aux_NPAR_read = false;
          vartype aux_last_type_read_for_NPAR = UNKNOWN;
          Matrix2d<EndfFloatCpp> var_RV_2d_double_Matrix2d;
          vartype aux_last_type_read_for_RV = UNKNOWN;
          cpp_template = "[ MAT , 32 , 151 / EL , EH , LRU , LRF , NRO , NAPS ] CONT";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read CONT record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EL", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable EL
          var_EL_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EL", std::vector<int>({}), py::none()));
          aux_EL_read = true;
          validate_vartype_consistency("EL", SCALAR_DOUBLE, aux_last_type_read_for_EL);
          aux_last_type_read_for_EL = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EH", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable EH
          var_EH_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EH", std::vector<int>({}), py::none()));
          aux_EH_read = true;
          validate_vartype_consistency("EH", SCALAR_DOUBLE, aux_last_type_read_for_EH);
          aux_last_type_read_for_EH = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LRU", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LRU
          var_LRU_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LRU", std::vector<int>({}), py::none()));
          aux_LRU_read = true;
          validate_vartype_consistency("LRU", SCALAR_INT, aux_last_type_read_for_LRU);
          aux_last_type_read_for_LRU = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LRF", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable LRF
          var_LRF_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LRF", std::vector<int>({}), py::none()));
          aux_LRF_read = true;
          validate_vartype_consistency("LRF", SCALAR_INT, aux_last_type_read_for_LRF);
          aux_last_type_read_for_LRF = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NRO", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NRO
          var_NRO_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRO", std::vector<int>({}), py::none()));
          aux_NRO_read = true;
          validate_vartype_consistency("NRO", SCALAR_INT, aux_last_type_read_for_NRO);
          aux_last_type_read_for_NRO = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NAPS", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NAPS
          var_NAPS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NAPS", std::vector<int>({}), py::none()));
          aux_NAPS_read = true;
          validate_vartype_consistency("NAPS", SCALAR_INT, aux_last_type_read_for_NAPS);
          aux_last_type_read_for_NAPS = SCALAR_INT;
          cont << cpp_draft_line;
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , 0 , NI ] CONT";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                // read CONT record
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable NI
                var_NI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none()));
                aux_NI_read = true;
                validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
                aux_last_type_read_for_NI = SCALAR_INT;
                cont << cpp_draft_line;
                throw std::runtime_error("Encountered STOP instruction in recipe: NRO != 0 branch not implemented in ENDF recipe MF32");
              }
            }
          }
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              // if statement evaluation with lookahead
              {
                {
                  // variable declarations
                  EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                  EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                  bool& glob_aux_EL_read = aux_EL_read;
                  bool aux_EL_read = glob_aux_EL_read;
                  vartype aux_last_type_read_for_EL = UNKNOWN;
                  EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                  EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                  bool& glob_aux_EH_read = aux_EH_read;
                  bool aux_EH_read = glob_aux_EH_read;
                  vartype aux_last_type_read_for_EH = UNKNOWN;
                  int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                  int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                  bool& glob_aux_LRU_read = aux_LRU_read;
                  bool aux_LRU_read = glob_aux_LRU_read;
                  vartype aux_last_type_read_for_LRU = UNKNOWN;
                  int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                  int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                  bool& glob_aux_LRF_read = aux_LRF_read;
                  bool aux_LRF_read = glob_aux_LRF_read;
                  vartype aux_last_type_read_for_LRF = UNKNOWN;
                  int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                  int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                  bool& glob_aux_NRO_read = aux_NRO_read;
                  bool aux_NRO_read = glob_aux_NRO_read;
                  vartype aux_last_type_read_for_NRO = UNKNOWN;
                  int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                  int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                  bool& glob_aux_NAPS_read = aux_NAPS_read;
                  bool aux_NAPS_read = glob_aux_NAPS_read;
                  vartype aux_last_type_read_for_NAPS = UNKNOWN;
                  int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                  int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                  bool& glob_aux_NI_read = aux_NI_read;
                  bool aux_NI_read = glob_aux_NI_read;
                  vartype aux_last_type_read_for_NI = UNKNOWN;
                  EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                  EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                  bool& glob_aux_SPI_read = aux_SPI_read;
                  bool aux_SPI_read = glob_aux_SPI_read;
                  vartype aux_last_type_read_for_SPI = UNKNOWN;
                  EndfFloatCpp& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                  EndfFloatCpp var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                  bool& glob_aux_AP_read = aux_AP_read;
                  bool aux_AP_read = glob_aux_AP_read;
                  vartype aux_last_type_read_for_AP = UNKNOWN;
                  int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                  int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                  bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                  bool aux_LCOMP_read = glob_aux_LCOMP_read;
                  vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                  int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                  int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                  bool& glob_aux_NLS_read = aux_NLS_read;
                  bool aux_NLS_read = glob_aux_NLS_read;
                  vartype aux_last_type_read_for_NLS = UNKNOWN;
                  int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                  int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                  bool& glob_aux_ISR_read = aux_ISR_read;
                  bool aux_ISR_read = glob_aux_ISR_read;
                  vartype aux_last_type_read_for_ISR = UNKNOWN;
                  try {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::cast(-99999.9)));
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::cast(-99999.9)));
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::cast(-99999)));
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::cast(-99999)));
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::cast(-99999)));
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                  } catch (const std::out_of_range& e) {
                    // // accept failure in lookahead
                  }
                  if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(0)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&(((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))))))) {
                    cpp_found_match = true;
                  }
                }
                if (cpp_found_match) {
                  cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  // read CONT record
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                  // assign expression to variable SPI
                  var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                  aux_SPI_read = true;
                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none())), write_opts);
                  // assign expression to variable AP
                  var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                  aux_AP_read = true;
                  validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                  aux_last_type_read_for_AP = SCALAR_DOUBLE;
                  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none())), write_opts);
                  // assign expression to variable LCOMP
                  var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none()));
                  aux_LCOMP_read = true;
                  validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                  aux_last_type_read_for_LCOMP = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                  // assign expression to variable NLS
                  var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                  aux_NLS_read = true;
                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                  aux_last_type_read_for_NLS = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none())), write_opts);
                  // assign expression to variable ISR
                  var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none()));
                  aux_ISR_read = true;
                  validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                  aux_last_type_read_for_ISR = SCALAR_INT;
                  cont << cpp_draft_line;
                  // evaluate if-elif-else clause
                  {
                    bool cpp_found_match = false;
                    if (! cpp_found_match) {
                      if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)!=(0)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , DAP , 0 , 0 , 0 , 0 ] CONT";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read CONT record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable DAP
                        var_DAP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({}), py::none()));
                        aux_DAP_read = true;
                        validate_vartype_consistency("DAP", SCALAR_DOUBLE, aux_last_type_read_for_DAP);
                        aux_last_type_read_for_DAP = SCALAR_DOUBLE;
                        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                        cont << cpp_draft_line;
                      }
                    }
                  }

                  for (int var_k_0d_int_Scalar = 1;
                     var_k_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                    bool aux_k_read = true;
                    // open section somesec
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      cpp_current_dict = cpp_index_shifter_store.get_value("somesec", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
                      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                      // variable declarations
                      EndfFloatCpp var_AWRI_0d_double_Scalar;
                      bool aux_AWRI_read = false;
                      vartype aux_last_type_read_for_AWRI = UNKNOWN;
                      int var_L_0d_int_Scalar;
                      bool aux_L_read = false;
                      vartype aux_last_type_read_for_L = UNKNOWN;
                      int cpp_int_val;
                      bool aux_cpp_int_val_read = false;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int var_NRS_0d_int_Scalar;
                      bool aux_NRS_read = false;
                      vartype aux_last_type_read_for_NRS = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                      vartype aux_last_type_read_for_ER = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                      vartype aux_last_type_read_for_AJ = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GT_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GT = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GN_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GN = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GG = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GF = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DE2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DE2 = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DN2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DN2 = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DNDG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DNDG = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DG2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DG2 = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DNDF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DNDF = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DGDF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DGDF = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DF2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DF2 = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DJDN_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJDN = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DJDG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJDG = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DJDF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJDF = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_DJ2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJ2 = UNKNOWN;
                      cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , L , 0 , (18*NRS) , NRS / \n { ER , AJ , GT , GN , GG , GF , \n DE2 , DN2 , DNDG , DG2 , DNDF , DGDF , \n DF2 , DJDN , DJDG , DJDF , DJ2 , 0.0 } { m = 1 to NRS } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read LIST record
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable AWRI
                      var_AWRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none()));
                      aux_AWRI_read = true;
                      validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                      aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable L
                      var_L_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none()));
                      aux_L_read = true;
                      validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                      aux_last_type_read_for_L = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, (18*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none()))), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (18*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NRS
                      var_NRS_0d_int_Scalar = (cpp_int_val/18);
                      aux_NRS_read = true;
                      validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                      aux_last_type_read_for_NRS = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())), write_opts);
                      if ((! (aux_NRS_read == true))) {
                        // assign expression to variable NRS
                        var_NRS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none()));
                        aux_NRS_read = true;
                        validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                        aux_last_type_read_for_NRS = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (18*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none()))), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (18*py::cast<int>(cpp_index_shifter_store.get_value("NRS", std::vector<int>({}), py::none())));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST body

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // read LIST body
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable ER
                          var_ER_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                          aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable AJ
                          var_AJ_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                          aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GT", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable GT
                          var_GT_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GT", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                          aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable GN
                          var_GN_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                          aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable GG
                          var_GG_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                          aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable GF
                          var_GF_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                          aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DE2", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable DE2
                          var_DE2_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DE2", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("DE2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DE2);
                          aux_last_type_read_for_DE2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DN2", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable DN2
                          var_DN2_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DN2", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("DN2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DN2);
                          aux_last_type_read_for_DN2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DNDG", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable DNDG
                          var_DNDG_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DNDG", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("DNDG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DNDG);
                          aux_last_type_read_for_DNDG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DG2", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable DG2
                          var_DG2_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DG2", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("DG2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DG2);
                          aux_last_type_read_for_DG2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DNDF", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable DNDF
                          var_DNDF_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DNDF", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("DNDF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DNDF);
                          aux_last_type_read_for_DNDF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGDF", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable DGDF
                          var_DGDF_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGDF", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("DGDF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGDF);
                          aux_last_type_read_for_DGDF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DF2", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable DF2
                          var_DF2_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DF2", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("DF2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DF2);
                          aux_last_type_read_for_DF2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DJDN", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable DJDN
                          var_DJDN_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DJDN", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("DJDN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJDN);
                          aux_last_type_read_for_DJDN = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DJDG", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable DJDG
                          var_DJDG_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DJDG", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("DJDG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJDG);
                          aux_last_type_read_for_DJDG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DJDF", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable DJDF
                          var_DJDF_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DJDF", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("DJDF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJDF);
                          aux_last_type_read_for_DJDF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DJ2", std::vector<int>({var_m_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable DJ2
                          var_DJ2_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DJ2", std::vector<int>({var_m_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("DJ2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJ2);
                          aux_last_type_read_for_DJ2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    EndfFloatCpp& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    EndfFloatCpp var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                    int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                    bool& glob_aux_NLS_read = aux_NLS_read;
                    bool aux_NLS_read = glob_aux_NLS_read;
                    vartype aux_last_type_read_for_NLS = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                      // read CONT record
                      // assign expression to variable SPI
                      var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::cast(-99999.9)));
                      aux_SPI_read = true;
                      validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                      aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                      // assign expression to variable AP
                      var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::cast(-99999.9)));
                      aux_AP_read = true;
                      validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                      aux_last_type_read_for_AP = SCALAR_DOUBLE;
                      // assign expression to variable LCOMP
                      var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::cast(-99999)));
                      aux_LCOMP_read = true;
                      validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                      aux_last_type_read_for_LCOMP = SCALAR_INT;
                      // assign expression to variable NLS
                      var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::cast(-99999)));
                      aux_NLS_read = true;
                      validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                      aux_last_type_read_for_NLS = SCALAR_INT;
                      // assign expression to variable ISR
                      var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::cast(-99999)));
                      aux_ISR_read = true;
                      validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                      aux_last_type_read_for_ISR = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(1)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&(((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read CONT record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none()));
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none()));
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    cont << cpp_draft_line;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , DAP , 0 , 0 , 0 , 0 ] CONT";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read CONT record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable DAP
                          var_DAP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({}), py::none()));
                          aux_DAP_read = true;
                          validate_vartype_consistency("DAP", SCALAR_DOUBLE, aux_last_type_read_for_DAP);
                          aux_last_type_read_for_DAP = SCALAR_DOUBLE;
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                          cont << cpp_draft_line;
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , 0 , 0 , NSRS , NLRS ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read CONT record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none()));
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NSRS", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NSRS
                    var_NSRS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NSRS", std::vector<int>({}), py::none()));
                    aux_NSRS_read = true;
                    validate_vartype_consistency("NSRS", SCALAR_INT, aux_last_type_read_for_NSRS);
                    aux_last_type_read_for_NSRS = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NLRS", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NLRS
                    var_NLRS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLRS", std::vector<int>({}), py::none()));
                    aux_NLRS_read = true;
                    validate_vartype_consistency("NLRS", SCALAR_INT, aux_last_type_read_for_NLRS);
                    aux_last_type_read_for_NLRS = SCALAR_INT;
                    cont << cpp_draft_line;

                    for (int var_p_0d_int_Scalar = 1;
                       var_p_0d_int_Scalar <= var_NSRS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                      bool aux_p_read = true;
                      // open section nsrs_subsec
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        cpp_current_dict = cpp_index_shifter_store.get_value("nsrs_subsec", std::vector<int>({var_p_0d_int_Scalar}), py::dict());
                        IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                        // variable declarations
                        int var_MPAR_0d_int_Scalar;
                        bool aux_MPAR_read = false;
                        vartype aux_last_type_read_for_MPAR = UNKNOWN;
                        int var_NRB_0d_int_Scalar;
                        bool aux_NRB_read = false;
                        vartype aux_last_type_read_for_NRB = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_ER = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                        vartype aux_last_type_read_for_AJ = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GT_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GT = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GN_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GN = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GG = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GF = UNKNOWN;
                        Matrix2d<EndfFloatCpp> var_V_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_V = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , MPAR , 0 , ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2)) , NRB / \n { ER , AJ , GT , GN , GG , GF } { k = 1 to NRB } , \n { { V } { n = m to (MPAR*NRB) } } { m = 1 to (MPAR*NRB) } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable MPAR
                        var_MPAR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()));
                        aux_MPAR_read = true;
                        validate_vartype_consistency("MPAR", SCALAR_INT, aux_last_type_read_for_MPAR);
                        aux_last_type_read_for_MPAR = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NRB
                        var_NRB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none()));
                        aux_NRB_read = true;
                        validate_vartype_consistency("NRB", SCALAR_INT, aux_last_type_read_for_NRB);
                        aux_last_type_read_for_NRB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, ((6*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))+(((py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))*((py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))+1))/2)), write_opts);
                        if ((! (aux_MPAR_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for MPAR because this variable could not be isolated.");
                        } else {
                        }
                        if ((! (aux_NRB_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for NRB because this variable could not be isolated.");
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, ((6*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))+(((py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))*((py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))+1))/2)), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = ((6*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))+(((py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))*((py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))+1))/2));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NRB_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable AJ
                            var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                            aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GT", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable GT
                            var_GT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GT", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                            aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable GN
                            var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                            aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable GG
                            var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                            aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable GF
                            var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                            aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          var_V_2d_double_Matrix2d.init(1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), 1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), true, false);

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body

                            for (int var_n_0d_int_Scalar = var_m_0d_int_Scalar;
                               var_n_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_n_0d_int_Scalar++) {
                              bool aux_n_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("V", std::vector<int>({var_m_0d_int_Scalar, var_n_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable V
                              var_V_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("V", std::vector<int>({var_m_0d_int_Scalar, var_n_0d_int_Scalar}), py::none()));
                              validate_vartype_consistency("V", MATRIX2D_DOUBLE, aux_last_type_read_for_V);
                              aux_last_type_read_for_V = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                        cpp_current_dict = cpp_parent_dict;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    EndfFloatCpp& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    EndfFloatCpp var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                    int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                    bool& glob_aux_NLS_read = aux_NLS_read;
                    bool aux_NLS_read = glob_aux_NLS_read;
                    vartype aux_last_type_read_for_NLS = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                      // read CONT record
                      // assign expression to variable SPI
                      var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::cast(-99999.9)));
                      aux_SPI_read = true;
                      validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                      aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                      // assign expression to variable AP
                      var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::cast(-99999.9)));
                      aux_AP_read = true;
                      validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                      aux_last_type_read_for_AP = SCALAR_DOUBLE;
                      // assign expression to variable LCOMP
                      var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::cast(-99999)));
                      aux_LCOMP_read = true;
                      validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                      aux_last_type_read_for_LCOMP = SCALAR_INT;
                      // assign expression to variable NLS
                      var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::cast(-99999)));
                      aux_NLS_read = true;
                      validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                      aux_last_type_read_for_NLS = SCALAR_INT;
                      // assign expression to variable ISR
                      var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::cast(-99999)));
                      aux_ISR_read = true;
                      validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                      aux_last_type_read_for_ISR = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(1)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(3)))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read CONT record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none()));
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none()));
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    cont << cpp_draft_line;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , MLS , 1 / \n { DAP } { k = 1 to MLS } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("MLS", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable MLS
                          var_MLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MLS", std::vector<int>({}), py::none()));
                          aux_MLS_read = true;
                          validate_vartype_consistency("MLS", SCALAR_INT, aux_last_type_read_for_MLS);
                          aux_last_type_read_for_MLS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, 1, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("MLS", std::vector<int>({}), py::none())), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("MLS", std::vector<int>({}), py::none()));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_MLS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable DAP
                              var_DAP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("DAP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DAP);
                              aux_last_type_read_for_DAP = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , 0 , 0 , NSRS , NLRS ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read CONT record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none()));
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NSRS", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NSRS
                    var_NSRS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NSRS", std::vector<int>({}), py::none()));
                    aux_NSRS_read = true;
                    validate_vartype_consistency("NSRS", SCALAR_INT, aux_last_type_read_for_NSRS);
                    aux_last_type_read_for_NSRS = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NLRS", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NLRS
                    var_NLRS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLRS", std::vector<int>({}), py::none()));
                    aux_NLRS_read = true;
                    validate_vartype_consistency("NLRS", SCALAR_INT, aux_last_type_read_for_NLRS);
                    aux_last_type_read_for_NLRS = SCALAR_INT;
                    cont << cpp_draft_line;

                    for (int var_p_0d_int_Scalar = 1;
                       var_p_0d_int_Scalar <= var_NSRS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                      bool aux_p_read = true;
                      // open section nsrs_subsec
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        cpp_current_dict = cpp_index_shifter_store.get_value("nsrs_subsec", std::vector<int>({var_p_0d_int_Scalar}), py::dict());
                        IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                        // variable declarations
                        int var_MPAR_0d_int_Scalar;
                        bool aux_MPAR_read = false;
                        vartype aux_last_type_read_for_MPAR = UNKNOWN;
                        int var_NRB_0d_int_Scalar;
                        bool aux_NRB_read = false;
                        vartype aux_last_type_read_for_NRB = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_ER = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                        vartype aux_last_type_read_for_AJ = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GN_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GN = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GG = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GFA_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GFA = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_GFB_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GFB = UNKNOWN;
                        Matrix2d<EndfFloatCpp> var_V_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_V = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , MPAR , 0 , ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2)) , NRB / \n { ER , AJ , GN , GG , GFA , GFB } { k = 1 to NRB } , \n { { V } { n = m to (MPAR*NRB) } } { m = 1 to (MPAR*NRB) } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable MPAR
                        var_MPAR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()));
                        aux_MPAR_read = true;
                        validate_vartype_consistency("MPAR", SCALAR_INT, aux_last_type_read_for_MPAR);
                        aux_last_type_read_for_MPAR = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NRB
                        var_NRB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none()));
                        aux_NRB_read = true;
                        validate_vartype_consistency("NRB", SCALAR_INT, aux_last_type_read_for_NRB);
                        aux_last_type_read_for_NRB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, ((6*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))+(((py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))*((py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))+1))/2)), write_opts);
                        if ((! (aux_MPAR_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for MPAR because this variable could not be isolated.");
                        } else {
                        }
                        if ((! (aux_NRB_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for NRB because this variable could not be isolated.");
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, ((6*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))+(((py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))*((py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))+1))/2)), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = ((6*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))+(((py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))*((py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))+1))/2));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NRB_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable AJ
                            var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                            aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable GN
                            var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                            aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable GG
                            var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                            aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GFA", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable GFA
                            var_GFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GFA", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("GFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFA);
                            aux_last_type_read_for_GFA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GFB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable GFB
                            var_GFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GFB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("GFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFB);
                            aux_last_type_read_for_GFB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          var_V_2d_double_Matrix2d.init(1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), 1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), true, false);

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body

                            for (int var_n_0d_int_Scalar = var_m_0d_int_Scalar;
                               var_n_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_n_0d_int_Scalar++) {
                              bool aux_n_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("V", std::vector<int>({var_m_0d_int_Scalar, var_n_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable V
                              var_V_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("V", std::vector<int>({var_m_0d_int_Scalar, var_n_0d_int_Scalar}), py::none()));
                              validate_vartype_consistency("V", MATRIX2D_DOUBLE, aux_last_type_read_for_V);
                              aux_last_type_read_for_V = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                        cpp_current_dict = cpp_parent_dict;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , LCOMP , 0 , ISR ] CONT";
                      // read CONT record
                      // assign expression to variable LCOMP
                      var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::cast(-99999)));
                      aux_LCOMP_read = true;
                      validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                      aux_last_type_read_for_LCOMP = SCALAR_INT;
                      // assign expression to variable ISR
                      var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::cast(-99999)));
                      aux_ISR_read = true;
                      validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                      aux_last_type_read_for_ISR = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(1)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(7)))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , LCOMP , 0 , ISR ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read CONT record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none()));
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none()));
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    cont << cpp_draft_line;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , JCH , (1+((NCH-1)/6)) / \n { { DAP } { n = 1 to NCH } } { m = 1 to (JCH/NCH) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("JCH", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable JCH
                          var_JCH_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("JCH", std::vector<int>({}), py::none()));
                          aux_JCH_read = true;
                          validate_vartype_consistency("JCH", SCALAR_INT, aux_last_type_read_for_JCH);
                          aux_last_type_read_for_JCH = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, (1+((py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none()))-1)/6)), write_opts);
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (1+((py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none()))-1)/6));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NCH
                          var_NCH_0d_int_Scalar = ((((((1/6)*(-1))+1)*(-1))+cpp_int_val)/(1/6));
                          aux_NCH_read = true;
                          validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                          aux_last_type_read_for_NCH = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("JCH", std::vector<int>({}), py::none())), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("JCH", std::vector<int>({}), py::none()));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body
                            var_DAP_2d_double_Matrix2d.init(1, (var_JCH_0d_int_Scalar/var_NCH_0d_int_Scalar), 1, var_NCH_0d_int_Scalar, false, false);

                            for (int var_m_0d_int_Scalar = 1;
                               var_m_0d_int_Scalar <= (var_JCH_0d_int_Scalar/var_NCH_0d_int_Scalar); var_m_0d_int_Scalar++) {
                              bool aux_m_read = true;
                              // read LIST body

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // read LIST body
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({var_m_0d_int_Scalar, var_n_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable DAP
                                var_DAP_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({var_m_0d_int_Scalar, var_n_0d_int_Scalar}), py::none()));
                                validate_vartype_consistency("DAP", MATRIX2D_DOUBLE, aux_last_type_read_for_DAP);
                                aux_last_type_read_for_DAP = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , 0 , 0 , NSRS , 0 ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read CONT record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none()));
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NSRS", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NSRS
                    var_NSRS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NSRS", std::vector<int>({}), py::none()));
                    aux_NSRS_read = true;
                    validate_vartype_consistency("NSRS", SCALAR_INT, aux_last_type_read_for_NSRS);
                    aux_last_type_read_for_NSRS = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                    cont << cpp_draft_line;

                    for (int var_k_0d_int_Scalar = 1;
                       var_k_0d_int_Scalar <= var_NSRS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                      bool aux_k_read = true;
                      // open section nsrs_subsec
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        cpp_current_dict = cpp_index_shifter_store.get_value("nsrs_subsec", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
                        IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                        // variable declarations
                        int var_NJSX_0d_int_Scalar;
                        bool aux_NJSX_read = false;
                        vartype aux_last_type_read_for_NJSX = UNKNOWN;
                        int var_N_0d_int_Scalar;
                        bool aux_N_read = false;
                        vartype aux_last_type_read_for_N = UNKNOWN;
                        int var_NPARB_0d_int_Scalar;
                        bool aux_NPARB_read = false;
                        vartype aux_last_type_read_for_NPARB = UNKNOWN;
                        Matrix2d<EndfFloatCpp> var_V_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_V = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NJSX , 0 , 0 , 0 ] CONT";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read CONT record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("NJSX", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NJSX
                        var_NJSX_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NJSX", std::vector<int>({}), py::none()));
                        aux_NJSX_read = true;
                        validate_vartype_consistency("NJSX", SCALAR_INT, aux_last_type_read_for_NJSX);
                        aux_last_type_read_for_NJSX = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                        cont << cpp_draft_line;

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NJSX_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // open section J_pi_group
                          {
                            py::dict cpp_parent_dict = cpp_current_dict;
                            cpp_current_dict = cpp_index_shifter_store.get_value("J_pi_group", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                            // variable declarations
                            int var_NCH_0d_int_Scalar;
                            bool aux_NCH_read = false;
                            vartype aux_last_type_read_for_NCH = UNKNOWN;
                            int var_NRB_0d_int_Scalar;
                            bool aux_NRB_read = false;
                            vartype aux_last_type_read_for_NRB = UNKNOWN;
                            NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                            vartype aux_last_type_read_for_ER = UNKNOWN;
                            Matrix2d<EndfFloatCpp> var_GAM_2d_double_Matrix2d;
                            vartype aux_last_type_read_for_GAM = UNKNOWN;
                            cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NCH , NRB , (6*NX) , NX / \n { ER , { GAM } { q = 1 to NCH } \n { 0.0 } { r = 1 to num_zeros } } { p = 1 to NRB } ] LIST";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST record
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())), write_opts);
                            if ((! (aux_NCH_read == true))) {
                              // assign expression to variable NCH
                              var_NCH_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none()));
                              aux_NCH_read = true;
                              validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                              aux_last_type_read_for_NCH = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())), write_opts);
                            // assign expression to variable NRB
                            var_NRB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none()));
                            aux_NRB_read = true;
                            validate_vartype_consistency("NRB", SCALAR_INT, aux_last_type_read_for_NRB);
                            aux_last_type_read_for_NRB = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 4, (6*((((1+py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))+((5-py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))%6))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))/6)), write_opts);
                            if ((! (aux_NCH_read == true))) {
                              throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRB)/6))==value cannot be solved for NCH because the modulo operator is not supported.");
                            } else {
                            }
                            if ((! (aux_NRB_read == true))) {
                              throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRB)/6))==value cannot be solved for NRB because the modulo operator is not supported.");
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 5, ((((1+py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))+((5-py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))%6))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))/6), write_opts);
                            if ((! (aux_NCH_read == true))) {
                              throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRB)/6)==value cannot be solved for NCH because the modulo operator is not supported.");
                            } else {
                            }
                            if ((! (aux_NRB_read == true))) {
                              throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRB)/6)==value cannot be solved for NRB because the modulo operator is not supported.");
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 4, (6*((((1+py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))+((5-py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))%6))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))/6)), write_opts);
                            cont << cpp_draft_line;
                            {
                              int cpp_npl = (6*((((1+py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))+((5-py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))%6))*py::cast<int>(cpp_index_shifter_store.get_value("NRB", std::vector<int>({}), py::none())))/6));
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              // read LIST body
                              var_GAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRB_0d_int_Scalar, false, false);

                              for (int var_p_0d_int_Scalar = 1;
                                 var_p_0d_int_Scalar <= var_NRB_0d_int_Scalar; var_p_0d_int_Scalar++) {
                                bool aux_p_read = true;
                                // read LIST body
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_p_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable ER
                                var_ER_1d_double_NestedVector.set(var_p_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_p_0d_int_Scalar}), py::none())));
                                validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                                aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }

                                for (int var_q_0d_int_Scalar = 1;
                                   var_q_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_q_0d_int_Scalar++) {
                                  bool aux_q_read = true;
                                  // read LIST body
                                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GAM", std::vector<int>({var_q_0d_int_Scalar, var_p_0d_int_Scalar}), py::none())), write_opts);
                                  // assign expression to variable GAM
                                  var_GAM_2d_double_Matrix2d(var_q_0d_int_Scalar, var_p_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GAM", std::vector<int>({var_q_0d_int_Scalar, var_p_0d_int_Scalar}), py::none()));
                                  validate_vartype_consistency("GAM", MATRIX2D_DOUBLE, aux_last_type_read_for_GAM);
                                  aux_last_type_read_for_GAM = MATRIX2D_DOUBLE;
                                  cpp_i++;
                                  cpp_j++;
                                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                    cont << cpp_draft_line;
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                    cpp_j = 0;
                                  }
                                }

                                for (int var_r_0d_int_Scalar = 1;
                                   var_r_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_r_0d_int_Scalar++) {
                                  bool aux_r_read = true;
                                  // read LIST body
                                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                  cpp_i++;
                                  cpp_j++;
                                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                    cont << cpp_draft_line;
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                    cpp_j = 0;
                                  }
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            cont << cpp_draft_line;
                            cpp_current_dict = cpp_parent_dict;
                          }
                        }
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , N , NPARB / \n { { V } { q = p to NPARB } } { p = 1 to NPARB } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("N", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable N
                        var_N_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("N", std::vector<int>({}), py::none()));
                        aux_N_read = true;
                        validate_vartype_consistency("N", SCALAR_INT, aux_last_type_read_for_N);
                        aux_last_type_read_for_N = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NPARB", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NPARB
                        var_NPARB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NPARB", std::vector<int>({}), py::none()));
                        aux_NPARB_read = true;
                        validate_vartype_consistency("NPARB", SCALAR_INT, aux_last_type_read_for_NPARB);
                        aux_last_type_read_for_NPARB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("N", std::vector<int>({}), py::none())), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("N", std::vector<int>({}), py::none()));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body
                          var_V_2d_double_Matrix2d.init(1, var_NPARB_0d_int_Scalar, 1, var_NPARB_0d_int_Scalar, true, false);

                          for (int var_p_0d_int_Scalar = 1;
                             var_p_0d_int_Scalar <= var_NPARB_0d_int_Scalar; var_p_0d_int_Scalar++) {
                            bool aux_p_read = true;
                            // read LIST body

                            for (int var_q_0d_int_Scalar = var_p_0d_int_Scalar;
                               var_q_0d_int_Scalar <= var_NPARB_0d_int_Scalar; var_q_0d_int_Scalar++) {
                              bool aux_q_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("V", std::vector<int>({var_p_0d_int_Scalar, var_q_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable V
                              var_V_2d_double_Matrix2d(var_p_0d_int_Scalar, var_q_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("V", std::vector<int>({var_p_0d_int_Scalar, var_q_0d_int_Scalar}), py::none()));
                              validate_vartype_consistency("V", MATRIX2D_DOUBLE, aux_last_type_read_for_V);
                              aux_last_type_read_for_V = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                        cpp_current_dict = cpp_parent_dict;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    EndfFloatCpp& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    EndfFloatCpp var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , 0 , ISR ] CONT";
                      // read CONT record
                      // assign expression to variable SPI
                      var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::cast(-99999.9)));
                      aux_SPI_read = true;
                      validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                      aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                      // assign expression to variable AP
                      var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::cast(-99999.9)));
                      aux_AP_read = true;
                      validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                      aux_last_type_read_for_AP = SCALAR_DOUBLE;
                      // assign expression to variable LCOMP
                      var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::cast(-99999)));
                      aux_LCOMP_read = true;
                      validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                      aux_last_type_read_for_LCOMP = SCALAR_INT;
                      // assign expression to variable ISR
                      var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::cast(-99999)));
                      aux_ISR_read = true;
                      validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                      aux_last_type_read_for_ISR = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(2)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&(((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , 0 , ISR ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read CONT record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none()));
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none()));
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    cont << cpp_draft_line;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , DAP , 0 , 0 , 0 , 0 ] CONT";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read CONT record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable DAP
                          var_DAP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({}), py::none()));
                          aux_DAP_read = true;
                          validate_vartype_consistency("DAP", SCALAR_DOUBLE, aux_last_type_read_for_DAP);
                          aux_last_type_read_for_DAP = SCALAR_DOUBLE;
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                          cont << cpp_draft_line;
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , QX , 0 , LRX , (12*NRSA) , NRSA / \n { ER , AJ , GT , GN , GG , GF , \n DER , 0.0 , 0.0 , DGN , DGG , DGF } { k = 1 to NRSA } ] LIST";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read LIST record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none()));
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QX", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable QX
                    var_QX_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QX", std::vector<int>({}), py::none()));
                    aux_QX_read = true;
                    validate_vartype_consistency("QX", SCALAR_DOUBLE, aux_last_type_read_for_QX);
                    aux_last_type_read_for_QX = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LRX", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable LRX
                    var_LRX_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LRX", std::vector<int>({}), py::none()));
                    aux_LRX_read = true;
                    validate_vartype_consistency("LRX", SCALAR_INT, aux_last_type_read_for_LRX);
                    aux_last_type_read_for_LRX = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none()))), write_opts);
                    // assign expression to variable cpp_int_val
                    cpp_int_val = (12*py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none())));
                    aux_cpp_int_val_read = true;
                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                    // assign expression to variable NRSA
                    var_NRSA_0d_int_Scalar = (cpp_int_val/12);
                    aux_NRSA_read = true;
                    validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                    aux_last_type_read_for_NRSA = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none())), write_opts);
                    if ((! (aux_NRSA_read == true))) {
                      // assign expression to variable NRSA
                      var_NRSA_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none()));
                      aux_NRSA_read = true;
                      validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                      aux_last_type_read_for_NRSA = SCALAR_INT;
                    } else {
                    }
                    cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none()))), write_opts);
                    cont << cpp_draft_line;
                    {
                      int cpp_npl = (12*py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none())));
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_NRSA_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable ER
                        var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                        aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable AJ
                        var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                        aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GT", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable GT
                        var_GT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GT", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                        aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable GN
                        var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                        aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable GG
                        var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                        aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable GF
                        var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                        aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable DER
                        var_DER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("DER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DER);
                        aux_last_type_read_for_DER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGN", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable DGN
                        var_DGN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGN", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("DGN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGN);
                        aux_last_type_read_for_DGN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGG", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable DGG
                        var_DGG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGG", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("DGG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGG);
                        aux_last_type_read_for_DGG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGF", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable DGF
                        var_DGF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGF", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("DGF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGF);
                        aux_last_type_read_for_DGF = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cont << cpp_draft_line;
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NDIGIT , NNN , NM , 0 ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read CONT record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("NDIGIT", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NDIGIT
                    var_NDIGIT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NDIGIT", std::vector<int>({}), py::none()));
                    aux_NDIGIT_read = true;
                    validate_vartype_consistency("NDIGIT", SCALAR_INT, aux_last_type_read_for_NDIGIT);
                    aux_last_type_read_for_NDIGIT = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("NNN", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NNN
                    var_NNN_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NNN", std::vector<int>({}), py::none()));
                    aux_NNN_read = true;
                    validate_vartype_consistency("NNN", SCALAR_INT, aux_last_type_read_for_NNN);
                    aux_last_type_read_for_NNN = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NM", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NM
                    var_NM_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NM", std::vector<int>({}), py::none()));
                    aux_NM_read = true;
                    validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
                    aux_last_type_read_for_NM = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                    cont << cpp_draft_line;

                    for (int var_k_0d_int_Scalar = 1;
                       var_k_0d_int_Scalar <= var_NM_0d_int_Scalar; var_k_0d_int_Scalar++) {
                      bool aux_k_read = true;
                      {
                        cpp_template = "[ MAT , 32 , 151 / II , JJ , KIJ { NDIGIT } ] INTG";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        int cpp_ndigit = var_NDIGIT_0d_int_Scalar;
                        if ((cpp_ndigit < 2 || cpp_ndigit > 6)) {
                          throw std::runtime_error("invalid NDIGIT (must be between 2 and 6)");
                        }
                        cpp_write_custom_int_field(cpp_draft_line, 0, 5, py::cast<int>(cpp_index_shifter_store.get_value("II", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        cpp_write_custom_int_field(cpp_draft_line, 5, 5, py::cast<int>(cpp_index_shifter_store.get_value("JJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        // assign expression to variable II
                        var_II_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("II", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("II", NESTEDVECTOR_INT, aux_last_type_read_for_II);
                        aux_last_type_read_for_II = NESTEDVECTOR_INT;
                        // assign expression to variable JJ
                        var_JJ_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("JJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("JJ", NESTEDVECTOR_INT, aux_last_type_read_for_JJ);
                        aux_last_type_read_for_JJ = NESTEDVECTOR_INT;
                        int cpp_step = cpp_ndigit + 1;
                        int cpp_end = 65;
                        int cpp_start;
                        if (cpp_ndigit <= 5) {
                          cpp_start = 11;
                        } else {
                          cpp_start = 10;
                        }
                        std::vector<int> cpp_intvec;
                        int elpos = 0;
                        for (int cpp_i = cpp_start; cpp_i < cpp_end; cpp_i += cpp_step) {
                        cpp_write_custom_int_field(cpp_draft_line, cpp_i, cpp_step, py::cast<int>(cpp_index_shifter_store.get_value("KIJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())[py::cast(elpos)]));
                          cpp_intvec.push_back(py::cast<int>(cpp_index_shifter_store.get_value("KIJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())[py::cast(elpos)]));
                          elpos++;
                        }
                        // assign expression to variable KIJ
                        var_KIJ_1d_intvec_NestedVector.set(var_k_0d_int_Scalar, cpp_intvec);
                        validate_vartype_consistency("KIJ", NESTEDVECTOR_INTVEC, aux_last_type_read_for_KIJ);
                        aux_last_type_read_for_KIJ = NESTEDVECTOR_INTVEC;
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    EndfFloatCpp& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    EndfFloatCpp var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    EndfFloatCpp& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    EndfFloatCpp var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LAD_0d_int_Scalar = var_LAD_0d_int_Scalar;
                    int var_LAD_0d_int_Scalar = glob_var_LAD_0d_int_Scalar;
                    bool& glob_aux_LAD_read = aux_LAD_read;
                    bool aux_LAD_read = glob_aux_LAD_read;
                    vartype aux_last_type_read_for_LAD = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 32 , 151 / SPI , AP , LAD , LCOMP , 0 , ISR ] CONT";
                      // read CONT record
                      // assign expression to variable SPI
                      var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::cast(-99999.9)));
                      aux_SPI_read = true;
                      validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                      aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                      // assign expression to variable AP
                      var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::cast(-99999.9)));
                      aux_AP_read = true;
                      validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                      aux_last_type_read_for_AP = SCALAR_DOUBLE;
                      // assign expression to variable LAD
                      var_LAD_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LAD", std::vector<int>({}), py::cast(-99999)));
                      aux_LAD_read = true;
                      validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                      aux_last_type_read_for_LAD = SCALAR_INT;
                      // assign expression to variable LCOMP
                      var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::cast(-99999)));
                      aux_LCOMP_read = true;
                      validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                      aux_last_type_read_for_LCOMP = SCALAR_INT;
                      // assign expression to variable ISR
                      var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::cast(-99999)));
                      aux_ISR_read = true;
                      validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                      aux_last_type_read_for_ISR = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(2)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(3)))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , LAD , LCOMP , 0 , ISR ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read CONT record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LAD", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable LAD
                    var_LAD_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LAD", std::vector<int>({}), py::none()));
                    aux_LAD_read = true;
                    validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                    aux_last_type_read_for_LAD = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none()));
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none()));
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    cont << cpp_draft_line;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , MLS , 1 / \n { DAP } { k = 1 to MLS } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("MLS", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable MLS
                          var_MLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MLS", std::vector<int>({}), py::none()));
                          aux_MLS_read = true;
                          validate_vartype_consistency("MLS", SCALAR_INT, aux_last_type_read_for_MLS);
                          aux_last_type_read_for_MLS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, 1, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("MLS", std::vector<int>({}), py::none())), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("MLS", std::vector<int>({}), py::none()));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_MLS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable DAP
                              var_DAP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("DAP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DAP);
                              aux_last_type_read_for_DAP = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , APL , 0 , 0 , (12*NRSA) , NRSA / \n { ER , AJ , GN , GG , GFA , GFB , \n DER , 0.0 , DGN , DGG , DGFA , DGFB } { k = 1 to NRSA } ] LIST";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read LIST record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none()));
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APL", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable APL
                    var_APL_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APL", std::vector<int>({}), py::none()));
                    aux_APL_read = true;
                    validate_vartype_consistency("APL", SCALAR_DOUBLE, aux_last_type_read_for_APL);
                    aux_last_type_read_for_APL = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none()))), write_opts);
                    // assign expression to variable cpp_int_val
                    cpp_int_val = (12*py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none())));
                    aux_cpp_int_val_read = true;
                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                    // assign expression to variable NRSA
                    var_NRSA_0d_int_Scalar = (cpp_int_val/12);
                    aux_NRSA_read = true;
                    validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                    aux_last_type_read_for_NRSA = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none())), write_opts);
                    if ((! (aux_NRSA_read == true))) {
                      // assign expression to variable NRSA
                      var_NRSA_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none()));
                      aux_NRSA_read = true;
                      validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                      aux_last_type_read_for_NRSA = SCALAR_INT;
                    } else {
                    }
                    cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none()))), write_opts);
                    cont << cpp_draft_line;
                    {
                      int cpp_npl = (12*py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none())));
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_NRSA_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable ER
                        var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                        aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable AJ
                        var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                        aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable GN
                        var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GN", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                        aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable GG
                        var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                        aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GFA", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable GFA
                        var_GFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GFA", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("GFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFA);
                        aux_last_type_read_for_GFA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GFB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable GFB
                        var_GFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GFB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("GFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFB);
                        aux_last_type_read_for_GFB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable DER
                        var_DER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("DER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DER);
                        aux_last_type_read_for_DER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGN", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable DGN
                        var_DGN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGN", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("DGN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGN);
                        aux_last_type_read_for_DGN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGG", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable DGG
                        var_DGG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGG", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("DGG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGG);
                        aux_last_type_read_for_DGG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGFA", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable DGFA
                        var_DGFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGFA", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("DGFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGFA);
                        aux_last_type_read_for_DGFA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGFB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable DGFB
                        var_DGFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGFB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("DGFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGFB);
                        aux_last_type_read_for_DGFB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cont << cpp_draft_line;
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NDIGIT , NNN , NM , 0 ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read CONT record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("NDIGIT", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NDIGIT
                    var_NDIGIT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NDIGIT", std::vector<int>({}), py::none()));
                    aux_NDIGIT_read = true;
                    validate_vartype_consistency("NDIGIT", SCALAR_INT, aux_last_type_read_for_NDIGIT);
                    aux_last_type_read_for_NDIGIT = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("NNN", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NNN
                    var_NNN_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NNN", std::vector<int>({}), py::none()));
                    aux_NNN_read = true;
                    validate_vartype_consistency("NNN", SCALAR_INT, aux_last_type_read_for_NNN);
                    aux_last_type_read_for_NNN = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NM", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NM
                    var_NM_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NM", std::vector<int>({}), py::none()));
                    aux_NM_read = true;
                    validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
                    aux_last_type_read_for_NM = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                    cont << cpp_draft_line;

                    for (int var_k_0d_int_Scalar = 1;
                       var_k_0d_int_Scalar <= var_NM_0d_int_Scalar; var_k_0d_int_Scalar++) {
                      bool aux_k_read = true;
                      {
                        cpp_template = "[ MAT , 32 , 151 / II , JJ , KIJ { NDIGIT } ] INTG";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        int cpp_ndigit = var_NDIGIT_0d_int_Scalar;
                        if ((cpp_ndigit < 2 || cpp_ndigit > 6)) {
                          throw std::runtime_error("invalid NDIGIT (must be between 2 and 6)");
                        }
                        cpp_write_custom_int_field(cpp_draft_line, 0, 5, py::cast<int>(cpp_index_shifter_store.get_value("II", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        cpp_write_custom_int_field(cpp_draft_line, 5, 5, py::cast<int>(cpp_index_shifter_store.get_value("JJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        // assign expression to variable II
                        var_II_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("II", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("II", NESTEDVECTOR_INT, aux_last_type_read_for_II);
                        aux_last_type_read_for_II = NESTEDVECTOR_INT;
                        // assign expression to variable JJ
                        var_JJ_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("JJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("JJ", NESTEDVECTOR_INT, aux_last_type_read_for_JJ);
                        aux_last_type_read_for_JJ = NESTEDVECTOR_INT;
                        int cpp_step = cpp_ndigit + 1;
                        int cpp_end = 65;
                        int cpp_start;
                        if (cpp_ndigit <= 5) {
                          cpp_start = 11;
                        } else {
                          cpp_start = 10;
                        }
                        std::vector<int> cpp_intvec;
                        int elpos = 0;
                        for (int cpp_i = cpp_start; cpp_i < cpp_end; cpp_i += cpp_step) {
                        cpp_write_custom_int_field(cpp_draft_line, cpp_i, cpp_step, py::cast<int>(cpp_index_shifter_store.get_value("KIJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())[py::cast(elpos)]));
                          cpp_intvec.push_back(py::cast<int>(cpp_index_shifter_store.get_value("KIJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())[py::cast(elpos)]));
                          elpos++;
                        }
                        // assign expression to variable KIJ
                        var_KIJ_1d_intvec_NestedVector.set(var_k_0d_int_Scalar, cpp_intvec);
                        validate_vartype_consistency("KIJ", NESTEDVECTOR_INTVEC, aux_last_type_read_for_KIJ);
                        aux_last_type_read_for_KIJ = NESTEDVECTOR_INTVEC;
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    EndfFloatCpp& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    EndfFloatCpp var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    EndfFloatCpp& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    EndfFloatCpp var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    int& glob_var_IFG_0d_int_Scalar = var_IFG_0d_int_Scalar;
                    int var_IFG_0d_int_Scalar = glob_var_IFG_0d_int_Scalar;
                    bool& glob_aux_IFG_read = aux_IFG_read;
                    bool aux_IFG_read = glob_aux_IFG_read;
                    vartype aux_last_type_read_for_IFG = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_NJS_0d_int_Scalar = var_NJS_0d_int_Scalar;
                    int var_NJS_0d_int_Scalar = glob_var_NJS_0d_int_Scalar;
                    bool& glob_aux_NJS_read = aux_NJS_read;
                    bool aux_NJS_read = glob_aux_NJS_read;
                    vartype aux_last_type_read_for_NJS = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    try {
                      cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , IFG , LCOMP , NJS , ISR ] CONT";
                      // read CONT record
                      // assign expression to variable IFG
                      var_IFG_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("IFG", std::vector<int>({}), py::cast(-99999)));
                      aux_IFG_read = true;
                      validate_vartype_consistency("IFG", SCALAR_INT, aux_last_type_read_for_IFG);
                      aux_last_type_read_for_IFG = SCALAR_INT;
                      // assign expression to variable LCOMP
                      var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::cast(-99999)));
                      aux_LCOMP_read = true;
                      validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                      aux_last_type_read_for_LCOMP = SCALAR_INT;
                      // assign expression to variable NJS
                      var_NJS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::cast(-99999)));
                      aux_NJS_read = true;
                      validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                      aux_last_type_read_for_NJS = SCALAR_INT;
                      // assign expression to variable ISR
                      var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::cast(-99999)));
                      aux_ISR_read = true;
                      validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                      aux_last_type_read_for_ISR = SCALAR_INT;
                    } catch (const std::out_of_range& e) {
                      // // accept failure in lookahead
                    }
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(2)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(7)))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , IFG , LCOMP , NJS , ISR ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read CONT record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("IFG", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable IFG
                    var_IFG_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("IFG", std::vector<int>({}), py::none()));
                    aux_IFG_read = true;
                    validate_vartype_consistency("IFG", SCALAR_INT, aux_last_type_read_for_IFG);
                    aux_last_type_read_for_IFG = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCOMP", std::vector<int>({}), py::none()));
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NJS
                    var_NJS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none()));
                    aux_NJS_read = true;
                    validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                    aux_last_type_read_for_NJS = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("ISR", std::vector<int>({}), py::none()));
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    cont << cpp_draft_line;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , NJCH , (1+((NJCH-1)/6)) / \n { { DAP } { n = 1 to (NJCH/NJS) } } { m = 1 to (NJCH/NJS) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NJCH", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable NJCH
                          var_NJCH_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NJCH", std::vector<int>({}), py::none()));
                          aux_NJCH_read = true;
                          validate_vartype_consistency("NJCH", SCALAR_INT, aux_last_type_read_for_NJCH);
                          aux_last_type_read_for_NJCH = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, (1+((py::cast<int>(cpp_index_shifter_store.get_value("NJCH", std::vector<int>({}), py::none()))-1)/6)), write_opts);
                          if ((! (aux_NJCH_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (1+((py::cast<int>(cpp_index_shifter_store.get_value("NJCH", std::vector<int>({}), py::none()))-1)/6));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NJCH
                            var_NJCH_0d_int_Scalar = ((((((1/6)*(-1))+1)*(-1))+cpp_int_val)/(1/6));
                            aux_NJCH_read = true;
                            validate_vartype_consistency("NJCH", SCALAR_INT, aux_last_type_read_for_NJCH);
                            aux_last_type_read_for_NJCH = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NJCH", std::vector<int>({}), py::none())), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NJCH", std::vector<int>({}), py::none()));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body
                            var_DAP_2d_double_Matrix2d.init(1, (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar), 1, (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar), false, false);

                            for (int var_m_0d_int_Scalar = 1;
                               var_m_0d_int_Scalar <= (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar); var_m_0d_int_Scalar++) {
                              bool aux_m_read = true;
                              // read LIST body

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar); var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // read LIST body
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({var_m_0d_int_Scalar, var_n_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable DAP
                                var_DAP_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DAP", std::vector<int>({var_m_0d_int_Scalar, var_n_0d_int_Scalar}), py::none()));
                                validate_vartype_consistency("DAP", MATRIX2D_DOUBLE, aux_last_type_read_for_DAP);
                                aux_last_type_read_for_DAP = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NPP , NJSX , (12*NPP) , (2*NPP) / \n { MA , MB , ZA , ZB , IA , IB , \n Q , PNT , SHF , MT , PA , PB } { k = 1 to NPP } ] LIST";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read LIST record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NPP
                    var_NPP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none()));
                    aux_NPP_read = true;
                    validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                    aux_last_type_read_for_NPP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("NJSX", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NJSX
                    var_NJSX_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NJSX", std::vector<int>({}), py::none()));
                    aux_NJSX_read = true;
                    validate_vartype_consistency("NJSX", SCALAR_INT, aux_last_type_read_for_NJSX);
                    aux_last_type_read_for_NJSX = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none()))), write_opts);
                    if ((! (aux_NPP_read == true))) {
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (12*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none())));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NPP
                      var_NPP_0d_int_Scalar = (cpp_int_val/12);
                      aux_NPP_read = true;
                      validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                      aux_last_type_read_for_NPP = SCALAR_INT;
                    } else {
                    }
                    cpp_write_field<int>(cpp_draft_line, 5, (2*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none()))), write_opts);
                    if ((! (aux_NPP_read == true))) {
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none())));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NPP
                      var_NPP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NPP_read = true;
                      validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                      aux_last_type_read_for_NPP = SCALAR_INT;
                    } else {
                    }
                    cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none()))), write_opts);
                    cont << cpp_draft_line;
                    {
                      int cpp_npl = (12*py::cast<int>(cpp_index_shifter_store.get_value("NPP", std::vector<int>({}), py::none())));
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_NPP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("MA", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable MA
                        var_MA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("MA", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("MA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MA);
                        aux_last_type_read_for_MA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("MB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable MB
                        var_MB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("MB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("MB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MB);
                        aux_last_type_read_for_MB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable ZA
                        var_ZA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("ZA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZA);
                        aux_last_type_read_for_ZA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable ZB
                        var_ZB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("ZB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZB);
                        aux_last_type_read_for_ZB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("IA", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable IA
                        var_IA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("IA", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("IA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IA);
                        aux_last_type_read_for_IA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("IB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable IB
                        var_IB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("IB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("IB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IB);
                        aux_last_type_read_for_IB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Q", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable Q
                        var_Q_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Q", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("Q", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Q);
                        aux_last_type_read_for_Q = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PNT", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable PNT
                        var_PNT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PNT", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("PNT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PNT);
                        aux_last_type_read_for_PNT = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SHF", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable SHF
                        var_SHF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SHF", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("SHF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SHF);
                        aux_last_type_read_for_SHF = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("MT", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable MT
                        var_MT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("MT", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("MT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MT);
                        aux_last_type_read_for_MT = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PA", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable PA
                        var_PA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PA", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("PA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PA);
                        aux_last_type_read_for_PA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PB", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable PB
                        var_PB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PB", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("PB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PB);
                        aux_last_type_read_for_PB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cont << cpp_draft_line;

                    for (int var_q_0d_int_Scalar = 1;
                       var_q_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_q_0d_int_Scalar++) {
                      bool aux_q_read = true;
                      // open section somesec
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        cpp_current_dict = cpp_index_shifter_store.get_value("somesec", std::vector<int>({var_q_0d_int_Scalar}), py::dict());
                        IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                        // variable declarations
                        EndfFloatCpp var_AJ_0d_double_Scalar;
                        bool aux_AJ_read = false;
                        vartype aux_last_type_read_for_AJ = UNKNOWN;
                        EndfFloatCpp var_PJ_0d_double_Scalar;
                        bool aux_PJ_read = false;
                        vartype aux_last_type_read_for_PJ = UNKNOWN;
                        int cpp_int_val;
                        bool aux_cpp_int_val_read = false;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int var_NCH_0d_int_Scalar;
                        bool aux_NCH_read = false;
                        vartype aux_last_type_read_for_NCH = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_PPI_1d_double_NestedVector;
                        vartype aux_last_type_read_for_PPI = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_L_1d_double_NestedVector;
                        vartype aux_last_type_read_for_L = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_SCH_1d_double_NestedVector;
                        vartype aux_last_type_read_for_SCH = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_BND_1d_double_NestedVector;
                        vartype aux_last_type_read_for_BND = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_APE_1d_double_NestedVector;
                        vartype aux_last_type_read_for_APE = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_APT_1d_double_NestedVector;
                        vartype aux_last_type_read_for_APT = UNKNOWN;
                        int var_NRSA_0d_int_Scalar;
                        bool aux_NRSA_read = false;
                        vartype aux_last_type_read_for_NRSA = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_ER = UNKNOWN;
                        Matrix2d<EndfFloatCpp> var_GAM_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_GAM = UNKNOWN;
                        NestedVector<EndfFloatCpp> var_DER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_DER = UNKNOWN;
                        Matrix2d<EndfFloatCpp> var_DGAM_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_DGAM = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / AJ , PJ , 0 , 0 , (6*NCH) , NCH / \n { PPI , L , SCH , BND , APE , APT } { k = 1 to NCH } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable AJ
                        var_AJ_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({}), py::none()));
                        aux_AJ_read = true;
                        validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                        aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PJ", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable PJ
                        var_PJ_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PJ", std::vector<int>({}), py::none()));
                        aux_PJ_read = true;
                        validate_vartype_consistency("PJ", SCALAR_DOUBLE, aux_last_type_read_for_PJ);
                        aux_last_type_read_for_PJ = SCALAR_DOUBLE;
                        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none()))), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = (6*py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())));
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NCH
                        var_NCH_0d_int_Scalar = (cpp_int_val/6);
                        aux_NCH_read = true;
                        validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                        aux_last_type_read_for_NCH = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())), write_opts);
                        if ((! (aux_NCH_read == true))) {
                          // assign expression to variable NCH
                          var_NCH_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none()));
                          aux_NCH_read = true;
                          validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                          aux_last_type_read_for_NCH = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none()))), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = (6*py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PPI", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable PPI
                            var_PPI_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("PPI", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("PPI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PPI);
                            aux_last_type_read_for_PPI = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("L", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable L
                            var_L_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("L", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("L", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_L);
                            aux_last_type_read_for_L = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SCH", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable SCH
                            var_SCH_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SCH", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("SCH", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SCH);
                            aux_last_type_read_for_SCH = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("BND", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable BND
                            var_BND_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("BND", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("BND", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BND);
                            aux_last_type_read_for_BND = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APE", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable APE
                            var_APE_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APE", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("APE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APE);
                            aux_last_type_read_for_APE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APT", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable APT
                            var_APT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("APT", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("APT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APT);
                            aux_last_type_read_for_APT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , NRSA , (12*NX) , NX / \n { ER , { GAM } { p = 1 to NCH } , { 0.0 } { r = 1 to num_zeros } \n DER , { DGAM } { p = 1 to NCH } , { 0.0 } { r = 1 to num_zeros } \n } { k = 1 to NRSA } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NRSA
                        var_NRSA_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none()));
                        aux_NRSA_read = true;
                        validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                        aux_last_type_read_for_NRSA = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, (12*((((2*(py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none()))+1))+(2*((5-py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))%6)))*py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none())))/12)), write_opts);
                        if ((! (aux_NCH_read == true))) {
                          throw std::runtime_error("The equation (12*((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12))==value cannot be solved for NCH because the modulo operator is not supported.");
                        } else {
                        }
                        if ((! (aux_NRSA_read == true))) {
                          throw std::runtime_error("The equation (12*((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12))==value cannot be solved for NRSA because the modulo operator is not supported.");
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 5, ((((2*(py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none()))+1))+(2*((5-py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))%6)))*py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none())))/12), write_opts);
                        if ((! (aux_NCH_read == true))) {
                          throw std::runtime_error("The equation ((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12)==value cannot be solved for NCH because the modulo operator is not supported.");
                        } else {
                        }
                        if ((! (aux_NRSA_read == true))) {
                          throw std::runtime_error("The equation ((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12)==value cannot be solved for NRSA because the modulo operator is not supported.");
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, (12*((((2*(py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none()))+1))+(2*((5-py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))%6)))*py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none())))/12)), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = (12*((((2*(py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none()))+1))+(2*((5-py::cast<int>(cpp_index_shifter_store.get_value("NCH", std::vector<int>({}), py::none())))%6)))*py::cast<int>(cpp_index_shifter_store.get_value("NRSA", std::vector<int>({}), py::none())))/12));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body
                          var_GAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRSA_0d_int_Scalar, false, false);
                          var_DGAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRSA_0d_int_Scalar, false, false);

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NRSA_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }

                            for (int var_p_0d_int_Scalar = 1;
                               var_p_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_p_0d_int_Scalar++) {
                              bool aux_p_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GAM", std::vector<int>({var_p_0d_int_Scalar, var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable GAM
                              var_GAM_2d_double_Matrix2d(var_p_0d_int_Scalar, var_k_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GAM", std::vector<int>({var_p_0d_int_Scalar, var_k_0d_int_Scalar}), py::none()));
                              validate_vartype_consistency("GAM", MATRIX2D_DOUBLE, aux_last_type_read_for_GAM);
                              aux_last_type_read_for_GAM = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }

                            for (int var_r_0d_int_Scalar = 1;
                               var_r_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_r_0d_int_Scalar++) {
                              bool aux_r_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable DER
                            var_DER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("DER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DER);
                            aux_last_type_read_for_DER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }

                            for (int var_p_0d_int_Scalar = 1;
                               var_p_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_p_0d_int_Scalar++) {
                              bool aux_p_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGAM", std::vector<int>({var_p_0d_int_Scalar, var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable DGAM
                              var_DGAM_2d_double_Matrix2d(var_p_0d_int_Scalar, var_k_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("DGAM", std::vector<int>({var_p_0d_int_Scalar, var_k_0d_int_Scalar}), py::none()));
                              validate_vartype_consistency("DGAM", MATRIX2D_DOUBLE, aux_last_type_read_for_DGAM);
                              aux_last_type_read_for_DGAM = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }

                            for (int var_r_0d_int_Scalar = 1;
                               var_r_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_r_0d_int_Scalar++) {
                              bool aux_r_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, 0.0, write_opts);
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                        cpp_current_dict = cpp_parent_dict;
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NDIGIT , NNN , NM , 0 ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read CONT record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("NDIGIT", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NDIGIT
                    var_NDIGIT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NDIGIT", std::vector<int>({}), py::none()));
                    aux_NDIGIT_read = true;
                    validate_vartype_consistency("NDIGIT", SCALAR_INT, aux_last_type_read_for_NDIGIT);
                    aux_last_type_read_for_NDIGIT = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("NNN", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NNN
                    var_NNN_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NNN", std::vector<int>({}), py::none()));
                    aux_NNN_read = true;
                    validate_vartype_consistency("NNN", SCALAR_INT, aux_last_type_read_for_NNN);
                    aux_last_type_read_for_NNN = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NM", std::vector<int>({}), py::none())), write_opts);
                    // assign expression to variable NM
                    var_NM_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NM", std::vector<int>({}), py::none()));
                    aux_NM_read = true;
                    validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
                    aux_last_type_read_for_NM = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                    cont << cpp_draft_line;

                    for (int var_q_0d_int_Scalar = 1;
                       var_q_0d_int_Scalar <= var_NM_0d_int_Scalar; var_q_0d_int_Scalar++) {
                      bool aux_q_read = true;
                      {
                        cpp_template = "[ MAT , 32 , 151 / II , JJ , KIJ { NDIGIT } ] INTG";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        int cpp_ndigit = var_NDIGIT_0d_int_Scalar;
                        if ((cpp_ndigit < 2 || cpp_ndigit > 6)) {
                          throw std::runtime_error("invalid NDIGIT (must be between 2 and 6)");
                        }
                        cpp_write_custom_int_field(cpp_draft_line, 0, 5, py::cast<int>(cpp_index_shifter_store.get_value("II", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                        cpp_write_custom_int_field(cpp_draft_line, 5, 5, py::cast<int>(cpp_index_shifter_store.get_value("JJ", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                        // assign expression to variable II
                        var_II_1d_int_NestedVector.set(var_q_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("II", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("II", NESTEDVECTOR_INT, aux_last_type_read_for_II);
                        aux_last_type_read_for_II = NESTEDVECTOR_INT;
                        // assign expression to variable JJ
                        var_JJ_1d_int_NestedVector.set(var_q_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("JJ", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                        validate_vartype_consistency("JJ", NESTEDVECTOR_INT, aux_last_type_read_for_JJ);
                        aux_last_type_read_for_JJ = NESTEDVECTOR_INT;
                        int cpp_step = cpp_ndigit + 1;
                        int cpp_end = 65;
                        int cpp_start;
                        if (cpp_ndigit <= 5) {
                          cpp_start = 11;
                        } else {
                          cpp_start = 10;
                        }
                        std::vector<int> cpp_intvec;
                        int elpos = 0;
                        for (int cpp_i = cpp_start; cpp_i < cpp_end; cpp_i += cpp_step) {
                        cpp_write_custom_int_field(cpp_draft_line, cpp_i, cpp_step, py::cast<int>(cpp_index_shifter_store.get_value("KIJ", std::vector<int>({var_q_0d_int_Scalar}), py::none())[py::cast(elpos)]));
                          cpp_intvec.push_back(py::cast<int>(cpp_index_shifter_store.get_value("KIJ", std::vector<int>({var_q_0d_int_Scalar}), py::none())[py::cast(elpos)]));
                          elpos++;
                        }
                        // assign expression to variable KIJ
                        var_KIJ_1d_intvec_NestedVector.set(var_q_0d_int_Scalar, cpp_intvec);
                        validate_vartype_consistency("KIJ", NESTEDVECTOR_INTVEC, aux_last_type_read_for_KIJ);
                        aux_last_type_read_for_KIJ = NESTEDVECTOR_INTVEC;
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                if ((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(2)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  // read CONT record
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none())), write_opts);
                  // assign expression to variable SPI
                  var_SPI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("SPI", std::vector<int>({}), py::none()));
                  aux_SPI_read = true;
                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none())), write_opts);
                  // assign expression to variable AP
                  var_AP_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AP", std::vector<int>({}), py::none()));
                  aux_AP_read = true;
                  validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                  aux_last_type_read_for_AP = SCALAR_DOUBLE;
                  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none())), write_opts);
                  // assign expression to variable NLS
                  var_NLS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NLS", std::vector<int>({}), py::none()));
                  aux_NLS_read = true;
                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                  aux_last_type_read_for_NLS = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                  cont << cpp_draft_line;

                  for (int var_q_0d_int_Scalar = 1;
                     var_q_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_q_0d_int_Scalar++) {
                    bool aux_q_read = true;
                    // open section l_group
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      cpp_current_dict = cpp_index_shifter_store.get_value("l_group", std::vector<int>({var_q_0d_int_Scalar}), py::dict());
                      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                      // variable declarations
                      EndfFloatCpp var_AWRI_0d_double_Scalar;
                      bool aux_AWRI_read = false;
                      vartype aux_last_type_read_for_AWRI = UNKNOWN;
                      int var_L_0d_int_Scalar;
                      bool aux_L_read = false;
                      vartype aux_last_type_read_for_L = UNKNOWN;
                      int cpp_int_val;
                      bool aux_cpp_int_val_read = false;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int var_NJS_0d_int_Scalar;
                      bool aux_NJS_read = false;
                      vartype aux_last_type_read_for_NJS = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_D_1d_double_NestedVector;
                      vartype aux_last_type_read_for_D = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_AJ_1d_double_NestedVector;
                      vartype aux_last_type_read_for_AJ = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GNO_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GNO = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GG = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GF = UNKNOWN;
                      NestedVector<EndfFloatCpp> var_GX_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GX = UNKNOWN;
                      cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , L , 0 , (6*NJS) , NJS / \n { D , AJ , GNO , GG , GF , GX } { k = 1 to NJS } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read LIST record
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable AWRI
                      var_AWRI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWRI", std::vector<int>({}), py::none()));
                      aux_AWRI_read = true;
                      validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                      aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable L
                      var_L_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({}), py::none()));
                      aux_L_read = true;
                      validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                      aux_last_type_read_for_L = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none()))), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (6*py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none())));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NJS
                      var_NJS_0d_int_Scalar = (cpp_int_val/6);
                      aux_NJS_read = true;
                      validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                      aux_last_type_read_for_NJS = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none())), write_opts);
                      if ((! (aux_NJS_read == true))) {
                        // assign expression to variable NJS
                        var_NJS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none()));
                        aux_NJS_read = true;
                        validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                        aux_last_type_read_for_NJS = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none()))), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (6*py::cast<int>(cpp_index_shifter_store.get_value("NJS", std::vector<int>({}), py::none())));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST body

                        for (int var_k_0d_int_Scalar = 1;
                           var_k_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                          bool aux_k_read = true;
                          // read LIST body
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("D", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable D
                          var_D_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("D", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("D", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_D);
                          aux_last_type_read_for_D = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable AJ
                          var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AJ", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                          aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GNO", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable GNO
                          var_GNO_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GNO", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("GNO", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GNO);
                          aux_last_type_read_for_GNO = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable GG
                          var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GG", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                          aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable GF
                          var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GF", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                          aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GX", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable GX
                          var_GX_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("GX", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("GX", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GX);
                          aux_last_type_read_for_GX = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                  cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , MPAR , 0 , ((NPAR*(NPAR+1))/2) , NPAR / \n { { RV } { q = p to NPAR } } { p = 1 to NPAR } ] LIST";
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  // read LIST record
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none())), write_opts);
                  // assign expression to variable MPAR
                  var_MPAR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MPAR", std::vector<int>({}), py::none()));
                  aux_MPAR_read = true;
                  validate_vartype_consistency("MPAR", SCALAR_INT, aux_last_type_read_for_MPAR);
                  aux_last_type_read_for_MPAR = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NPAR", std::vector<int>({}), py::none())), write_opts);
                  // assign expression to variable NPAR
                  var_NPAR_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NPAR", std::vector<int>({}), py::none()));
                  aux_NPAR_read = true;
                  validate_vartype_consistency("NPAR", SCALAR_INT, aux_last_type_read_for_NPAR);
                  aux_last_type_read_for_NPAR = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_index_shifter_store.get_value("NPAR", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NPAR", std::vector<int>({}), py::none()))+1))/2), write_opts);
                  if ((! (aux_NPAR_read == true))) {
                    throw std::runtime_error("The equation ((NPAR*(NPAR+1))/2)==value cannot be solved for NPAR because this variable could not be isolated.");
                  } else {
                  }
                  cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_index_shifter_store.get_value("NPAR", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NPAR", std::vector<int>({}), py::none()))+1))/2), write_opts);
                  cont << cpp_draft_line;
                  {
                    int cpp_npl = ((py::cast<int>(cpp_index_shifter_store.get_value("NPAR", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NPAR", std::vector<int>({}), py::none()))+1))/2);
                    int cpp_i = 0;
                    int cpp_j = 0;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read LIST body
                    var_RV_2d_double_Matrix2d.init(1, var_NPAR_0d_int_Scalar, 1, var_NPAR_0d_int_Scalar, true, false);

                    for (int var_p_0d_int_Scalar = 1;
                       var_p_0d_int_Scalar <= var_NPAR_0d_int_Scalar; var_p_0d_int_Scalar++) {
                      bool aux_p_read = true;
                      // read LIST body

                      for (int var_q_0d_int_Scalar = var_p_0d_int_Scalar;
                         var_q_0d_int_Scalar <= var_NPAR_0d_int_Scalar; var_q_0d_int_Scalar++) {
                        bool aux_q_read = true;
                        // read LIST body
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RV", std::vector<int>({var_p_0d_int_Scalar, var_q_0d_int_Scalar}), py::none())), write_opts);
                        // assign expression to variable RV
                        var_RV_2d_double_Matrix2d(var_p_0d_int_Scalar, var_q_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("RV", std::vector<int>({var_p_0d_int_Scalar, var_q_0d_int_Scalar}), py::none()));
                        validate_vartype_consistency("RV", MATRIX2D_DOUBLE, aux_last_type_read_for_RV);
                        aux_last_type_read_for_RV = MATRIX2D_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          cpp_j = 0;
                        }
                      }
                    }
                    if (cpp_i != cpp_npl) {
                      throw std::runtime_error("not exactly NPL elements consumed");
                    }
                  }
                  cont << cpp_draft_line;
                }
              }
            }
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 284c3ace698a427c06623ccd760dca26
// MD5 hash of the following function definition: 4b3b687317b7bda613499a5b905d2ec6
void write_mf33_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_MTL_0d_int_Scalar;
  bool aux_MTL_read = false;
  vartype aux_last_type_read_for_MTL = UNKNOWN;
  int var_NL_0d_int_Scalar;
  bool aux_NL_read = false;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 33;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 33;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 33 , MT / ZA , AWR , 0 , MTL , 0 , NL ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MTL", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable MTL
  var_MTL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MTL", std::vector<int>({}), py::none()));
  aux_MTL_read = true;
  validate_vartype_consistency("MTL", SCALAR_INT, aux_last_type_read_for_MTL);
  aux_last_type_read_for_MTL = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NL
  var_NL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::none()));
  aux_NL_read = true;
  validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
  aux_last_type_read_for_NL = SCALAR_INT;
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_MTL_read == true)) && ((var_MTL_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;

        for (int var_n_0d_int_Scalar = 1;
           var_n_0d_int_Scalar <= var_NL_0d_int_Scalar; var_n_0d_int_Scalar++) {
          bool aux_n_read = true;
          // open section subsection
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            cpp_current_dict = cpp_index_shifter_store.get_value("subsection", std::vector<int>({var_n_0d_int_Scalar}), py::dict());
            IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
            // variable declarations
            EndfFloatCpp var_XMF1_0d_double_Scalar;
            bool aux_XMF1_read = false;
            vartype aux_last_type_read_for_XMF1 = UNKNOWN;
            EndfFloatCpp var_XLFS1_0d_double_Scalar;
            bool aux_XLFS1_read = false;
            vartype aux_last_type_read_for_XLFS1 = UNKNOWN;
            int var_MAT1_0d_int_Scalar;
            bool aux_MAT1_read = false;
            vartype aux_last_type_read_for_MAT1 = UNKNOWN;
            int var_MT1_0d_int_Scalar;
            bool aux_MT1_read = false;
            vartype aux_last_type_read_for_MT1 = UNKNOWN;
            int var_NC_0d_int_Scalar;
            bool aux_NC_read = false;
            vartype aux_last_type_read_for_NC = UNKNOWN;
            int var_NI_0d_int_Scalar;
            bool aux_NI_read = false;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            cpp_template = "[ MAT , 33 , MT / XMF1 , XLFS1 , MAT1 , MT1 , NC , NI ] CONT";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
            // read CONT record
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMF1", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable XMF1
            var_XMF1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMF1", std::vector<int>({}), py::none()));
            aux_XMF1_read = true;
            validate_vartype_consistency("XMF1", SCALAR_DOUBLE, aux_last_type_read_for_XMF1);
            aux_last_type_read_for_XMF1 = SCALAR_DOUBLE;
            cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XLFS1", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable XLFS1
            var_XLFS1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XLFS1", std::vector<int>({}), py::none()));
            aux_XLFS1_read = true;
            validate_vartype_consistency("XLFS1", SCALAR_DOUBLE, aux_last_type_read_for_XLFS1);
            aux_last_type_read_for_XLFS1 = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("MAT1", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable MAT1
            var_MAT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT1", std::vector<int>({}), py::none()));
            aux_MAT1_read = true;
            validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
            aux_last_type_read_for_MAT1 = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MT1", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable MT1
            var_MT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT1", std::vector<int>({}), py::none()));
            aux_MT1_read = true;
            validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
            aux_last_type_read_for_MT1 = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NC
            var_NC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none()));
            aux_NC_read = true;
            validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
            aux_last_type_read_for_NC = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none())), write_opts);
            // assign expression to variable NI
            var_NI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none()));
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
            cont << cpp_draft_line;

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NC_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section nc_subsection
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.get_value("nc_subsection", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                // variable declarations
                int var_LTY_0d_int_Scalar;
                bool aux_LTY_read = false;
                vartype aux_last_type_read_for_LTY = UNKNOWN;
                EndfFloatCpp var_E1_0d_double_Scalar;
                bool aux_E1_read = false;
                vartype aux_last_type_read_for_E1 = UNKNOWN;
                EndfFloatCpp var_E2_0d_double_Scalar;
                bool aux_E2_read = false;
                vartype aux_last_type_read_for_E2 = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NCI_0d_int_Scalar;
                bool aux_NCI_read = false;
                vartype aux_last_type_read_for_NCI = UNKNOWN;
                NestedVector<EndfFloatCpp> var_C_1d_double_NestedVector;
                vartype aux_last_type_read_for_C = UNKNOWN;
                NestedVector<EndfFloatCpp> var_XMT_1d_double_NestedVector;
                vartype aux_last_type_read_for_XMT = UNKNOWN;
                int var_MATS_0d_int_Scalar;
                bool aux_MATS_read = false;
                vartype aux_last_type_read_for_MATS = UNKNOWN;
                int var_MTS_0d_int_Scalar;
                bool aux_MTS_read = false;
                vartype aux_last_type_read_for_MTS = UNKNOWN;
                int var_NEI_0d_int_Scalar;
                bool aux_NEI_read = false;
                vartype aux_last_type_read_for_NEI = UNKNOWN;
                EndfFloatCpp var_XMFS_0d_double_Scalar;
                bool aux_XMFS_read = false;
                vartype aux_last_type_read_for_XMFS = UNKNOWN;
                EndfFloatCpp var_XLFSS_0d_double_Scalar;
                bool aux_XLFSS_read = false;
                vartype aux_last_type_read_for_XLFSS = UNKNOWN;
                NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                NestedVector<EndfFloatCpp> var_WE_1d_double_NestedVector;
                vartype aux_last_type_read_for_WE = UNKNOWN;
                cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                // read CONT record
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LTY", std::vector<int>({}), py::none())), write_opts);
                // assign expression to variable LTY
                var_LTY_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LTY", std::vector<int>({}), py::none()));
                aux_LTY_read = true;
                validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                aux_last_type_read_for_LTY = SCALAR_INT;
                cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                cont << cpp_draft_line;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if ((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(0)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      cpp_template = "[ MAT , 33 , MT / E1 , E2 , 0 , 0 , (2*NCI) , NCI / \n { C , XMT } { i = 1 to NCI } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read LIST record
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable E1
                      var_E1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none()));
                      aux_E1_read = true;
                      validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                      aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable E2
                      var_E2_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none()));
                      aux_E2_read = true;
                      validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                      aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none()))), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none())));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NCI
                      var_NCI_0d_int_Scalar = (cpp_int_val/2);
                      aux_NCI_read = true;
                      validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                      aux_last_type_read_for_NCI = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none())), write_opts);
                      if ((! (aux_NCI_read == true))) {
                        // assign expression to variable NCI
                        var_NCI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none()));
                        aux_NCI_read = true;
                        validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                        aux_last_type_read_for_NCI = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none()))), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (2*py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none())));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST body

                        for (int var_i_0d_int_Scalar = 1;
                           var_i_0d_int_Scalar <= var_NCI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                          bool aux_i_read = true;
                          // read LIST body
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("C", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable C
                          var_C_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("C", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
                          aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMT", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable XMT
                          var_XMT_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMT", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("XMT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_XMT);
                          aux_last_type_read_for_XMT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if (((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)>=(1)))))&&((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)<=(3)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 33 , MT / E1 , E2 , MATS , MTS , ((2*NEI)+2) , NEI / \n XMFS , XLFSS , { E , WE } { i = 1 to NEI } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable E1
                        var_E1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none()));
                        aux_E1_read = true;
                        validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                        aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable E2
                        var_E2_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none()));
                        aux_E2_read = true;
                        validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                        aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("MATS", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable MATS
                        var_MATS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MATS", std::vector<int>({}), py::none()));
                        aux_MATS_read = true;
                        validate_vartype_consistency("MATS", SCALAR_INT, aux_last_type_read_for_MATS);
                        aux_last_type_read_for_MATS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MTS", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable MTS
                        var_MTS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MTS", std::vector<int>({}), py::none()));
                        aux_MTS_read = true;
                        validate_vartype_consistency("MTS", SCALAR_INT, aux_last_type_read_for_MTS);
                        aux_last_type_read_for_MTS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, ((2*py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())))+2), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = ((2*py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())))+2);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NEI
                        var_NEI_0d_int_Scalar = ((cpp_int_val+(-2))/2);
                        aux_NEI_read = true;
                        validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                        aux_last_type_read_for_NEI = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())), write_opts);
                        if ((! (aux_NEI_read == true))) {
                          // assign expression to variable NEI
                          var_NEI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none()));
                          aux_NEI_read = true;
                          validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                          aux_last_type_read_for_NEI = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, ((2*py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())))+2), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = ((2*py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())))+2);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMFS", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable XMFS
                          var_XMFS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMFS", std::vector<int>({}), py::none()));
                          aux_XMFS_read = true;
                          validate_vartype_consistency("XMFS", SCALAR_DOUBLE, aux_last_type_read_for_XMFS);
                          aux_last_type_read_for_XMFS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XLFSS", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable XLFSS
                          var_XLFSS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XLFSS", std::vector<int>({}), py::none()));
                          aux_XLFSS_read = true;
                          validate_vartype_consistency("XLFSS", SCALAR_DOUBLE, aux_last_type_read_for_XLFSS);
                          aux_last_type_read_for_XLFSS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }

                          for (int var_i_0d_int_Scalar = 1;
                             var_i_0d_int_Scalar <= var_NEI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                            bool aux_i_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("WE", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable WE
                            var_WE_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("WE", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("WE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_WE);
                            aux_last_type_read_for_WE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NI_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section ni_subsection
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                cpp_current_dict = cpp_index_shifter_store.get_value("ni_subsection", std::vector<int>({var_m_0d_int_Scalar}), py::dict());
                IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
                // variable declarations
                int var_LT_0d_int_Scalar;
                bool aux_LT_read = false;
                vartype aux_last_type_read_for_LT = UNKNOWN;
                int var_LB_0d_int_Scalar;
                bool aux_LB_read = false;
                vartype aux_last_type_read_for_LB = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NP_0d_int_Scalar;
                bool aux_NP_read = false;
                vartype aux_last_type_read_for_NP = UNKNOWN;
                NestedVector<EndfFloatCpp> var_Ek_1d_double_NestedVector;
                vartype aux_last_type_read_for_Ek = UNKNOWN;
                NestedVector<EndfFloatCpp> var_Fk_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fk = UNKNOWN;
                NestedVector<EndfFloatCpp> var_El_1d_double_NestedVector;
                vartype aux_last_type_read_for_El = UNKNOWN;
                NestedVector<EndfFloatCpp> var_Fl_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fl = UNKNOWN;
                int var_LS_0d_int_Scalar;
                bool aux_LS_read = false;
                vartype aux_last_type_read_for_LS = UNKNOWN;
                int var_NE_0d_int_Scalar;
                bool aux_NE_read = false;
                vartype aux_last_type_read_for_NE = UNKNOWN;
                NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                Matrix2d<EndfFloatCpp> var_F_2d_double_Matrix2d;
                vartype aux_last_type_read_for_F = UNKNOWN;
                int var_NER_0d_int_Scalar;
                bool aux_NER_read = false;
                vartype aux_last_type_read_for_NER = UNKNOWN;
                int var_NEC_0d_int_Scalar;
                bool aux_NEC_read = false;
                vartype aux_last_type_read_for_NEC = UNKNOWN;
                NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
                vartype aux_last_type_read_for_ER = UNKNOWN;
                NestedVector<EndfFloatCpp> var_EC_1d_double_NestedVector;
                vartype aux_last_type_read_for_EC = UNKNOWN;
                NestedVector<EndfFloatCpp> var_F_1d_double_NestedVector;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                        int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                        bool& glob_aux_LT_read = aux_LT_read;
                        bool aux_LT_read = glob_aux_LT_read;
                        vartype aux_last_type_read_for_LT = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_cpp_int_val = cpp_int_val;
                        int cpp_int_val = glob_cpp_int_val;
                        bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                        bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                        int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                        bool& glob_aux_NP_read = aux_NP_read;
                        bool aux_NP_read = glob_aux_NP_read;
                        vartype aux_last_type_read_for_NP = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                          // read LIST record
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::cast(-99999)));
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::cast(-99999))));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::cast(-99999)));
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)>=(0)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)<=(4)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none()));
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()))), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())));
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())), write_opts);
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()));
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()))), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= (var_NP_0d_int_Scalar-var_LT_0d_int_Scalar); var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Ek", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable Ek
                            var_Ek_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Ek", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("Ek", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ek);
                            aux_last_type_read_for_Ek = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Fk", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable Fk
                            var_Fk_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Fk", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("Fk", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fk);
                            aux_last_type_read_for_Fk = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_LT_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("El", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable El
                            var_El_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("El", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("El", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_El);
                            aux_last_type_read_for_El = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Fl", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable Fl
                            var_Fl_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Fl", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("Fl", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fl);
                            aux_last_type_read_for_Fl = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                            // read LIST record
                            // assign expression to variable LS
                            var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::cast(-99999)));
                            aux_LS_read = true;
                            validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                            aux_last_type_read_for_LS = SCALAR_INT;
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable NE
                            var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::cast(-99999)));
                            aux_NE_read = true;
                            validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                            aux_last_type_read_for_NE = SCALAR_INT;
                            if ((! (aux_NE_read == true))) {
                              throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE-1))+1) , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none()));
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))-1))+1), write_opts);
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))-1))+1), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = ((py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))-1))+1);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = 1;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar, var_kp_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar, var_kp_0d_int_Scalar}), py::none()));
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                            // read LIST record
                            // assign expression to variable LS
                            var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::cast(-99999)));
                            aux_LS_read = true;
                            validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                            aux_last_type_read_for_LS = SCALAR_INT;
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable NE
                            var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::cast(-99999)));
                            aux_NE_read = true;
                            validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                            aux_last_type_read_for_NE = SCALAR_INT;
                            if ((! (aux_NE_read == true))) {
                              throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE+1))/2) , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none()));
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))+1))/2), write_opts);
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))+1))/2), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = ((py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))*(py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()))+1))/2);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = var_k_0d_int_Scalar;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar, var_kp_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar, var_kp_0d_int_Scalar}), py::none()));
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NER_0d_int_Scalar = var_NER_0d_int_Scalar;
                          int var_NER_0d_int_Scalar = glob_var_NER_0d_int_Scalar;
                          bool& glob_aux_NER_read = aux_NER_read;
                          bool aux_NER_read = glob_aux_NER_read;
                          vartype aux_last_type_read_for_NER = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NEC_0d_int_Scalar = var_NEC_0d_int_Scalar;
                          int var_NEC_0d_int_Scalar = glob_var_NEC_0d_int_Scalar;
                          bool& glob_aux_NEC_read = aux_NEC_read;
                          bool aux_NEC_read = glob_aux_NEC_read;
                          vartype aux_last_type_read_for_NEC = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                            // read LIST record
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::cast(-99999)));
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::cast(-99999)))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::cast(-99999)))));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NEC
                            var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                            aux_NEC_read = true;
                            validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                            aux_last_type_read_for_NEC = SCALAR_INT;
                            if ((! (aux_NER_read == true))) {
                              // assign expression to variable cpp_int_val
                              cpp_int_val = (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::cast(-99999)))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::cast(-99999)))));
                              aux_cpp_int_val_read = true;
                              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                              // assign expression to variable NER
                              var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                              aux_NER_read = true;
                              validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                              aux_last_type_read_for_NER = SCALAR_INT;
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if ((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(6)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , 0 , LB , (1+(NER*NEC)) , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()));
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::none())))), write_opts);
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::none()))));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NEC
                          var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                          aux_NEC_read = true;
                          validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                          aux_last_type_read_for_NEC = SCALAR_INT;
                          if ((! (aux_NER_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::none()))));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::none())))), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = (1+(py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()))*py::cast<int>(cpp_index_shifter_store.get_value("NEC", std::vector<int>({}), py::none()))));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NER_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable ER
                              var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                              aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NEC_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EC", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable EC
                              var_EC_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EC", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("EC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EC);
                              aux_last_type_read_for_EC = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NER_0d_int_Scalar-1), 1, (var_NEC_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NER_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_l_0d_int_Scalar = 1;
                                 var_l_0d_int_Scalar <= (var_NEC_0d_int_Scalar-1); var_l_0d_int_Scalar++) {
                                bool aux_l_read = true;
                                // read LIST body
                                cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())), write_opts);
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_l_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar, var_l_0d_int_Scalar}), py::none()));
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                          int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                          bool& glob_aux_LT_read = aux_LT_read;
                          bool aux_LT_read = glob_aux_LT_read;
                          vartype aux_last_type_read_for_LT = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                          int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                          bool& glob_aux_NP_read = aux_NP_read;
                          bool aux_NP_read = glob_aux_NP_read;
                          vartype aux_last_type_read_for_NP = UNKNOWN;
                          try {
                            cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                            // read LIST record
                            // assign expression to variable LT
                            var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::cast(-99999)));
                            aux_LT_read = true;
                            validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                            aux_last_type_read_for_LT = SCALAR_INT;
                            // assign expression to variable LB
                            var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                            aux_LB_read = true;
                            validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                            aux_last_type_read_for_LB = SCALAR_INT;
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::cast(-99999))));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = (cpp_int_val/2);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                            if ((! (aux_NP_read == true))) {
                              // assign expression to variable NP
                              var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::cast(-99999)));
                              aux_NP_read = true;
                              validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                              aux_last_type_read_for_NP = SCALAR_INT;
                            } else {
                            }
                          } catch (const std::out_of_range& e) {
                            // // accept failure in lookahead
                          }
                          if ((((((((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(8))))))||(((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(9)))))))))&&((((aux_LT_read == true)) && ((var_LT_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST record
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none()));
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()))), write_opts);
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())), write_opts);
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()));
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()))), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable F
                              var_F_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_k_0d_int_Scalar}), py::none())));
                              validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }
            cpp_current_dict = cpp_parent_dict;
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 8421256b750ec19b722b38ddb32ece21
// MD5 hash of the following function definition: 752a33fe4e3023508ef6a2b347e22470
void write_mf34_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LTT_0d_int_Scalar;
  bool aux_LTT_read = false;
  vartype aux_last_type_read_for_LTT = UNKNOWN;
  int var_NMT1_0d_int_Scalar;
  bool aux_NMT1_read = false;
  vartype aux_last_type_read_for_NMT1 = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 34;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 34;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 34 , MT / ZA , AWR , 0 , LTT , 0 , NMT1 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LTT", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LTT
  var_LTT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LTT", std::vector<int>({}), py::none()));
  aux_LTT_read = true;
  validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
  aux_last_type_read_for_LTT = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NMT1", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NMT1
  var_NMT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NMT1", std::vector<int>({}), py::none()));
  aux_NMT1_read = true;
  validate_vartype_consistency("NMT1", SCALAR_INT, aux_last_type_read_for_NMT1);
  aux_last_type_read_for_NMT1 = SCALAR_INT;
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NMT1_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.get_value("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      int var_MAT1_0d_int_Scalar;
      bool aux_MAT1_read = false;
      vartype aux_last_type_read_for_MAT1 = UNKNOWN;
      int var_MT1_0d_int_Scalar;
      bool aux_MT1_read = false;
      vartype aux_last_type_read_for_MT1 = UNKNOWN;
      int var_NL_0d_int_Scalar;
      bool aux_NL_read = false;
      vartype aux_last_type_read_for_NL = UNKNOWN;
      NestedVector<int> var_L_1d_int_NestedVector;
      vartype aux_last_type_read_for_L = UNKNOWN;
      NestedVector<int> var_L1_1d_int_NestedVector;
      vartype aux_last_type_read_for_L1 = UNKNOWN;
      int var_LCT_0d_int_Scalar;
      bool aux_LCT_read = false;
      vartype aux_last_type_read_for_LCT = UNKNOWN;
      NestedVector<int> var_NI_1d_int_NestedVector;
      vartype aux_last_type_read_for_NI = UNKNOWN;
      NestedVector<NestedVector<int>> var_LS_2d_int_NestedVector;
      NestedVector<int>* ptr_LS_2d_idx0;
      vartype aux_last_type_read_for_LS = UNKNOWN;
      NestedVector<NestedVector<int>> var_LB_2d_int_NestedVector;
      NestedVector<int>* ptr_LB_2d_idx0;
      vartype aux_last_type_read_for_LB = UNKNOWN;
      NestedVector<NestedVector<int>> var_NT_2d_int_NestedVector;
      NestedVector<int>* ptr_NT_2d_idx0;
      vartype aux_last_type_read_for_NT = UNKNOWN;
      NestedVector<NestedVector<int>> var_NE_2d_int_NestedVector;
      NestedVector<int>* ptr_NE_2d_idx0;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      NestedVector<NestedVector<NestedVector<EndfFloatCpp>>> var_Data_3d_double_NestedVector;
      NestedVector<EndfFloatCpp>* ptr_Data_3d_idx1;
      NestedVector<NestedVector<EndfFloatCpp>>* ptr_Data_3d_idx0;
      vartype aux_last_type_read_for_Data = UNKNOWN;
      int var_NL1_0d_int_Scalar;
      bool aux_NL1_read = false;
      vartype aux_last_type_read_for_NL1 = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            {
              // variable declarations
              int& glob_var_MAT1_0d_int_Scalar = var_MAT1_0d_int_Scalar;
              int var_MAT1_0d_int_Scalar = glob_var_MAT1_0d_int_Scalar;
              bool& glob_aux_MAT1_read = aux_MAT1_read;
              bool aux_MAT1_read = glob_aux_MAT1_read;
              vartype aux_last_type_read_for_MAT1 = UNKNOWN;
              int& glob_var_MT1_0d_int_Scalar = var_MT1_0d_int_Scalar;
              int var_MT1_0d_int_Scalar = glob_var_MT1_0d_int_Scalar;
              bool& glob_aux_MT1_read = aux_MT1_read;
              bool aux_MT1_read = glob_aux_MT1_read;
              vartype aux_last_type_read_for_MT1 = UNKNOWN;
              int& glob_var_NL_0d_int_Scalar = var_NL_0d_int_Scalar;
              int var_NL_0d_int_Scalar = glob_var_NL_0d_int_Scalar;
              bool& glob_aux_NL_read = aux_NL_read;
              bool aux_NL_read = glob_aux_NL_read;
              vartype aux_last_type_read_for_NL = UNKNOWN;
              try {
                cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , MAT1 , MT1 , NL , NL ] CONT";
                // read CONT record
                // assign expression to variable MAT1
                var_MAT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT1", std::vector<int>({}), py::cast(-99999)));
                aux_MAT1_read = true;
                validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
                aux_last_type_read_for_MAT1 = SCALAR_INT;
                // assign expression to variable MT1
                var_MT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT1", std::vector<int>({}), py::cast(-99999)));
                aux_MT1_read = true;
                validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
                aux_last_type_read_for_MT1 = SCALAR_INT;
                // assign expression to variable NL
                var_NL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::cast(-99999)));
                aux_NL_read = true;
                validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = SCALAR_INT;
                if ((! (aux_NL_read == true))) {
                  // assign expression to variable NL
                  var_NL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::cast(-99999)));
                  aux_NL_read = true;
                  validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
                  aux_last_type_read_for_NL = SCALAR_INT;
                } else {
                }
              } catch (const std::out_of_range& e) {
                // // accept failure in lookahead
              }
              if (((((((((aux_MT1_read == true)) && ((var_MT1_0d_int_Scalar)==(0))))))||(((((aux_MT_read == true)) && ((var_MT_0d_int_Scalar)==(var_MT1_0d_int_Scalar)))))))) {
                cpp_found_match = true;
              }
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , MAT1 , MT1 , NL , NL ] CONT";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read CONT record
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("MAT1", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable MAT1
              var_MAT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT1", std::vector<int>({}), py::none()));
              aux_MAT1_read = true;
              validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
              aux_last_type_read_for_MAT1 = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MT1", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable MT1
              var_MT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT1", std::vector<int>({}), py::none()));
              aux_MT1_read = true;
              validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
              aux_last_type_read_for_MT1 = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable NL
              var_NL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::none()));
              aux_NL_read = true;
              validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
              aux_last_type_read_for_NL = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::none())), write_opts);
              if ((! (aux_NL_read == true))) {
                // assign expression to variable NL
                var_NL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::none()));
                aux_NL_read = true;
                validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = SCALAR_INT;
              } else {
              }
              cont << cpp_draft_line;

              for (int var_n_0d_int_Scalar = 1;
                 var_n_0d_int_Scalar <= ((var_NL_0d_int_Scalar*(var_NL_0d_int_Scalar+1))/2); var_n_0d_int_Scalar++) {
                bool aux_n_read = true;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if ((((((((aux_n_read == true)) && ((var_n_0d_int_Scalar)==(1)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , LCT , NI ] CONT";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read CONT record
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
                      // assign expression to variable L
                      var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
                      validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                      aux_last_type_read_for_L = NESTEDVECTOR_INT;
                      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("L1", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
                      // assign expression to variable L1
                      var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("L1", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
                      validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                      aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                      cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("LCT", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable LCT
                      var_LCT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCT", std::vector<int>({}), py::none()));
                      aux_LCT_read = true;
                      validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
                      aux_last_type_read_for_LCT = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
                      // assign expression to variable NI
                      var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
                      validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                      aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                      cont << cpp_draft_line;
                    }
                  }
                  if (! cpp_found_match) {
                    cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , 0 , NI ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read CONT record
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
                    // assign expression to variable L
                    var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
                    validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                    aux_last_type_read_for_L = NESTEDVECTOR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("L1", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
                    // assign expression to variable L1
                    var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("L1", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
                    validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                    aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
                    // assign expression to variable NI
                    var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
                    validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                    aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                    cont << cpp_draft_line;
                  }
                }
                ptr_LS_2d_idx0 = var_LS_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                ptr_LB_2d_idx0 = var_LB_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                ptr_NE_2d_idx0 = var_NE_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                ptr_Data_3d_idx0 = var_Data_3d_double_NestedVector.prepare(var_n_0d_int_Scalar);

                for (int var_m_0d_int_Scalar = 1;
                   var_m_0d_int_Scalar <= var_NI_1d_int_NestedVector[var_n_0d_int_Scalar]; var_m_0d_int_Scalar++) {
                  bool aux_m_read = true;
                  cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { Data } { q = 1 to NT } ] LIST";
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  // read LIST record
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
                  // assign expression to variable LS
                  ptr_LS_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
                  validate_vartype_consistency("LS", NESTEDVECTOR_INT, aux_last_type_read_for_LS);
                  aux_last_type_read_for_LS = NESTEDVECTOR_INT;
                  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
                  // assign expression to variable LB
                  ptr_LB_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
                  validate_vartype_consistency("LB", NESTEDVECTOR_INT, aux_last_type_read_for_LB);
                  aux_last_type_read_for_LB = NESTEDVECTOR_INT;
                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
                  // assign expression to variable NT
                  ptr_NT_2d_idx0 = var_NT_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                  ptr_NT_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
                  validate_vartype_consistency("NT", NESTEDVECTOR_INT, aux_last_type_read_for_NT);
                  aux_last_type_read_for_NT = NESTEDVECTOR_INT;
                  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
                  // assign expression to variable NE
                  ptr_NE_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
                  validate_vartype_consistency("NE", NESTEDVECTOR_INT, aux_last_type_read_for_NE);
                  aux_last_type_read_for_NE = NESTEDVECTOR_INT;
                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
                  cont << cpp_draft_line;
                  {
                    int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none()));
                    int cpp_i = 0;
                    int cpp_j = 0;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    // read LIST body
                    ptr_Data_3d_idx1 = ptr_Data_3d_idx0->prepare(var_m_0d_int_Scalar);

                    for (int var_q_0d_int_Scalar = 1;
                       var_q_0d_int_Scalar <= var_NT_2d_int_NestedVector[var_n_0d_int_Scalar][var_m_0d_int_Scalar]; var_q_0d_int_Scalar++) {
                      bool aux_q_read = true;
                      // read LIST body
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Data", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar, var_q_0d_int_Scalar}), py::none())), write_opts);
                      // assign expression to variable Data
                      ptr_Data_3d_idx1->set(var_q_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Data", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar, var_q_0d_int_Scalar}), py::none())));
                      validate_vartype_consistency("Data", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Data);
                      aux_last_type_read_for_Data = NESTEDVECTOR_DOUBLE;
                      cpp_i++;
                      cpp_j++;
                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                        cont << cpp_draft_line;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        cpp_j = 0;
                      }
                    }
                    if (cpp_i != cpp_npl) {
                      throw std::runtime_error("not exactly NPL elements consumed");
                    }
                  }
                  cont << cpp_draft_line;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , MAT1 , MT1 , NL , NL1 ] CONT";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read CONT record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("MAT1", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable MAT1
          var_MAT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT1", std::vector<int>({}), py::none()));
          aux_MAT1_read = true;
          validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
          aux_last_type_read_for_MAT1 = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MT1", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable MT1
          var_MT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT1", std::vector<int>({}), py::none()));
          aux_MT1_read = true;
          validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
          aux_last_type_read_for_MT1 = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NL
          var_NL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::none()));
          aux_NL_read = true;
          validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
          aux_last_type_read_for_NL = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NL1", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NL1
          var_NL1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NL1", std::vector<int>({}), py::none()));
          aux_NL1_read = true;
          validate_vartype_consistency("NL1", SCALAR_INT, aux_last_type_read_for_NL1);
          aux_last_type_read_for_NL1 = SCALAR_INT;
          cont << cpp_draft_line;

          for (int var_n_0d_int_Scalar = 1;
             var_n_0d_int_Scalar <= (var_NL_0d_int_Scalar*var_NL1_0d_int_Scalar); var_n_0d_int_Scalar++) {
            bool aux_n_read = true;
            // evaluate if-elif-else clause
            {
              bool cpp_found_match = false;
              if (! cpp_found_match) {
                if ((((((((aux_n_read == true)) && ((var_n_0d_int_Scalar)==(1)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , LCT , NI ] CONT";
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                  // read CONT record
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
                  // assign expression to variable L
                  var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
                  validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                  aux_last_type_read_for_L = NESTEDVECTOR_INT;
                  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("L1", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
                  // assign expression to variable L1
                  var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("L1", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
                  validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                  aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("LCT", std::vector<int>({}), py::none())), write_opts);
                  // assign expression to variable LCT
                  var_LCT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LCT", std::vector<int>({}), py::none()));
                  aux_LCT_read = true;
                  validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
                  aux_last_type_read_for_LCT = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
                  // assign expression to variable NI
                  var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
                  validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                  aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                  cont << cpp_draft_line;
                }
              }
              if (! cpp_found_match) {
                cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , 0 , NI ] CONT";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                // read CONT record
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable L
                var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("L", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                aux_last_type_read_for_L = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("L1", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable L1
                var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("L1", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_n_0d_int_Scalar}), py::none())), write_opts);
                // assign expression to variable NI
                var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({var_n_0d_int_Scalar}), py::none())));
                validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                cont << cpp_draft_line;
              }
            }
            ptr_LS_2d_idx0 = var_LS_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
            ptr_LB_2d_idx0 = var_LB_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
            ptr_NE_2d_idx0 = var_NE_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
            ptr_Data_3d_idx0 = var_Data_3d_double_NestedVector.prepare(var_n_0d_int_Scalar);

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NI_1d_int_NestedVector[var_n_0d_int_Scalar]; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { Data } { q = 1 to NT } ] LIST";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read LIST record
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable LS
              ptr_LS_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("LS", NESTEDVECTOR_INT, aux_last_type_read_for_LS);
              aux_last_type_read_for_LS = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable LB
              ptr_LB_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("LB", NESTEDVECTOR_INT, aux_last_type_read_for_LB);
              aux_last_type_read_for_LB = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable NT
              ptr_NT_2d_idx0 = var_NT_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
              ptr_NT_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("NT", NESTEDVECTOR_INT, aux_last_type_read_for_NT);
              aux_last_type_read_for_NT = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
              // assign expression to variable NE
              ptr_NE_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())));
              validate_vartype_consistency("NE", NESTEDVECTOR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none())), write_opts);
              cont << cpp_draft_line;
              {
                int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar}), py::none()));
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                // read LIST body
                ptr_Data_3d_idx1 = ptr_Data_3d_idx0->prepare(var_m_0d_int_Scalar);

                for (int var_q_0d_int_Scalar = 1;
                   var_q_0d_int_Scalar <= var_NT_2d_int_NestedVector[var_n_0d_int_Scalar][var_m_0d_int_Scalar]; var_q_0d_int_Scalar++) {
                  bool aux_q_read = true;
                  // read LIST body
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Data", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar, var_q_0d_int_Scalar}), py::none())), write_opts);
                  // assign expression to variable Data
                  ptr_Data_3d_idx1->set(var_q_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Data", std::vector<int>({var_n_0d_int_Scalar, var_m_0d_int_Scalar, var_q_0d_int_Scalar}), py::none())));
                  validate_vartype_consistency("Data", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Data);
                  aux_last_type_read_for_Data = NESTEDVECTOR_DOUBLE;
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    cpp_j = 0;
                  }
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
              cont << cpp_draft_line;
            }
          }
        }
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: ef5fac1c99989a26cffcf79262c5c69c
// MD5 hash of the following function definition: 472ed07ffe711d74b8f3fca0cac676bd
void write_mf35_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 35;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 35;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 35 , MT / ZA , AWR , 0 , 0 , NK , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NK", std::vector<int>({}), py::none()));
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.get_value("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_E1_0d_double_Scalar;
      bool aux_E1_read = false;
      vartype aux_last_type_read_for_E1 = UNKNOWN;
      EndfFloatCpp var_E2_0d_double_Scalar;
      bool aux_E2_read = false;
      vartype aux_last_type_read_for_E2 = UNKNOWN;
      int var_LS_0d_int_Scalar;
      bool aux_LS_read = false;
      vartype aux_last_type_read_for_LS = UNKNOWN;
      int var_LB_0d_int_Scalar;
      bool aux_LB_read = false;
      vartype aux_last_type_read_for_LB = UNKNOWN;
      int var_NT_0d_int_Scalar;
      bool aux_NT_read = false;
      vartype aux_last_type_read_for_NT = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      Matrix2d<EndfFloatCpp> var_F_2d_double_Matrix2d;
      vartype aux_last_type_read_for_F = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            {
              // variable declarations
              EndfFloatCpp& glob_var_E1_0d_double_Scalar = var_E1_0d_double_Scalar;
              EndfFloatCpp var_E1_0d_double_Scalar = glob_var_E1_0d_double_Scalar;
              bool& glob_aux_E1_read = aux_E1_read;
              bool aux_E1_read = glob_aux_E1_read;
              vartype aux_last_type_read_for_E1 = UNKNOWN;
              EndfFloatCpp& glob_var_E2_0d_double_Scalar = var_E2_0d_double_Scalar;
              EndfFloatCpp var_E2_0d_double_Scalar = glob_var_E2_0d_double_Scalar;
              bool& glob_aux_E2_read = aux_E2_read;
              bool aux_E2_read = glob_aux_E2_read;
              vartype aux_last_type_read_for_E2 = UNKNOWN;
              int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
              int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
              bool& glob_aux_LS_read = aux_LS_read;
              bool aux_LS_read = glob_aux_LS_read;
              vartype aux_last_type_read_for_LS = UNKNOWN;
              int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
              int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
              bool& glob_aux_LB_read = aux_LB_read;
              bool aux_LB_read = glob_aux_LB_read;
              vartype aux_last_type_read_for_LB = UNKNOWN;
              int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
              int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
              bool& glob_aux_NT_read = aux_NT_read;
              bool aux_NT_read = glob_aux_NT_read;
              vartype aux_last_type_read_for_NT = UNKNOWN;
              int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
              int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
              bool& glob_aux_NE_read = aux_NE_read;
              bool aux_NE_read = glob_aux_NE_read;
              vartype aux_last_type_read_for_NE = UNKNOWN;
              try {
                cpp_template = "[ MAT , 35 , MT / E1 , E2 , LS , LB , NT , NE / \n { E } { i = 1 to NE } , { { F } { j = i to (NE-1) } } { i = 1 to (NE-1) } ] LIST";
                // read LIST record
                // assign expression to variable E1
                var_E1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::cast(-99999.9)));
                aux_E1_read = true;
                validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                // assign expression to variable E2
                var_E2_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::cast(-99999.9)));
                aux_E2_read = true;
                validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                // assign expression to variable LS
                var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::cast(-99999)));
                aux_LS_read = true;
                validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                aux_last_type_read_for_LS = SCALAR_INT;
                // assign expression to variable LB
                var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                aux_LB_read = true;
                validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                aux_last_type_read_for_LB = SCALAR_INT;
                // assign expression to variable NT
                var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::cast(-99999)));
                aux_NT_read = true;
                validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                aux_last_type_read_for_NT = SCALAR_INT;
                // assign expression to variable NE
                var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::cast(-99999)));
                aux_NE_read = true;
                validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                aux_last_type_read_for_NE = SCALAR_INT;
              } catch (const std::out_of_range& e) {
                // // accept failure in lookahead
              }
              if (((((((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(7)))))))) {
                cpp_found_match = true;
              }
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 35 , MT / E1 , E2 , LS , LB , NT , NE / \n { E } { i = 1 to NE } , { { F } { j = i to (NE-1) } } { i = 1 to (NE-1) } ] LIST";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
              // read LIST record
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable E1
              var_E1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none()));
              aux_E1_read = true;
              validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
              aux_last_type_read_for_E1 = SCALAR_DOUBLE;
              cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable E2
              var_E2_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none()));
              aux_E2_read = true;
              validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
              aux_last_type_read_for_E2 = SCALAR_DOUBLE;
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable LS
              var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none()));
              aux_LS_read = true;
              validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
              aux_last_type_read_for_LS = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable LB
              var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
              aux_LB_read = true;
              validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
              aux_last_type_read_for_LB = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable NT
              var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
              aux_NT_read = true;
              validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
              aux_last_type_read_for_NT = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
              cont << cpp_draft_line;
              {
                int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                // read LIST body

                for (int var_i_0d_int_Scalar = 1;
                   var_i_0d_int_Scalar <= var_NE_0d_int_Scalar; var_i_0d_int_Scalar++) {
                  bool aux_i_read = true;
                  // read LIST body
                  cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                  // assign expression to variable E
                  var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                  validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                    cpp_j = 0;
                  }
                }
                var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                for (int var_i_0d_int_Scalar = 1;
                   var_i_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_i_0d_int_Scalar++) {
                  bool aux_i_read = true;
                  // read LIST body

                  for (int var_j_0d_int_Scalar = var_i_0d_int_Scalar;
                     var_j_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_j_0d_int_Scalar++) {
                    bool aux_j_read = true;
                    // read LIST body
                    cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none())), write_opts);
                    // assign expression to variable F
                    var_F_2d_double_Matrix2d(var_i_0d_int_Scalar, var_j_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_i_0d_int_Scalar, var_j_0d_int_Scalar}), py::none()));
                    validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                    aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cont << cpp_draft_line;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      cpp_j = 0;
                    }
                  }
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
              cont << cpp_draft_line;
            }
          }
        }
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 9762b69b4ad00343103fe284b177ae48
// MD5 hash of the following function definition: 3b44c112b704c2f4789af07ea94becc6
void write_mf40_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;
  bool list_mode = write_opts.array_type != "dict";  py::dict cpp_parent_dict;
  py::dict cpp_current_dict = endf_dict;
  IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  EndfFloatCpp var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  EndfFloatCpp var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  int mat = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  int mf = 40;
  int mt = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT", std::vector<int>({}), py::none()));
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 40;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT", std::vector<int>({}), py::none()));
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 40 , MT / ZA , AWR , LIS , 0 , NS , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
  // read CONT record
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ZA", std::vector<int>({}), py::none()));
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("AWR", std::vector<int>({}), py::none()));
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LIS", std::vector<int>({}), py::none()));
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NS", std::vector<int>({}), py::none())), write_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NS", std::vector<int>({}), py::none()));
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      cpp_current_dict = cpp_index_shifter_store.get_value("subsection", std::vector<int>({var_k_0d_int_Scalar}), py::dict());
      IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
      // variable declarations
      EndfFloatCpp var_QM_0d_double_Scalar;
      bool aux_QM_read = false;
      vartype aux_last_type_read_for_QM = UNKNOWN;
      EndfFloatCpp var_QI_0d_double_Scalar;
      bool aux_QI_read = false;
      vartype aux_last_type_read_for_QI = UNKNOWN;
      int var_IZAP_0d_int_Scalar;
      bool aux_IZAP_read = false;
      vartype aux_last_type_read_for_IZAP = UNKNOWN;
      int var_LFS_0d_int_Scalar;
      bool aux_LFS_read = false;
      vartype aux_last_type_read_for_LFS = UNKNOWN;
      int var_NL_0d_int_Scalar;
      bool aux_NL_read = false;
      vartype aux_last_type_read_for_NL = UNKNOWN;
      cpp_template = "[ MAT , 40 , MT / QM , QI , IZAP , LFS , 0 , NL ] CONT";
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
      // read CONT record
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QM", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable QM
      var_QM_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QM", std::vector<int>({}), py::none()));
      aux_QM_read = true;
      validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
      aux_last_type_read_for_QM = SCALAR_DOUBLE;
      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QI", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable QI
      var_QI_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("QI", std::vector<int>({}), py::none()));
      aux_QI_read = true;
      validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
      aux_last_type_read_for_QI = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("IZAP", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable IZAP
      var_IZAP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("IZAP", std::vector<int>({}), py::none()));
      aux_IZAP_read = true;
      validate_vartype_consistency("IZAP", SCALAR_INT, aux_last_type_read_for_IZAP);
      aux_last_type_read_for_IZAP = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LFS", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable LFS
      var_LFS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LFS", std::vector<int>({}), py::none()));
      aux_LFS_read = true;
      validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
      aux_last_type_read_for_LFS = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::none())), write_opts);
      // assign expression to variable NL
      var_NL_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NL", std::vector<int>({}), py::none()));
      aux_NL_read = true;
      validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
      aux_last_type_read_for_NL = SCALAR_INT;
      cont << cpp_draft_line;

      for (int var_i_0d_int_Scalar = 1;
         var_i_0d_int_Scalar <= var_NL_0d_int_Scalar; var_i_0d_int_Scalar++) {
        bool aux_i_read = true;
        // open section subsubsec
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          cpp_current_dict = cpp_index_shifter_store.get_value("subsubsec", std::vector<int>({var_i_0d_int_Scalar}), py::dict());
          IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
          // variable declarations
          EndfFloatCpp var_XMF1_0d_double_Scalar;
          bool aux_XMF1_read = false;
          vartype aux_last_type_read_for_XMF1 = UNKNOWN;
          EndfFloatCpp var_XLFS1_0d_double_Scalar;
          bool aux_XLFS1_read = false;
          vartype aux_last_type_read_for_XLFS1 = UNKNOWN;
          int var_MAT1_0d_int_Scalar;
          bool aux_MAT1_read = false;
          vartype aux_last_type_read_for_MAT1 = UNKNOWN;
          int var_MT1_0d_int_Scalar;
          bool aux_MT1_read = false;
          vartype aux_last_type_read_for_MT1 = UNKNOWN;
          int var_NC_0d_int_Scalar;
          bool aux_NC_read = false;
          vartype aux_last_type_read_for_NC = UNKNOWN;
          int var_NI_0d_int_Scalar;
          bool aux_NI_read = false;
          vartype aux_last_type_read_for_NI = UNKNOWN;
          cpp_template = "[ MAT , 40 , MT / XMF1 , XLFS1 , MAT1 , MT1 , NC , NI ] CONT";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
          // read CONT record
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMF1", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable XMF1
          var_XMF1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMF1", std::vector<int>({}), py::none()));
          aux_XMF1_read = true;
          validate_vartype_consistency("XMF1", SCALAR_DOUBLE, aux_last_type_read_for_XMF1);
          aux_last_type_read_for_XMF1 = SCALAR_DOUBLE;
          cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XLFS1", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable XLFS1
          var_XLFS1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XLFS1", std::vector<int>({}), py::none()));
          aux_XLFS1_read = true;
          validate_vartype_consistency("XLFS1", SCALAR_DOUBLE, aux_last_type_read_for_XLFS1);
          aux_last_type_read_for_XLFS1 = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("MAT1", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable MAT1
          var_MAT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MAT1", std::vector<int>({}), py::none()));
          aux_MAT1_read = true;
          validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
          aux_last_type_read_for_MAT1 = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MT1", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable MT1
          var_MT1_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MT1", std::vector<int>({}), py::none()));
          aux_MT1_read = true;
          validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
          aux_last_type_read_for_MT1 = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NC
          var_NC_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NC", std::vector<int>({}), py::none()));
          aux_NC_read = true;
          validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
          aux_last_type_read_for_NC = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none())), write_opts);
          // assign expression to variable NI
          var_NI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NI", std::vector<int>({}), py::none()));
          aux_NI_read = true;
          validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
          aux_last_type_read_for_NI = SCALAR_INT;
          cont << cpp_draft_line;

          for (int var_j_0d_int_Scalar = 1;
             var_j_0d_int_Scalar <= var_NC_0d_int_Scalar; var_j_0d_int_Scalar++) {
            bool aux_j_read = true;
            // open section nc_subsubsubsec
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.get_value("nc_subsubsubsec", std::vector<int>({var_j_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              // variable declarations
              int var_LTY_0d_int_Scalar;
              bool aux_LTY_read = false;
              vartype aux_last_type_read_for_LTY = UNKNOWN;
              EndfFloatCpp var_E1_0d_double_Scalar;
              bool aux_E1_read = false;
              vartype aux_last_type_read_for_E1 = UNKNOWN;
              EndfFloatCpp var_E2_0d_double_Scalar;
              bool aux_E2_read = false;
              vartype aux_last_type_read_for_E2 = UNKNOWN;
              int cpp_int_val;
              bool aux_cpp_int_val_read = false;
              vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
              int var_NCI_0d_int_Scalar;
              bool aux_NCI_read = false;
              vartype aux_last_type_read_for_NCI = UNKNOWN;
              NestedVector<EndfFloatCpp> var_C_1d_double_NestedVector;
              vartype aux_last_type_read_for_C = UNKNOWN;
              NestedVector<EndfFloatCpp> var_XMT_1d_double_NestedVector;
              vartype aux_last_type_read_for_XMT = UNKNOWN;
              int var_MATS_0d_int_Scalar;
              bool aux_MATS_read = false;
              vartype aux_last_type_read_for_MATS = UNKNOWN;
              int var_MTS_0d_int_Scalar;
              bool aux_MTS_read = false;
              vartype aux_last_type_read_for_MTS = UNKNOWN;
              int var_NEI_0d_int_Scalar;
              bool aux_NEI_read = false;
              vartype aux_last_type_read_for_NEI = UNKNOWN;
              EndfFloatCpp var_XMFS_0d_double_Scalar;
              bool aux_XMFS_read = false;
              vartype aux_last_type_read_for_XMFS = UNKNOWN;
              EndfFloatCpp var_XLFSS_0d_double_Scalar;
              bool aux_XLFSS_read = false;
              vartype aux_last_type_read_for_XLFSS = UNKNOWN;
              NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
              vartype aux_last_type_read_for_E = UNKNOWN;
              NestedVector<EndfFloatCpp> var_WE_1d_double_NestedVector;
              vartype aux_last_type_read_for_WE = UNKNOWN;
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  // if statement evaluation with lookahead
                  {
                    {
                      // variable declarations
                      int& glob_var_LTY_0d_int_Scalar = var_LTY_0d_int_Scalar;
                      int var_LTY_0d_int_Scalar = glob_var_LTY_0d_int_Scalar;
                      bool& glob_aux_LTY_read = aux_LTY_read;
                      bool aux_LTY_read = glob_aux_LTY_read;
                      vartype aux_last_type_read_for_LTY = UNKNOWN;
                      try {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                        // read CONT record
                        // assign expression to variable LTY
                        var_LTY_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LTY", std::vector<int>({}), py::cast(-99999)));
                        aux_LTY_read = true;
                        validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                        aux_last_type_read_for_LTY = SCALAR_INT;
                      } catch (const std::out_of_range& e) {
                        // // accept failure in lookahead
                      }
                      if ((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(0)))))))) {
                        cpp_found_match = true;
                      }
                    }
                    if (cpp_found_match) {
                      cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read CONT record
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LTY", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable LTY
                      var_LTY_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LTY", std::vector<int>({}), py::none()));
                      aux_LTY_read = true;
                      validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                      aux_last_type_read_for_LTY = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                      cont << cpp_draft_line;
                      cpp_template = "[ MAT , 40 , MT / E1 , E2 , 0 , 0 , (2*NCI) , NCI / \n { C , XMT } { i = 1 to NCI } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read LIST record
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable E1
                      var_E1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none()));
                      aux_E1_read = true;
                      validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                      aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable E2
                      var_E2_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none()));
                      aux_E2_read = true;
                      validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                      aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none()))), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none())));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NCI
                      var_NCI_0d_int_Scalar = (cpp_int_val/2);
                      aux_NCI_read = true;
                      validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                      aux_last_type_read_for_NCI = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none())), write_opts);
                      if ((! (aux_NCI_read == true))) {
                        // assign expression to variable NCI
                        var_NCI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none()));
                        aux_NCI_read = true;
                        validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                        aux_last_type_read_for_NCI = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none()))), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (2*py::cast<int>(cpp_index_shifter_store.get_value("NCI", std::vector<int>({}), py::none())));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST body

                        for (int var_i_0d_int_Scalar = 1;
                           var_i_0d_int_Scalar <= var_NCI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                          bool aux_i_read = true;
                          // read LIST body
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("C", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable C
                          var_C_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("C", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
                          aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMT", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable XMT
                          var_XMT_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMT", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("XMT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_XMT);
                          aux_last_type_read_for_XMT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LTY_0d_int_Scalar = var_LTY_0d_int_Scalar;
                        int var_LTY_0d_int_Scalar = glob_var_LTY_0d_int_Scalar;
                        bool& glob_aux_LTY_read = aux_LTY_read;
                        bool aux_LTY_read = glob_aux_LTY_read;
                        vartype aux_last_type_read_for_LTY = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                          // read CONT record
                          // assign expression to variable LTY
                          var_LTY_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LTY", std::vector<int>({}), py::cast(-99999)));
                          aux_LTY_read = true;
                          validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                          aux_last_type_read_for_LTY = SCALAR_INT;
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if ((((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(1))))))||(((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(2))))))||(((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(3)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read CONT record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LTY", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable LTY
                        var_LTY_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LTY", std::vector<int>({}), py::none()));
                        aux_LTY_read = true;
                        validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                        aux_last_type_read_for_LTY = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                        cont << cpp_draft_line;
                        cpp_template = "[ MAT , 40 , MT / E1 , E2 , MATS , MTS , ((2*NEI)+2) , NEI / \n XMFS , XLFSS , { E , WE } { i = 1 to NEI } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable E1
                        var_E1_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E1", std::vector<int>({}), py::none()));
                        aux_E1_read = true;
                        validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                        aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable E2
                        var_E2_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E2", std::vector<int>({}), py::none()));
                        aux_E2_read = true;
                        validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                        aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("MATS", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable MATS
                        var_MATS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MATS", std::vector<int>({}), py::none()));
                        aux_MATS_read = true;
                        validate_vartype_consistency("MATS", SCALAR_INT, aux_last_type_read_for_MATS);
                        aux_last_type_read_for_MATS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("MTS", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable MTS
                        var_MTS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("MTS", std::vector<int>({}), py::none()));
                        aux_MTS_read = true;
                        validate_vartype_consistency("MTS", SCALAR_INT, aux_last_type_read_for_MTS);
                        aux_last_type_read_for_MTS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, ((2*py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())))+2), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = ((2*py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())))+2);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NEI
                        var_NEI_0d_int_Scalar = ((cpp_int_val+(-2))/2);
                        aux_NEI_read = true;
                        validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                        aux_last_type_read_for_NEI = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())), write_opts);
                        if ((! (aux_NEI_read == true))) {
                          // assign expression to variable NEI
                          var_NEI_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none()));
                          aux_NEI_read = true;
                          validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                          aux_last_type_read_for_NEI = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, ((2*py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())))+2), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = ((2*py::cast<int>(cpp_index_shifter_store.get_value("NEI", std::vector<int>({}), py::none())))+2);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMFS", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable XMFS
                          var_XMFS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XMFS", std::vector<int>({}), py::none()));
                          aux_XMFS_read = true;
                          validate_vartype_consistency("XMFS", SCALAR_DOUBLE, aux_last_type_read_for_XMFS);
                          aux_last_type_read_for_XMFS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XLFSS", std::vector<int>({}), py::none())), write_opts);
                          // assign expression to variable XLFSS
                          var_XLFSS_0d_double_Scalar = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("XLFSS", std::vector<int>({}), py::none()));
                          aux_XLFSS_read = true;
                          validate_vartype_consistency("XLFSS", SCALAR_DOUBLE, aux_last_type_read_for_XLFSS);
                          aux_last_type_read_for_XLFSS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }

                          for (int var_i_0d_int_Scalar = 1;
                             var_i_0d_int_Scalar <= var_NEI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                            bool aux_i_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("WE", std::vector<int>({var_i_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable WE
                            var_WE_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("WE", std::vector<int>({var_i_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("WE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_WE);
                            aux_last_type_read_for_WE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }

          for (int var_j_0d_int_Scalar = 1;
             var_j_0d_int_Scalar <= var_NI_0d_int_Scalar; var_j_0d_int_Scalar++) {
            bool aux_j_read = true;
            // open section ni_subsubsubsec
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              cpp_current_dict = cpp_index_shifter_store.get_value("ni_subsubsubsec", std::vector<int>({var_j_0d_int_Scalar}), py::dict());
              IndexShifterStore cpp_index_shifter_store(cpp_current_dict, list_mode);
              // variable declarations
              int var_LT_0d_int_Scalar;
              bool aux_LT_read = false;
              vartype aux_last_type_read_for_LT = UNKNOWN;
              int var_LB_0d_int_Scalar;
              bool aux_LB_read = false;
              vartype aux_last_type_read_for_LB = UNKNOWN;
              int cpp_int_val;
              bool aux_cpp_int_val_read = false;
              vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
              int var_NP_0d_int_Scalar;
              bool aux_NP_read = false;
              vartype aux_last_type_read_for_NP = UNKNOWN;
              NestedVector<EndfFloatCpp> var_Ek_1d_double_NestedVector;
              vartype aux_last_type_read_for_Ek = UNKNOWN;
              NestedVector<EndfFloatCpp> var_Fk_1d_double_NestedVector;
              vartype aux_last_type_read_for_Fk = UNKNOWN;
              NestedVector<EndfFloatCpp> var_El_1d_double_NestedVector;
              vartype aux_last_type_read_for_El = UNKNOWN;
              NestedVector<EndfFloatCpp> var_Fl_1d_double_NestedVector;
              vartype aux_last_type_read_for_Fl = UNKNOWN;
              int var_LS_0d_int_Scalar;
              bool aux_LS_read = false;
              vartype aux_last_type_read_for_LS = UNKNOWN;
              int var_NT_0d_int_Scalar;
              bool aux_NT_read = false;
              vartype aux_last_type_read_for_NT = UNKNOWN;
              int var_NE_0d_int_Scalar;
              bool aux_NE_read = false;
              vartype aux_last_type_read_for_NE = UNKNOWN;
              NestedVector<EndfFloatCpp> var_E_1d_double_NestedVector;
              vartype aux_last_type_read_for_E = UNKNOWN;
              Matrix2d<EndfFloatCpp> var_F_2d_double_Matrix2d;
              vartype aux_last_type_read_for_F = UNKNOWN;
              int var_NER_0d_int_Scalar;
              bool aux_NER_read = false;
              vartype aux_last_type_read_for_NER = UNKNOWN;
              NestedVector<EndfFloatCpp> var_ER_1d_double_NestedVector;
              vartype aux_last_type_read_for_ER = UNKNOWN;
              NestedVector<EndfFloatCpp> var_EC_1d_double_NestedVector;
              vartype aux_last_type_read_for_EC = UNKNOWN;
              NestedVector<EndfFloatCpp> var_F_1d_double_NestedVector;
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  // if statement evaluation with lookahead
                  {
                    {
                      // variable declarations
                      int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                      int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                      bool& glob_aux_LT_read = aux_LT_read;
                      bool aux_LT_read = glob_aux_LT_read;
                      vartype aux_last_type_read_for_LT = UNKNOWN;
                      int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                      int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                      bool& glob_aux_LB_read = aux_LB_read;
                      bool aux_LB_read = glob_aux_LB_read;
                      vartype aux_last_type_read_for_LB = UNKNOWN;
                      int& glob_cpp_int_val = cpp_int_val;
                      int cpp_int_val = glob_cpp_int_val;
                      bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                      bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                      int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                      bool& glob_aux_NP_read = aux_NP_read;
                      bool aux_NP_read = glob_aux_NP_read;
                      vartype aux_last_type_read_for_NP = UNKNOWN;
                      try {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { q = 1 to (NP-LT) } \n { El , Fl } { q = 1 to LT } ] LIST";
                        // read LIST record
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::cast(-99999)));
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::cast(-99999))));
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::cast(-99999)));
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                      } catch (const std::out_of_range& e) {
                        // // accept failure in lookahead
                      }
                      if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)>=(0)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)<=(4)))))))) {
                        cpp_found_match = true;
                      }
                    }
                    if (cpp_found_match) {
                      cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { q = 1 to (NP-LT) } \n { El , Fl } { q = 1 to LT } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                      // read LIST record
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                      cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable LT
                      var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none()));
                      aux_LT_read = true;
                      validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                      aux_last_type_read_for_LT = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                      // assign expression to variable LB
                      var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                      aux_LB_read = true;
                      validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                      aux_last_type_read_for_LB = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()))), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NP
                      var_NP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NP_read = true;
                      validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                      aux_last_type_read_for_NP = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())), write_opts);
                      if ((! (aux_NP_read == true))) {
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()));
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()))), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST body

                        for (int var_q_0d_int_Scalar = 1;
                           var_q_0d_int_Scalar <= (var_NP_0d_int_Scalar-var_LT_0d_int_Scalar); var_q_0d_int_Scalar++) {
                          bool aux_q_read = true;
                          // read LIST body
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Ek", std::vector<int>({var_q_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable Ek
                          var_Ek_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Ek", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("Ek", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ek);
                          aux_last_type_read_for_Ek = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Fk", std::vector<int>({var_q_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable Fk
                          var_Fk_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Fk", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("Fk", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fk);
                          aux_last_type_read_for_Fk = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                        }

                        for (int var_q_0d_int_Scalar = 1;
                           var_q_0d_int_Scalar <= var_LT_0d_int_Scalar; var_q_0d_int_Scalar++) {
                          bool aux_q_read = true;
                          // read LIST body
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("El", std::vector<int>({var_q_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable El
                          var_El_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("El", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("El", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_El);
                          aux_last_type_read_for_El = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                          cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Fl", std::vector<int>({var_q_0d_int_Scalar}), py::none())), write_opts);
                          // assign expression to variable Fl
                          var_Fl_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("Fl", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                          validate_vartype_consistency("Fl", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fl);
                          aux_last_type_read_for_Fl = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                        int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                        bool& glob_aux_LS_read = aux_LS_read;
                        bool aux_LS_read = glob_aux_LS_read;
                        vartype aux_last_type_read_for_LS = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                        int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                        bool& glob_aux_NT_read = aux_NT_read;
                        bool aux_NT_read = glob_aux_NT_read;
                        vartype aux_last_type_read_for_NT = UNKNOWN;
                        int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                        int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                        bool& glob_aux_NE_read = aux_NE_read;
                        bool aux_NE_read = glob_aux_NE_read;
                        vartype aux_last_type_read_for_NE = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = 1 to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                          // read LIST record
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::cast(-99999)));
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NT
                          var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::cast(-99999)));
                          aux_NT_read = true;
                          validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                          aux_last_type_read_for_NT = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::cast(-99999)));
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(0)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = 1 to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none()));
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NE_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_q_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), false, false);

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body

                            for (int var_qp_0d_int_Scalar = 1;
                               var_qp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_qp_0d_int_Scalar++) {
                              bool aux_qp_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_q_0d_int_Scalar, var_qp_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_q_0d_int_Scalar, var_qp_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_q_0d_int_Scalar, var_qp_0d_int_Scalar}), py::none()));
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                        int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                        bool& glob_aux_LS_read = aux_LS_read;
                        bool aux_LS_read = glob_aux_LS_read;
                        vartype aux_last_type_read_for_LS = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                        int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                        bool& glob_aux_NT_read = aux_NT_read;
                        bool aux_NT_read = glob_aux_NT_read;
                        vartype aux_last_type_read_for_NT = UNKNOWN;
                        int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                        int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                        bool& glob_aux_NE_read = aux_NE_read;
                        bool aux_NE_read = glob_aux_NE_read;
                        vartype aux_last_type_read_for_NE = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = q to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                          // read LIST record
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::cast(-99999)));
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NT
                          var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::cast(-99999)));
                          aux_NT_read = true;
                          validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                          aux_last_type_read_for_NT = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::cast(-99999)));
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = q to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LS", std::vector<int>({}), py::none()));
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NE", std::vector<int>({}), py::none()));
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NE_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_q_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body

                            for (int var_qp_0d_int_Scalar = var_q_0d_int_Scalar;
                               var_qp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_qp_0d_int_Scalar++) {
                              bool aux_qp_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_q_0d_int_Scalar, var_qp_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_q_0d_int_Scalar, var_qp_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_q_0d_int_Scalar, var_qp_0d_int_Scalar}), py::none()));
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                        int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                        bool& glob_aux_NT_read = aux_NT_read;
                        bool aux_NT_read = glob_aux_NT_read;
                        vartype aux_last_type_read_for_NT = UNKNOWN;
                        int& glob_var_NER_0d_int_Scalar = var_NER_0d_int_Scalar;
                        int var_NER_0d_int_Scalar = glob_var_NER_0d_int_Scalar;
                        bool& glob_aux_NER_read = aux_NER_read;
                        bool aux_NER_read = glob_aux_NER_read;
                        vartype aux_last_type_read_for_NER = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { q = 1 to NER } { EC } { q = 1 to ((NT-1)/NER) } \n { { F } { l = 1 to (((NT-1)/NER)-1) } } { q = 1 to (NER-1) } ] LIST";
                          // read LIST record
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NT
                          var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::cast(-99999)));
                          aux_NT_read = true;
                          validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                          aux_last_type_read_for_NT = SCALAR_INT;
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::cast(-99999)));
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if ((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(6)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { q = 1 to NER } { EC } { q = 1 to ((NT-1)/NER) } \n { { F } { l = 1 to (((NT-1)/NER)-1) } } { q = 1 to (NER-1) } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable NER
                        var_NER_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NER", std::vector<int>({}), py::none()));
                        aux_NER_read = true;
                        validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                        aux_last_type_read_for_NER = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none())), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = py::cast<int>(cpp_index_shifter_store.get_value("NT", std::vector<int>({}), py::none()));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NER_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_q_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("ER", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= ((var_NT_0d_int_Scalar-1)/var_NER_0d_int_Scalar); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EC", std::vector<int>({var_q_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable EC
                            var_EC_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("EC", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("EC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EC);
                            aux_last_type_read_for_EC = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NER_0d_int_Scalar-1), 1, (((var_NT_0d_int_Scalar-1)/var_NER_0d_int_Scalar)-1), false, false);

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= (var_NER_0d_int_Scalar-1); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body

                            for (int var_l_0d_int_Scalar = 1;
                               var_l_0d_int_Scalar <= (((var_NT_0d_int_Scalar-1)/var_NER_0d_int_Scalar)-1); var_l_0d_int_Scalar++) {
                              bool aux_l_read = true;
                              // read LIST body
                              cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_q_0d_int_Scalar, var_l_0d_int_Scalar}), py::none())), write_opts);
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_q_0d_int_Scalar, var_l_0d_int_Scalar) = py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_q_0d_int_Scalar, var_l_0d_int_Scalar}), py::none()));
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                        int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                        bool& glob_aux_LT_read = aux_LT_read;
                        bool aux_LT_read = glob_aux_LT_read;
                        vartype aux_last_type_read_for_LT = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_cpp_int_val = cpp_int_val;
                        int cpp_int_val = glob_cpp_int_val;
                        bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                        bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                        int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                        bool& glob_aux_NP_read = aux_NP_read;
                        bool aux_NP_read = glob_aux_NP_read;
                        vartype aux_last_type_read_for_NP = UNKNOWN;
                        try {
                          cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { q = 1 to NP } ] LIST";
                          // read LIST record
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::cast(-99999)));
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::cast(-99999)));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::cast(-99999))));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::cast(-99999)));
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                        } catch (const std::out_of_range& e) {
                          // // accept failure in lookahead
                        }
                        if ((((((((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(8))))))||(((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(9)))))))))&&((((aux_LT_read == true)) && ((var_LT_0d_int_Scalar)==(0)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { q = 1 to NP } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                        // read LIST record
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<EndfFloatCpp>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LT", std::vector<int>({}), py::none()));
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none())), write_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("LB", std::vector<int>({}), py::none()));
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()))), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())));
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())), write_opts);
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()));
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none()))), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = (2*py::cast<int>(cpp_index_shifter_store.get_value("NP", std::vector<int>({}), py::none())));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_q_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("E", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                            cpp_write_field<EndfFloatCpp>(cpp_draft_line, cpp_j, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_q_0d_int_Scalar}), py::none())), write_opts);
                            // assign expression to variable F
                            var_F_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<EndfFloatCpp>(cpp_index_shifter_store.get_value("F", std::vector<int>({var_q_0d_int_Scalar}), py::none())));
                            validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                            aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum, write_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}
void write_endf_ostream(std::ostream& cont, py::dict endf_dict, py::object exclude, py::object include, WritingOptions write_opts=default_writing_options()) {
  int mat;
  int mf;
  int mt;
  int last_mat = -9999;
  int last_mf = -9999;
  int last_mt = -9999;
  bool section_encountered = false;
  bool found_tpid = false;
  auto d = py::reinterpret_borrow<py::dict>(endf_dict);
  py::object mf_keys = d.attr("keys")();
  std::vector<int> sorted_mf_keys;
  for (auto mf_key : mf_keys) {
    sorted_mf_keys.push_back(py::cast<int>(mf_key));
  }
  std::sort(sorted_mf_keys.begin(), sorted_mf_keys.end());
  std::map<int, std::vector<int>> sorted_mfmt_keys;
  for (auto mf_key : sorted_mf_keys) {
    py::object mt_keys = d[py::cast(mf_key)].attr("keys")();
  std::vector<int> sorted_mt_keys;
    for (auto mt_key : mt_keys) {
      sorted_mt_keys.push_back(py::cast<int>(mt_key));
    }
    std::sort(sorted_mt_keys.begin(), sorted_mt_keys.end());
    sorted_mfmt_keys[mf_key] = sorted_mt_keys;
  }
  for (auto mf_key : sorted_mf_keys) {
    py::dict mf_dict = d[py::cast(mf_key)];
    std::vector<int> sorted_mt_keys = sorted_mfmt_keys[mf_key];
    for (auto mt_key : sorted_mt_keys) {
      py::object mt_dict = mf_dict[py::cast(mt_key)];
      mf = mf_key;
      mt = mt_key;
      if ((! should_parse_section(mf, mt, exclude, include))) {
        continue;
      }
      if ((section_encountered && mf != last_mf && mf != 0 && last_mf != 0)) {
        cont << cpp_prepare_send(mat, 0, write_opts);
      }
      if (mf == 0 && mt == 0) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf0mt0_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 1 && mt == 460) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf1mt460_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 1 && mt == 458) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf1mt458_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 1 && mt == 456) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf1mt456_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 1 && mt == 455) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf1mt455_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 1 && mt == 452) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf1mt452_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 1 && mt == 451) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf1mt451_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 2 && mt == 151) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf2mt151_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 3) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf3_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 4) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf4_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 5) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf5_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 6) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf6_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 7 && mt == 451) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf7mt451_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 7 && mt == 4) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf7mt4_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 7 && mt == 2) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf7mt2_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 8 && mt == 459) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf8mt459_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 8 && mt == 457) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf8mt457_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 8 && mt == 454) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf8mt454_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 8) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf8_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 9) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf9_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 10) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf10_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 12) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf12_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 13) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf13_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 14) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf14_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 15) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf15_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 23) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf23_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 26) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf26_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 27) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf27_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 28) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf28_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 31) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf31_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 32) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf32_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 33) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf33_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 34) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf34_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 35) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf35_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 40) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          if ((! mt_dict.contains("MF"))) {
            mt_dict["MF"] = mf;
          }
          if ((! mt_dict.contains("MT"))) {
            mt_dict["MT"] = mt;
          }
          write_mf40_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else {
        write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
      }
      last_mat = mat;
      last_mf = mf;
      last_mt = mt;
    }
  }
  cont << cpp_prepare_send(mat, 0, write_opts);
  cont << cpp_prepare_send(0, 0, write_opts);
  cont << cpp_prepare_send(-1, 0, write_opts, false);
}

std::string write_mf0mt0(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf0mt0_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf1mt451(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf1mt451_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf1mt452(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf1mt452_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf1mt455(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf1mt455_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf1mt456(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf1mt456_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf1mt458(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf1mt458_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf1mt460(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf1mt460_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf2mt151(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf2mt151_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf3(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf3_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf4(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf4_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf5(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf5_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf6(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf6_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf7mt2(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf7mt2_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf7mt4(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf7mt4_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf7mt451(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf7mt451_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf8(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf8_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf8mt454(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf8mt454_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf8mt457(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf8mt457_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf8mt459(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf8mt459_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf9(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf9_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf10(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf10_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf12(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf12_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf13(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf13_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf14(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf14_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf15(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf15_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf23(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf23_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf26(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf26_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf27(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf27_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf28(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf28_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf31(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf31_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf32(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf32_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf33(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf33_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf34(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf34_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf35(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf35_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf40(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf40_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_endf(py::dict endf_dict, py::object exclude, py::object include, WritingOptions write_opts) {
  std::ostringstream oss;
  write_endf_ostream(oss, endf_dict, exclude, include, write_opts);
  return oss.str();
}

void write_mf0mt0_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf0mt0_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf1mt451_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf1mt451_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf1mt452_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf1mt452_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf1mt455_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf1mt455_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf1mt456_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf1mt456_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf1mt458_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf1mt458_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf1mt460_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf1mt460_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf2mt151_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf2mt151_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf3_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf3_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf4_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf4_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf5_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf5_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf6_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf6_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf7mt2_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf7mt2_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf7mt4_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf7mt4_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf7mt451_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf7mt451_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf8_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf8_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf8mt454_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf8mt454_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf8mt457_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf8mt457_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf8mt459_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf8mt459_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf9_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf9_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf10_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf10_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf12_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf12_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf13_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf13_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf14_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf14_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf15_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf15_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf23_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf23_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf26_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf26_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf27_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf27_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf28_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf28_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf31_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf31_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf32_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf32_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf33_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf33_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf34_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf34_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf35_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf35_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf40_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf40_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_endf_file(std::string& filename, py::dict endf_dict, py::object exclude, py::object include, WritingOptions write_opts) {
  std::ofstream outfile(filename, std::ios::binary);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_endf_ostream(outfile, endf_dict, exclude, include, write_opts);
  outfile.close();
}



PYBIND11_MODULE(jendl, m) {

  // static bool parsing_options_registered = false;
  // if (! parsing_options_registered) {
  //   py::class_<ParsingOptions>(m, "ParsingOptions")
  //     .def(py::init<>())
  //     .def_readwrite("ignore_number_mismatch", &ParsingOptions::ignore_number_mismatch)
  //     .def_readwrite("ignore_zero_mismatch", &ParsingOptions::ignore_zero_mismatch)
  //     .def_readwrite("ignore_varspec_mismatch", &ParsingOptions::ignore_varspec_mismatch)
  //     .def_readwrite("accept_spaces", &ParsingOptions::accept_spaces)
  //     .def_readwrite("ignore_blank_lines", &ParsingOptions::ignore_blank_lines)
  //     .def_readwrite("ignore_send_records", &ParsingOptions::ignore_send_records)
  //     .def_readwrite("ignore_missing_tpid", &ParsingOptions::ignore_missing_tpid)
  //     .def_readwrite("validate_control_records", &ParsingOptions::validate_control_records);
  //   parsing_options_registered = true;
  // }
  m.def("parse_endf", &parse_endf, "parsing function", py::arg("cont"), py::arg("exclude") = py::none(), py::arg("include") = py::none(), py::arg("parse_opts") = false);
  m.def("parse_endf_file", &parse_endf_file, "parsing function", py::arg("filename"), py::arg("exclude") = py::none(), py::arg("include") = py::none(), py::arg("parse_opts") = default_parsing_options());
  m.def("write_endf", &write_endf, "parsing function", py::arg("endf_dict"), py::arg("exclude") = py::none(), py::arg("include") = py::none(), py::arg("WritingOptions") = false);
  m.def("write_endf_file", &write_endf_file, "parsing function", py::arg("filename"), py::arg("endf_dict"), py::arg("exclude") = py::none(), py::arg("include") = py::none(), py::arg("write_opts") = default_writing_options());
}
