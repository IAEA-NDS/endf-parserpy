// This C++ file is kept as an example in the git repository but will not
// be kept in sync with the ENDF recipes stored in `endf_parserpy.endf_recipes`.
// The installation procedure triggered by `pip install` and `poetry install`
// automatically replaces these files by C++ code that reflects the content
// of the ENDF recipes.
//
// File generated by endf_parserpy.compiler.endf2cpp.py::generate_cpp_module_code
// MD5 hash of file content below this line: 15bc3d036611e81e883caac3e41cb7cd

#include <pybind11/pybind11.h>
#include <pybind11/stl.h> // Necessary for STL containers like std::map

#include <stdexcept>
#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <vector>
#include <string>
#include <cassert>

namespace py = pybind11;


struct Tab1Body {
  std::vector<int> INT;
  std::vector<int> NBT;
  std::vector<double> X;
  std::vector<double> Y;
};


struct Tab2Body {
  std::vector<int> INT;
  std::vector<int> NBT;
};


bool seq_contains(py::sequence seq, py::object value) {
  int i = 0;
  for (const auto& item : seq) {
    if (py::cast<py::object>(item).equal(value)) {
      return true;
    }
  }
  return false;
}


bool should_parse_section(int mf, int mt, py::object& exclude, py::object& include) {
  py::tuple mf_mt_tup = py::make_tuple(mf, mt);
  if (! exclude.is_none()) {
    if (! py::isinstance<py::sequence>(exclude)) {
      throw std::runtime_error("`exclude` argument must be of sequence type");
    }
    if (seq_contains(exclude, py::int_(mf)) || seq_contains(exclude, mf_mt_tup)) {
      return false;
    } else {
      return true;
    }
  } else if (! include.is_none()) {
    if (! py::isinstance<py::sequence>(include)) {
      throw std::runtime_error("`include` argument must be of sequence type");
    }
    if (seq_contains(include, py::int_(mf)) || seq_contains(include, mf_mt_tup)) {
      return true;
    } else {
      return false;
    }
  } else {
    return true;
  }
}


struct ParsingOptions {
  bool ignore_number_mismatch;
  bool ignore_zero_mismatch;
  bool ignore_varspec_mismatch;
  bool accept_spaces;
  bool ignore_blank_lines;
  bool ignore_send_records;
  bool ignore_missing_tpid;
  bool validate_control_records;
};


ParsingOptions default_parsing_options() {
  return ParsingOptions{
    false,  // ignore_number_mismatch
    true,  // ignore_zero_mismatch
    true,  // ignore_varspec_mismatch
    true,  // accept_spaces
    false,  // ignore_blank_lines
    false,  // ignore_send_records
    false,  // ignore_missing_tpid
    false  // validate_control_records
  };
}


namespace pybind11 { namespace detail {
  template <> struct type_caster<ParsingOptions> {
  public:
    PYBIND11_TYPE_CASTER(ParsingOptions, _("ParsingOptions"));

    // conversion from Python to C++
    bool load(handle src, bool) {
      if (!py::isinstance<py::dict>(src))
        return false;
      auto d = reinterpret_borrow<py::dict>(src);
      py::object keys = d.attr("keys")();
      for (auto key : keys) {
        std::string key_str = py::str(key);
        if (key_str == "ignore_number_mismatch")
          value.ignore_number_mismatch = d["ignore_number_mismatch"].cast<bool>();
        else if (key_str == "ignore_zero_mismatch")
          value.ignore_zero_mismatch = true;
        else if (key_str == "ignore_varspec_mismatch")
          value.ignore_varspec_mismatch = d["ignore_varspec_mismatch"].cast<bool>();
        else if (key_str == "accept_spaces")
          value.accept_spaces = d["accept_spaces"].cast<bool>();
        else if (key_str == "ignore_blank_lines")
          value.ignore_blank_lines = d["ignore_blank_lines"].cast<bool>();
        else if (key_str == "ignore_send_records")
          value.ignore_send_records = d["ignore_send_records"].cast<bool>();
        else if (key_str == "ignore_missing_tpid")
          value.ignore_missing_tpid = d["ignore_missing_tpid"].cast<bool>();
        else if (key_str == "validate_control_records")
          value.validate_control_records = d["validate_control_records"].cast<bool>();
        else
          throw std::runtime_error("unknown option `" + key_str + "` provided");
      }

      // use default values for missing options
      ParsingOptions default_opts = default_parsing_options();

      if (! d.contains("ignore_number_mismatch")) {
        value.ignore_number_mismatch = default_opts.ignore_number_mismatch;
      }

      if (! d.contains("ignore_zero_mismatch")) {
        value.ignore_zero_mismatch = default_opts.ignore_zero_mismatch;
      }

      if (! d.contains("ignore_varspec_mismatch")) {
        value.ignore_varspec_mismatch = default_opts.ignore_varspec_mismatch;
      }

      if (! d.contains("accept_spaces")) {
        value.accept_spaces = default_opts.accept_spaces;
      }

      if (! d.contains("ignore_blank_lines")) {
        value.ignore_blank_lines = default_opts.ignore_blank_lines;
      }

      if (! d.contains("ignore_send_records")) {
        value.ignore_send_records = default_opts.ignore_send_records;
      }

      if (! d.contains("ignore_missing_tpid")) {
        value.ignore_missing_tpid = default_opts.ignore_missing_tpid;
      }

      if (! d.contains("validate_control_records")) {
        value.validate_control_records = default_opts.validate_control_records;
      }

      return true;
    }

    // conversion from C++ to Python
    static handle cast(const ParsingOptions &src, return_value_policy, handle) {
      py::dict d;
      d["ignore_number_mismatch"] = src.ignore_number_mismatch;
      d["ignore_zero_mismatch"] = src.ignore_zero_mismatch;
      d["ignore_varspec_mismatch"] = src.ignore_varspec_mismatch;
      d["accept_spaces"] = src.accept_spaces;
      d["ignore_blank_lines"] = src.ignore_blank_lines;
      d["ignore_send_records"] = src.ignore_send_records;
      d["ignore_missing_tpid"] = src.ignore_missing_tpid;
      d["validate_control_records"] = src.validate_control_records;
      return d.release();
    }

  };
}}


template<typename U, typename V, typename W>
void throw_mismatch_error(
  U quantity, V expected_value, W actual_value,
  std::string line, std::string template_line
) {
  std::stringstream errmsg;
  errmsg << "Invalid " << quantity << " encountered! "
         << "Expected " << quantity << "=" << expected_value
         << " but found " << quantity <<"=" << actual_value << std::endl;
  if (template_line.size() > 0) {
    errmsg << "Template: " << template_line << std::endl;
  }
  if (line.size() > 0) {
    errmsg << "Line: " << line << std::endl;
  }
  throw std::runtime_error(errmsg.str());
}


template<typename V, typename W>
void throw_number_mismatch_error(
  V expected_value, W actual_value,
  std::string line, std::string template_line
) {
  std::stringstream errmsg;
  errmsg << "Expected a field to contain the value " << expected_value
         << " but found instead the value " << actual_value << "." << std::endl;
  if (template_line.size() > 0) {
    errmsg << "Template: " << template_line << std::endl;
  }
  if (line.size() > 0) {
    errmsg << "Line: " << line << std::endl;
  }
  throw std::runtime_error(errmsg.str());
}


double endfstr2float(const char* str, ParsingOptions &parse_opts) {
  char tbuf[13];
  int j = 0;
  bool in_number = false;
  bool in_exponent = false;
  int last_nonspace_pos=-1;
  for (int i=10; i >= 0; i--) {
    if (str[i] != ' ') {
      last_nonspace_pos = i;
      break;
    }
  }
  if (last_nonspace_pos == -1) {
    return 0.0;
  }
  for (int i=0; i <= last_nonspace_pos; i++) {
    char c = str[i];
    if (c == ' ') {
      if (parse_opts.accept_spaces || ! in_number) {
        continue;
      } else {
        std::stringstream errmsg;
        errmsg << "encontered number with spaces: \""
               << std::string(str, 11) << "\"" << std::endl;
        throw std::runtime_error(errmsg.str());
      }
    }
    if (in_number) {
      if (!in_exponent) {
        if (c=='+' || c=='-') {
          tbuf[j++] = 'e';
          in_exponent = true;
        } else if (c=='e' || c=='E') {
          in_exponent = true;
        }
      }
    } else {
      if (c == '.' || (c >= '0' && c <= '9') || c == '-' || c == '+') {
        in_number = true;
      }
    }
    tbuf[j++] = c;
  }
  if (j==0) tbuf[j++] = '0';
  tbuf[j++] = '\0';
  return std::stod(tbuf);
}


int endfstr2int(const char* str, ParsingOptions &parse_opts) {
  char strzero[12];
  std::memcpy(strzero, str, 11);
  strzero[11] = '\0';
  for (int i=0; i < 11; i++) {
    if (str[i] != ' ') {
      return std::atoi(strzero);
    }
  }
  return 0;
}


template<typename T>
T cpp_read_field(const char *str, const char fieldnum, ParsingOptions &parse_opts) {
  static_assert(std::is_same<T, double>::value || std::is_same<T, int>::value, "T must be int or double");
  if (std::is_same<T, double>::value) {
    return endfstr2float(str+fieldnum*11, parse_opts);
  } else {
    return endfstr2int(str+fieldnum*11, parse_opts);
  }
}


// the next couple of functions are for handling
// are auxiliary functions to amek cpp_validate_field
// for different types (in particular std::vector and std::string)

template<typename T>
typename std::enable_if<std::is_scalar<T>::value, bool>::type
is_zero_check(const T value) {
  return value == 0;
}


template<typename T>
typename std::enable_if<! std::is_scalar<T>::value, bool>::type
is_zero_check(const T value) {
  return false;
}


template<typename U, typename V>
typename std::enable_if<!std::is_scalar<U>::value || !std::is_scalar<V>::value, void>::type
cpp_validate_field(
  U expected_value,
  V actual_value,
  bool contains_variable,
  bool contains_desired_number,
  bool contains_inconsistent_varspec,
  std::string exprstr,
  std::string &line_template,
  std::string &line,
  ParsingOptions &parse_opts
) {
  std::stringstream errmsg;
  errmsg << "Both the expected and actual value are vectors --- "
         << "not implemented at the moment" << std::endl;
  throw std::runtime_error(errmsg.str());
}


template<typename U, typename V>
typename std::enable_if<std::is_scalar<U>::value && std::is_scalar<V>::value, void>::type
cpp_validate_field(
  U expected_value,
  V actual_value,
  bool contains_variable,
  bool contains_desired_number,
  bool contains_inconsistent_varspec,
  std::string exprstr,
  std::string &line_template,
  std::string &line,
  ParsingOptions &parse_opts
) {
  if (expected_value == actual_value) return;

  // inconsistency detected
  if (! contains_variable) {
    // dealing with a number
    // ignore zero mismatch only active for scalar data types
    if (is_zero_check(expected_value) && parse_opts.ignore_zero_mismatch) return;
    if (contains_desired_number && parse_opts.ignore_number_mismatch) return;
    throw_number_mismatch_error(expected_value, actual_value, line, line_template);
  } else {
    // dealing with an expression with variables
    if (contains_inconsistent_varspec && parse_opts.ignore_varspec_mismatch) return;
    throw_mismatch_error(exprstr, expected_value, actual_value, line, line_template);
  }
}

// we are done with the cpp_validate_field related functionality

double cpp_read_custom_int_field(const char *str, int start_pos, int length) {
  char strzero[length+1];
  std::memcpy(strzero, str+start_pos, length);
  strzero[length] = '\0';
  for (int i=0; i < length; i++) {
    if (strzero[i] != ' ') {
      return std::atoi(strzero);
    }
  }
  return 0;
}


int cpp_read_mat_number(const char *str) {
  return cpp_read_custom_int_field(str, 66, 4);
}


int cpp_read_mf_number(const char *str) {
  return cpp_read_custom_int_field(str, 70, 2);
}


int cpp_read_mt_number(const char *str) {
  return cpp_read_custom_int_field(str, 72, 3);
}


std::string cpp_read_raw_line(std::istream& cont) {
  std::string line;
  std::getline(cont, line);
  return line;
}


std::string cpp_read_line(
  std::istream& cont, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  std::string line;
  std::getline(cont, line);
  if (parse_opts.validate_control_records) {
    int curmat = cpp_read_mat_number(line.c_str());
    int curmf = cpp_read_mf_number(line.c_str());
    int curmt = cpp_read_mt_number(line.c_str());
    if (curmat != mat)
      throw_mismatch_error("MAT", mat, curmat, line, "");
    if (curmf != mf)
      throw_mismatch_error("MF", mf, curmf, line, "");
    if (curmt != mt)
      throw_mismatch_error("MT", mt, curmt, line, "");
  }
  return line;
}


std::string cpp_read_send(std::istream& cont, int mat, int mf, ParsingOptions &parse_opts) {
  std::string line = cpp_read_line(cont, mat, mf, 0, parse_opts);
  int mtnum = cpp_read_mt_number(line.c_str());
  if (cpp_read_field<double>(line.c_str(), 0, parse_opts) != 0.0 ||
    cpp_read_field<double>(line.c_str(), 1, parse_opts) != 0.0 ||
    cpp_read_field<int>(line.c_str(), 2, parse_opts) != 0 ||
    cpp_read_field<int>(line.c_str(), 3, parse_opts) != 0 ||
    cpp_read_field<int>(line.c_str(), 4, parse_opts) != 0 ||
    cpp_read_field<int>(line.c_str(), 5, parse_opts) != 0 ||
    mtnum != 0) {

    std::stringstream errmsg;
    errmsg << "Expected SEND record does not contain one!" << std::endl
           << "Line: " << line << std::endl;
    throw std::runtime_error(errmsg.str());
  }
  if (parse_opts.validate_control_records) {
    int curmat = cpp_read_mat_number(line.c_str());
    int curmf = cpp_read_mf_number(line.c_str());
    if (curmat != mat)
      throw_mismatch_error("MAT", mat, curmat, line, "");
    if (curmf != mf)
      throw_mismatch_error("MF", mf, curmf, line, "");
  }
  return line;
}


bool cpp_is_fend_record(std::string line, int mat, ParsingOptions &parse_opts) {
  int curmat = cpp_read_mat_number(line.c_str());
  if (mat != curmat && parse_opts.validate_control_records) {
      throw_mismatch_error("MAT", mat, curmat, line, "");
  }
  int mf = cpp_read_mf_number(line.c_str());
  int mt = cpp_read_mt_number(line.c_str());
  double c1 = cpp_read_field<double>(line.c_str(), 0, parse_opts);
  double c2 = cpp_read_field<double>(line.c_str(), 1, parse_opts);
  int n1 = cpp_read_field<int>(line.c_str(), 2, parse_opts);
  int n2 = cpp_read_field<int>(line.c_str(), 3, parse_opts);
  int l1 = cpp_read_field<int>(line.c_str(), 4, parse_opts);
  int l2 = cpp_read_field<int>(line.c_str(), 5, parse_opts);
  bool cond = (c1 == 0.0 && c2 == 0.0 && n1 == 0 && n2 == 0);
  cond &= (l1 == 0 && l2 == 0 && mf == 0 && mt == 0);
  return cond;
}


bool cpp_is_mend_record(std::string line, ParsingOptions &parse_opts) {
  int mat = cpp_read_mat_number(line.c_str());
  bool cond = cpp_is_fend_record(line, 0, parse_opts);
  cond &= (mat == 0);
  return cond;
}


bool cpp_is_tend_record(std::string line, ParsingOptions &parse_opts) {
  int mat = cpp_read_mat_number(line.c_str());
  bool cond = cpp_is_fend_record(line, -1, parse_opts);
  cond &= (mat == -1);
  return cond;
}


bool cpp_is_blank_line(std::string line) {
  for (int i=0; i < line.size(); i++) {
    if (line[i] != ' ') return false;
  }
  return true;
}

template<typename T>
std::vector<T> cpp_read_vec(
  std::istream& cont, const int numel, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  int j = 0;
  std::vector<T> res;
  std::string line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  for (int i=0; i < numel; i++) {
    res.push_back(cpp_read_field<T>(line.c_str(), j++, parse_opts));
    if (j > 5 && i+1 < numel) {
      line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      j = 0;
    }
  }
  return res;
}


template<typename T>
std::vector<T> cpp_read_vec_debug(
  std::istream& cont, std::string& line, const int numel, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  int j = 0;
  std::vector<T> res;
  std::ostringstream oss;
  std::string curline = cpp_read_line(cont, mat, mf, mt, parse_opts);
  for (int i=0; i < numel; i++) {
    res.push_back(cpp_read_field<T>(curline.c_str(), j++, parse_opts));
    if (j > 5 && i+1 < numel) {
      oss << curline << std::endl;
      curline = cpp_read_line(cont, mat, mf, mt, parse_opts);
      j = 0;
    }
  }
  oss << curline << std::endl;
  line = oss.str();
  return res;
}


Tab2Body read_tab2_body_debug(
  std::istream& cont, std::string& line, int nr, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  std::ostringstream oss;
  std::string tmpline;
  Tab2Body tab_body;
  std::vector<int> interp = cpp_read_vec_debug<int>(cont, tmpline, 2*nr, mat, mf, mt, parse_opts);
  oss << tmpline;
  int j = 0;
  for (int i=0; i < nr; i++) {
    tab_body.NBT.push_back(interp[j++]);
    tab_body.INT.push_back(interp[j++]);
  }
  line = oss.str();
  return tab_body;
}


Tab2Body read_tab2_body(
  std::istream& cont, int nr, int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  Tab2Body tab_body;
  std::vector<int> interp = cpp_read_vec<int>(cont, 2*nr, mat, mf, mt, parse_opts);
  int j = 0;
  for (int i=0; i < nr; i++) {
    tab_body.NBT.push_back(interp[j++]);
    tab_body.INT.push_back(interp[j++]);
  }
  return tab_body;
}


Tab1Body read_tab1_body_debug(
  std::istream& cont, std::string& line, int nr, int np,
  int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  std::ostringstream oss;
  std::string tmpline;
  Tab1Body tab_body;
  std::vector<int> interp = cpp_read_vec_debug<int>(cont, tmpline, 2*nr, mat, mf, mt, parse_opts);
  oss << tmpline;
  int j = 0;
  for (int i=0; i < nr; i++) {
    tab_body.NBT.push_back(interp[j++]);
    tab_body.INT.push_back(interp[j++]);
  }
  std::vector<double> data = cpp_read_vec_debug<double>(cont, tmpline, 2*np, mat, mf, mt, parse_opts);
  oss << tmpline;
  j = 0;
  for (int i=0; i < np; i++) {
    tab_body.X.push_back(data[j++]);
    tab_body.Y.push_back(data[j++]);
  }
  line = oss.str();
  return tab_body;
}


Tab1Body read_tab1_body(
  std::istream& cont, int nr, int np,
  int mat, int mf, int mt, ParsingOptions &parse_opts
) {
  Tab1Body tab_body;
  std::vector<int> interp = cpp_read_vec<int>(cont, 2*nr, mat, mf, mt, parse_opts);
  int j = 0;
  for (int i=0; i < nr; i++) {
    tab_body.NBT.push_back(interp[j++]);
    tab_body.INT.push_back(interp[j++]);
  }
  std::vector<double> data = cpp_read_vec<double>(cont, 2*np, mat, mf, mt, parse_opts);
  j = 0;
  for (int i=0; i < np; i++) {
    tab_body.X.push_back(data[j++]);
    tab_body.Y.push_back(data[j++]);
  }
  return tab_body;
}


std::vector<std::string> read_section_verbatim(
    int mat, int mf, int mt, std::istream& cont, bool is_first, ParsingOptions &parse_opts
) {
  std::streampos curpos;
  std::string line;
  std::vector<std::string> secvec;
  int curmf;
  int curmt;
  size_t lastpos;
  while (! cont.eof()) {
    line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // remove trailing \r that we may
    // get from reading win-style line endings
    lastpos = line.size() - 1;
    if (line[lastpos] == '\r') {
      line.erase(lastpos);
    }
    curmf = std::stoi(line.substr(70, 2));
    curmt = std::stoi(line.substr(72, 3));
    if (curmf != mf || curmt != mt) break;
    // the newline for compatibility with the Python parser
    secvec.push_back(line + "\n");
    curpos = cont.tellg();
  }
  if (! is_first && (curmf != mf || curmt != 0)) {
     std::string errmsg = "expected SEND of MF/MT " +
                          std::to_string(mf) + "/" + std::to_string(mt);
     throw std::runtime_error(errmsg);
  }
  if (is_first) {
    // we rewind one line because in the case of MF0/MT0 (tapeid)
    // we have also consumed the HEAD record of the next section
    cont.seekg(curpos);
  }
  return secvec;
}



struct WritingOptions {
  bool abuse_signpos;
  bool keep_E;
  bool prefer_noexp;
  bool skip_intzero;
};


WritingOptions default_writing_options() {
  return WritingOptions{
    false,  // abuse_signpos
    false,  // keep_E
    false,  // prefer_noexp
    false   // skip_intzero
  };
}


namespace pybind11 { namespace detail {
  template <> struct type_caster<WritingOptions> {
  public:
    PYBIND11_TYPE_CASTER(WritingOptions, _("WritingOptions"));

    // conversion from Python to C++
    bool load(handle src, bool) {
      if (!py::isinstance<py::dict>(src))
        return false;
      auto d = reinterpret_borrow<py::dict>(src);
      py::object keys = d.attr("keys")();
      for (auto key : keys) {
        std::string key_str = py::str(key);
        if (key_str == "abuse_signpos")
          value.abuse_signpos = d["abuse_signpos"].cast<bool>();
        else if (key_str == "keep_E")
          value.keep_E = d["keep_E"].cast<bool>();
        else if (key_str == "prefer_noexp")
          value.prefer_noexp = d["prefer_noexp"].cast<bool>();
        else if (key_str == "skip_intzero")
          value.skip_intzero = d["skip_intzero"].cast<bool>();
        else
          throw std::runtime_error("unknown option `" + key_str + "` provided");
      }

      // use default values for missing options
      WritingOptions default_opts = default_writing_options();

      if (! d.contains("abuse_signpos")) {
        value.abuse_signpos = default_opts.abuse_signpos;
      }
      if (! d.contains("keep_E")) {
        value.keep_E = default_opts.keep_E;
      }
      if (! d.contains("prefer_noexp")) {
        value.prefer_noexp = default_opts.prefer_noexp;
      }
      if (! d.contains("skip_intzero")) {
        value.skip_intzero = default_opts.skip_intzero;
      }
      return true;
    }

    // conversion from C++ to Python
    static handle cast(const WritingOptions &src, return_value_policy, handle) {
      py::dict d;
      d["abuse_signpos"] = src.abuse_signpos;
      d["keep_E"] = src.keep_E;
      d["prefer_noexp"] = src.prefer_noexp;
      d["skip_intzero"] = src.skip_intzero;
      return d.release();
    }

  };
}}


void cpp_write_custom_int_field(std::string &str, int start, int length, int value) {
  std::ostringstream oss;
  oss << std::right << std::setw(length) << value;
  str.replace(start, length, oss.str());
}


void cpp_write_mat_number(std::string& str, int value) {
  cpp_write_custom_int_field(str, 66, 4, value);
}


void cpp_write_mf_number(std::string& str, int value) {
  cpp_write_custom_int_field(str, 70, 2, value);
}


void cpp_write_mt_number(std::string& str, int value) {
  cpp_write_custom_int_field(str, 72, 3, value);
}


void cpp_write_line_number(std::string& str, int value) {
  cpp_write_custom_int_field(str, 75, 5, value);
}


std::string cpp_prepare_line(int mat, int mf, int mt, int &linenum) {
  std::string line(80, ' ');
  line += '\n';
  cpp_write_mat_number(line, mat);
  cpp_write_mf_number(line, mf);
  cpp_write_mt_number(line, mt);
  cpp_write_line_number(line, ++linenum);
  return line;
}


std::string float2endfstr_helper(
  double value, int prec, size_t &exp_pos, WritingOptions &write_opts
) {
  std::ostringstream oss;
  oss << std::scientific << std::setprecision(prec) << value;
  std::string numstr = oss.str();
  size_t strsize = numstr.size();
  size_t zerostart = std::string::npos;
  exp_pos = numstr.find("e");
  if (exp_pos == std::string::npos) {
    throw std::runtime_error("`e` character not found");
  }
  for (int i=exp_pos+1; i < strsize; i++) {
    if ((numstr[i] >= '1' && numstr[i] <= '9') || i+1 == strsize) {
      if (zerostart != std::string::npos) {
        numstr.erase(zerostart, i - zerostart);
        break;
      }
    } else if (zerostart == std::string::npos && numstr[i] == '0') {
      zerostart = i;
    }
  }
  return numstr;
}


std::string float2endfstr_decimal_helper(
  double value, int width, WritingOptions &write_opts
) {
  std::stringstream ss;
  std::string numstr;
  int commapos;
  ss << std::fixed << std::setprecision(16) << value;
  numstr = ss.str();
  commapos = numstr.find('.');
  if (commapos == std::string::npos) {
    throw std::runtime_error("error occured while converting float to string");
  }
  if (commapos >= width) {
    return numstr;
  }
  int prec = width - commapos;
  if (value >= 0) {
    prec--;
  }
  std::stringstream ss2;
  ss2 << std::fixed << std::setprecision(prec) << value;
  return ss2.str();
}


std::string float2endfstr(double value, WritingOptions &write_opts) {
  std::ostringstream oss;
  std::string numstr;
  int number_length = 10;
  int digits_after_comma = 6;
  bool delete_E = (! write_opts.keep_E);
  size_t exp_pos;
  if (! delete_E) {
    digits_after_comma--;
  }
  if (value >= 0 && write_opts.abuse_signpos) {
    number_length++;
    digits_after_comma++;
  }
  numstr = float2endfstr_helper(
    value, digits_after_comma, exp_pos, write_opts
  );
  int prec_red = numstr.size() - number_length;
  // account for excess length by char 'e'
  if (delete_E) {
    prec_red -= 1;
  }
  // account for excess length in numstr to minus sign
  if (value < 0) {
    prec_red -= 1;
  }
  if (prec_red > 0) {
    numstr = float2endfstr_helper(
      value, digits_after_comma - prec_red, exp_pos, write_opts
    );
  }
  if (write_opts.prefer_noexp) {
    std::string numstr_noexp = float2endfstr_decimal_helper(
      value, number_length, write_opts
    );
    int sign_inc = 0;
    if (value < 0) sign_inc++;
    if (numstr_noexp.size() <= number_length + sign_inc) {
      double recon_value = std::stod(numstr);
      double recon_value_noexp = std::stod(numstr_noexp);
      double recon_value_diff = std::abs(recon_value - value);
      double recon_value_reldiff = recon_value_diff / (std::abs(value)+1e-12);
      double recon_value_noexp_diff = std::abs(recon_value_noexp - value);
      double recon_value_noexp_reldiff =  recon_value_noexp_diff / (std::abs(value)+1e-12);
      if (recon_value_reldiff >= recon_value_noexp_reldiff) {
        if (write_opts.skip_intzero && static_cast<int>(recon_value_noexp) == 0) {
          numstr_noexp = float2endfstr_decimal_helper(
            value, number_length+1, write_opts
          );
          size_t zeropos = numstr_noexp.find('0');
          size_t commapos = numstr_noexp.find('.');
          if (zeropos+1 != commapos) {
            throw std::runtime_error("integer zero matching failed");
          }
          numstr_noexp.erase(zeropos, 1);
        }
        numstr = numstr_noexp;
        delete_E = false;
      }
    }
  }
  if (delete_E) {
    numstr.erase(exp_pos, 1);
  }
  oss << std::right << std::setw(11) << numstr;
  return oss.str();
}


std::string int2endfstr(int value) {
  std::ostringstream oss;
  oss << std::right << std::setw(11) << value;
  return oss.str();
}


template<typename T>
void cpp_write_field(std::string& line, const char fieldnum, T value, WritingOptions &write_opts) {
  static_assert(std::is_same<T, double>::value || std::is_same<T, int>::value, "T must be int or double");
  std::string fieldstr;
  if (std::is_same<T, double>::value) {
    fieldstr = float2endfstr(value, write_opts);
  } else {
    fieldstr = int2endfstr(value);
  }
  if (fieldstr.size() != 11) { throw std::runtime_error(std::string("wrong size") + std::to_string(fieldstr.size()) + std::string("  ") + std::string(fieldstr)); }
  line.replace(fieldnum*11, 11, fieldstr);
}


void write_tab1_body(
  std::string& line, Tab1Body tab_body, int mat, int mf, int mt, int& linenum, WritingOptions &write_opts
) {
  assert(tab_body.INT.size() == tab_body.NBT.size() && "INT and NBT must have same size");
  assert(tab_body.X.size() == tab_body.Y.size() && "X and Y must have same size");
  int nr = tab_body.INT.size();
  int np = tab_body.X.size();
  std::ostringstream oss;
  std::string curline = cpp_prepare_line(mat, mf, mt, linenum);
  int j = 0;
  for (int i=0; i < nr; i++) {
    cpp_write_field(curline, j++, tab_body.NBT[i], write_opts);
    cpp_write_field(curline, j++, tab_body.INT[i], write_opts);
    if (j > 5 && i+1 < nr) {
      oss << curline;
      curline = cpp_prepare_line(mat, mf, mt, linenum);
      j = 0;
    }
  }
  oss << curline;

  j = 0;
  curline = cpp_prepare_line(mat, mf, mt, linenum);
  for (int i=0; i < np; i++) {
    cpp_write_field(curline, j++, tab_body.X[i], write_opts);
    cpp_write_field(curline, j++, tab_body.Y[i], write_opts);
    if (j > 5 && i+1 < np) {
      oss << curline;
      curline = cpp_prepare_line(mat, mf, mt, linenum);
      j = 0;
    }
  }
  oss << curline;
  line = oss.str();
}


void write_tab2_body(
  std::string& line, Tab2Body tab_body, int mat, int mf, int mt, int& linenum, WritingOptions &write_opts
) {
  assert(tab_body.INT.size() == tab_body.NBT.size() && "INT and NBT must have same size");
  int nr = tab_body.INT.size();
  std::ostringstream oss;
  std::string curline = cpp_prepare_line(mat, mf, mt, linenum);
  int j = 0;
  for (int i=0; i < nr; i++) {
    cpp_write_field(curline, j++, tab_body.NBT[i], write_opts);
    cpp_write_field(curline, j++, tab_body.INT[i], write_opts);
    if (j > 5 && i+1 < nr) {
      oss << curline;
      curline = cpp_prepare_line(mat, mf, mt, linenum);
      j = 0;
    }
  }
  oss << curline;
  line = oss.str();
}


std::string cpp_prepare_send(int mat, int mf, WritingOptions &write_opts) {
  std::string line(80, ' ');
  line += '\n';
  cpp_write_mat_number(line, mat);
  cpp_write_mf_number(line, mf);
  cpp_write_mt_number(line, 0);
  cpp_write_field(line, 0, 0.0, write_opts);
  cpp_write_field(line, 1, 0.0, write_opts);
  cpp_write_field(line, 2, 0, write_opts);
  cpp_write_field(line, 3, 0, write_opts);
  cpp_write_field(line, 4, 0, write_opts);
  cpp_write_field(line, 5, 0, write_opts);
  if (mf == 0) {
    // for writing FEND/MEND/TEND record
    cpp_write_line_number(line, 0);
  } else {
    cpp_write_line_number(line, 99999);
  }
  return line;
}


int get_mat_from_mfmt_section(py::object mfmt_section) {
  int mat;
  if (py::isinstance<py::dict>(mfmt_section)) {
    py::dict mfmt_section_dict = py::cast<py::dict>(mfmt_section);
    mat = py::cast<int>(mfmt_section_dict["MAT"]);
    return mat;
  }
  if (! py::isinstance<py::list>(mfmt_section)) {
    throw std::runtime_error(
      "expect section to be represented by `list` or `dict`"
    );
  }
  py::list mfmt_section_list = py::cast<py::list>(mfmt_section);
  if (mfmt_section_list.size() == 0) {
    throw std::runtime_error("list representing section is empty");
  }
  std::string first_line = py::cast<std::string>(mfmt_section_list[0]);
  std::string matstr = first_line.substr(66, 4);
  mat = std::stoi(matstr);
  return mat;
}


void write_section_verbatim(
  std::ostream& oss, py::list mfmt_section, WritingOptions &write_opts
) {
  if (mfmt_section.size() == 0) {
    throw std::runtime_error("an MF/MT section must not be represented by an empty list");
  }
  int mat;
  int mf;
  int mt;
  for (const auto& item : mfmt_section) {
    std::string linestr = py::cast<std::string>(item);
    if (linestr.back() != '\n') {
      linestr.push_back('\n');
    }
    mat = cpp_read_mat_number(linestr.c_str());
    mf = cpp_read_mf_number(linestr.c_str());
    mt = cpp_read_mt_number(linestr.c_str());
    oss << linestr;
  }
  std::string send_line = cpp_prepare_send(mat, mf, write_opts);
  oss << send_line;
}

enum vartype {
  MATRIX2D_DOUBLE,
  MATRIX2D_FLOATVEC,
  MATRIX2D_INT,
  MATRIX2D_INTVEC,
  MATRIX2D_STRING,
  NESTEDVECTOR_DOUBLE,
  NESTEDVECTOR_FLOATVEC,
  NESTEDVECTOR_INT,
  NESTEDVECTOR_INTVEC,
  NESTEDVECTOR_STRING,
  SCALAR_DOUBLE,
  SCALAR_FLOATVEC,
  SCALAR_INT,
  SCALAR_INTVEC,
  SCALAR_STRING,
  UNKNOWN
};

std::string vartype2str(vartype vt) {
    switch (vt) {
        case MATRIX2D_DOUBLE:  return "MATRIX2D_DOUBLE";
        case MATRIX2D_INT:  return "MATRIX2D_INT";
        case MATRIX2D_STRING:  return "MATRIX2D_STRING";
        case MATRIX2D_INTVEC:  return "MATRIX2D_INTVEC";
        case MATRIX2D_FLOATVEC:  return "MATRIX2D_FLOATVEC";
        case NESTEDVECTOR_DOUBLE:  return "NESTEDVECTOR_DOUBLE";
        case NESTEDVECTOR_INT:  return "NESTEDVECTOR_INT";
        case NESTEDVECTOR_STRING:  return "NESTEDVECTOR_STRING";
        case NESTEDVECTOR_INTVEC:  return "NESTEDVECTOR_INTVEC";
        case NESTEDVECTOR_FLOATVEC:  return "NESTEDVECTOR_FLOATVEC";
        case SCALAR_DOUBLE:  return "SCALAR_DOUBLE";
        case SCALAR_INT:  return "SCALAR_INT";
        case SCALAR_STRING:  return "SCALAR_STRING";
        case SCALAR_INTVEC:  return "SCALAR_INTVEC";
        case SCALAR_FLOATVEC:  return "SCALAR_FLOATVEC";
    }
    throw std::runtime_error("should not arrivere here");
    return "should not arrive here";
}


void validate_vartype_consistency(std::string varname, vartype current_type, vartype expected_type) {
  if (current_type != expected_type && expected_type != UNKNOWN) {
    std::string current_type_str = vartype2str(current_type);
    std::string expected_type_str = vartype2str(expected_type);
    std::stringstream errmsg;
    errmsg << "variable `" << varname << "` is now encountered "
          << "with type `" << current_type_str << "` but was "
          << "previously encountered with type `" << expected_type_str << ". "
          << "Either the ENDF recipe is wrongly specified or the ENDF file "
          << "contains some forbidden flag values." << std::endl;
    throw std::runtime_error(errmsg.str());
  }
}

template<typename T>
class Matrix2d {

  private:
    std::vector<T> data;
    size_t num_rows;
    size_t num_cols;
    size_t row_start;
    size_t col_start;
    bool initialized;
    bool accessed;
    bool triagonal;
    bool lower;

  public:

    Matrix2d() : initialized(false), accessed(false),
                 triagonal(false), lower(false) {};

    void init(size_t first_row_idx, size_t last_row_idx,
              size_t first_col_idx, size_t last_col_idx,
              bool triagonal=false, bool lower=false) {
      this->num_rows = last_row_idx - first_row_idx + 1;
      this->num_cols = last_col_idx - first_col_idx + 1;
      this->row_start = first_row_idx;
      this->col_start = first_col_idx;
      this->data.resize(this->num_rows * this->num_cols);
      this->initialized = true;
      this->triagonal = triagonal;
      this->lower = lower;
    }

    bool is_initialized() {
      return initialized;
    }

    bool did_read() {
      return accessed;
    }

    T& operator()(size_t i, size_t j) {
      accessed = true;
      return data.at((i-row_start)*num_cols + (j-col_start));
    }

    int get_row_start_index() {
      return row_start;
    }

    int get_row_last_index() {
      return row_start + num_rows - 1;
    }

    int get_col_start_index() {
      return col_start;
    }

    int get_col_start_index(int i) {
      if (! triagonal || lower) {
        return col_start;
      } else {
        return col_start + (i - row_start);
      }
    }

    int get_col_last_index() {
      return col_start + num_cols - 1;
    }

    int get_col_last_index(int i) {
      if (! triagonal || ! lower) {
        return col_start + num_cols - 1;
      } else {
        return col_start + (i - row_start);
      }
    }
};

template<typename T>
class NestedVector : public std::vector<T> {
  private:
    int startIndex;
    int lastIndex;

  public:
    // default constructor
    NestedVector() : startIndex(0), lastIndex(-1) {}

    // copy constructor
    NestedVector(const NestedVector<T>& other) :
      std::vector<T>(other), startIndex(other.startIndex),
      lastIndex(other.lastIndex) {}

    // assignment constructor
    NestedVector<T>& operator=(const NestedVector<T>& other) {
      if (this != &other) {
        std::vector<T>::operator=(other);
        startIndex = other.startIndex;
        lastIndex = other.lastIndex;
      }
      return *this;
    }

    void set_start_index(int start) {
      this->startIndex = start;
    }

    int get_start_index() {
      return this->startIndex;
    }

    void set_last_index(int lastIndex) {
      this->lastIndex = lastIndex;
    }

    int get_last_index() {
      return this->lastIndex;
    }

    T& operator[](int index) {
      if (! contains(index)) {
        throw std::out_of_range("index out of range 1");
      }
      return std::vector<T>::operator[](index - startIndex);
    }

    T& at(int index) {
      return std::vector<T>::at(index - startIndex);
    }

    T* prepare(int index) {
      if (contains(index)) return &((*this)[index]);
      T cpp_curel;
      set(index, cpp_curel);
      return &(*this)[index];
    }

    void set(int index, const T& value) {
      bool is_first = false;
      if (this->lastIndex == -1) {
        this->startIndex = index;
        this->lastIndex = index;
        is_first = true;
      }
      if (index == startIndex + (int)this->size()) {
        std::vector<T>::push_back(value);
        if (! is_first) {
          this->lastIndex++;
        }
      } else if (index >= startIndex && index < startIndex + (int)this->size())  {
        std::vector<T>::operator[](index - startIndex) = value;
      } else {
        throw std::out_of_range("index out of range 2");
      }
    }

    bool contains(int index) {
      return (this->startIndex <= index && index <= this->lastIndex);
    }
};


// MD5 hash of ENDF recipe underlying the following function: a38e6e76968fb4463ab67282d5c7f80d
// MD5 hash of the following function definition: b2ad1cc10c0c267d2b1d560d225d4eea
py::dict parse_mf0mt0_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  std::string var_TAPEDESCR_0d_string_Scalar;
  bool aux_TAPEDESCR_read = false;
  vartype aux_last_type_read_for_TAPEDESCR = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 0;
  int mt = 0;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 0;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 0;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 0 , 0 / TAPEDESCR ] TEXT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // assign expression to variable TAPEDESCR
  var_TAPEDESCR_0d_string_Scalar = cpp_line.substr(0, 66);
  aux_TAPEDESCR_read = true;
  validate_vartype_consistency("TAPEDESCR", SCALAR_STRING, aux_last_type_read_for_TAPEDESCR);
  aux_last_type_read_for_TAPEDESCR = SCALAR_STRING;
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_TAPEDESCR == SCALAR_STRING) && (aux_TAPEDESCR_read == true))) {
    cpp_current_dict["TAPEDESCR"] = var_TAPEDESCR_0d_string_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 58de2de2b82537497333c5e7a5bc310c
// MD5 hash of the following function definition: 448287c7ae57c080616f4fb93081e047
py::dict parse_mf1mt451_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LRP_0d_int_Scalar;
  bool aux_LRP_read = false;
  vartype aux_last_type_read_for_LRP = UNKNOWN;
  int var_LFI_0d_int_Scalar;
  bool aux_LFI_read = false;
  vartype aux_last_type_read_for_LFI = UNKNOWN;
  int var_NLIB_0d_int_Scalar;
  bool aux_NLIB_read = false;
  vartype aux_last_type_read_for_NLIB = UNKNOWN;
  int var_NMOD_0d_int_Scalar;
  bool aux_NMOD_read = false;
  vartype aux_last_type_read_for_NMOD = UNKNOWN;
  double var_ELIS_0d_double_Scalar;
  bool aux_ELIS_read = false;
  vartype aux_last_type_read_for_ELIS = UNKNOWN;
  double var_STA_0d_double_Scalar;
  bool aux_STA_read = false;
  vartype aux_last_type_read_for_STA = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_LISO_0d_int_Scalar;
  bool aux_LISO_read = false;
  vartype aux_last_type_read_for_LISO = UNKNOWN;
  int var_NFOR_0d_int_Scalar;
  bool aux_NFOR_read = false;
  vartype aux_last_type_read_for_NFOR = UNKNOWN;
  double var_AWI_0d_double_Scalar;
  bool aux_AWI_read = false;
  vartype aux_last_type_read_for_AWI = UNKNOWN;
  double var_EMAX_0d_double_Scalar;
  bool aux_EMAX_read = false;
  vartype aux_last_type_read_for_EMAX = UNKNOWN;
  int var_LREL_0d_int_Scalar;
  bool aux_LREL_read = false;
  vartype aux_last_type_read_for_LREL = UNKNOWN;
  int var_NSUB_0d_int_Scalar;
  bool aux_NSUB_read = false;
  vartype aux_last_type_read_for_NSUB = UNKNOWN;
  int var_NVER_0d_int_Scalar;
  bool aux_NVER_read = false;
  vartype aux_last_type_read_for_NVER = UNKNOWN;
  double var_TEMP_0d_double_Scalar;
  bool aux_TEMP_read = false;
  vartype aux_last_type_read_for_TEMP = UNKNOWN;
  int var_LDRV_0d_int_Scalar;
  bool aux_LDRV_read = false;
  vartype aux_last_type_read_for_LDRV = UNKNOWN;
  int var_NWD_0d_int_Scalar;
  bool aux_NWD_read = false;
  vartype aux_last_type_read_for_NWD = UNKNOWN;
  int var_NXC_0d_int_Scalar;
  bool aux_NXC_read = false;
  vartype aux_last_type_read_for_NXC = UNKNOWN;
  std::string var_ZSYMAM_0d_string_Scalar;
  bool aux_ZSYMAM_read = false;
  vartype aux_last_type_read_for_ZSYMAM = UNKNOWN;
  std::string var_ALAB_0d_string_Scalar;
  bool aux_ALAB_read = false;
  vartype aux_last_type_read_for_ALAB = UNKNOWN;
  std::string var_EDATE_0d_string_Scalar;
  bool aux_EDATE_read = false;
  vartype aux_last_type_read_for_EDATE = UNKNOWN;
  std::string var_AUTH_0d_string_Scalar;
  bool aux_AUTH_read = false;
  vartype aux_last_type_read_for_AUTH = UNKNOWN;
  std::string var_REF_0d_string_Scalar;
  bool aux_REF_read = false;
  vartype aux_last_type_read_for_REF = UNKNOWN;
  std::string var_DDATE_0d_string_Scalar;
  bool aux_DDATE_read = false;
  vartype aux_last_type_read_for_DDATE = UNKNOWN;
  std::string var_RDATE_0d_string_Scalar;
  bool aux_RDATE_read = false;
  vartype aux_last_type_read_for_RDATE = UNKNOWN;
  std::string var_ENDATE_0d_string_Scalar;
  bool aux_ENDATE_read = false;
  vartype aux_last_type_read_for_ENDATE = UNKNOWN;
  NestedVector<std::string> var_HSUB_1d_string_NestedVector;
  vartype aux_last_type_read_for_HSUB = UNKNOWN;
  NestedVector<std::string> var_DESCRIPTION_1d_string_NestedVector;
  vartype aux_last_type_read_for_DESCRIPTION = UNKNOWN;
  NestedVector<int> var_MFx_1d_int_NestedVector;
  vartype aux_last_type_read_for_MFx = UNKNOWN;
  NestedVector<int> var_MTx_1d_int_NestedVector;
  vartype aux_last_type_read_for_MTx = UNKNOWN;
  NestedVector<int> var_NCx_1d_int_NestedVector;
  vartype aux_last_type_read_for_NCx = UNKNOWN;
  NestedVector<int> var_MOD_1d_int_NestedVector;
  vartype aux_last_type_read_for_MOD = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 1;
  int mt = 451;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 451;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 1 , 451 / ZA , AWR , LRP , LFI , NLIB , NMOD ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LRP
  var_LRP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LRP_read = true;
  validate_vartype_consistency("LRP", SCALAR_INT, aux_last_type_read_for_LRP);
  aux_last_type_read_for_LRP = SCALAR_INT;
  // assign expression to variable LFI
  var_LFI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LFI_read = true;
  validate_vartype_consistency("LFI", SCALAR_INT, aux_last_type_read_for_LFI);
  aux_last_type_read_for_LFI = SCALAR_INT;
  // assign expression to variable NLIB
  var_NLIB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NLIB_read = true;
  validate_vartype_consistency("NLIB", SCALAR_INT, aux_last_type_read_for_NLIB);
  aux_last_type_read_for_NLIB = SCALAR_INT;
  // assign expression to variable NMOD
  var_NMOD_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NMOD_read = true;
  validate_vartype_consistency("NMOD", SCALAR_INT, aux_last_type_read_for_NMOD);
  aux_last_type_read_for_NMOD = SCALAR_INT;
  cpp_template = "[ MAT , 1 , 451 / ELIS , STA , LIS , LISO , 0 , NFOR ] CONT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ELIS
  var_ELIS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ELIS_read = true;
  validate_vartype_consistency("ELIS", SCALAR_DOUBLE, aux_last_type_read_for_ELIS);
  aux_last_type_read_for_ELIS = SCALAR_DOUBLE;
  // assign expression to variable STA
  var_STA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_STA_read = true;
  validate_vartype_consistency("STA", SCALAR_DOUBLE, aux_last_type_read_for_STA);
  aux_last_type_read_for_STA = SCALAR_DOUBLE;
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  // assign expression to variable LISO
  var_LISO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LISO_read = true;
  validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
  aux_last_type_read_for_LISO = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NFOR
  var_NFOR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NFOR_read = true;
  validate_vartype_consistency("NFOR", SCALAR_INT, aux_last_type_read_for_NFOR);
  aux_last_type_read_for_NFOR = SCALAR_INT;
  cpp_template = "[ MAT , 1 , 451 / AWI , EMAX , LREL , 0 , NSUB , NVER ] CONT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable AWI
  var_AWI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_AWI_read = true;
  validate_vartype_consistency("AWI", SCALAR_DOUBLE, aux_last_type_read_for_AWI);
  aux_last_type_read_for_AWI = SCALAR_DOUBLE;
  // assign expression to variable EMAX
  var_EMAX_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_EMAX_read = true;
  validate_vartype_consistency("EMAX", SCALAR_DOUBLE, aux_last_type_read_for_EMAX);
  aux_last_type_read_for_EMAX = SCALAR_DOUBLE;
  // assign expression to variable LREL
  var_LREL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LREL_read = true;
  validate_vartype_consistency("LREL", SCALAR_INT, aux_last_type_read_for_LREL);
  aux_last_type_read_for_LREL = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NSUB
  var_NSUB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NSUB_read = true;
  validate_vartype_consistency("NSUB", SCALAR_INT, aux_last_type_read_for_NSUB);
  aux_last_type_read_for_NSUB = SCALAR_INT;
  // assign expression to variable NVER
  var_NVER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NVER_read = true;
  validate_vartype_consistency("NVER", SCALAR_INT, aux_last_type_read_for_NVER);
  aux_last_type_read_for_NVER = SCALAR_INT;
  cpp_template = "[ MAT , 1 , 451 / TEMP , 0.0 , LDRV , 0 , NWD , NXC ] CONT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable TEMP
  var_TEMP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_TEMP_read = true;
  validate_vartype_consistency("TEMP", SCALAR_DOUBLE, aux_last_type_read_for_TEMP);
  aux_last_type_read_for_TEMP = SCALAR_DOUBLE;
  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LDRV
  var_LDRV_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LDRV_read = true;
  validate_vartype_consistency("LDRV", SCALAR_INT, aux_last_type_read_for_LDRV);
  aux_last_type_read_for_LDRV = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NWD
  var_NWD_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NWD_read = true;
  validate_vartype_consistency("NWD", SCALAR_INT, aux_last_type_read_for_NWD);
  aux_last_type_read_for_NWD = SCALAR_INT;
  // assign expression to variable NXC
  var_NXC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NXC_read = true;
  validate_vartype_consistency("NXC", SCALAR_INT, aux_last_type_read_for_NXC);
  aux_last_type_read_for_NXC = SCALAR_INT;
  cpp_template = "[ MAT , 1 , 451 / ZSYMAM { 11 } , ALAB { 11 } , EDATE { 10 } , { 1 } , AUTH { 33 } ] TEXT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // assign expression to variable ZSYMAM
  var_ZSYMAM_0d_string_Scalar = cpp_line.substr(0, 11);
  aux_ZSYMAM_read = true;
  validate_vartype_consistency("ZSYMAM", SCALAR_STRING, aux_last_type_read_for_ZSYMAM);
  aux_last_type_read_for_ZSYMAM = SCALAR_STRING;
  // assign expression to variable ALAB
  var_ALAB_0d_string_Scalar = cpp_line.substr(11, 11);
  aux_ALAB_read = true;
  validate_vartype_consistency("ALAB", SCALAR_STRING, aux_last_type_read_for_ALAB);
  aux_last_type_read_for_ALAB = SCALAR_STRING;
  // assign expression to variable EDATE
  var_EDATE_0d_string_Scalar = cpp_line.substr(22, 10);
  aux_EDATE_read = true;
  validate_vartype_consistency("EDATE", SCALAR_STRING, aux_last_type_read_for_EDATE);
  aux_last_type_read_for_EDATE = SCALAR_STRING;
  // assign expression to variable AUTH
  var_AUTH_0d_string_Scalar = cpp_line.substr(33, 33);
  aux_AUTH_read = true;
  validate_vartype_consistency("AUTH", SCALAR_STRING, aux_last_type_read_for_AUTH);
  aux_last_type_read_for_AUTH = SCALAR_STRING;
  cpp_template = "[ MAT , 1 , 451 / { 1 } , REF { 21 } , DDATE { 10 } , { 1 } , \n RDATE { 10 } , { 12 } , ENDATE { 8 } , { 3 } ] TEXT";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // assign expression to variable REF
  var_REF_0d_string_Scalar = cpp_line.substr(1, 21);
  aux_REF_read = true;
  validate_vartype_consistency("REF", SCALAR_STRING, aux_last_type_read_for_REF);
  aux_last_type_read_for_REF = SCALAR_STRING;
  // assign expression to variable DDATE
  var_DDATE_0d_string_Scalar = cpp_line.substr(22, 10);
  aux_DDATE_read = true;
  validate_vartype_consistency("DDATE", SCALAR_STRING, aux_last_type_read_for_DDATE);
  aux_last_type_read_for_DDATE = SCALAR_STRING;
  // assign expression to variable RDATE
  var_RDATE_0d_string_Scalar = cpp_line.substr(33, 10);
  aux_RDATE_read = true;
  validate_vartype_consistency("RDATE", SCALAR_STRING, aux_last_type_read_for_RDATE);
  aux_last_type_read_for_RDATE = SCALAR_STRING;
  // assign expression to variable ENDATE
  var_ENDATE_0d_string_Scalar = cpp_line.substr(55, 8);
  aux_ENDATE_read = true;
  validate_vartype_consistency("ENDATE", SCALAR_STRING, aux_last_type_read_for_ENDATE);
  aux_last_type_read_for_ENDATE = SCALAR_STRING;

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= 3; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 1 , 451 / HSUB [ i ] ] TEXT";
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // assign expression to variable HSUB
    var_HSUB_1d_string_NestedVector.set(var_i_0d_int_Scalar, cpp_line.substr(0, 66));
    validate_vartype_consistency("HSUB", NESTEDVECTOR_STRING, aux_last_type_read_for_HSUB);
    aux_last_type_read_for_HSUB = NESTEDVECTOR_STRING;
  }

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= (var_NWD_0d_int_Scalar-5); var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 1 , 451 / DESCRIPTION [ i ] ] TEXT";
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // assign expression to variable DESCRIPTION
    var_DESCRIPTION_1d_string_NestedVector.set(var_i_0d_int_Scalar, cpp_line.substr(0, 66));
    validate_vartype_consistency("DESCRIPTION", NESTEDVECTOR_STRING, aux_last_type_read_for_DESCRIPTION);
    aux_last_type_read_for_DESCRIPTION = NESTEDVECTOR_STRING;
  }

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NXC_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 1 , 451 / blank , blank , MFx , MTx , NCx , MOD ] DIR";
    // read TEXT record
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // assign expression to variable MFx
    var_MFx_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
    validate_vartype_consistency("MFx", NESTEDVECTOR_INT, aux_last_type_read_for_MFx);
    aux_last_type_read_for_MFx = NESTEDVECTOR_INT;
    // assign expression to variable MTx
    var_MTx_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
    validate_vartype_consistency("MTx", NESTEDVECTOR_INT, aux_last_type_read_for_MTx);
    aux_last_type_read_for_MTx = NESTEDVECTOR_INT;
    // assign expression to variable NCx
    var_NCx_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
    validate_vartype_consistency("NCx", NESTEDVECTOR_INT, aux_last_type_read_for_NCx);
    aux_last_type_read_for_NCx = NESTEDVECTOR_INT;
    // assign expression to variable MOD
    var_MOD_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
    validate_vartype_consistency("MOD", NESTEDVECTOR_INT, aux_last_type_read_for_MOD);
    aux_last_type_read_for_MOD = NESTEDVECTOR_INT;
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LRP == SCALAR_INT) && (aux_LRP_read == true))) {
    cpp_current_dict["LRP"] = var_LRP_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LFI == SCALAR_INT) && (aux_LFI_read == true))) {
    cpp_current_dict["LFI"] = var_LFI_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NLIB == SCALAR_INT) && (aux_NLIB_read == true))) {
    cpp_current_dict["NLIB"] = var_NLIB_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NMOD == SCALAR_INT) && (aux_NMOD_read == true))) {
    cpp_current_dict["NMOD"] = var_NMOD_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ELIS == SCALAR_DOUBLE) && (aux_ELIS_read == true))) {
    cpp_current_dict["ELIS"] = var_ELIS_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_STA == SCALAR_DOUBLE) && (aux_STA_read == true))) {
    cpp_current_dict["STA"] = var_STA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LIS == SCALAR_INT) && (aux_LIS_read == true))) {
    cpp_current_dict["LIS"] = var_LIS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LISO == SCALAR_INT) && (aux_LISO_read == true))) {
    cpp_current_dict["LISO"] = var_LISO_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NFOR == SCALAR_INT) && (aux_NFOR_read == true))) {
    cpp_current_dict["NFOR"] = var_NFOR_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_AWI == SCALAR_DOUBLE) && (aux_AWI_read == true))) {
    cpp_current_dict["AWI"] = var_AWI_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_EMAX == SCALAR_DOUBLE) && (aux_EMAX_read == true))) {
    cpp_current_dict["EMAX"] = var_EMAX_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LREL == SCALAR_INT) && (aux_LREL_read == true))) {
    cpp_current_dict["LREL"] = var_LREL_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NSUB == SCALAR_INT) && (aux_NSUB_read == true))) {
    cpp_current_dict["NSUB"] = var_NSUB_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NVER == SCALAR_INT) && (aux_NVER_read == true))) {
    cpp_current_dict["NVER"] = var_NVER_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_TEMP == SCALAR_DOUBLE) && (aux_TEMP_read == true))) {
    cpp_current_dict["TEMP"] = var_TEMP_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LDRV == SCALAR_INT) && (aux_LDRV_read == true))) {
    cpp_current_dict["LDRV"] = var_LDRV_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NWD == SCALAR_INT) && (aux_NWD_read == true))) {
    cpp_current_dict["NWD"] = var_NWD_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NXC == SCALAR_INT) && (aux_NXC_read == true))) {
    cpp_current_dict["NXC"] = var_NXC_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZSYMAM == SCALAR_STRING) && (aux_ZSYMAM_read == true))) {
    cpp_current_dict["ZSYMAM"] = var_ZSYMAM_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_ALAB == SCALAR_STRING) && (aux_ALAB_read == true))) {
    cpp_current_dict["ALAB"] = var_ALAB_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_EDATE == SCALAR_STRING) && (aux_EDATE_read == true))) {
    cpp_current_dict["EDATE"] = var_EDATE_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_AUTH == SCALAR_STRING) && (aux_AUTH_read == true))) {
    cpp_current_dict["AUTH"] = var_AUTH_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_REF == SCALAR_STRING) && (aux_REF_read == true))) {
    cpp_current_dict["REF"] = var_REF_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_DDATE == SCALAR_STRING) && (aux_DDATE_read == true))) {
    cpp_current_dict["DDATE"] = var_DDATE_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_RDATE == SCALAR_STRING) && (aux_RDATE_read == true))) {
    cpp_current_dict["RDATE"] = var_RDATE_0d_string_Scalar;
  }
  if (((aux_last_type_read_for_ENDATE == SCALAR_STRING) && (aux_ENDATE_read == true))) {
    cpp_current_dict["ENDATE"] = var_ENDATE_0d_string_Scalar;
  }
  if ((var_HSUB_1d_string_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_HSUB_1d_string_NestedVector;
    cpp_current_dict["HSUB"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["HSUB"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_DESCRIPTION_1d_string_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_DESCRIPTION_1d_string_NestedVector;
    cpp_current_dict["DESCRIPTION"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["DESCRIPTION"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_MFx_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_MFx_1d_int_NestedVector;
    cpp_current_dict["MFx"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["MFx"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_MTx_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_MTx_1d_int_NestedVector;
    cpp_current_dict["MTx"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["MTx"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_NCx_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_NCx_1d_int_NestedVector;
    cpp_current_dict["NCx"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["NCx"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_MOD_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_MOD_1d_int_NestedVector;
    cpp_current_dict["MOD"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["MOD"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 714e5d90ebe6fa41e07bef414c2ac8f4
// MD5 hash of the following function definition: e5ef36394932c963be358cfe4ee84b9f
py::dict parse_mf1mt452_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LNU_0d_int_Scalar;
  bool aux_LNU_read = false;
  vartype aux_last_type_read_for_LNU = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  NestedVector<double> var_C_1d_double_NestedVector;
  vartype aux_last_type_read_for_C = UNKNOWN;
  std::vector<double> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<double> var_nu_0d_floatvec_Scalar;
  bool aux_nu_read = false;
  vartype aux_last_type_read_for_nu = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 1;
  int mt = 452;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 452;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 1 , 452 / ZA , AWR , 0 , LNU , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LNU
  var_LNU_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LNU_read = true;
  validate_vartype_consistency("LNU", SCALAR_INT, aux_last_type_read_for_LNU);
  aux_last_type_read_for_LNU = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 1 , 452 / 0.0 , 0.0 , 0 , 0 , NC , 0 / { C } { k = 1 to NC } ] LIST";
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        // read LIST record
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        // assign expression to variable NC
        var_NC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        aux_NC_read = true;
        validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
        aux_last_type_read_for_NC = SCALAR_INT;
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        {
          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          int cpp_i = 0;
          int cpp_j = 0;
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST body

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NC_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // read LIST body
            // assign expression to variable C
            var_C_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
            validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
            aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
          }
          if (cpp_i != cpp_npl) {
            throw std::runtime_error("not exactly NPL elements consumed");
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 452 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nu ] TAB1";
          // read TAB1 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          {
            Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Eint
            var_Eint_0d_floatvec_Scalar = tab_body.X;
            aux_Eint_read = true;
            validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
            aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
            // assign expression to variable nu
            var_nu_0d_floatvec_Scalar = tab_body.Y;
            aux_nu_read = true;
            validate_vartype_consistency("nu", SCALAR_FLOATVEC, aux_last_type_read_for_nu);
            aux_last_type_read_for_nu = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LNU == SCALAR_INT) && (aux_LNU_read == true))) {
    cpp_current_dict["LNU"] = var_LNU_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
    cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
  }
  if ((var_C_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_C_1d_double_NestedVector;
    cpp_current_dict["C"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["C"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
    cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_nu == SCALAR_FLOATVEC) && (aux_nu_read == true))) {
    cpp_current_dict["nu"] = var_nu_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 6372082f09eb7576770b456ddd80b3fb
// MD5 hash of the following function definition: 308993d5485d99400b8713d3a1a1d85c
py::dict parse_mf1mt455_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LDG_0d_int_Scalar;
  bool aux_LDG_read = false;
  vartype aux_last_type_read_for_LDG = UNKNOWN;
  int var_LNU_0d_int_Scalar;
  bool aux_LNU_read = false;
  vartype aux_last_type_read_for_LNU = UNKNOWN;
  int var_NNF_0d_int_Scalar;
  bool aux_NNF_read = false;
  vartype aux_last_type_read_for_NNF = UNKNOWN;
  NestedVector<double> var_lambda_1d_double_NestedVector;
  vartype aux_last_type_read_for_lambda = UNKNOWN;
  std::vector<double> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<double> var_nubar_d_0d_floatvec_Scalar;
  double var_nubar_d_0d_double_Scalar;
  bool aux_nubar_d_read = false;
  vartype aux_last_type_read_for_nubar_d = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int var_NE_0d_int_Scalar;
  bool aux_NE_read = false;
  vartype aux_last_type_read_for_NE = UNKNOWN;
  NestedVector<double> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<NestedVector<double>> var_lambda_2d_double_NestedVector;
  NestedVector<double>* ptr_lambda_2d_idx0;
  NestedVector<NestedVector<double>> var_alpha_2d_double_NestedVector;
  NestedVector<double>* ptr_alpha_2d_idx0;
  vartype aux_last_type_read_for_alpha = UNKNOWN;
  double var_E1_0d_double_Scalar;
  bool aux_E1_read = false;
  vartype aux_last_type_read_for_E1 = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  NestedVector<double> var_nubar_d_1d_double_NestedVector;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 1;
  int mt = 455;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 455;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 1 , 455 / ZA , AWR , LDG , LNU , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LDG
  var_LDG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LDG_read = true;
  validate_vartype_consistency("LDG", SCALAR_INT, aux_last_type_read_for_LDG);
  aux_last_type_read_for_LDG = SCALAR_INT;
  // assign expression to variable LNU
  var_LNU_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LNU_read = true;
  validate_vartype_consistency("LNU", SCALAR_INT, aux_last_type_read_for_LNU);
  aux_last_type_read_for_LNU = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(0)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NNF , 0 / \n { lambda } { k = 1 to NNF } ] LIST";
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        // read LIST record
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        // assign expression to variable NNF
        var_NNF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        aux_NNF_read = true;
        validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
        aux_last_type_read_for_NNF = SCALAR_INT;
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        {
          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          int cpp_i = 0;
          int cpp_j = 0;
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST body

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // read LIST body
            // assign expression to variable lambda
            var_lambda_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
            validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
            aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
          }
          if (cpp_i != cpp_npl) {
            throw std::runtime_error("not exactly NPL elements consumed");
          }
        }
        cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nubar_d ] TAB1";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
        {
          Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
          // assign expression to variable Eint
          var_Eint_0d_floatvec_Scalar = tab_body.X;
          aux_Eint_read = true;
          validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
          aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
          // assign expression to variable nubar_d
          var_nubar_d_0d_floatvec_Scalar = tab_body.Y;
          aux_nubar_d_read = true;
          validate_vartype_consistency("nubar_d", SCALAR_FLOATVEC, aux_last_type_read_for_nubar_d);
          aux_last_type_read_for_nubar_d = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(1)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
          // read TAB2 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NE
          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NE_read = true;
          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
          aux_last_type_read_for_NE = SCALAR_INT;
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          {
            Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            cpp_template = "[ MAT , 1 , 455 / 0.0 , E , 0 , 0 , (NNF*2) , 0 / \n { lambda , alpha } { l = 1 to NNF } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable cpp_int_val
            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_cpp_int_val_read = true;
            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
            // assign expression to variable NNF
            var_NNF_0d_int_Scalar = (cpp_int_val/2);
            aux_NNF_read = true;
            validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
            aux_last_type_read_for_NNF = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body
              ptr_lambda_2d_idx0 = var_lambda_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
              ptr_alpha_2d_idx0 = var_alpha_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                // read LIST body
                // assign expression to variable lambda
                ptr_lambda_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
                aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable alpha
                ptr_alpha_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("alpha", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_alpha);
                aux_last_type_read_for_alpha = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
          }
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nubar_d ] TAB1";
          // read TAB1 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          {
            Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Eint
            var_Eint_0d_floatvec_Scalar = tab_body.X;
            aux_Eint_read = true;
            validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
            aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
            // assign expression to variable nubar_d
            var_nubar_d_0d_floatvec_Scalar = tab_body.Y;
            aux_nubar_d_read = true;
            validate_vartype_consistency("nubar_d", SCALAR_FLOATVEC, aux_last_type_read_for_nubar_d);
            aux_last_type_read_for_nubar_d = SCALAR_FLOATVEC;
            if ((! (aux_INT_read == true))) {
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
            } else {
              cpp_validate_field(var_INT_0d_intvec_Scalar, tab_body.INT,  true, false, false, "INT",
                cpp_template, cpp_line, parse_opts);
            }
            if ((! (aux_NBT_read == true))) {
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            } else {
              cpp_validate_field(var_NBT_0d_intvec_Scalar, tab_body.NBT,  true, false, false, "NBT",
                cpp_template, cpp_line, parse_opts);
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(0)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NNF , 0 / { lambda } { k = 1 to NNF } ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NNF
          var_NNF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NNF_read = true;
          validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
          aux_last_type_read_for_NNF = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              // assign expression to variable lambda
              var_lambda_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
              aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , 1 , 0 / nubar_d ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(1, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "1",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body
            // assign expression to variable nubar_d
            var_nubar_d_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_nubar_d_read = true;
            validate_vartype_consistency("nubar_d", SCALAR_DOUBLE, aux_last_type_read_for_nubar_d);
            aux_last_type_read_for_nubar_d = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(1)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
          // read TAB2 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NE
          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NE_read = true;
          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
          aux_last_type_read_for_NE = SCALAR_INT;
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          {
            Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            cpp_template = "[ MAT , 1 , 455 / 0.0 , E1 , 0 , 0 , (NNF*2) , 0 / \n { lambda , alpha } { l = 1 to NNF } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable E1
            var_E1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_E1_read = true;
            validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
            aux_last_type_read_for_E1 = SCALAR_DOUBLE;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable cpp_int_val
            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_cpp_int_val_read = true;
            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
            // assign expression to variable NNF
            var_NNF_0d_int_Scalar = (cpp_int_val/2);
            aux_NNF_read = true;
            validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
            aux_last_type_read_for_NNF = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body
              ptr_lambda_2d_idx0 = var_lambda_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
              ptr_alpha_2d_idx0 = var_alpha_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                // read LIST body
                // assign expression to variable lambda
                ptr_lambda_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
                aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable alpha
                ptr_alpha_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("alpha", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_alpha);
                aux_last_type_read_for_alpha = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
          }
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NC , 0 / { nubar_d } { k = 1 to NC } ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NC
          var_NC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NC_read = true;
          validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
          aux_last_type_read_for_NC = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NC_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              // assign expression to variable nubar_d
              var_nubar_d_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("nubar_d", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_nubar_d);
              aux_last_type_read_for_nubar_d = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LDG == SCALAR_INT) && (aux_LDG_read == true))) {
    cpp_current_dict["LDG"] = var_LDG_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LNU == SCALAR_INT) && (aux_LNU_read == true))) {
    cpp_current_dict["LNU"] = var_LNU_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NNF == SCALAR_INT) && (aux_NNF_read == true))) {
    cpp_current_dict["NNF"] = var_NNF_0d_int_Scalar;
  }
  if ((var_lambda_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_lambda_1d_double_NestedVector;
    cpp_current_dict["lambda"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["lambda"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
    cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_nubar_d == SCALAR_FLOATVEC) && (aux_nubar_d_read == true))) {
    cpp_current_dict["nubar_d"] = var_nubar_d_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_nubar_d == SCALAR_DOUBLE) && (aux_nubar_d_read == true))) {
    cpp_current_dict["nubar_d"] = var_nubar_d_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
    cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
  }
  if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_E_1d_double_NestedVector;
    cpp_current_dict["E"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["E"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_lambda_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_lambda_2d_double_NestedVector;
    cpp_current_dict["lambda"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["lambda"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_alpha_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_alpha_2d_double_NestedVector;
    cpp_current_dict["alpha"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["alpha"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if (((aux_last_type_read_for_E1 == SCALAR_DOUBLE) && (aux_E1_read == true))) {
    cpp_current_dict["E1"] = var_E1_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
    cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
  }
  if ((var_nubar_d_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_nubar_d_1d_double_NestedVector;
    cpp_current_dict["nubar_d"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["nubar_d"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: dc95e75784d9f676b28daf84959ecfb2
// MD5 hash of the following function definition: 881453a4a14dad50238146a63bdb56b6
py::dict parse_mf1mt456_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LNU_0d_int_Scalar;
  bool aux_LNU_read = false;
  vartype aux_last_type_read_for_LNU = UNKNOWN;
  std::vector<double> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<double> var_nubar_p_0d_floatvec_Scalar;
  double var_nubar_p_0d_double_Scalar;
  bool aux_nubar_p_read = false;
  vartype aux_last_type_read_for_nubar_p = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 1;
  int mt = 456;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 456;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 1 , 456 / ZA , AWR , 0 , LNU , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LNU
  var_LNU_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LNU_read = true;
  validate_vartype_consistency("LNU", SCALAR_INT, aux_last_type_read_for_LNU);
  aux_last_type_read_for_LNU = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 1 , 456 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nubar_p ] TAB1";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
        {
          Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
          // assign expression to variable Eint
          var_Eint_0d_floatvec_Scalar = tab_body.X;
          aux_Eint_read = true;
          validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
          aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
          // assign expression to variable nubar_p
          var_nubar_p_0d_floatvec_Scalar = tab_body.Y;
          aux_nubar_p_read = true;
          validate_vartype_consistency("nubar_p", SCALAR_FLOATVEC, aux_last_type_read_for_nubar_p);
          aux_last_type_read_for_nubar_p = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 456 / 0.0 , 0.0 , 0 , 0 , 1 , 0 / nubar_p ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(1, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "1",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body
            // assign expression to variable nubar_p
            var_nubar_p_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_nubar_p_read = true;
            validate_vartype_consistency("nubar_p", SCALAR_DOUBLE, aux_last_type_read_for_nubar_p);
            aux_last_type_read_for_nubar_p = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LNU == SCALAR_INT) && (aux_LNU_read == true))) {
    cpp_current_dict["LNU"] = var_LNU_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
    cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_nubar_p == SCALAR_FLOATVEC) && (aux_nubar_p_read == true))) {
    cpp_current_dict["nubar_p"] = var_nubar_p_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_nubar_p == SCALAR_DOUBLE) && (aux_nubar_p_read == true))) {
    cpp_current_dict["nubar_p"] = var_nubar_p_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 5b7d22a0815ff99a2cbd6db8a6ad59a3
// MD5 hash of the following function definition: e85750dfe62ba42debdfd1ad254ea739
py::dict parse_mf1mt458_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LFC_0d_int_Scalar;
  bool aux_LFC_read = false;
  vartype aux_last_type_read_for_LFC = UNKNOWN;
  int var_NPLY_0d_int_Scalar;
  bool aux_NPLY_read = false;
  vartype aux_last_type_read_for_NPLY = UNKNOWN;
  double var_EFR_0d_double_Scalar;
  bool aux_EFR_read = false;
  vartype aux_last_type_read_for_EFR = UNKNOWN;
  double var_dEFR_0d_double_Scalar;
  bool aux_dEFR_read = false;
  vartype aux_last_type_read_for_dEFR = UNKNOWN;
  double var_ENP_0d_double_Scalar;
  bool aux_ENP_read = false;
  vartype aux_last_type_read_for_ENP = UNKNOWN;
  double var_dENP_0d_double_Scalar;
  bool aux_dENP_read = false;
  vartype aux_last_type_read_for_dENP = UNKNOWN;
  double var_END_0d_double_Scalar;
  bool aux_END_read = false;
  vartype aux_last_type_read_for_END = UNKNOWN;
  double var_dEND_0d_double_Scalar;
  bool aux_dEND_read = false;
  vartype aux_last_type_read_for_dEND = UNKNOWN;
  double var_EGP_0d_double_Scalar;
  bool aux_EGP_read = false;
  vartype aux_last_type_read_for_EGP = UNKNOWN;
  double var_dEGP_0d_double_Scalar;
  bool aux_dEGP_read = false;
  vartype aux_last_type_read_for_dEGP = UNKNOWN;
  double var_EGD_0d_double_Scalar;
  bool aux_EGD_read = false;
  vartype aux_last_type_read_for_EGD = UNKNOWN;
  double var_dEGD_0d_double_Scalar;
  bool aux_dEGD_read = false;
  vartype aux_last_type_read_for_dEGD = UNKNOWN;
  double var_EB_0d_double_Scalar;
  bool aux_EB_read = false;
  vartype aux_last_type_read_for_EB = UNKNOWN;
  double var_dEB_0d_double_Scalar;
  bool aux_dEB_read = false;
  vartype aux_last_type_read_for_dEB = UNKNOWN;
  double var_ENU_0d_double_Scalar;
  bool aux_ENU_read = false;
  vartype aux_last_type_read_for_ENU = UNKNOWN;
  double var_dENU_0d_double_Scalar;
  bool aux_dENU_read = false;
  vartype aux_last_type_read_for_dENU = UNKNOWN;
  double var_ER_0d_double_Scalar;
  bool aux_ER_read = false;
  vartype aux_last_type_read_for_ER = UNKNOWN;
  double var_dER_0d_double_Scalar;
  bool aux_dER_read = false;
  vartype aux_last_type_read_for_dER = UNKNOWN;
  double var_ET_0d_double_Scalar;
  bool aux_ET_read = false;
  vartype aux_last_type_read_for_ET = UNKNOWN;
  double var_dET_0d_double_Scalar;
  bool aux_dET_read = false;
  vartype aux_last_type_read_for_dET = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<double> var_c_EFR_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EFR = UNKNOWN;
  NestedVector<double> var_dc_EFR_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EFR = UNKNOWN;
  NestedVector<double> var_c_ENP_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ENP = UNKNOWN;
  NestedVector<double> var_dc_ENP_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ENP = UNKNOWN;
  NestedVector<double> var_c_END_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_END = UNKNOWN;
  NestedVector<double> var_dc_END_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_END = UNKNOWN;
  NestedVector<double> var_c_EGP_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EGP = UNKNOWN;
  NestedVector<double> var_dc_EGP_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EGP = UNKNOWN;
  NestedVector<double> var_c_EGD_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EGD = UNKNOWN;
  NestedVector<double> var_dc_EGD_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EGD = UNKNOWN;
  NestedVector<double> var_c_EB_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EB = UNKNOWN;
  NestedVector<double> var_dc_EB_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EB = UNKNOWN;
  NestedVector<double> var_c_ENU_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ENU = UNKNOWN;
  NestedVector<double> var_dc_ENU_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ENU = UNKNOWN;
  NestedVector<double> var_c_ER_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ER = UNKNOWN;
  NestedVector<double> var_dc_ER_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ER = UNKNOWN;
  NestedVector<double> var_c_ET_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ET = UNKNOWN;
  NestedVector<double> var_dc_ET_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ET = UNKNOWN;
  int var_NFC_0d_int_Scalar;
  bool aux_NFC_read = false;
  vartype aux_last_type_read_for_NFC = UNKNOWN;
  NestedVector<int> var_LDRV_1d_int_NestedVector;
  vartype aux_last_type_read_for_LDRV = UNKNOWN;
  NestedVector<int> var_IFC_1d_int_NestedVector;
  vartype aux_last_type_read_for_IFC = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 1;
  int mt = 458;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 458;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        std::streampos cpp_old_streampos = cont.tellg();
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LFC_0d_int_Scalar = var_LFC_0d_int_Scalar;
          int var_LFC_0d_int_Scalar = glob_var_LFC_0d_int_Scalar;
          bool& glob_aux_LFC_read = aux_LFC_read;
          bool aux_LFC_read = glob_aux_LFC_read;
          vartype aux_last_type_read_for_LFC = UNKNOWN;
          int& glob_var_NPLY_0d_int_Scalar = var_NPLY_0d_int_Scalar;
          int var_NPLY_0d_int_Scalar = glob_var_NPLY_0d_int_Scalar;
          bool& glob_aux_NPLY_read = aux_NPLY_read;
          bool aux_NPLY_read = glob_aux_NPLY_read;
          vartype aux_last_type_read_for_NPLY = UNKNOWN;
          cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
          cpp_line = cpp_read_raw_line(cont);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LFC
          var_LFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_LFC_read = true;
          validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
          aux_last_type_read_for_LFC = SCALAR_INT;
          cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
          cpp_line = cpp_read_raw_line(cont);
          // read LIST record
          // assign expression to variable NPLY
          var_NPLY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_NPLY_read = true;
          validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
          aux_last_type_read_for_NPLY = SCALAR_INT;
          if (((((((((aux_LFC_read == true)) && ((var_LFC_0d_int_Scalar)==(0)))))&&((((aux_NPLY_read == true)) && ((var_NPLY_0d_int_Scalar)==(0)))))))) {
            cpp_found_match = true;
          }
          cont.seekg(cpp_old_streampos);
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable LFC
          var_LFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_LFC_read = true;
          validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
          aux_last_type_read_for_LFC = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NPLY
          var_NPLY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_NPLY_read = true;
          validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
          aux_last_type_read_for_NPLY = SCALAR_INT;
          cpp_validate_field(18, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "18",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(9, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "9",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body
            // assign expression to variable EFR
            var_EFR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_EFR_read = true;
            validate_vartype_consistency("EFR", SCALAR_DOUBLE, aux_last_type_read_for_EFR);
            aux_last_type_read_for_EFR = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dEFR
            var_dEFR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dEFR_read = true;
            validate_vartype_consistency("dEFR", SCALAR_DOUBLE, aux_last_type_read_for_dEFR);
            aux_last_type_read_for_dEFR = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable ENP
            var_ENP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_ENP_read = true;
            validate_vartype_consistency("ENP", SCALAR_DOUBLE, aux_last_type_read_for_ENP);
            aux_last_type_read_for_ENP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dENP
            var_dENP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dENP_read = true;
            validate_vartype_consistency("dENP", SCALAR_DOUBLE, aux_last_type_read_for_dENP);
            aux_last_type_read_for_dENP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable END
            var_END_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_END_read = true;
            validate_vartype_consistency("END", SCALAR_DOUBLE, aux_last_type_read_for_END);
            aux_last_type_read_for_END = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dEND
            var_dEND_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dEND_read = true;
            validate_vartype_consistency("dEND", SCALAR_DOUBLE, aux_last_type_read_for_dEND);
            aux_last_type_read_for_dEND = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable EGP
            var_EGP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_EGP_read = true;
            validate_vartype_consistency("EGP", SCALAR_DOUBLE, aux_last_type_read_for_EGP);
            aux_last_type_read_for_EGP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dEGP
            var_dEGP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dEGP_read = true;
            validate_vartype_consistency("dEGP", SCALAR_DOUBLE, aux_last_type_read_for_dEGP);
            aux_last_type_read_for_dEGP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable EGD
            var_EGD_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_EGD_read = true;
            validate_vartype_consistency("EGD", SCALAR_DOUBLE, aux_last_type_read_for_EGD);
            aux_last_type_read_for_EGD = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dEGD
            var_dEGD_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dEGD_read = true;
            validate_vartype_consistency("dEGD", SCALAR_DOUBLE, aux_last_type_read_for_dEGD);
            aux_last_type_read_for_dEGD = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable EB
            var_EB_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_EB_read = true;
            validate_vartype_consistency("EB", SCALAR_DOUBLE, aux_last_type_read_for_EB);
            aux_last_type_read_for_EB = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dEB
            var_dEB_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dEB_read = true;
            validate_vartype_consistency("dEB", SCALAR_DOUBLE, aux_last_type_read_for_dEB);
            aux_last_type_read_for_dEB = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable ENU
            var_ENU_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_ENU_read = true;
            validate_vartype_consistency("ENU", SCALAR_DOUBLE, aux_last_type_read_for_ENU);
            aux_last_type_read_for_ENU = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dENU
            var_dENU_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dENU_read = true;
            validate_vartype_consistency("dENU", SCALAR_DOUBLE, aux_last_type_read_for_dENU);
            aux_last_type_read_for_dENU = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable ER
            var_ER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_ER_read = true;
            validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
            aux_last_type_read_for_ER = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dER
            var_dER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dER_read = true;
            validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
            aux_last_type_read_for_dER = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable ET
            var_ET_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_ET_read = true;
            validate_vartype_consistency("ET", SCALAR_DOUBLE, aux_last_type_read_for_ET);
            aux_last_type_read_for_ET = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            // assign expression to variable dET
            var_dET_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
            aux_dET_read = true;
            validate_vartype_consistency("dET", SCALAR_DOUBLE, aux_last_type_read_for_dET);
            aux_last_type_read_for_dET = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_j = 0;
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LFC_0d_int_Scalar = var_LFC_0d_int_Scalar;
            int var_LFC_0d_int_Scalar = glob_var_LFC_0d_int_Scalar;
            bool& glob_aux_LFC_read = aux_LFC_read;
            bool aux_LFC_read = glob_aux_LFC_read;
            vartype aux_last_type_read_for_LFC = UNKNOWN;
            int& glob_var_NPLY_0d_int_Scalar = var_NPLY_0d_int_Scalar;
            int var_NPLY_0d_int_Scalar = glob_var_NPLY_0d_int_Scalar;
            bool& glob_aux_NPLY_read = aux_NPLY_read;
            bool aux_NPLY_read = glob_aux_NPLY_read;
            vartype aux_last_type_read_for_NPLY = UNKNOWN;
            int& glob_cpp_int_val = cpp_int_val;
            int cpp_int_val = glob_cpp_int_val;
            bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
            bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
            cpp_line = cpp_read_raw_line(cont);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , (18*(NPLY+1)) , (9*(NPLY+1)) / \n { c_EFR , dc_EFR , c_ENP , dc_ENP , c_END , dc_END , \n c_EGP , dc_EGP , c_EGD , dc_EGD , c_EB , dc_EB , \n c_ENU , dc_ENU , c_ER , dc_ER , c_ET , dc_ET } { k = 0 to NPLY } ] LIST";
            cpp_line = cpp_read_raw_line(cont);
            // read LIST record
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
            if ((! (aux_NPLY_read == true))) {
              // assign expression to variable cpp_int_val
              cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = ((cpp_int_val+(-18))/18);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } else {
            }
            if ((! (aux_NPLY_read == true))) {
              // assign expression to variable cpp_int_val
              cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = ((cpp_int_val+(-9))/9);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } else {
            }
            if (((((((((aux_LFC_read == true)) && ((var_LFC_0d_int_Scalar)==(0)))))&&((((aux_NPLY_read == true)) && ((var_NPLY_0d_int_Scalar)>(0)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , (18*(NPLY+1)) , (9*(NPLY+1)) / \n { c_EFR , dc_EFR , c_ENP , dc_ENP , c_END , dc_END , \n c_EGP , dc_EGP , c_EGD , dc_EGD , c_EB , dc_EB , \n c_ENU , dc_ENU , c_ER , dc_ER , c_ET , dc_ET } { k = 0 to NPLY } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
            if ((! (aux_NPLY_read == true))) {
              // assign expression to variable cpp_int_val
              cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = ((cpp_int_val+(-18))/18);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } else {
              cpp_validate_field((18*(var_NPLY_0d_int_Scalar+1)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(18*(NPLY+1))",
                cpp_template, cpp_line, parse_opts);
            }
            if ((! (aux_NPLY_read == true))) {
              // assign expression to variable cpp_int_val
              cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = ((cpp_int_val+(-9))/9);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } else {
              cpp_validate_field((9*(var_NPLY_0d_int_Scalar+1)), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "(9*(NPLY+1))",
                cpp_template, cpp_line, parse_opts);
            }
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body

              for (int var_k_0d_int_Scalar = 0;
                 var_k_0d_int_Scalar <= var_NPLY_0d_int_Scalar; var_k_0d_int_Scalar++) {
                bool aux_k_read = true;
                // read LIST body
                // assign expression to variable c_EFR
                var_c_EFR_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_EFR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EFR);
                aux_last_type_read_for_c_EFR = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_EFR
                var_dc_EFR_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_EFR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EFR);
                aux_last_type_read_for_dc_EFR = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_ENP
                var_c_ENP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_ENP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ENP);
                aux_last_type_read_for_c_ENP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_ENP
                var_dc_ENP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_ENP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ENP);
                aux_last_type_read_for_dc_ENP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_END
                var_c_END_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_END", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_END);
                aux_last_type_read_for_c_END = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_END
                var_dc_END_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_END", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_END);
                aux_last_type_read_for_dc_END = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_EGP
                var_c_EGP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_EGP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EGP);
                aux_last_type_read_for_c_EGP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_EGP
                var_dc_EGP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_EGP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EGP);
                aux_last_type_read_for_dc_EGP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_EGD
                var_c_EGD_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_EGD", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EGD);
                aux_last_type_read_for_c_EGD = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_EGD
                var_dc_EGD_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_EGD", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EGD);
                aux_last_type_read_for_dc_EGD = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_EB
                var_c_EB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_EB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EB);
                aux_last_type_read_for_c_EB = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_EB
                var_dc_EB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_EB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EB);
                aux_last_type_read_for_dc_EB = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_ENU
                var_c_ENU_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_ENU", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ENU);
                aux_last_type_read_for_c_ENU = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_ENU
                var_dc_ENU_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_ENU", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ENU);
                aux_last_type_read_for_dc_ENU = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_ER
                var_c_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ER);
                aux_last_type_read_for_c_ER = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_ER
                var_dc_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ER);
                aux_last_type_read_for_dc_ER = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable c_ET
                var_c_ET_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("c_ET", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ET);
                aux_last_type_read_for_c_ET = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dc_ET
                var_dc_ET_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("dc_ET", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ET);
                aux_last_type_read_for_dc_ET = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LFC_0d_int_Scalar = var_LFC_0d_int_Scalar;
            int var_LFC_0d_int_Scalar = glob_var_LFC_0d_int_Scalar;
            bool& glob_aux_LFC_read = aux_LFC_read;
            bool aux_LFC_read = glob_aux_LFC_read;
            vartype aux_last_type_read_for_LFC = UNKNOWN;
            int& glob_var_NFC_0d_int_Scalar = var_NFC_0d_int_Scalar;
            int var_NFC_0d_int_Scalar = glob_var_NFC_0d_int_Scalar;
            bool& glob_aux_NFC_read = aux_NFC_read;
            bool aux_NFC_read = glob_aux_NFC_read;
            vartype aux_last_type_read_for_NFC = UNKNOWN;
            int& glob_var_NPLY_0d_int_Scalar = var_NPLY_0d_int_Scalar;
            int var_NPLY_0d_int_Scalar = glob_var_NPLY_0d_int_Scalar;
            bool& glob_aux_NPLY_read = aux_NPLY_read;
            bool aux_NPLY_read = glob_aux_NPLY_read;
            vartype aux_last_type_read_for_NPLY = UNKNOWN;
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , NFC ] HEAD";
            cpp_line = cpp_read_raw_line(cont);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            // assign expression to variable NFC
            var_NFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NFC_read = true;
            validate_vartype_consistency("NFC", SCALAR_INT, aux_last_type_read_for_NFC);
            aux_last_type_read_for_NFC = SCALAR_INT;
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
            cpp_line = cpp_read_raw_line(cont);
            // read LIST record
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
            if (((((((((aux_LFC_read == true)) && ((var_LFC_0d_int_Scalar)==(1)))))&&((((aux_NPLY_read == true)) && ((var_NPLY_0d_int_Scalar)==(0)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , NFC ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable NFC
            var_NFC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NFC_read = true;
            validate_vartype_consistency("NFC", SCALAR_INT, aux_last_type_read_for_NFC);
            aux_last_type_read_for_NFC = SCALAR_INT;
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
            cpp_validate_field(18, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "18",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(9, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "9",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body
              // assign expression to variable EFR
              var_EFR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_EFR_read = true;
              validate_vartype_consistency("EFR", SCALAR_DOUBLE, aux_last_type_read_for_EFR);
              aux_last_type_read_for_EFR = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dEFR
              var_dEFR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dEFR_read = true;
              validate_vartype_consistency("dEFR", SCALAR_DOUBLE, aux_last_type_read_for_dEFR);
              aux_last_type_read_for_dEFR = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable ENP
              var_ENP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_ENP_read = true;
              validate_vartype_consistency("ENP", SCALAR_DOUBLE, aux_last_type_read_for_ENP);
              aux_last_type_read_for_ENP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dENP
              var_dENP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dENP_read = true;
              validate_vartype_consistency("dENP", SCALAR_DOUBLE, aux_last_type_read_for_dENP);
              aux_last_type_read_for_dENP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable END
              var_END_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_END_read = true;
              validate_vartype_consistency("END", SCALAR_DOUBLE, aux_last_type_read_for_END);
              aux_last_type_read_for_END = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dEND
              var_dEND_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dEND_read = true;
              validate_vartype_consistency("dEND", SCALAR_DOUBLE, aux_last_type_read_for_dEND);
              aux_last_type_read_for_dEND = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable EGP
              var_EGP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_EGP_read = true;
              validate_vartype_consistency("EGP", SCALAR_DOUBLE, aux_last_type_read_for_EGP);
              aux_last_type_read_for_EGP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dEGP
              var_dEGP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dEGP_read = true;
              validate_vartype_consistency("dEGP", SCALAR_DOUBLE, aux_last_type_read_for_dEGP);
              aux_last_type_read_for_dEGP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable EGD
              var_EGD_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_EGD_read = true;
              validate_vartype_consistency("EGD", SCALAR_DOUBLE, aux_last_type_read_for_EGD);
              aux_last_type_read_for_EGD = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dEGD
              var_dEGD_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dEGD_read = true;
              validate_vartype_consistency("dEGD", SCALAR_DOUBLE, aux_last_type_read_for_dEGD);
              aux_last_type_read_for_dEGD = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable EB
              var_EB_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_EB_read = true;
              validate_vartype_consistency("EB", SCALAR_DOUBLE, aux_last_type_read_for_EB);
              aux_last_type_read_for_EB = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dEB
              var_dEB_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dEB_read = true;
              validate_vartype_consistency("dEB", SCALAR_DOUBLE, aux_last_type_read_for_dEB);
              aux_last_type_read_for_dEB = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable ENU
              var_ENU_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_ENU_read = true;
              validate_vartype_consistency("ENU", SCALAR_DOUBLE, aux_last_type_read_for_ENU);
              aux_last_type_read_for_ENU = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dENU
              var_dENU_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dENU_read = true;
              validate_vartype_consistency("dENU", SCALAR_DOUBLE, aux_last_type_read_for_dENU);
              aux_last_type_read_for_dENU = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable ER
              var_ER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_ER_read = true;
              validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
              aux_last_type_read_for_ER = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dER
              var_dER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dER_read = true;
              validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
              aux_last_type_read_for_dER = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable ET
              var_ET_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_ET_read = true;
              validate_vartype_consistency("ET", SCALAR_DOUBLE, aux_last_type_read_for_ET);
              aux_last_type_read_for_ET = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dET
              var_dET_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
              aux_dET_read = true;
              validate_vartype_consistency("dET", SCALAR_DOUBLE, aux_last_type_read_for_dET);
              aux_last_type_read_for_dET = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NFC_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , LDRV , IFC , NR , NP / Eint / EIFC ] TAB1 ( fiscomp [ k ] )";
              // read TAB1 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable LDRV
              var_LDRV_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
              validate_vartype_consistency("LDRV", NESTEDVECTOR_INT, aux_last_type_read_for_LDRV);
              aux_last_type_read_for_LDRV = NESTEDVECTOR_INT;
              // assign expression to variable IFC
              var_IFC_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
              validate_vartype_consistency("IFC", NESTEDVECTOR_INT, aux_last_type_read_for_IFC);
              aux_last_type_read_for_IFC = NESTEDVECTOR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                if ((! cpp_parent_dict.contains("fiscomp"))) {
                  cpp_parent_dict["fiscomp"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict["fiscomp"];
                if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                  cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                }
                cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                // variable declarations
                std::vector<double> var_Eint_0d_floatvec_Scalar;
                bool aux_Eint_read = false;
                vartype aux_last_type_read_for_Eint = UNKNOWN;
                std::vector<double> var_EIFC_0d_floatvec_Scalar;
                bool aux_EIFC_read = false;
                vartype aux_last_type_read_for_EIFC = UNKNOWN;
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                  // assign expression to variable EIFC
                  var_EIFC_0d_floatvec_Scalar = tab_body.Y;
                  aux_EIFC_read = true;
                  validate_vartype_consistency("EIFC", SCALAR_FLOATVEC, aux_last_type_read_for_EIFC);
                  aux_last_type_read_for_EIFC = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
                  cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
                }
                if (((aux_last_type_read_for_EIFC == SCALAR_FLOATVEC) && (aux_EIFC_read == true))) {
                  cpp_current_dict["EIFC"] = var_EIFC_0d_floatvec_Scalar;
                }
                if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                  cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                }
                if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                  cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LFC == SCALAR_INT) && (aux_LFC_read == true))) {
    cpp_current_dict["LFC"] = var_LFC_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NPLY == SCALAR_INT) && (aux_NPLY_read == true))) {
    cpp_current_dict["NPLY"] = var_NPLY_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_EFR == SCALAR_DOUBLE) && (aux_EFR_read == true))) {
    cpp_current_dict["EFR"] = var_EFR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dEFR == SCALAR_DOUBLE) && (aux_dEFR_read == true))) {
    cpp_current_dict["dEFR"] = var_dEFR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_ENP == SCALAR_DOUBLE) && (aux_ENP_read == true))) {
    cpp_current_dict["ENP"] = var_ENP_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dENP == SCALAR_DOUBLE) && (aux_dENP_read == true))) {
    cpp_current_dict["dENP"] = var_dENP_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_END == SCALAR_DOUBLE) && (aux_END_read == true))) {
    cpp_current_dict["END"] = var_END_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dEND == SCALAR_DOUBLE) && (aux_dEND_read == true))) {
    cpp_current_dict["dEND"] = var_dEND_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_EGP == SCALAR_DOUBLE) && (aux_EGP_read == true))) {
    cpp_current_dict["EGP"] = var_EGP_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dEGP == SCALAR_DOUBLE) && (aux_dEGP_read == true))) {
    cpp_current_dict["dEGP"] = var_dEGP_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_EGD == SCALAR_DOUBLE) && (aux_EGD_read == true))) {
    cpp_current_dict["EGD"] = var_EGD_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dEGD == SCALAR_DOUBLE) && (aux_dEGD_read == true))) {
    cpp_current_dict["dEGD"] = var_dEGD_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_EB == SCALAR_DOUBLE) && (aux_EB_read == true))) {
    cpp_current_dict["EB"] = var_EB_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dEB == SCALAR_DOUBLE) && (aux_dEB_read == true))) {
    cpp_current_dict["dEB"] = var_dEB_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_ENU == SCALAR_DOUBLE) && (aux_ENU_read == true))) {
    cpp_current_dict["ENU"] = var_ENU_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dENU == SCALAR_DOUBLE) && (aux_dENU_read == true))) {
    cpp_current_dict["dENU"] = var_dENU_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_ER == SCALAR_DOUBLE) && (aux_ER_read == true))) {
    cpp_current_dict["ER"] = var_ER_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dER == SCALAR_DOUBLE) && (aux_dER_read == true))) {
    cpp_current_dict["dER"] = var_dER_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_ET == SCALAR_DOUBLE) && (aux_ET_read == true))) {
    cpp_current_dict["ET"] = var_ET_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dET == SCALAR_DOUBLE) && (aux_dET_read == true))) {
    cpp_current_dict["dET"] = var_dET_0d_double_Scalar;
  }
  if ((var_c_EFR_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_c_EFR_1d_double_NestedVector;
    cpp_current_dict["c_EFR"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["c_EFR"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_dc_EFR_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_dc_EFR_1d_double_NestedVector;
    cpp_current_dict["dc_EFR"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["dc_EFR"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_c_ENP_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_c_ENP_1d_double_NestedVector;
    cpp_current_dict["c_ENP"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["c_ENP"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_dc_ENP_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_dc_ENP_1d_double_NestedVector;
    cpp_current_dict["dc_ENP"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["dc_ENP"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_c_END_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_c_END_1d_double_NestedVector;
    cpp_current_dict["c_END"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["c_END"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_dc_END_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_dc_END_1d_double_NestedVector;
    cpp_current_dict["dc_END"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["dc_END"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_c_EGP_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_c_EGP_1d_double_NestedVector;
    cpp_current_dict["c_EGP"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["c_EGP"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_dc_EGP_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_dc_EGP_1d_double_NestedVector;
    cpp_current_dict["dc_EGP"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["dc_EGP"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_c_EGD_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_c_EGD_1d_double_NestedVector;
    cpp_current_dict["c_EGD"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["c_EGD"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_dc_EGD_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_dc_EGD_1d_double_NestedVector;
    cpp_current_dict["dc_EGD"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["dc_EGD"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_c_EB_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_c_EB_1d_double_NestedVector;
    cpp_current_dict["c_EB"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["c_EB"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_dc_EB_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_dc_EB_1d_double_NestedVector;
    cpp_current_dict["dc_EB"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["dc_EB"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_c_ENU_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_c_ENU_1d_double_NestedVector;
    cpp_current_dict["c_ENU"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["c_ENU"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_dc_ENU_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_dc_ENU_1d_double_NestedVector;
    cpp_current_dict["dc_ENU"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["dc_ENU"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_c_ER_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_c_ER_1d_double_NestedVector;
    cpp_current_dict["c_ER"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["c_ER"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_dc_ER_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_dc_ER_1d_double_NestedVector;
    cpp_current_dict["dc_ER"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["dc_ER"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_c_ET_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_c_ET_1d_double_NestedVector;
    cpp_current_dict["c_ET"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["c_ET"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_dc_ET_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_dc_ET_1d_double_NestedVector;
    cpp_current_dict["dc_ET"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["dc_ET"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if (((aux_last_type_read_for_NFC == SCALAR_INT) && (aux_NFC_read == true))) {
    cpp_current_dict["NFC"] = var_NFC_0d_int_Scalar;
  }
  if ((var_LDRV_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_LDRV_1d_int_NestedVector;
    cpp_current_dict["LDRV"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["LDRV"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_IFC_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_IFC_1d_int_NestedVector;
    cpp_current_dict["IFC"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["IFC"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 446edfca967a9a8a84a4dade6f54784f
// MD5 hash of the following function definition: df0cc8547868fe7c44cda1735e510c38
py::dict parse_mf1mt460_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LO_0d_int_Scalar;
  bool aux_LO_read = false;
  vartype aux_last_type_read_for_LO = UNKNOWN;
  int var_NG_0d_int_Scalar;
  bool aux_NG_read = false;
  vartype aux_last_type_read_for_NG = UNKNOWN;
  NestedVector<double> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<std::vector<double>> var_tint_1d_floatvec_NestedVector;
  vartype aux_last_type_read_for_tint = UNKNOWN;
  NestedVector<std::vector<double>> var_T_1d_floatvec_NestedVector;
  vartype aux_last_type_read_for_T = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int var_NNF_0d_int_Scalar;
  bool aux_NNF_read = false;
  vartype aux_last_type_read_for_NNF = UNKNOWN;
  NestedVector<double> var_lambda_1d_double_NestedVector;
  vartype aux_last_type_read_for_lambda = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 1;
  int mt = 460;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 460;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        std::streampos cpp_old_streampos = cont.tellg();
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
          int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
          bool& glob_aux_LO_read = aux_LO_read;
          bool aux_LO_read = glob_aux_LO_read;
          vartype aux_last_type_read_for_LO = UNKNOWN;
          int& glob_var_NG_0d_int_Scalar = var_NG_0d_int_Scalar;
          int var_NG_0d_int_Scalar = glob_var_NG_0d_int_Scalar;
          bool& glob_aux_NG_read = aux_NG_read;
          bool aux_NG_read = glob_aux_NG_read;
          vartype aux_last_type_read_for_NG = UNKNOWN;
          cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , NG , 0 ] HEAD";
          cpp_line = cpp_read_raw_line(cont);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LO
          var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LO_read = true;
          validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
          aux_last_type_read_for_LO = SCALAR_INT;
          // assign expression to variable NG
          var_NG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NG_read = true;
          validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
          aux_last_type_read_for_NG = SCALAR_INT;
          if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(1)))))))) {
            cpp_found_match = true;
          }
          cont.seekg(cpp_old_streampos);
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , NG , 0 ] HEAD";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LO
          var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LO_read = true;
          validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
          aux_last_type_read_for_LO = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NG
          var_NG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NG_read = true;
          validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
          aux_last_type_read_for_NG = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_NG_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 1 , 460 / E , 0.0 , i , 0 , NR , NP / tint [ i ] / T [ i ] ] TAB1";
            // read TAB1 record
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            if ((! (aux_i_read == true))) {
              // assign expression to variable i
            } else {
              cpp_validate_field(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "i",
                cpp_template, cpp_line, parse_opts);
            }
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            {
              Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
              // assign expression to variable tint
              var_tint_1d_floatvec_NestedVector.set(var_i_0d_int_Scalar, tab_body.X);
              validate_vartype_consistency("tint", NESTEDVECTOR_FLOATVEC, aux_last_type_read_for_tint);
              aux_last_type_read_for_tint = NESTEDVECTOR_FLOATVEC;
              // assign expression to variable T
              var_T_1d_floatvec_NestedVector.set(var_i_0d_int_Scalar, tab_body.Y);
              validate_vartype_consistency("T", NESTEDVECTOR_FLOATVEC, aux_last_type_read_for_T);
              aux_last_type_read_for_T = NESTEDVECTOR_FLOATVEC;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
            int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
            bool& glob_aux_LO_read = aux_LO_read;
            bool aux_LO_read = glob_aux_LO_read;
            vartype aux_last_type_read_for_LO = UNKNOWN;
            cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , 0 , 0 ] HEAD";
            cpp_line = cpp_read_raw_line(cont);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LO
            var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(2)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , 0 , 0 ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LO
            var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_template = "[ MAT , 1 , 460 / 0.0 , 0.0 , 0 , 0 , NNF , 0 / \n { lambda } { i = 1 to NNF } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable NNF
            var_NNF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NNF_read = true;
            validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
            aux_last_type_read_for_NNF = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body

              for (int var_i_0d_int_Scalar = 1;
                 var_i_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_i_0d_int_Scalar++) {
                bool aux_i_read = true;
                // read LIST body
                // assign expression to variable lambda
                var_lambda_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
                aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LO == SCALAR_INT) && (aux_LO_read == true))) {
    cpp_current_dict["LO"] = var_LO_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NG == SCALAR_INT) && (aux_NG_read == true))) {
    cpp_current_dict["NG"] = var_NG_0d_int_Scalar;
  }
  if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_E_1d_double_NestedVector;
    cpp_current_dict["E"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["E"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_tint_1d_floatvec_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_tint_1d_floatvec_NestedVector;
    cpp_current_dict["tint"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["tint"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_T_1d_floatvec_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_T_1d_floatvec_NestedVector;
    cpp_current_dict["T"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["T"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NNF == SCALAR_INT) && (aux_NNF_read == true))) {
    cpp_current_dict["NNF"] = var_NNF_0d_int_Scalar;
  }
  if ((var_lambda_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_lambda_1d_double_NestedVector;
    cpp_current_dict["lambda"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["lambda"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 2248296c1207eae0ffc6859b0c2eec26
// MD5 hash of the following function definition: 7f63e883005f460bfdc19f50014e05a7
py::dict parse_mf2mt151_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NIS_0d_int_Scalar;
  bool aux_NIS_read = false;
  vartype aux_last_type_read_for_NIS = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 2;
  int mt = 151;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 2;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 151;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 2 , 151 / ZA , AWR , 0 , 0 , NIS , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NIS
  var_NIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NIS_read = true;
  validate_vartype_consistency("NIS", SCALAR_INT, aux_last_type_read_for_NIS);
  aux_last_type_read_for_NIS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NIS_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    // open section isotope
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      if ((! cpp_parent_dict.contains("isotope"))) {
        cpp_parent_dict["isotope"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict["isotope"];
      if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
      // variable declarations
      double var_ZAI_0d_double_Scalar;
      bool aux_ZAI_read = false;
      vartype aux_last_type_read_for_ZAI = UNKNOWN;
      double var_ABN_0d_double_Scalar;
      bool aux_ABN_read = false;
      vartype aux_last_type_read_for_ABN = UNKNOWN;
      int var_LFW_0d_int_Scalar;
      bool aux_LFW_read = false;
      vartype aux_last_type_read_for_LFW = UNKNOWN;
      int var_NER_0d_int_Scalar;
      bool aux_NER_read = false;
      vartype aux_last_type_read_for_NER = UNKNOWN;
      cpp_template = "[ MAT , 2 , 151 / ZAI , ABN , 0 , LFW , NER , 0 ] CONT";
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read CONT record
      // assign expression to variable ZAI
      var_ZAI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
      aux_ZAI_read = true;
      validate_vartype_consistency("ZAI", SCALAR_DOUBLE, aux_last_type_read_for_ZAI);
      aux_last_type_read_for_ZAI = SCALAR_DOUBLE;
      // assign expression to variable ABN
      var_ABN_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
      aux_ABN_read = true;
      validate_vartype_consistency("ABN", SCALAR_DOUBLE, aux_last_type_read_for_ABN);
      aux_last_type_read_for_ABN = SCALAR_DOUBLE;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
      // assign expression to variable LFW
      var_LFW_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LFW_read = true;
      validate_vartype_consistency("LFW", SCALAR_INT, aux_last_type_read_for_LFW);
      aux_last_type_read_for_LFW = SCALAR_INT;
      // assign expression to variable NER
      var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      aux_NER_read = true;
      validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
      aux_last_type_read_for_NER = SCALAR_INT;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);

      for (int var_j_0d_int_Scalar = 1;
         var_j_0d_int_Scalar <= var_NER_0d_int_Scalar; var_j_0d_int_Scalar++) {
        bool aux_j_read = true;
        // open section range
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          if ((! cpp_parent_dict.contains("range"))) {
            cpp_parent_dict["range"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict["range"];
          if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
            cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
          }
          cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
          // variable declarations
          double var_EL_0d_double_Scalar;
          bool aux_EL_read = false;
          vartype aux_last_type_read_for_EL = UNKNOWN;
          double var_EH_0d_double_Scalar;
          bool aux_EH_read = false;
          vartype aux_last_type_read_for_EH = UNKNOWN;
          int var_LRU_0d_int_Scalar;
          bool aux_LRU_read = false;
          vartype aux_last_type_read_for_LRU = UNKNOWN;
          int var_LRF_0d_int_Scalar;
          bool aux_LRF_read = false;
          vartype aux_last_type_read_for_LRF = UNKNOWN;
          int var_NRO_0d_int_Scalar;
          bool aux_NRO_read = false;
          vartype aux_last_type_read_for_NRO = UNKNOWN;
          int var_NAPS_0d_int_Scalar;
          bool aux_NAPS_read = false;
          vartype aux_last_type_read_for_NAPS = UNKNOWN;
          double var_SPI_0d_double_Scalar;
          bool aux_SPI_read = false;
          vartype aux_last_type_read_for_SPI = UNKNOWN;
          double var_AP_0d_double_Scalar;
          std::vector<double> var_AP_0d_floatvec_Scalar;
          bool aux_AP_read = false;
          vartype aux_last_type_read_for_AP = UNKNOWN;
          int var_NLS_0d_int_Scalar;
          bool aux_NLS_read = false;
          vartype aux_last_type_read_for_NLS = UNKNOWN;
          std::vector<double> var_Eint_0d_floatvec_Scalar;
          bool aux_Eint_read = false;
          vartype aux_last_type_read_for_Eint = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          int var_LAD_0d_int_Scalar;
          bool aux_LAD_read = false;
          vartype aux_last_type_read_for_LAD = UNKNOWN;
          int var_NLSC_0d_int_Scalar;
          bool aux_NLSC_read = false;
          vartype aux_last_type_read_for_NLSC = UNKNOWN;
          int var_IFG_0d_int_Scalar;
          bool aux_IFG_read = false;
          vartype aux_last_type_read_for_IFG = UNKNOWN;
          int var_KRM_0d_int_Scalar;
          bool aux_KRM_read = false;
          vartype aux_last_type_read_for_KRM = UNKNOWN;
          int var_NJS_0d_int_Scalar;
          bool aux_NJS_read = false;
          vartype aux_last_type_read_for_NJS = UNKNOWN;
          int var_KRL_0d_int_Scalar;
          bool aux_KRL_read = false;
          vartype aux_last_type_read_for_KRL = UNKNOWN;
          int var_NPP_0d_int_Scalar;
          bool aux_NPP_read = false;
          vartype aux_last_type_read_for_NPP = UNKNOWN;
          int cpp_int_val;
          bool aux_cpp_int_val_read = false;
          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
          NestedVector<double> var_MA_1d_double_NestedVector;
          vartype aux_last_type_read_for_MA = UNKNOWN;
          NestedVector<double> var_MB_1d_double_NestedVector;
          vartype aux_last_type_read_for_MB = UNKNOWN;
          NestedVector<double> var_ZA_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          NestedVector<double> var_ZB_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZB = UNKNOWN;
          NestedVector<double> var_IA_1d_double_NestedVector;
          vartype aux_last_type_read_for_IA = UNKNOWN;
          NestedVector<double> var_IB_1d_double_NestedVector;
          vartype aux_last_type_read_for_IB = UNKNOWN;
          NestedVector<double> var_Q_1d_double_NestedVector;
          vartype aux_last_type_read_for_Q = UNKNOWN;
          NestedVector<double> var_PNT_1d_double_NestedVector;
          vartype aux_last_type_read_for_PNT = UNKNOWN;
          NestedVector<double> var_SHF_1d_double_NestedVector;
          vartype aux_last_type_read_for_SHF = UNKNOWN;
          NestedVector<double> var_MT_1d_double_NestedVector;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          NestedVector<double> var_PA_1d_double_NestedVector;
          vartype aux_last_type_read_for_PA = UNKNOWN;
          NestedVector<double> var_PB_1d_double_NestedVector;
          vartype aux_last_type_read_for_PB = UNKNOWN;
          int var_LSSF_0d_int_Scalar;
          bool aux_LSSF_read = false;
          vartype aux_last_type_read_for_LSSF = UNKNOWN;
          int var_NE_0d_int_Scalar;
          bool aux_NE_read = false;
          vartype aux_last_type_read_for_NE = UNKNOWN;
          NestedVector<double> var_ES_1d_double_NestedVector;
          vartype aux_last_type_read_for_ES = UNKNOWN;
          cpp_template = "[ MAT , 2 , 151 / EL , EH , LRU , LRF , NRO , NAPS ] CONT";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable EL
          var_EL_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_EL_read = true;
          validate_vartype_consistency("EL", SCALAR_DOUBLE, aux_last_type_read_for_EL);
          aux_last_type_read_for_EL = SCALAR_DOUBLE;
          // assign expression to variable EH
          var_EH_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_EH_read = true;
          validate_vartype_consistency("EH", SCALAR_DOUBLE, aux_last_type_read_for_EH);
          aux_last_type_read_for_EH = SCALAR_DOUBLE;
          // assign expression to variable LRU
          var_LRU_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LRU_read = true;
          validate_vartype_consistency("LRU", SCALAR_INT, aux_last_type_read_for_LRU);
          aux_last_type_read_for_LRU = SCALAR_INT;
          // assign expression to variable LRF
          var_LRF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_LRF_read = true;
          validate_vartype_consistency("LRF", SCALAR_INT, aux_last_type_read_for_LRF);
          aux_last_type_read_for_LRF = SCALAR_INT;
          // assign expression to variable NRO
          var_NRO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NRO_read = true;
          validate_vartype_consistency("NRO", SCALAR_INT, aux_last_type_read_for_NRO);
          aux_last_type_read_for_NRO = SCALAR_INT;
          // assign expression to variable NAPS
          var_NAPS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NAPS_read = true;
          validate_vartype_consistency("NAPS", SCALAR_INT, aux_last_type_read_for_NAPS);
          aux_last_type_read_for_NAPS = SCALAR_INT;
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((((((aux_NIS_read == true)) && ((var_NIS_0d_int_Scalar)==(1)))))&&((((aux_ZAI_read == true)) && ((var_ZAI_0d_double_Scalar)==(var_ZA_0d_double_Scalar)))))&&((((aux_ABN_read == true)) && ((var_ABN_0d_double_Scalar)==(1)))))&&((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(0)))))&&((((aux_NER_read == true)) && ((var_NER_0d_int_Scalar)==(1)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if (((((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(0)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(0)))))&&((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)==(0)))))&&((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      // evaluate if-elif-else clause
                      {
                        bool cpp_found_match = false;
                        if (! cpp_found_match) {
                          // if statement evaluation with lookahead
                          {
                            std::streampos cpp_old_streampos = cont.tellg();
                            {
                              // variable declarations
                              double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                              double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                              bool& glob_aux_EL_read = aux_EL_read;
                              bool aux_EL_read = glob_aux_EL_read;
                              vartype aux_last_type_read_for_EL = UNKNOWN;
                              double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                              double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                              bool& glob_aux_EH_read = aux_EH_read;
                              bool aux_EH_read = glob_aux_EH_read;
                              vartype aux_last_type_read_for_EH = UNKNOWN;
                              int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                              int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                              bool& glob_aux_LRU_read = aux_LRU_read;
                              bool aux_LRU_read = glob_aux_LRU_read;
                              vartype aux_last_type_read_for_LRU = UNKNOWN;
                              int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                              int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                              bool& glob_aux_LRF_read = aux_LRF_read;
                              bool aux_LRF_read = glob_aux_LRF_read;
                              vartype aux_last_type_read_for_LRF = UNKNOWN;
                              int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                              int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                              bool& glob_aux_NRO_read = aux_NRO_read;
                              bool aux_NRO_read = glob_aux_NRO_read;
                              vartype aux_last_type_read_for_NRO = UNKNOWN;
                              int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                              int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                              bool& glob_aux_NAPS_read = aux_NAPS_read;
                              bool aux_NAPS_read = glob_aux_NAPS_read;
                              vartype aux_last_type_read_for_NAPS = UNKNOWN;
                              double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                              double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                              bool& glob_aux_SPI_read = aux_SPI_read;
                              bool aux_SPI_read = glob_aux_SPI_read;
                              vartype aux_last_type_read_for_SPI = UNKNOWN;
                              double& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                              double var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                              bool& glob_aux_AP_read = aux_AP_read;
                              bool aux_AP_read = glob_aux_AP_read;
                              vartype aux_last_type_read_for_AP = UNKNOWN;
                              int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                              int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                              bool& glob_aux_NLS_read = aux_NLS_read;
                              bool aux_NLS_read = glob_aux_NLS_read;
                              vartype aux_last_type_read_for_NLS = UNKNOWN;
                              cpp_template = "[ MAT , 2 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                              cpp_line = cpp_read_raw_line(cont);
                              // read CONT record
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                              if ((((((((aux_NLS_read == true)) && ((var_NLS_0d_int_Scalar)==(0)))))))) {
                                cpp_found_match = true;
                              }
                              cont.seekg(cpp_old_streampos);
                            }
                            if (cpp_found_match) {
                              cpp_template = "[ MAT , 2 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read CONT record
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if (((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      // evaluate if-elif-else clause
                      {
                        bool cpp_found_match = false;
                        if (! cpp_found_match) {
                          if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                            // if statement evaluation
                            cpp_found_match = true;
                            cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                            // read TAB1 record
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            {
                              Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                              // assign expression to variable Eint
                              var_Eint_0d_floatvec_Scalar = tab_body.X;
                              aux_Eint_read = true;
                              validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                              aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                              if ((! (aux_AP_read == true))) {
                                // assign expression to variable AP
                                var_AP_0d_floatvec_Scalar = tab_body.Y;
                                aux_AP_read = true;
                                validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                              } else {
                                if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                  cpp_validate_field(var_AP_0d_double_Scalar, tab_body.Y,  true, false, false, "AP",
                                    cpp_template, cpp_line, parse_opts);
                                } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                  cpp_validate_field(var_AP_0d_floatvec_Scalar, tab_body.Y,  true, false, false, "AP",
                                    cpp_template, cpp_line, parse_opts);
                                }
                              }
                              // assign expression to variable INT
                              var_INT_0d_intvec_Scalar = tab_body.INT;
                              aux_INT_read = true;
                              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                              aux_last_type_read_for_INT = SCALAR_INTVEC;
                              // assign expression to variable NBT
                              var_NBT_0d_intvec_Scalar = tab_body.NBT;
                              aux_NBT_read = true;
                              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                              aux_last_type_read_for_NBT = SCALAR_INTVEC;
                            }
                          }
                        }
                      }
                      // evaluate if-elif-else clause
                      {
                        bool cpp_found_match = false;
                        if (! cpp_found_match) {
                          if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                            // if statement evaluation
                            cpp_found_match = true;
                            cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , 0 , 0 , NLS , 0 ] CONT";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read CONT record
                            if ((! (aux_SPI_read == true))) {
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                            } else {
                              cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                cpp_template, cpp_line, parse_opts);
                            }
                            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            if ((! (aux_NLS_read == true))) {
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                cpp_template, cpp_line, parse_opts);
                            }
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                          }
                        }
                        if (! cpp_found_match) {
                          cpp_template = "[ MAT , 2 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read CONT record
                          if ((! (aux_SPI_read == true))) {
                            // assign expression to variable SPI
                            var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                            aux_SPI_read = true;
                            validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                            aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                          } else {
                            cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                              cpp_template, cpp_line, parse_opts);
                          }
                          if ((! (aux_AP_read == true))) {
                            // assign expression to variable AP
                            var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                            aux_AP_read = true;
                            validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                            aux_last_type_read_for_AP = SCALAR_DOUBLE;
                          } else {
                            if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                              cpp_validate_field(var_AP_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                cpp_template, cpp_line, parse_opts);
                            } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                              cpp_validate_field(var_AP_0d_floatvec_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                cpp_template, cpp_line, parse_opts);
                            }
                          }
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          if ((! (aux_NLS_read == true))) {
                            // assign expression to variable NLS
                            var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_NLS_read = true;
                            validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                            aux_last_type_read_for_NLS = SCALAR_INT;
                          } else {
                            cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                              cpp_template, cpp_line, parse_opts);
                          }
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                        }
                      }

                      for (int var_m_0d_int_Scalar = 1;
                         var_m_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                        bool aux_m_read = true;
                        // open section spingroup
                        {
                          py::dict cpp_parent_dict = cpp_current_dict;
                          if ((! cpp_parent_dict.contains("spingroup"))) {
                            cpp_parent_dict["spingroup"] = py::dict();
                          }
                          py::dict cpp_current_dict = cpp_parent_dict["spingroup"];
                          if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                            cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                          }
                          cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                          // variable declarations
                          double var_AWRI_0d_double_Scalar;
                          bool aux_AWRI_read = false;
                          vartype aux_last_type_read_for_AWRI = UNKNOWN;
                          double var_QX_0d_double_Scalar;
                          bool aux_QX_read = false;
                          vartype aux_last_type_read_for_QX = UNKNOWN;
                          int var_L_0d_int_Scalar;
                          bool aux_L_read = false;
                          vartype aux_last_type_read_for_L = UNKNOWN;
                          int var_LRX_0d_int_Scalar;
                          bool aux_LRX_read = false;
                          vartype aux_last_type_read_for_LRX = UNKNOWN;
                          int cpp_int_val;
                          bool aux_cpp_int_val_read = false;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int var_NRS_0d_int_Scalar;
                          bool aux_NRS_read = false;
                          vartype aux_last_type_read_for_NRS = UNKNOWN;
                          NestedVector<double> var_ER_1d_double_NestedVector;
                          vartype aux_last_type_read_for_ER = UNKNOWN;
                          NestedVector<double> var_AJ_1d_double_NestedVector;
                          vartype aux_last_type_read_for_AJ = UNKNOWN;
                          NestedVector<double> var_GT_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GT = UNKNOWN;
                          NestedVector<double> var_GN_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GN = UNKNOWN;
                          NestedVector<double> var_GG_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GG = UNKNOWN;
                          NestedVector<double> var_GF_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GF = UNKNOWN;
                          cpp_template = "[ MAT , 2 , 151 / AWRI , QX , L , LRX , (6*NRS) , NRS / \n { ER , AJ , GT , GN , GG , GF } { k = 1 to NRS } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          // assign expression to variable AWRI
                          var_AWRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                          aux_AWRI_read = true;
                          validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                          aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                          // assign expression to variable QX
                          var_QX_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                          aux_QX_read = true;
                          validate_vartype_consistency("QX", SCALAR_DOUBLE, aux_last_type_read_for_QX);
                          aux_last_type_read_for_QX = SCALAR_DOUBLE;
                          // assign expression to variable L
                          var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_L_read = true;
                          validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                          aux_last_type_read_for_L = SCALAR_INT;
                          // assign expression to variable LRX
                          var_LRX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LRX_read = true;
                          validate_vartype_consistency("LRX", SCALAR_INT, aux_last_type_read_for_LRX);
                          aux_last_type_read_for_LRX = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NRS
                          var_NRS_0d_int_Scalar = (cpp_int_val/6);
                          aux_NRS_read = true;
                          validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                          aux_last_type_read_for_NRS = SCALAR_INT;
                          if ((! (aux_NRS_read == true))) {
                            // assign expression to variable NRS
                            var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NRS_read = true;
                            validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                            aux_last_type_read_for_NRS = SCALAR_INT;
                          } else {
                            cpp_validate_field(var_NRS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NRS",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable ER
                              var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                              aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable AJ
                              var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                              aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable GT
                              var_GT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                              aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable GN
                              var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                              aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable GG
                              var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                              aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable GF
                              var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                              aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          // store data in Python dictionary
                          if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                            cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_QX == SCALAR_DOUBLE) && (aux_QX_read == true))) {
                            cpp_current_dict["QX"] = var_QX_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                            cpp_current_dict["L"] = var_L_0d_int_Scalar;
                          }
                          if (((aux_last_type_read_for_LRX == SCALAR_INT) && (aux_LRX_read == true))) {
                            cpp_current_dict["LRX"] = var_LRX_0d_int_Scalar;
                          }
                          if (((aux_last_type_read_for_NRS == SCALAR_INT) && (aux_NRS_read == true))) {
                            cpp_current_dict["NRS"] = var_NRS_0d_int_Scalar;
                          }
                          if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                            auto& cpp_curvar0 = var_ER_1d_double_NestedVector;
                            cpp_current_dict["ER"] = py::dict();
                            py::dict cpp_curdict0 = cpp_current_dict["ER"];
                            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                            }
                          }
                          if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                            auto& cpp_curvar0 = var_AJ_1d_double_NestedVector;
                            cpp_current_dict["AJ"] = py::dict();
                            py::dict cpp_curdict0 = cpp_current_dict["AJ"];
                            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                            }
                          }
                          if ((var_GT_1d_double_NestedVector.get_last_index() != -1)) {
                            auto& cpp_curvar0 = var_GT_1d_double_NestedVector;
                            cpp_current_dict["GT"] = py::dict();
                            py::dict cpp_curdict0 = cpp_current_dict["GT"];
                            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                            }
                          }
                          if ((var_GN_1d_double_NestedVector.get_last_index() != -1)) {
                            auto& cpp_curvar0 = var_GN_1d_double_NestedVector;
                            cpp_current_dict["GN"] = py::dict();
                            py::dict cpp_curdict0 = cpp_current_dict["GN"];
                            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                            }
                          }
                          if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                            auto& cpp_curvar0 = var_GG_1d_double_NestedVector;
                            cpp_current_dict["GG"] = py::dict();
                            py::dict cpp_curdict0 = cpp_current_dict["GG"];
                            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                            }
                          }
                          if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
                            auto& cpp_curvar0 = var_GF_1d_double_NestedVector;
                            cpp_current_dict["GF"] = py::dict();
                            py::dict cpp_curdict0 = cpp_current_dict["GF"];
                            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                            }
                          }
                          cpp_current_dict = cpp_parent_dict;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if ((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(3)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                              // read TAB1 record
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              {
                                Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                                // assign expression to variable Eint
                                var_Eint_0d_floatvec_Scalar = tab_body.X;
                                aux_Eint_read = true;
                                validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                                aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                                if ((! (aux_AP_read == true))) {
                                  // assign expression to variable AP
                                  var_AP_0d_floatvec_Scalar = tab_body.Y;
                                  aux_AP_read = true;
                                  validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                  aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                                } else {
                                  if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                    cpp_validate_field(var_AP_0d_double_Scalar, tab_body.Y,  true, false, false, "AP",
                                      cpp_template, cpp_line, parse_opts);
                                  } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                    cpp_validate_field(var_AP_0d_floatvec_Scalar, tab_body.Y,  true, false, false, "AP",
                                      cpp_template, cpp_line, parse_opts);
                                  }
                                }
                                // assign expression to variable INT
                                var_INT_0d_intvec_Scalar = tab_body.INT;
                                aux_INT_read = true;
                                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                aux_last_type_read_for_INT = SCALAR_INTVEC;
                                // assign expression to variable NBT
                                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                aux_NBT_read = true;
                                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                aux_last_type_read_for_NBT = SCALAR_INTVEC;
                              }
                            }
                          }
                        }
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , LAD , 0 , NLS , NLSC ] CONT";
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read CONT record
                              if ((! (aux_SPI_read == true))) {
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              } else {
                                cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                  cpp_template, cpp_line, parse_opts);
                              }
                              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable LAD
                              var_LAD_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                              aux_LAD_read = true;
                              validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                              aux_last_type_read_for_LAD = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              if ((! (aux_NLS_read == true))) {
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } else {
                                cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                  cpp_template, cpp_line, parse_opts);
                              }
                              // assign expression to variable NLSC
                              var_NLSC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              aux_NLSC_read = true;
                              validate_vartype_consistency("NLSC", SCALAR_INT, aux_last_type_read_for_NLSC);
                              aux_last_type_read_for_NLSC = SCALAR_INT;
                            }
                          }
                          if (! cpp_found_match) {
                            cpp_template = "[ MAT , 2 , 151 / SPI , AP , LAD , 0 , NLS , NLSC ] CONT";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read CONT record
                            if ((! (aux_SPI_read == true))) {
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                            } else {
                              cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                cpp_template, cpp_line, parse_opts);
                            }
                            if ((! (aux_AP_read == true))) {
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                            } else {
                              if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                cpp_validate_field(var_AP_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                  cpp_template, cpp_line, parse_opts);
                              } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                cpp_validate_field(var_AP_0d_floatvec_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                  cpp_template, cpp_line, parse_opts);
                              }
                            }
                            // assign expression to variable LAD
                            var_LAD_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_LAD_read = true;
                            validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                            aux_last_type_read_for_LAD = SCALAR_INT;
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            if ((! (aux_NLS_read == true))) {
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                cpp_template, cpp_line, parse_opts);
                            }
                            // assign expression to variable NLSC
                            var_NLSC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NLSC_read = true;
                            validate_vartype_consistency("NLSC", SCALAR_INT, aux_last_type_read_for_NLSC);
                            aux_last_type_read_for_NLSC = SCALAR_INT;
                          }
                        }

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // open section spingroup
                          {
                            py::dict cpp_parent_dict = cpp_current_dict;
                            if ((! cpp_parent_dict.contains("spingroup"))) {
                              cpp_parent_dict["spingroup"] = py::dict();
                            }
                            py::dict cpp_current_dict = cpp_parent_dict["spingroup"];
                            if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                              cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                            }
                            cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                            // variable declarations
                            double var_AWRI_0d_double_Scalar;
                            bool aux_AWRI_read = false;
                            vartype aux_last_type_read_for_AWRI = UNKNOWN;
                            double var_APL_0d_double_Scalar;
                            bool aux_APL_read = false;
                            vartype aux_last_type_read_for_APL = UNKNOWN;
                            int var_L_0d_int_Scalar;
                            bool aux_L_read = false;
                            vartype aux_last_type_read_for_L = UNKNOWN;
                            int cpp_int_val;
                            bool aux_cpp_int_val_read = false;
                            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                            int var_NRS_0d_int_Scalar;
                            bool aux_NRS_read = false;
                            vartype aux_last_type_read_for_NRS = UNKNOWN;
                            NestedVector<double> var_ER_1d_double_NestedVector;
                            vartype aux_last_type_read_for_ER = UNKNOWN;
                            NestedVector<double> var_AJ_1d_double_NestedVector;
                            vartype aux_last_type_read_for_AJ = UNKNOWN;
                            NestedVector<double> var_GN_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GN = UNKNOWN;
                            NestedVector<double> var_GG_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GG = UNKNOWN;
                            NestedVector<double> var_GFA_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GFA = UNKNOWN;
                            NestedVector<double> var_GFB_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GFB = UNKNOWN;
                            cpp_template = "[ MAT , 2 , 151 / AWRI , APL , L , 0 , (6*NRS) , NRS / \n { ER , AJ , GN , GG , GFA , GFB } { k = 1 to NRS } ] LIST";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST record
                            // assign expression to variable AWRI
                            var_AWRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                            aux_AWRI_read = true;
                            validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                            aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                            // assign expression to variable APL
                            var_APL_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                            aux_APL_read = true;
                            validate_vartype_consistency("APL", SCALAR_DOUBLE, aux_last_type_read_for_APL);
                            aux_last_type_read_for_APL = SCALAR_DOUBLE;
                            // assign expression to variable L
                            var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_L_read = true;
                            validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                            aux_last_type_read_for_L = SCALAR_INT;
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NRS
                            var_NRS_0d_int_Scalar = (cpp_int_val/6);
                            aux_NRS_read = true;
                            validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                            aux_last_type_read_for_NRS = SCALAR_INT;
                            if ((! (aux_NRS_read == true))) {
                              // assign expression to variable NRS
                              var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              aux_NRS_read = true;
                              validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                              aux_last_type_read_for_NRS = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NRS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NRS",
                                cpp_template, cpp_line, parse_opts);
                            }
                            {
                              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read LIST body

                              for (int var_k_0d_int_Scalar = 1;
                                 var_k_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                                bool aux_k_read = true;
                                // read LIST body
                                // assign expression to variable ER
                                var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                                aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable AJ
                                var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                                aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable GN
                                var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                                aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable GG
                                var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                                aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable GFA
                                var_GFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("GFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFA);
                                aux_last_type_read_for_GFA = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable GFB
                                var_GFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("GFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFB);
                                aux_last_type_read_for_GFB = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            // store data in Python dictionary
                            if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                              cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_APL == SCALAR_DOUBLE) && (aux_APL_read == true))) {
                              cpp_current_dict["APL"] = var_APL_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                              cpp_current_dict["L"] = var_L_0d_int_Scalar;
                            }
                            if (((aux_last_type_read_for_NRS == SCALAR_INT) && (aux_NRS_read == true))) {
                              cpp_current_dict["NRS"] = var_NRS_0d_int_Scalar;
                            }
                            if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_ER_1d_double_NestedVector;
                              cpp_current_dict["ER"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["ER"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_AJ_1d_double_NestedVector;
                              cpp_current_dict["AJ"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["AJ"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_GN_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_GN_1d_double_NestedVector;
                              cpp_current_dict["GN"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["GN"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_GG_1d_double_NestedVector;
                              cpp_current_dict["GG"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["GG"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_GFA_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_GFA_1d_double_NestedVector;
                              cpp_current_dict["GFA"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["GFA"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_GFB_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_GFB_1d_double_NestedVector;
                              cpp_current_dict["GFB"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["GFB"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            cpp_current_dict = cpp_parent_dict;
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if ((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(7)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , IFG , KRM , NJS , KRL ] CONT";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read CONT record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable IFG
                        var_IFG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_IFG_read = true;
                        validate_vartype_consistency("IFG", SCALAR_INT, aux_last_type_read_for_IFG);
                        aux_last_type_read_for_IFG = SCALAR_INT;
                        // assign expression to variable KRM
                        var_KRM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_KRM_read = true;
                        validate_vartype_consistency("KRM", SCALAR_INT, aux_last_type_read_for_KRM);
                        aux_last_type_read_for_KRM = SCALAR_INT;
                        // assign expression to variable NJS
                        var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_NJS_read = true;
                        validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                        aux_last_type_read_for_NJS = SCALAR_INT;
                        // assign expression to variable KRL
                        var_KRL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_KRL_read = true;
                        validate_vartype_consistency("KRL", SCALAR_INT, aux_last_type_read_for_KRL);
                        aux_last_type_read_for_KRL = SCALAR_INT;
                        cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , NPP , 0 , (12*NPP) , (2*NPP) / \n { MA , MB , ZA , ZB , IA , IB , \n Q , PNT , SHF , MT , PA , PB } { k = 1 to NPP } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable NPP
                        var_NPP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_NPP_read = true;
                        validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                        aux_last_type_read_for_NPP = SCALAR_INT;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        if ((! (aux_NPP_read == true))) {
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NPP
                          var_NPP_0d_int_Scalar = (cpp_int_val/12);
                          aux_NPP_read = true;
                          validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                          aux_last_type_read_for_NPP = SCALAR_INT;
                        } else {
                          cpp_validate_field((12*var_NPP_0d_int_Scalar), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(12*NPP)",
                            cpp_template, cpp_line, parse_opts);
                        }
                        if ((! (aux_NPP_read == true))) {
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NPP
                          var_NPP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NPP_read = true;
                          validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                          aux_last_type_read_for_NPP = SCALAR_INT;
                        } else {
                          cpp_validate_field((2*var_NPP_0d_int_Scalar), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "(2*NPP)",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NPP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable MA
                            var_MA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("MA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MA);
                            aux_last_type_read_for_MA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable MB
                            var_MB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("MB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MB);
                            aux_last_type_read_for_MB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable ZA
                            var_ZA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("ZA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZA);
                            aux_last_type_read_for_ZA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable ZB
                            var_ZB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("ZB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZB);
                            aux_last_type_read_for_ZB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable IA
                            var_IA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("IA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IA);
                            aux_last_type_read_for_IA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable IB
                            var_IB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("IB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IB);
                            aux_last_type_read_for_IB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable Q
                            var_Q_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Q", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Q);
                            aux_last_type_read_for_Q = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable PNT
                            var_PNT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("PNT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PNT);
                            aux_last_type_read_for_PNT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable SHF
                            var_SHF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("SHF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SHF);
                            aux_last_type_read_for_SHF = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable MT
                            var_MT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("MT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MT);
                            aux_last_type_read_for_MT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable PA
                            var_PA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("PA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PA);
                            aux_last_type_read_for_PA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable PB
                            var_PB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("PB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PB);
                            aux_last_type_read_for_PB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }

                        for (int var_k_0d_int_Scalar = 1;
                           var_k_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                          bool aux_k_read = true;
                          // open section spingroup
                          {
                            py::dict cpp_parent_dict = cpp_current_dict;
                            if ((! cpp_parent_dict.contains("spingroup"))) {
                              cpp_parent_dict["spingroup"] = py::dict();
                            }
                            py::dict cpp_current_dict = cpp_parent_dict["spingroup"];
                            if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                              cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                            }
                            cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                            // variable declarations
                            double var_AJ_0d_double_Scalar;
                            bool aux_AJ_read = false;
                            vartype aux_last_type_read_for_AJ = UNKNOWN;
                            double var_PJ_0d_double_Scalar;
                            bool aux_PJ_read = false;
                            vartype aux_last_type_read_for_PJ = UNKNOWN;
                            int var_KBK_0d_int_Scalar;
                            bool aux_KBK_read = false;
                            vartype aux_last_type_read_for_KBK = UNKNOWN;
                            int var_KPS_0d_int_Scalar;
                            bool aux_KPS_read = false;
                            vartype aux_last_type_read_for_KPS = UNKNOWN;
                            int cpp_int_val;
                            bool aux_cpp_int_val_read = false;
                            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                            int var_NCH_0d_int_Scalar;
                            bool aux_NCH_read = false;
                            vartype aux_last_type_read_for_NCH = UNKNOWN;
                            NestedVector<double> var_PPI_1d_double_NestedVector;
                            vartype aux_last_type_read_for_PPI = UNKNOWN;
                            NestedVector<double> var_L_1d_double_NestedVector;
                            vartype aux_last_type_read_for_L = UNKNOWN;
                            NestedVector<double> var_SCH_1d_double_NestedVector;
                            vartype aux_last_type_read_for_SCH = UNKNOWN;
                            NestedVector<double> var_BND_1d_double_NestedVector;
                            vartype aux_last_type_read_for_BND = UNKNOWN;
                            NestedVector<double> var_APE_1d_double_NestedVector;
                            vartype aux_last_type_read_for_APE = UNKNOWN;
                            NestedVector<double> var_APT_1d_double_NestedVector;
                            vartype aux_last_type_read_for_APT = UNKNOWN;
                            int var_NRS_0d_int_Scalar;
                            bool aux_NRS_read = false;
                            vartype aux_last_type_read_for_NRS = UNKNOWN;
                            NestedVector<double> var_ER_1d_double_NestedVector;
                            vartype aux_last_type_read_for_ER = UNKNOWN;
                            Matrix2d<double> var_GAM_2d_double_Matrix2d;
                            vartype aux_last_type_read_for_GAM = UNKNOWN;
                            int var_NX_0d_int_Scalar;
                            bool aux_NX_read = false;
                            vartype aux_last_type_read_for_NX = UNKNOWN;
                            cpp_template = "[ MAT , 2 , 151 / AJ , PJ , KBK , KPS , (6*NCH) , NCH / \n { PPI , L , SCH , BND , APE , APT } { l = 1 to NCH } ] LIST";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST record
                            // assign expression to variable AJ
                            var_AJ_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                            aux_AJ_read = true;
                            validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                            aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                            // assign expression to variable PJ
                            var_PJ_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                            aux_PJ_read = true;
                            validate_vartype_consistency("PJ", SCALAR_DOUBLE, aux_last_type_read_for_PJ);
                            aux_last_type_read_for_PJ = SCALAR_DOUBLE;
                            // assign expression to variable KBK
                            var_KBK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_KBK_read = true;
                            validate_vartype_consistency("KBK", SCALAR_INT, aux_last_type_read_for_KBK);
                            aux_last_type_read_for_KBK = SCALAR_INT;
                            // assign expression to variable KPS
                            var_KPS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                            aux_KPS_read = true;
                            validate_vartype_consistency("KPS", SCALAR_INT, aux_last_type_read_for_KPS);
                            aux_last_type_read_for_KPS = SCALAR_INT;
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NCH
                            var_NCH_0d_int_Scalar = (cpp_int_val/6);
                            aux_NCH_read = true;
                            validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                            aux_last_type_read_for_NCH = SCALAR_INT;
                            if ((! (aux_NCH_read == true))) {
                              // assign expression to variable NCH
                              var_NCH_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              aux_NCH_read = true;
                              validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                              aux_last_type_read_for_NCH = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NCH_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NCH",
                                cpp_template, cpp_line, parse_opts);
                            }
                            {
                              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read LIST body

                              for (int var_l_0d_int_Scalar = 1;
                                 var_l_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_l_0d_int_Scalar++) {
                                bool aux_l_read = true;
                                // read LIST body
                                // assign expression to variable PPI
                                var_PPI_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("PPI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PPI);
                                aux_last_type_read_for_PPI = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable L
                                var_L_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("L", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_L);
                                aux_last_type_read_for_L = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable SCH
                                var_SCH_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("SCH", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SCH);
                                aux_last_type_read_for_SCH = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable BND
                                var_BND_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("BND", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BND);
                                aux_last_type_read_for_BND = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable APE
                                var_APE_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("APE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APE);
                                aux_last_type_read_for_APE = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable APT
                                var_APT_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("APT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APT);
                                aux_last_type_read_for_APT = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            // evaluate if-elif-else clause
                            {
                              bool cpp_found_match = false;
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  std::streampos cpp_old_streampos = cont.tellg();
                                  {
                                    // variable declarations
                                    double& glob_var_AJ_0d_double_Scalar = var_AJ_0d_double_Scalar;
                                    double var_AJ_0d_double_Scalar = glob_var_AJ_0d_double_Scalar;
                                    bool& glob_aux_AJ_read = aux_AJ_read;
                                    bool aux_AJ_read = glob_aux_AJ_read;
                                    vartype aux_last_type_read_for_AJ = UNKNOWN;
                                    double& glob_var_PJ_0d_double_Scalar = var_PJ_0d_double_Scalar;
                                    double var_PJ_0d_double_Scalar = glob_var_PJ_0d_double_Scalar;
                                    bool& glob_aux_PJ_read = aux_PJ_read;
                                    bool aux_PJ_read = glob_aux_PJ_read;
                                    vartype aux_last_type_read_for_PJ = UNKNOWN;
                                    int& glob_var_KBK_0d_int_Scalar = var_KBK_0d_int_Scalar;
                                    int var_KBK_0d_int_Scalar = glob_var_KBK_0d_int_Scalar;
                                    bool& glob_aux_KBK_read = aux_KBK_read;
                                    bool aux_KBK_read = glob_aux_KBK_read;
                                    vartype aux_last_type_read_for_KBK = UNKNOWN;
                                    int& glob_var_KPS_0d_int_Scalar = var_KPS_0d_int_Scalar;
                                    int var_KPS_0d_int_Scalar = glob_var_KPS_0d_int_Scalar;
                                    bool& glob_aux_KPS_read = aux_KPS_read;
                                    bool aux_KPS_read = glob_aux_KPS_read;
                                    vartype aux_last_type_read_for_KPS = UNKNOWN;
                                    int& glob_cpp_int_val = cpp_int_val;
                                    int cpp_int_val = glob_cpp_int_val;
                                    bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                                    bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                                    vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                    int& glob_var_NCH_0d_int_Scalar = var_NCH_0d_int_Scalar;
                                    int var_NCH_0d_int_Scalar = glob_var_NCH_0d_int_Scalar;
                                    bool& glob_aux_NCH_read = aux_NCH_read;
                                    bool aux_NCH_read = glob_aux_NCH_read;
                                    vartype aux_last_type_read_for_NCH = UNKNOWN;
                                    NestedVector<double>& glob_var_PPI_1d_double_NestedVector = var_PPI_1d_double_NestedVector;
                                    NestedVector<double> var_PPI_1d_double_NestedVector = glob_var_PPI_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_PPI = UNKNOWN;
                                    NestedVector<double>& glob_var_L_1d_double_NestedVector = var_L_1d_double_NestedVector;
                                    NestedVector<double> var_L_1d_double_NestedVector = glob_var_L_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_L = UNKNOWN;
                                    NestedVector<double>& glob_var_SCH_1d_double_NestedVector = var_SCH_1d_double_NestedVector;
                                    NestedVector<double> var_SCH_1d_double_NestedVector = glob_var_SCH_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_SCH = UNKNOWN;
                                    NestedVector<double>& glob_var_BND_1d_double_NestedVector = var_BND_1d_double_NestedVector;
                                    NestedVector<double> var_BND_1d_double_NestedVector = glob_var_BND_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_BND = UNKNOWN;
                                    NestedVector<double>& glob_var_APE_1d_double_NestedVector = var_APE_1d_double_NestedVector;
                                    NestedVector<double> var_APE_1d_double_NestedVector = glob_var_APE_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_APE = UNKNOWN;
                                    NestedVector<double>& glob_var_APT_1d_double_NestedVector = var_APT_1d_double_NestedVector;
                                    NestedVector<double> var_APT_1d_double_NestedVector = glob_var_APT_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_APT = UNKNOWN;
                                    int& glob_var_NRS_0d_int_Scalar = var_NRS_0d_int_Scalar;
                                    int var_NRS_0d_int_Scalar = glob_var_NRS_0d_int_Scalar;
                                    bool& glob_aux_NRS_read = aux_NRS_read;
                                    bool aux_NRS_read = glob_aux_NRS_read;
                                    vartype aux_last_type_read_for_NRS = UNKNOWN;
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*NX) , NX / \n { ER , { GAM } { m = 1 to NCH } , \n { 0.0 } { p = 1 to num_zeros } } { n = 1 to NRS } ] LIST";
                                    cpp_line = cpp_read_raw_line(cont);
                                    // read LIST record
                                    // assign expression to variable NRS
                                    var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                                    aux_NRS_read = true;
                                    validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                    aux_last_type_read_for_NRS = SCALAR_INT;
                                    if ((! (aux_NCH_read == true))) {
                                      throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NCH because the modulo operator is not supported.");
                                    } else {
                                    }
                                    if ((! (aux_NRS_read == true))) {
                                      throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NRS because the modulo operator is not supported.");
                                    } else {
                                    }
                                    if ((! (aux_NCH_read == true))) {
                                      throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NCH because the modulo operator is not supported.");
                                    } else {
                                    }
                                    if ((! (aux_NRS_read == true))) {
                                      throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NRS because the modulo operator is not supported.");
                                    } else {
                                    }
                                    if ((((((((aux_NRS_read == true)) && ((var_NRS_0d_int_Scalar)>(0)))))))) {
                                      cpp_found_match = true;
                                    }
                                    cont.seekg(cpp_old_streampos);
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*((((1+NCH)+((5-NCH)%6))*NRS)/6)) , ((((1+NCH)+((5-NCH)%6))*NRS)/6) / \n { ER , { GAM } { m = 1 to NCH } , \n { 0.0 } { p = 1 to num_zeros } } { n = 1 to NRS } ] LIST";
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST record
                                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    // assign expression to variable NRS
                                    var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                                    aux_NRS_read = true;
                                    validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                    aux_last_type_read_for_NRS = SCALAR_INT;
                                    if ((! (aux_NCH_read == true))) {
                                      throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NCH because the modulo operator is not supported.");
                                    } else {
                                      cpp_validate_field((6*((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRS_0d_int_Scalar)/6)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(6*((((1+NCH)+((5-NCH)%6))*NRS)/6))",
                                        cpp_template, cpp_line, parse_opts);
                                    }
                                    if ((! (aux_NRS_read == true))) {
                                      throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NRS because the modulo operator is not supported.");
                                    } else {
                                      cpp_validate_field((6*((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRS_0d_int_Scalar)/6)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(6*((((1+NCH)+((5-NCH)%6))*NRS)/6))",
                                        cpp_template, cpp_line, parse_opts);
                                    }
                                    if ((! (aux_NCH_read == true))) {
                                      throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NCH because the modulo operator is not supported.");
                                    } else {
                                      cpp_validate_field(((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRS_0d_int_Scalar)/6), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "((((1+NCH)+((5-NCH)%6))*NRS)/6)",
                                        cpp_template, cpp_line, parse_opts);
                                    }
                                    if ((! (aux_NRS_read == true))) {
                                      throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NRS because the modulo operator is not supported.");
                                    } else {
                                      cpp_validate_field(((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRS_0d_int_Scalar)/6), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "((((1+NCH)+((5-NCH)%6))*NRS)/6)",
                                        cpp_template, cpp_line, parse_opts);
                                    }
                                    {
                                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      // read LIST body
                                      var_GAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRS_0d_int_Scalar, false, false);

                                      for (int var_n_0d_int_Scalar = 1;
                                         var_n_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                        bool aux_n_read = true;
                                        // read LIST body
                                        // assign expression to variable ER
                                        var_ER_1d_double_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                        validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                                        aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                                        cpp_i++;
                                        cpp_j++;
                                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                          cpp_j = 0;
                                        }

                                        for (int var_m_0d_int_Scalar = 1;
                                           var_m_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                          bool aux_m_read = true;
                                          // read LIST body
                                          // assign expression to variable GAM
                                          var_GAM_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                          validate_vartype_consistency("GAM", MATRIX2D_DOUBLE, aux_last_type_read_for_GAM);
                                          aux_last_type_read_for_GAM = MATRIX2D_DOUBLE;
                                          cpp_i++;
                                          cpp_j++;
                                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                            cpp_j = 0;
                                          }
                                        }

                                        for (int var_p_0d_int_Scalar = 1;
                                           var_p_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_p_0d_int_Scalar++) {
                                          bool aux_p_read = true;
                                          // read LIST body
                                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                            cpp_template, cpp_line, parse_opts);
                                          cpp_i++;
                                          cpp_j++;
                                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                            cpp_j = 0;
                                          }
                                        }
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            // evaluate if-elif-else clause
                            {
                              bool cpp_found_match = false;
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  std::streampos cpp_old_streampos = cont.tellg();
                                  {
                                    // variable declarations
                                    double& glob_var_AJ_0d_double_Scalar = var_AJ_0d_double_Scalar;
                                    double var_AJ_0d_double_Scalar = glob_var_AJ_0d_double_Scalar;
                                    bool& glob_aux_AJ_read = aux_AJ_read;
                                    bool aux_AJ_read = glob_aux_AJ_read;
                                    vartype aux_last_type_read_for_AJ = UNKNOWN;
                                    double& glob_var_PJ_0d_double_Scalar = var_PJ_0d_double_Scalar;
                                    double var_PJ_0d_double_Scalar = glob_var_PJ_0d_double_Scalar;
                                    bool& glob_aux_PJ_read = aux_PJ_read;
                                    bool aux_PJ_read = glob_aux_PJ_read;
                                    vartype aux_last_type_read_for_PJ = UNKNOWN;
                                    int& glob_var_KBK_0d_int_Scalar = var_KBK_0d_int_Scalar;
                                    int var_KBK_0d_int_Scalar = glob_var_KBK_0d_int_Scalar;
                                    bool& glob_aux_KBK_read = aux_KBK_read;
                                    bool aux_KBK_read = glob_aux_KBK_read;
                                    vartype aux_last_type_read_for_KBK = UNKNOWN;
                                    int& glob_var_KPS_0d_int_Scalar = var_KPS_0d_int_Scalar;
                                    int var_KPS_0d_int_Scalar = glob_var_KPS_0d_int_Scalar;
                                    bool& glob_aux_KPS_read = aux_KPS_read;
                                    bool aux_KPS_read = glob_aux_KPS_read;
                                    vartype aux_last_type_read_for_KPS = UNKNOWN;
                                    int& glob_cpp_int_val = cpp_int_val;
                                    int cpp_int_val = glob_cpp_int_val;
                                    bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                                    bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                                    vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                    int& glob_var_NCH_0d_int_Scalar = var_NCH_0d_int_Scalar;
                                    int var_NCH_0d_int_Scalar = glob_var_NCH_0d_int_Scalar;
                                    bool& glob_aux_NCH_read = aux_NCH_read;
                                    bool aux_NCH_read = glob_aux_NCH_read;
                                    vartype aux_last_type_read_for_NCH = UNKNOWN;
                                    NestedVector<double>& glob_var_PPI_1d_double_NestedVector = var_PPI_1d_double_NestedVector;
                                    NestedVector<double> var_PPI_1d_double_NestedVector = glob_var_PPI_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_PPI = UNKNOWN;
                                    NestedVector<double>& glob_var_L_1d_double_NestedVector = var_L_1d_double_NestedVector;
                                    NestedVector<double> var_L_1d_double_NestedVector = glob_var_L_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_L = UNKNOWN;
                                    NestedVector<double>& glob_var_SCH_1d_double_NestedVector = var_SCH_1d_double_NestedVector;
                                    NestedVector<double> var_SCH_1d_double_NestedVector = glob_var_SCH_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_SCH = UNKNOWN;
                                    NestedVector<double>& glob_var_BND_1d_double_NestedVector = var_BND_1d_double_NestedVector;
                                    NestedVector<double> var_BND_1d_double_NestedVector = glob_var_BND_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_BND = UNKNOWN;
                                    NestedVector<double>& glob_var_APE_1d_double_NestedVector = var_APE_1d_double_NestedVector;
                                    NestedVector<double> var_APE_1d_double_NestedVector = glob_var_APE_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_APE = UNKNOWN;
                                    NestedVector<double>& glob_var_APT_1d_double_NestedVector = var_APT_1d_double_NestedVector;
                                    NestedVector<double> var_APT_1d_double_NestedVector = glob_var_APT_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_APT = UNKNOWN;
                                    int& glob_var_NRS_0d_int_Scalar = var_NRS_0d_int_Scalar;
                                    int var_NRS_0d_int_Scalar = glob_var_NRS_0d_int_Scalar;
                                    bool& glob_aux_NRS_read = aux_NRS_read;
                                    bool aux_NRS_read = glob_aux_NRS_read;
                                    vartype aux_last_type_read_for_NRS = UNKNOWN;
                                    NestedVector<double>& glob_var_ER_1d_double_NestedVector = var_ER_1d_double_NestedVector;
                                    NestedVector<double> var_ER_1d_double_NestedVector = glob_var_ER_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    Matrix2d<double>& glob_var_GAM_2d_double_Matrix2d = var_GAM_2d_double_Matrix2d;
                                    Matrix2d<double> var_GAM_2d_double_Matrix2d = glob_var_GAM_2d_double_Matrix2d;
                                    vartype aux_last_type_read_for_GAM = UNKNOWN;
                                    int& glob_var_NX_0d_int_Scalar = var_NX_0d_int_Scalar;
                                    int var_NX_0d_int_Scalar = glob_var_NX_0d_int_Scalar;
                                    bool& glob_aux_NX_read = aux_NX_read;
                                    bool aux_NX_read = glob_aux_NX_read;
                                    vartype aux_last_type_read_for_NX = UNKNOWN;
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*NX) , NX / \n { 0.0 } { m = 1 to 6 } ] LIST";
                                    cpp_line = cpp_read_raw_line(cont);
                                    // read LIST record
                                    if ((! (aux_NRS_read == true))) {
                                      // assign expression to variable NRS
                                      var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                                      aux_NRS_read = true;
                                      validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                      aux_last_type_read_for_NRS = SCALAR_INT;
                                    } else {
                                    }
                                    // assign expression to variable cpp_int_val
                                    cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_cpp_int_val_read = true;
                                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                    // assign expression to variable NX
                                    var_NX_0d_int_Scalar = (cpp_int_val/6);
                                    aux_NX_read = true;
                                    validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                    aux_last_type_read_for_NX = SCALAR_INT;
                                    if ((! (aux_NX_read == true))) {
                                      // assign expression to variable NX
                                      var_NX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                                      aux_NX_read = true;
                                      validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                      aux_last_type_read_for_NX = SCALAR_INT;
                                    } else {
                                    }
                                    if (((((((((aux_NRS_read == true)) && ((var_NRS_0d_int_Scalar)==(0)))))&&((((aux_NX_read == true)) && ((var_NX_0d_int_Scalar)==(1)))))))) {
                                      cpp_found_match = true;
                                    }
                                    cont.seekg(cpp_old_streampos);
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*NX) , NX / \n { 0.0 } { m = 1 to 6 } ] LIST";
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST record
                                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    if ((! (aux_NRS_read == true))) {
                                      // assign expression to variable NRS
                                      var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                                      aux_NRS_read = true;
                                      validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                      aux_last_type_read_for_NRS = SCALAR_INT;
                                    } else {
                                      cpp_validate_field(var_NRS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  true, false, false, "NRS",
                                        cpp_template, cpp_line, parse_opts);
                                    }
                                    // assign expression to variable cpp_int_val
                                    cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_cpp_int_val_read = true;
                                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                    // assign expression to variable NX
                                    var_NX_0d_int_Scalar = (cpp_int_val/6);
                                    aux_NX_read = true;
                                    validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                    aux_last_type_read_for_NX = SCALAR_INT;
                                    if ((! (aux_NX_read == true))) {
                                      // assign expression to variable NX
                                      var_NX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                                      aux_NX_read = true;
                                      validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                      aux_last_type_read_for_NX = SCALAR_INT;
                                    } else {
                                      cpp_validate_field(var_NX_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NX",
                                        cpp_template, cpp_line, parse_opts);
                                    }
                                    {
                                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      // read LIST body

                                      for (int var_m_0d_int_Scalar = 1;
                                         var_m_0d_int_Scalar <= 6; var_m_0d_int_Scalar++) {
                                        bool aux_m_read = true;
                                        // read LIST body
                                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                          cpp_template, cpp_line, parse_opts);
                                        cpp_i++;
                                        cpp_j++;
                                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                          cpp_j = 0;
                                        }
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            // store data in Python dictionary
                            if (((aux_last_type_read_for_AJ == SCALAR_DOUBLE) && (aux_AJ_read == true))) {
                              cpp_current_dict["AJ"] = var_AJ_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_PJ == SCALAR_DOUBLE) && (aux_PJ_read == true))) {
                              cpp_current_dict["PJ"] = var_PJ_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_KBK == SCALAR_INT) && (aux_KBK_read == true))) {
                              cpp_current_dict["KBK"] = var_KBK_0d_int_Scalar;
                            }
                            if (((aux_last_type_read_for_KPS == SCALAR_INT) && (aux_KPS_read == true))) {
                              cpp_current_dict["KPS"] = var_KPS_0d_int_Scalar;
                            }
                            if (((aux_last_type_read_for_NCH == SCALAR_INT) && (aux_NCH_read == true))) {
                              cpp_current_dict["NCH"] = var_NCH_0d_int_Scalar;
                            }
                            if ((var_PPI_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_PPI_1d_double_NestedVector;
                              cpp_current_dict["PPI"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["PPI"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_L_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_L_1d_double_NestedVector;
                              cpp_current_dict["L"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["L"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_SCH_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_SCH_1d_double_NestedVector;
                              cpp_current_dict["SCH"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["SCH"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_BND_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_BND_1d_double_NestedVector;
                              cpp_current_dict["BND"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["BND"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_APE_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_APE_1d_double_NestedVector;
                              cpp_current_dict["APE"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["APE"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_APT_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_APT_1d_double_NestedVector;
                              cpp_current_dict["APT"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["APT"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if (((aux_last_type_read_for_NRS == SCALAR_INT) && (aux_NRS_read == true))) {
                              cpp_current_dict["NRS"] = var_NRS_0d_int_Scalar;
                            }
                            if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_ER_1d_double_NestedVector;
                              cpp_current_dict["ER"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["ER"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if (var_GAM_2d_double_Matrix2d.did_read()) {
                                cpp_current_dict["GAM"] = py::dict();
                                py::dict cpp_curdict0 = cpp_current_dict["GAM"];
                                for (int cpp_i1 = var_GAM_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_GAM_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
                                  cpp_curdict0[py::cast(cpp_i1)] = py::dict();
                                  py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
                                  for (int cpp_i2 = var_GAM_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_GAM_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
                                    cpp_curdict1[py::cast(cpp_i2)] = var_GAM_2d_double_Matrix2d(cpp_i1, cpp_i2);
                                  }
                                }
                            }
                            if (((aux_last_type_read_for_NX == SCALAR_INT) && (aux_NX_read == true))) {
                              cpp_current_dict["NX"] = var_NX_0d_int_Scalar;
                            }
                            cpp_current_dict = cpp_parent_dict;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                if ((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(2)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  // evaluate if-elif-else clause
                  {
                    bool cpp_found_match = false;
                    if (! cpp_found_match) {
                      if (((((((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(0)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                              // read TAB1 record
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              {
                                Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                                // assign expression to variable Eint
                                var_Eint_0d_floatvec_Scalar = tab_body.X;
                                aux_Eint_read = true;
                                validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                                aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                                if ((! (aux_AP_read == true))) {
                                  // assign expression to variable AP
                                  var_AP_0d_floatvec_Scalar = tab_body.Y;
                                  aux_AP_read = true;
                                  validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                  aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                                } else {
                                  if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                    cpp_validate_field(var_AP_0d_double_Scalar, tab_body.Y,  true, false, false, "AP",
                                      cpp_template, cpp_line, parse_opts);
                                  } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                    cpp_validate_field(var_AP_0d_floatvec_Scalar, tab_body.Y,  true, false, false, "AP",
                                      cpp_template, cpp_line, parse_opts);
                                  }
                                }
                                // assign expression to variable INT
                                var_INT_0d_intvec_Scalar = tab_body.INT;
                                aux_INT_read = true;
                                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                aux_last_type_read_for_INT = SCALAR_INTVEC;
                                // assign expression to variable NBT
                                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                aux_NBT_read = true;
                                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                aux_last_type_read_for_NBT = SCALAR_INTVEC;
                              }
                            }
                          }
                        }
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , LSSF , 0 , NLS , 0 ] CONT";
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read CONT record
                              if ((! (aux_SPI_read == true))) {
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              } else {
                                cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                  cpp_template, cpp_line, parse_opts);
                              }
                              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable LSSF
                              var_LSSF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                              aux_LSSF_read = true;
                              validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                              aux_last_type_read_for_LSSF = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              if ((! (aux_NLS_read == true))) {
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } else {
                                cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                  cpp_template, cpp_line, parse_opts);
                              }
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                            }
                          }
                          if (! cpp_found_match) {
                            cpp_template = "[ MAT , 2 , 151 / SPI , AP , LSSF , 0 , NLS , 0 ] CONT";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read CONT record
                            if ((! (aux_SPI_read == true))) {
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                            } else {
                              cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                cpp_template, cpp_line, parse_opts);
                            }
                            if ((! (aux_AP_read == true))) {
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                            } else {
                              if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                cpp_validate_field(var_AP_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                  cpp_template, cpp_line, parse_opts);
                              } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                cpp_validate_field(var_AP_0d_floatvec_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                  cpp_template, cpp_line, parse_opts);
                              }
                            }
                            // assign expression to variable LSSF
                            var_LSSF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_LSSF_read = true;
                            validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                            aux_last_type_read_for_LSSF = SCALAR_INT;
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            if ((! (aux_NLS_read == true))) {
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                cpp_template, cpp_line, parse_opts);
                            }
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                          }
                        }

                        for (int var_p_0d_int_Scalar = 1;
                           var_p_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                          bool aux_p_read = true;
                          // open section l_group
                          {
                            py::dict cpp_parent_dict = cpp_current_dict;
                            if ((! cpp_parent_dict.contains("l_group"))) {
                              cpp_parent_dict["l_group"] = py::dict();
                            }
                            py::dict cpp_current_dict = cpp_parent_dict["l_group"];
                            if ((! cpp_current_dict.contains(py::cast(var_p_0d_int_Scalar)))) {
                              cpp_current_dict[py::cast(var_p_0d_int_Scalar)] = py::dict();
                            }
                            cpp_current_dict = cpp_current_dict[py::cast(var_p_0d_int_Scalar)];
                            // variable declarations
                            double var_AWRI_0d_double_Scalar;
                            bool aux_AWRI_read = false;
                            vartype aux_last_type_read_for_AWRI = UNKNOWN;
                            int var_L_0d_int_Scalar;
                            bool aux_L_read = false;
                            vartype aux_last_type_read_for_L = UNKNOWN;
                            int cpp_int_val;
                            bool aux_cpp_int_val_read = false;
                            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                            int var_NJS_0d_int_Scalar;
                            bool aux_NJS_read = false;
                            vartype aux_last_type_read_for_NJS = UNKNOWN;
                            NestedVector<double> var_D_1d_double_NestedVector;
                            vartype aux_last_type_read_for_D = UNKNOWN;
                            NestedVector<double> var_AJ_1d_double_NestedVector;
                            vartype aux_last_type_read_for_AJ = UNKNOWN;
                            NestedVector<double> var_AMUN_1d_double_NestedVector;
                            vartype aux_last_type_read_for_AMUN = UNKNOWN;
                            NestedVector<double> var_GN0_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GN0 = UNKNOWN;
                            NestedVector<double> var_GG_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GG = UNKNOWN;
                            cpp_template = "[ MAT , 2 , 151 / AWRI , 0.0 , L , 0 , (6*NJS) , NJS / \n { D , AJ , AMUN , GN0 , GG , 0.0 } { m = 1 to NJS } ] LIST";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST record
                            // assign expression to variable AWRI
                            var_AWRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                            aux_AWRI_read = true;
                            validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                            aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                              cpp_template, cpp_line, parse_opts);
                            // assign expression to variable L
                            var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                            aux_L_read = true;
                            validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                            aux_last_type_read_for_L = SCALAR_INT;
                            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                              cpp_template, cpp_line, parse_opts);
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NJS
                            var_NJS_0d_int_Scalar = (cpp_int_val/6);
                            aux_NJS_read = true;
                            validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                            aux_last_type_read_for_NJS = SCALAR_INT;
                            if ((! (aux_NJS_read == true))) {
                              // assign expression to variable NJS
                              var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                              aux_NJS_read = true;
                              validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                              aux_last_type_read_for_NJS = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NJS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NJS",
                                cpp_template, cpp_line, parse_opts);
                            }
                            {
                              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read LIST body

                              for (int var_m_0d_int_Scalar = 1;
                                 var_m_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                bool aux_m_read = true;
                                // read LIST body
                                // assign expression to variable D
                                var_D_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("D", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_D);
                                aux_last_type_read_for_D = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable AJ
                                var_AJ_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                                aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable AMUN
                                var_AMUN_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("AMUN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AMUN);
                                aux_last_type_read_for_AMUN = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable GN0
                                var_GN0_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("GN0", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN0);
                                aux_last_type_read_for_GN0 = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                // assign expression to variable GG
                                var_GG_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                                aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                  cpp_template, cpp_line, parse_opts);
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            // store data in Python dictionary
                            if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                              cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                            }
                            if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                              cpp_current_dict["L"] = var_L_0d_int_Scalar;
                            }
                            if (((aux_last_type_read_for_NJS == SCALAR_INT) && (aux_NJS_read == true))) {
                              cpp_current_dict["NJS"] = var_NJS_0d_int_Scalar;
                            }
                            if ((var_D_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_D_1d_double_NestedVector;
                              cpp_current_dict["D"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["D"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_AJ_1d_double_NestedVector;
                              cpp_current_dict["AJ"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["AJ"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_AMUN_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_AMUN_1d_double_NestedVector;
                              cpp_current_dict["AMUN"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["AMUN"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_GN0_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_GN0_1d_double_NestedVector;
                              cpp_current_dict["GN0"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["GN0"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_GG_1d_double_NestedVector;
                              cpp_current_dict["GG"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["GG"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            cpp_current_dict = cpp_parent_dict;
                          }
                        }
                      }
                    }
                    if (! cpp_found_match) {
                      if (! cpp_found_match) {
                        if (((((((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 2 , 151 / SPI , AP , LSSF , 0 , NE , NLS / \n { ES } { p = 1 to NE } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          if ((! (aux_SPI_read == true))) {
                            // assign expression to variable SPI
                            var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                            aux_SPI_read = true;
                            validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                            aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                          } else {
                            cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                              cpp_template, cpp_line, parse_opts);
                          }
                          if ((! (aux_AP_read == true))) {
                            // assign expression to variable AP
                            var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                            aux_AP_read = true;
                            validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                            aux_last_type_read_for_AP = SCALAR_DOUBLE;
                          } else {
                            if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                              cpp_validate_field(var_AP_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                cpp_template, cpp_line, parse_opts);
                            } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                              cpp_validate_field(var_AP_0d_floatvec_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                cpp_template, cpp_line, parse_opts);
                            }
                          }
                          // assign expression to variable LSSF
                          var_LSSF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LSSF_read = true;
                          validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                          aux_last_type_read_for_LSSF = SCALAR_INT;
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NLS_read == true))) {
                            // assign expression to variable NLS
                            var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NLS_read = true;
                            validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                            aux_last_type_read_for_NLS = SCALAR_INT;
                          } else {
                            cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NLS",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_p_0d_int_Scalar = 1;
                               var_p_0d_int_Scalar <= var_NE_0d_int_Scalar; var_p_0d_int_Scalar++) {
                              bool aux_p_read = true;
                              // read LIST body
                              // assign expression to variable ES
                              var_ES_1d_double_NestedVector.set(var_p_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                              aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }

                          for (int var_p_0d_int_Scalar = 1;
                             var_p_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                            bool aux_p_read = true;
                            // open section j_group
                            {
                              py::dict cpp_parent_dict = cpp_current_dict;
                              if ((! cpp_parent_dict.contains("j_group"))) {
                                cpp_parent_dict["j_group"] = py::dict();
                              }
                              py::dict cpp_current_dict = cpp_parent_dict["j_group"];
                              if ((! cpp_current_dict.contains(py::cast(var_p_0d_int_Scalar)))) {
                                cpp_current_dict[py::cast(var_p_0d_int_Scalar)] = py::dict();
                              }
                              cpp_current_dict = cpp_current_dict[py::cast(var_p_0d_int_Scalar)];
                              // variable declarations
                              double var_AWRI_0d_double_Scalar;
                              bool aux_AWRI_read = false;
                              vartype aux_last_type_read_for_AWRI = UNKNOWN;
                              int var_L_0d_int_Scalar;
                              bool aux_L_read = false;
                              vartype aux_last_type_read_for_L = UNKNOWN;
                              int var_NJS_0d_int_Scalar;
                              bool aux_NJS_read = false;
                              vartype aux_last_type_read_for_NJS = UNKNOWN;
                              cpp_template = "[ MAT , 2 , 151 / AWRI , 0.0 , L , 0 , NJS , 0 ] CONT";
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read CONT record
                              // assign expression to variable AWRI
                              var_AWRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                              aux_AWRI_read = true;
                              validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                              aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable L
                              var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                              aux_L_read = true;
                              validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                              aux_last_type_read_for_L = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable NJS
                              var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_NJS_read = true;
                              validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                              aux_last_type_read_for_NJS = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // open section subsec
                                {
                                  py::dict cpp_parent_dict = cpp_current_dict;
                                  if ((! cpp_parent_dict.contains("subsec"))) {
                                    cpp_parent_dict["subsec"] = py::dict();
                                  }
                                  py::dict cpp_current_dict = cpp_parent_dict["subsec"];
                                  if ((! cpp_current_dict.contains(py::cast(var_n_0d_int_Scalar)))) {
                                    cpp_current_dict[py::cast(var_n_0d_int_Scalar)] = py::dict();
                                  }
                                  cpp_current_dict = cpp_current_dict[py::cast(var_n_0d_int_Scalar)];
                                  // variable declarations
                                  int var_L_0d_int_Scalar;
                                  bool aux_L_read = false;
                                  vartype aux_last_type_read_for_L = UNKNOWN;
                                  int var_MUF_0d_int_Scalar;
                                  bool aux_MUF_read = false;
                                  vartype aux_last_type_read_for_MUF = UNKNOWN;
                                  int cpp_int_val;
                                  bool aux_cpp_int_val_read = false;
                                  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                  int var_NE_0d_int_Scalar;
                                  bool aux_NE_read = false;
                                  vartype aux_last_type_read_for_NE = UNKNOWN;
                                  double var_D_0d_double_Scalar;
                                  bool aux_D_read = false;
                                  vartype aux_last_type_read_for_D = UNKNOWN;
                                  double var_AJ_0d_double_Scalar;
                                  bool aux_AJ_read = false;
                                  vartype aux_last_type_read_for_AJ = UNKNOWN;
                                  double var_AMUN_0d_double_Scalar;
                                  bool aux_AMUN_read = false;
                                  vartype aux_last_type_read_for_AMUN = UNKNOWN;
                                  double var_GN0_0d_double_Scalar;
                                  bool aux_GN0_read = false;
                                  vartype aux_last_type_read_for_GN0 = UNKNOWN;
                                  double var_GG_0d_double_Scalar;
                                  bool aux_GG_read = false;
                                  vartype aux_last_type_read_for_GG = UNKNOWN;
                                  NestedVector<double> var_GF_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GF = UNKNOWN;
                                  cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , L , MUF , (NE+6) , 0 / \n D , AJ , AMUN , GN0 , GG , 0.0 , \n { GF } { m = 1 to NE } ] LIST";
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  // read LIST record
                                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                    cpp_template, cpp_line, parse_opts);
                                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                    cpp_template, cpp_line, parse_opts);
                                  if ((! (aux_L_read == true))) {
                                    // assign expression to variable L
                                    var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                                    aux_L_read = true;
                                    validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                                    aux_last_type_read_for_L = SCALAR_INT;
                                  } else {
                                    cpp_validate_field(var_L_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "L",
                                      cpp_template, cpp_line, parse_opts);
                                  }
                                  // assign expression to variable MUF
                                  var_MUF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                                  aux_MUF_read = true;
                                  validate_vartype_consistency("MUF", SCALAR_INT, aux_last_type_read_for_MUF);
                                  aux_last_type_read_for_MUF = SCALAR_INT;
                                  if ((! (aux_NE_read == true))) {
                                    // assign expression to variable cpp_int_val
                                    cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_cpp_int_val_read = true;
                                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                    // assign expression to variable NE
                                    var_NE_0d_int_Scalar = (cpp_int_val+(-6));
                                    aux_NE_read = true;
                                    validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                                    aux_last_type_read_for_NE = SCALAR_INT;
                                  } else {
                                    cpp_validate_field((var_NE_0d_int_Scalar+6), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(NE+6)",
                                      cpp_template, cpp_line, parse_opts);
                                  }
                                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                    cpp_template, cpp_line, parse_opts);
                                  {
                                    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    int cpp_i = 0;
                                    int cpp_j = 0;
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST body
                                    // assign expression to variable D
                                    var_D_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_D_read = true;
                                    validate_vartype_consistency("D", SCALAR_DOUBLE, aux_last_type_read_for_D);
                                    aux_last_type_read_for_D = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable AJ
                                    var_AJ_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_AJ_read = true;
                                    validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                                    aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable AMUN
                                    var_AMUN_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_AMUN_read = true;
                                    validate_vartype_consistency("AMUN", SCALAR_DOUBLE, aux_last_type_read_for_AMUN);
                                    aux_last_type_read_for_AMUN = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable GN0
                                    var_GN0_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_GN0_read = true;
                                    validate_vartype_consistency("GN0", SCALAR_DOUBLE, aux_last_type_read_for_GN0);
                                    aux_last_type_read_for_GN0 = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable GG
                                    var_GG_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_GG_read = true;
                                    validate_vartype_consistency("GG", SCALAR_DOUBLE, aux_last_type_read_for_GG);
                                    aux_last_type_read_for_GG = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }

                                    for (int var_m_0d_int_Scalar = 1;
                                       var_m_0d_int_Scalar <= var_NE_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                      bool aux_m_read = true;
                                      // read LIST body
                                      // assign expression to variable GF
                                      var_GF_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                                      aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                    }
                                    if (cpp_i != cpp_npl) {
                                      throw std::runtime_error("not exactly NPL elements consumed");
                                    }
                                  }
                                  // store data in Python dictionary
                                  if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                                    cpp_current_dict["L"] = var_L_0d_int_Scalar;
                                  }
                                  if (((aux_last_type_read_for_MUF == SCALAR_INT) && (aux_MUF_read == true))) {
                                    cpp_current_dict["MUF"] = var_MUF_0d_int_Scalar;
                                  }
                                  if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
                                    cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
                                  }
                                  if (((aux_last_type_read_for_D == SCALAR_DOUBLE) && (aux_D_read == true))) {
                                    cpp_current_dict["D"] = var_D_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_AJ == SCALAR_DOUBLE) && (aux_AJ_read == true))) {
                                    cpp_current_dict["AJ"] = var_AJ_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_AMUN == SCALAR_DOUBLE) && (aux_AMUN_read == true))) {
                                    cpp_current_dict["AMUN"] = var_AMUN_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_GN0 == SCALAR_DOUBLE) && (aux_GN0_read == true))) {
                                    cpp_current_dict["GN0"] = var_GN0_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_GG == SCALAR_DOUBLE) && (aux_GG_read == true))) {
                                    cpp_current_dict["GG"] = var_GG_0d_double_Scalar;
                                  }
                                  if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
                                    auto& cpp_curvar0 = var_GF_1d_double_NestedVector;
                                    cpp_current_dict["GF"] = py::dict();
                                    py::dict cpp_curdict0 = cpp_current_dict["GF"];
                                    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                                    }
                                  }
                                  cpp_current_dict = cpp_parent_dict;
                                }
                              }
                              // store data in Python dictionary
                              if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                                cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                              }
                              if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                                cpp_current_dict["L"] = var_L_0d_int_Scalar;
                              }
                              if (((aux_last_type_read_for_NJS == SCALAR_INT) && (aux_NJS_read == true))) {
                                cpp_current_dict["NJS"] = var_NJS_0d_int_Scalar;
                              }
                              cpp_current_dict = cpp_parent_dict;
                            }
                          }
                        }
                      }
                    }
                    if (! cpp_found_match) {
                      if (! cpp_found_match) {
                        if ((((((((((((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(0))))))||(((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(1)))))))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          // evaluate if-elif-else clause
                          {
                            bool cpp_found_match = false;
                            if (! cpp_found_match) {
                              if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                                // if statement evaluation
                                cpp_found_match = true;
                                cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                                // read TAB1 record
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                                  cpp_template, cpp_line, parse_opts);
                                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                  cpp_template, cpp_line, parse_opts);
                                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                  cpp_template, cpp_line, parse_opts);
                                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                  cpp_template, cpp_line, parse_opts);
                                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                                {
                                  Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                                  // assign expression to variable Eint
                                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                                  aux_Eint_read = true;
                                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                                  if ((! (aux_AP_read == true))) {
                                    // assign expression to variable AP
                                    var_AP_0d_floatvec_Scalar = tab_body.Y;
                                    aux_AP_read = true;
                                    validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                    aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                                  } else {
                                    if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                      cpp_validate_field(var_AP_0d_double_Scalar, tab_body.Y,  true, false, false, "AP",
                                        cpp_template, cpp_line, parse_opts);
                                    } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                      cpp_validate_field(var_AP_0d_floatvec_Scalar, tab_body.Y,  true, false, false, "AP",
                                        cpp_template, cpp_line, parse_opts);
                                    }
                                  }
                                  // assign expression to variable INT
                                  var_INT_0d_intvec_Scalar = tab_body.INT;
                                  aux_INT_read = true;
                                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                                  // assign expression to variable NBT
                                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                  aux_NBT_read = true;
                                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                                }
                              }
                            }
                          }
                          // evaluate if-elif-else clause
                          {
                            bool cpp_found_match = false;
                            if (! cpp_found_match) {
                              if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                                // if statement evaluation
                                cpp_found_match = true;
                                cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , LSSF , 0 , NLS , 0 ] CONT";
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                // read CONT record
                                if ((! (aux_SPI_read == true))) {
                                  // assign expression to variable SPI
                                  var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                  aux_SPI_read = true;
                                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                                } else {
                                  cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                    cpp_template, cpp_line, parse_opts);
                                }
                                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                  cpp_template, cpp_line, parse_opts);
                                // assign expression to variable LSSF
                                var_LSSF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                                aux_LSSF_read = true;
                                validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                                aux_last_type_read_for_LSSF = SCALAR_INT;
                                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                  cpp_template, cpp_line, parse_opts);
                                if ((! (aux_NLS_read == true))) {
                                  // assign expression to variable NLS
                                  var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                  aux_NLS_read = true;
                                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                  aux_last_type_read_for_NLS = SCALAR_INT;
                                } else {
                                  cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                    cpp_template, cpp_line, parse_opts);
                                }
                                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                  cpp_template, cpp_line, parse_opts);
                              }
                            }
                            if (! cpp_found_match) {
                              cpp_template = "[ MAT , 2 , 151 / SPI , AP , LSSF , 0 , NLS , 0 ] CONT";
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read CONT record
                              if ((! (aux_SPI_read == true))) {
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              } else {
                                cpp_validate_field(var_SPI_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "SPI",
                                  cpp_template, cpp_line, parse_opts);
                              }
                              if ((! (aux_AP_read == true))) {
                                // assign expression to variable AP
                                var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                                aux_AP_read = true;
                                validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                                aux_last_type_read_for_AP = SCALAR_DOUBLE;
                              } else {
                                if (((aux_last_type_read_for_AP == SCALAR_DOUBLE))) {
                                  cpp_validate_field(var_AP_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                    cpp_template, cpp_line, parse_opts);
                                } else if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC))) {
                                  cpp_validate_field(var_AP_0d_floatvec_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AP",
                                    cpp_template, cpp_line, parse_opts);
                                }
                              }
                              // assign expression to variable LSSF
                              var_LSSF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                              aux_LSSF_read = true;
                              validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                              aux_last_type_read_for_LSSF = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              if ((! (aux_NLS_read == true))) {
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } else {
                                cpp_validate_field(var_NLS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NLS",
                                  cpp_template, cpp_line, parse_opts);
                              }
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                            }
                          }

                          for (int var_p_0d_int_Scalar = 1;
                             var_p_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                            bool aux_p_read = true;
                            // open section l_group
                            {
                              py::dict cpp_parent_dict = cpp_current_dict;
                              if ((! cpp_parent_dict.contains("l_group"))) {
                                cpp_parent_dict["l_group"] = py::dict();
                              }
                              py::dict cpp_current_dict = cpp_parent_dict["l_group"];
                              if ((! cpp_current_dict.contains(py::cast(var_p_0d_int_Scalar)))) {
                                cpp_current_dict[py::cast(var_p_0d_int_Scalar)] = py::dict();
                              }
                              cpp_current_dict = cpp_current_dict[py::cast(var_p_0d_int_Scalar)];
                              // variable declarations
                              double var_AWRI_0d_double_Scalar;
                              bool aux_AWRI_read = false;
                              vartype aux_last_type_read_for_AWRI = UNKNOWN;
                              int var_L_0d_int_Scalar;
                              bool aux_L_read = false;
                              vartype aux_last_type_read_for_L = UNKNOWN;
                              int var_NJS_0d_int_Scalar;
                              bool aux_NJS_read = false;
                              vartype aux_last_type_read_for_NJS = UNKNOWN;
                              cpp_template = "[ MAT , 2 , 151 / AWRI , 0.0 , L , 0 , NJS , 0 ] CONT";
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read CONT record
                              // assign expression to variable AWRI
                              var_AWRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                              aux_AWRI_read = true;
                              validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                              aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable L
                              var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                              aux_L_read = true;
                              validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                              aux_last_type_read_for_L = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);
                              // assign expression to variable NJS
                              var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              aux_NJS_read = true;
                              validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                              aux_last_type_read_for_NJS = SCALAR_INT;
                              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                cpp_template, cpp_line, parse_opts);

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // open section subsec
                                {
                                  py::dict cpp_parent_dict = cpp_current_dict;
                                  if ((! cpp_parent_dict.contains("subsec"))) {
                                    cpp_parent_dict["subsec"] = py::dict();
                                  }
                                  py::dict cpp_current_dict = cpp_parent_dict["subsec"];
                                  if ((! cpp_current_dict.contains(py::cast(var_n_0d_int_Scalar)))) {
                                    cpp_current_dict[py::cast(var_n_0d_int_Scalar)] = py::dict();
                                  }
                                  cpp_current_dict = cpp_current_dict[py::cast(var_n_0d_int_Scalar)];
                                  // variable declarations
                                  double var_AJ_0d_double_Scalar;
                                  bool aux_AJ_read = false;
                                  vartype aux_last_type_read_for_AJ = UNKNOWN;
                                  int var_INT_0d_int_Scalar;
                                  bool aux_INT_read = false;
                                  vartype aux_last_type_read_for_INT = UNKNOWN;
                                  int cpp_int_val;
                                  bool aux_cpp_int_val_read = false;
                                  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                  int var_NE_0d_int_Scalar;
                                  bool aux_NE_read = false;
                                  vartype aux_last_type_read_for_NE = UNKNOWN;
                                  double var_AMUX_0d_double_Scalar;
                                  bool aux_AMUX_read = false;
                                  vartype aux_last_type_read_for_AMUX = UNKNOWN;
                                  double var_AMUN_0d_double_Scalar;
                                  bool aux_AMUN_read = false;
                                  vartype aux_last_type_read_for_AMUN = UNKNOWN;
                                  double var_AMUG_0d_double_Scalar;
                                  bool aux_AMUG_read = false;
                                  vartype aux_last_type_read_for_AMUG = UNKNOWN;
                                  double var_AMUF_0d_double_Scalar;
                                  bool aux_AMUF_read = false;
                                  vartype aux_last_type_read_for_AMUF = UNKNOWN;
                                  NestedVector<double> var_ES_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_ES = UNKNOWN;
                                  NestedVector<double> var_D_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_D = UNKNOWN;
                                  NestedVector<double> var_GX_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GX = UNKNOWN;
                                  NestedVector<double> var_GN0_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GN0 = UNKNOWN;
                                  NestedVector<double> var_GG_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GG = UNKNOWN;
                                  NestedVector<double> var_GF_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GF = UNKNOWN;
                                  cpp_template = "[ MAT , 2 , 151 / AJ , 0.0 , INT , 0 , ((6*NE)+6) , NE / \n 0.0 , 0.0 , AMUX , AMUN , AMUG , AMUF , \n { ES , D , GX , GN0 , GG , GF } { m = 1 to NE } ] LIST";
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  // read LIST record
                                  // assign expression to variable AJ
                                  var_AJ_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                  aux_AJ_read = true;
                                  validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                                  aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                                    cpp_template, cpp_line, parse_opts);
                                  if ((! (aux_INT_read == true))) {
                                    // assign expression to variable INT
                                    var_INT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                                    aux_INT_read = true;
                                    validate_vartype_consistency("INT", SCALAR_INT, aux_last_type_read_for_INT);
                                    aux_last_type_read_for_INT = SCALAR_INT;
                                  } else {
                                    cpp_validate_field(var_INT_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "INT",
                                      cpp_template, cpp_line, parse_opts);
                                  }
                                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                    cpp_template, cpp_line, parse_opts);
                                  // assign expression to variable cpp_int_val
                                  cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                  aux_cpp_int_val_read = true;
                                  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                  // assign expression to variable NE
                                  var_NE_0d_int_Scalar = ((cpp_int_val+(-6))/6);
                                  aux_NE_read = true;
                                  validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                                  aux_last_type_read_for_NE = SCALAR_INT;
                                  if ((! (aux_NE_read == true))) {
                                    // assign expression to variable NE
                                    var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                                    aux_NE_read = true;
                                    validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                                    aux_last_type_read_for_NE = SCALAR_INT;
                                  } else {
                                    cpp_validate_field(var_NE_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NE",
                                      cpp_template, cpp_line, parse_opts);
                                  }
                                  {
                                    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    int cpp_i = 0;
                                    int cpp_j = 0;
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST body
                                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable AMUX
                                    var_AMUX_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_AMUX_read = true;
                                    validate_vartype_consistency("AMUX", SCALAR_DOUBLE, aux_last_type_read_for_AMUX);
                                    aux_last_type_read_for_AMUX = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable AMUN
                                    var_AMUN_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_AMUN_read = true;
                                    validate_vartype_consistency("AMUN", SCALAR_DOUBLE, aux_last_type_read_for_AMUN);
                                    aux_last_type_read_for_AMUN = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable AMUG
                                    var_AMUG_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_AMUG_read = true;
                                    validate_vartype_consistency("AMUG", SCALAR_DOUBLE, aux_last_type_read_for_AMUG);
                                    aux_last_type_read_for_AMUG = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable AMUF
                                    var_AMUF_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_AMUF_read = true;
                                    validate_vartype_consistency("AMUF", SCALAR_DOUBLE, aux_last_type_read_for_AMUF);
                                    aux_last_type_read_for_AMUF = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }

                                    for (int var_m_0d_int_Scalar = 1;
                                       var_m_0d_int_Scalar <= var_NE_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                      bool aux_m_read = true;
                                      // read LIST body
                                      // assign expression to variable ES
                                      var_ES_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                                      aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable D
                                      var_D_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("D", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_D);
                                      aux_last_type_read_for_D = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable GX
                                      var_GX_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("GX", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GX);
                                      aux_last_type_read_for_GX = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable GN0
                                      var_GN0_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("GN0", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN0);
                                      aux_last_type_read_for_GN0 = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable GG
                                      var_GG_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                                      aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable GF
                                      var_GF_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                      validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                                      aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                    }
                                    if (cpp_i != cpp_npl) {
                                      throw std::runtime_error("not exactly NPL elements consumed");
                                    }
                                  }
                                  // store data in Python dictionary
                                  if (((aux_last_type_read_for_AJ == SCALAR_DOUBLE) && (aux_AJ_read == true))) {
                                    cpp_current_dict["AJ"] = var_AJ_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_INT == SCALAR_INT) && (aux_INT_read == true))) {
                                    cpp_current_dict["INT"] = var_INT_0d_int_Scalar;
                                  }
                                  if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
                                    cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
                                  }
                                  if (((aux_last_type_read_for_AMUX == SCALAR_DOUBLE) && (aux_AMUX_read == true))) {
                                    cpp_current_dict["AMUX"] = var_AMUX_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_AMUN == SCALAR_DOUBLE) && (aux_AMUN_read == true))) {
                                    cpp_current_dict["AMUN"] = var_AMUN_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_AMUG == SCALAR_DOUBLE) && (aux_AMUG_read == true))) {
                                    cpp_current_dict["AMUG"] = var_AMUG_0d_double_Scalar;
                                  }
                                  if (((aux_last_type_read_for_AMUF == SCALAR_DOUBLE) && (aux_AMUF_read == true))) {
                                    cpp_current_dict["AMUF"] = var_AMUF_0d_double_Scalar;
                                  }
                                  if ((var_ES_1d_double_NestedVector.get_last_index() != -1)) {
                                    auto& cpp_curvar0 = var_ES_1d_double_NestedVector;
                                    cpp_current_dict["ES"] = py::dict();
                                    py::dict cpp_curdict0 = cpp_current_dict["ES"];
                                    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                                    }
                                  }
                                  if ((var_D_1d_double_NestedVector.get_last_index() != -1)) {
                                    auto& cpp_curvar0 = var_D_1d_double_NestedVector;
                                    cpp_current_dict["D"] = py::dict();
                                    py::dict cpp_curdict0 = cpp_current_dict["D"];
                                    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                                    }
                                  }
                                  if ((var_GX_1d_double_NestedVector.get_last_index() != -1)) {
                                    auto& cpp_curvar0 = var_GX_1d_double_NestedVector;
                                    cpp_current_dict["GX"] = py::dict();
                                    py::dict cpp_curdict0 = cpp_current_dict["GX"];
                                    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                                    }
                                  }
                                  if ((var_GN0_1d_double_NestedVector.get_last_index() != -1)) {
                                    auto& cpp_curvar0 = var_GN0_1d_double_NestedVector;
                                    cpp_current_dict["GN0"] = py::dict();
                                    py::dict cpp_curdict0 = cpp_current_dict["GN0"];
                                    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                                    }
                                  }
                                  if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                                    auto& cpp_curvar0 = var_GG_1d_double_NestedVector;
                                    cpp_current_dict["GG"] = py::dict();
                                    py::dict cpp_curdict0 = cpp_current_dict["GG"];
                                    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                                    }
                                  }
                                  if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
                                    auto& cpp_curvar0 = var_GF_1d_double_NestedVector;
                                    cpp_current_dict["GF"] = py::dict();
                                    py::dict cpp_curdict0 = cpp_current_dict["GF"];
                                    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                                    }
                                  }
                                  cpp_current_dict = cpp_parent_dict;
                                }
                              }
                              // store data in Python dictionary
                              if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                                cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                              }
                              if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                                cpp_current_dict["L"] = var_L_0d_int_Scalar;
                              }
                              if (((aux_last_type_read_for_NJS == SCALAR_INT) && (aux_NJS_read == true))) {
                                cpp_current_dict["NJS"] = var_NJS_0d_int_Scalar;
                              }
                              cpp_current_dict = cpp_parent_dict;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_EL == SCALAR_DOUBLE) && (aux_EL_read == true))) {
            cpp_current_dict["EL"] = var_EL_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_EH == SCALAR_DOUBLE) && (aux_EH_read == true))) {
            cpp_current_dict["EH"] = var_EH_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_LRU == SCALAR_INT) && (aux_LRU_read == true))) {
            cpp_current_dict["LRU"] = var_LRU_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_LRF == SCALAR_INT) && (aux_LRF_read == true))) {
            cpp_current_dict["LRF"] = var_LRF_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NRO == SCALAR_INT) && (aux_NRO_read == true))) {
            cpp_current_dict["NRO"] = var_NRO_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NAPS == SCALAR_INT) && (aux_NAPS_read == true))) {
            cpp_current_dict["NAPS"] = var_NAPS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_SPI == SCALAR_DOUBLE) && (aux_SPI_read == true))) {
            cpp_current_dict["SPI"] = var_SPI_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_AP == SCALAR_DOUBLE) && (aux_AP_read == true))) {
            cpp_current_dict["AP"] = var_AP_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_AP == SCALAR_FLOATVEC) && (aux_AP_read == true))) {
            cpp_current_dict["AP"] = var_AP_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_NLS == SCALAR_INT) && (aux_NLS_read == true))) {
            cpp_current_dict["NLS"] = var_NLS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
            cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
            cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
          }
          if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
            cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
          }
          if (((aux_last_type_read_for_LAD == SCALAR_INT) && (aux_LAD_read == true))) {
            cpp_current_dict["LAD"] = var_LAD_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NLSC == SCALAR_INT) && (aux_NLSC_read == true))) {
            cpp_current_dict["NLSC"] = var_NLSC_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_IFG == SCALAR_INT) && (aux_IFG_read == true))) {
            cpp_current_dict["IFG"] = var_IFG_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_KRM == SCALAR_INT) && (aux_KRM_read == true))) {
            cpp_current_dict["KRM"] = var_KRM_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NJS == SCALAR_INT) && (aux_NJS_read == true))) {
            cpp_current_dict["NJS"] = var_NJS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_KRL == SCALAR_INT) && (aux_KRL_read == true))) {
            cpp_current_dict["KRL"] = var_KRL_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NPP == SCALAR_INT) && (aux_NPP_read == true))) {
            cpp_current_dict["NPP"] = var_NPP_0d_int_Scalar;
          }
          if ((var_MA_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_MA_1d_double_NestedVector;
            cpp_current_dict["MA"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["MA"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_MB_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_MB_1d_double_NestedVector;
            cpp_current_dict["MB"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["MB"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_ZA_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_ZA_1d_double_NestedVector;
            cpp_current_dict["ZA"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["ZA"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_ZB_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_ZB_1d_double_NestedVector;
            cpp_current_dict["ZB"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["ZB"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_IA_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_IA_1d_double_NestedVector;
            cpp_current_dict["IA"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["IA"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_IB_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_IB_1d_double_NestedVector;
            cpp_current_dict["IB"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["IB"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_Q_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_Q_1d_double_NestedVector;
            cpp_current_dict["Q"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["Q"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_PNT_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_PNT_1d_double_NestedVector;
            cpp_current_dict["PNT"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["PNT"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_SHF_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_SHF_1d_double_NestedVector;
            cpp_current_dict["SHF"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["SHF"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_MT_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_MT_1d_double_NestedVector;
            cpp_current_dict["MT"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["MT"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_PA_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_PA_1d_double_NestedVector;
            cpp_current_dict["PA"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["PA"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_PB_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_PB_1d_double_NestedVector;
            cpp_current_dict["PB"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["PB"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if (((aux_last_type_read_for_LSSF == SCALAR_INT) && (aux_LSSF_read == true))) {
            cpp_current_dict["LSSF"] = var_LSSF_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
            cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
          }
          if ((var_ES_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_ES_1d_double_NestedVector;
            cpp_current_dict["ES"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["ES"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_ZAI == SCALAR_DOUBLE) && (aux_ZAI_read == true))) {
        cpp_current_dict["ZAI"] = var_ZAI_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_ABN == SCALAR_DOUBLE) && (aux_ABN_read == true))) {
        cpp_current_dict["ABN"] = var_ABN_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_LFW == SCALAR_INT) && (aux_LFW_read == true))) {
        cpp_current_dict["LFW"] = var_LFW_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NER == SCALAR_INT) && (aux_NER_read == true))) {
        cpp_current_dict["NER"] = var_NER_0d_int_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NIS == SCALAR_INT) && (aux_NIS_read == true))) {
    cpp_current_dict["NIS"] = var_NIS_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: b060c9a10c5a2def7c0e13f02c35f9ae
// MD5 hash of the following function definition: 19608fb7f1ad76c3573fc8a1d02f0dbd
py::dict parse_mf3_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  double var_QM_0d_double_Scalar;
  bool aux_QM_read = false;
  vartype aux_last_type_read_for_QM = UNKNOWN;
  double var_QI_0d_double_Scalar;
  bool aux_QI_read = false;
  vartype aux_last_type_read_for_QI = UNKNOWN;
  int var_LR_0d_int_Scalar;
  bool aux_LR_read = false;
  vartype aux_last_type_read_for_LR = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 3;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 3;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 3 , MT / ZA , AWR , 0 , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_template = "[ MAT , 3 , MT / QM , QI , 0 , LR , NR , NP / E / xs ] TAB1 ( xstable )";
  // read TAB1 record
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // assign expression to variable QM
  var_QM_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_QM_read = true;
  validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
  aux_last_type_read_for_QM = SCALAR_DOUBLE;
  // assign expression to variable QI
  var_QI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_QI_read = true;
  validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
  aux_last_type_read_for_QI = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LR
  var_LR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LR_read = true;
  validate_vartype_consistency("LR", SCALAR_INT, aux_last_type_read_for_LR);
  aux_last_type_read_for_LR = SCALAR_INT;
  {
    py::dict cpp_parent_dict = cpp_current_dict;
    if ((! cpp_parent_dict.contains("xstable"))) {
      cpp_parent_dict["xstable"] = py::dict();
    }
    py::dict cpp_current_dict = cpp_parent_dict["xstable"];
    cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
    // variable declarations
    std::vector<double> var_E_0d_floatvec_Scalar;
    bool aux_E_read = false;
    vartype aux_last_type_read_for_E = UNKNOWN;
    std::vector<double> var_xs_0d_floatvec_Scalar;
    bool aux_xs_read = false;
    vartype aux_last_type_read_for_xs = UNKNOWN;
    std::vector<int> var_INT_0d_intvec_Scalar;
    bool aux_INT_read = false;
    vartype aux_last_type_read_for_INT = UNKNOWN;
    std::vector<int> var_NBT_0d_intvec_Scalar;
    bool aux_NBT_read = false;
    vartype aux_last_type_read_for_NBT = UNKNOWN;
    {
      Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
      // assign expression to variable E
      var_E_0d_floatvec_Scalar = tab_body.X;
      aux_E_read = true;
      validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
      aux_last_type_read_for_E = SCALAR_FLOATVEC;
      // assign expression to variable xs
      var_xs_0d_floatvec_Scalar = tab_body.Y;
      aux_xs_read = true;
      validate_vartype_consistency("xs", SCALAR_FLOATVEC, aux_last_type_read_for_xs);
      aux_last_type_read_for_xs = SCALAR_FLOATVEC;
      // assign expression to variable INT
      var_INT_0d_intvec_Scalar = tab_body.INT;
      aux_INT_read = true;
      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
      aux_last_type_read_for_INT = SCALAR_INTVEC;
      // assign expression to variable NBT
      var_NBT_0d_intvec_Scalar = tab_body.NBT;
      aux_NBT_read = true;
      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
      aux_last_type_read_for_NBT = SCALAR_INTVEC;
    }
    // store data in Python dictionary
    if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
      cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
    }
    if (((aux_last_type_read_for_xs == SCALAR_FLOATVEC) && (aux_xs_read == true))) {
      cpp_current_dict["xs"] = var_xs_0d_floatvec_Scalar;
    }
    if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
      cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
    }
    if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
      cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
    }
    cpp_current_dict = cpp_parent_dict;
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_QM == SCALAR_DOUBLE) && (aux_QM_read == true))) {
    cpp_current_dict["QM"] = var_QM_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_QI == SCALAR_DOUBLE) && (aux_QI_read == true))) {
    cpp_current_dict["QI"] = var_QI_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LR == SCALAR_INT) && (aux_LR_read == true))) {
    cpp_current_dict["LR"] = var_LR_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: c4d60855b8643a410283ef0c47845391
// MD5 hash of the following function definition: 0cfa985288ebd8f09143f83e4c36e003
py::dict parse_mf4_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LTT_0d_int_Scalar;
  bool aux_LTT_read = false;
  vartype aux_last_type_read_for_LTT = UNKNOWN;
  int var_LI_0d_int_Scalar;
  bool aux_LI_read = false;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_LCT_0d_int_Scalar;
  bool aux_LCT_read = false;
  vartype aux_last_type_read_for_LCT = UNKNOWN;
  int var_NM_0d_int_Scalar;
  bool aux_NM_read = false;
  vartype aux_last_type_read_for_NM = UNKNOWN;
  int var_NE_0d_int_Scalar;
  bool aux_NE_read = false;
  vartype aux_last_type_read_for_NE = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  double var_T_0d_double_Scalar;
  bool aux_T_read = false;
  vartype aux_last_type_read_for_T = UNKNOWN;
  NestedVector<double> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  int var_LT_0d_int_Scalar;
  bool aux_LT_read = false;
  vartype aux_last_type_read_for_LT = UNKNOWN;
  NestedVector<int> var_NL_1d_int_NestedVector;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  NestedVector<NestedVector<double>> var_a_2d_double_NestedVector;
  NestedVector<double>* ptr_a_2d_idx0;
  vartype aux_last_type_read_for_a = UNKNOWN;
  int var_NE1_0d_int_Scalar;
  bool aux_NE1_read = false;
  vartype aux_last_type_read_for_NE1 = UNKNOWN;
  NestedVector<NestedVector<double>> var_al_2d_double_NestedVector;
  NestedVector<double>* ptr_al_2d_idx0;
  vartype aux_last_type_read_for_al = UNKNOWN;
  int var_NE2_0d_int_Scalar;
  bool aux_NE2_read = false;
  vartype aux_last_type_read_for_NE2 = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 4;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 4;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 4 , MT / ZA , AWR , 0 , LTT , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LTT
  var_LTT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LTT_read = true;
  validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
  aux_last_type_read_for_LTT = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        std::streampos cpp_old_streampos = cont.tellg();
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LTT_0d_int_Scalar = var_LTT_0d_int_Scalar;
          int var_LTT_0d_int_Scalar = glob_var_LTT_0d_int_Scalar;
          bool& glob_aux_LTT_read = aux_LTT_read;
          bool aux_LTT_read = glob_aux_LTT_read;
          vartype aux_last_type_read_for_LTT = UNKNOWN;
          int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
          int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
          bool& glob_aux_LI_read = aux_LI_read;
          bool aux_LI_read = glob_aux_LI_read;
          vartype aux_last_type_read_for_LI = UNKNOWN;
          int& glob_var_LCT_0d_int_Scalar = var_LCT_0d_int_Scalar;
          int var_LCT_0d_int_Scalar = glob_var_LCT_0d_int_Scalar;
          bool& glob_aux_LCT_read = aux_LCT_read;
          bool aux_LCT_read = glob_aux_LCT_read;
          vartype aux_last_type_read_for_LCT = UNKNOWN;
          int& glob_var_NM_0d_int_Scalar = var_NM_0d_int_Scalar;
          int var_NM_0d_int_Scalar = glob_var_NM_0d_int_Scalar;
          bool& glob_aux_NM_read = aux_NM_read;
          bool aux_NM_read = glob_aux_NM_read;
          vartype aux_last_type_read_for_NM = UNKNOWN;
          cpp_template = "[ MAT , 4 , MT / 0.0 , AWR , LI , LCT , 0 , NM ] CONT";
          cpp_line = cpp_read_raw_line(cont);
          // read CONT record
          if ((! (aux_AWR_read == true))) {
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          } else {
          }
          // assign expression to variable LI
          var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          // assign expression to variable LCT
          var_LCT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_LCT_read = true;
          validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
          aux_last_type_read_for_LCT = SCALAR_INT;
          // assign expression to variable NM
          var_NM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NM_read = true;
          validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
          aux_last_type_read_for_NM = SCALAR_INT;
          if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(3)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
            cpp_found_match = true;
          }
          cont.seekg(cpp_old_streampos);
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 4 , MT / 0.0 , AWR , LI , LCT , 0 , NM ] CONT";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          if ((! (aux_AWR_read == true))) {
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          } else {
            cpp_validate_field(var_AWR_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AWR",
              cpp_template, cpp_line, parse_opts);
          }
          // assign expression to variable LI
          var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          // assign expression to variable LCT
          var_LCT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_LCT_read = true;
          validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
          aux_last_type_read_for_LCT = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NM
          var_NM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NM_read = true;
          validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
          aux_last_type_read_for_NM = SCALAR_INT;
        }
      }
    }
    if (! cpp_found_match) {
      cpp_template = "[ MAT , 4 , MT / 0.0 , AWR , LI , LCT , 0 , 0 ] CONT";
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read CONT record
      cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
        cpp_template, cpp_line, parse_opts);
      if ((! (aux_AWR_read == true))) {
        // assign expression to variable AWR
        var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
        aux_AWR_read = true;
        validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
        aux_last_type_read_for_AWR = SCALAR_DOUBLE;
      } else {
        cpp_validate_field(var_AWR_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "AWR",
          cpp_template, cpp_line, parse_opts);
      }
      // assign expression to variable LI
      var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
      aux_LI_read = true;
      validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
      aux_last_type_read_for_LI = SCALAR_INT;
      // assign expression to variable LCT
      var_LCT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LCT_read = true;
      validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
      aux_last_type_read_for_LCT = SCALAR_INT;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
    }
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(1)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
        // read TAB2 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        // assign expression to variable NE
        var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
        aux_NE_read = true;
        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
        aux_last_type_read_for_NE = SCALAR_INT;
        cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        {
          Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }

        for (int var_i_0d_int_Scalar = 1;
           var_i_0d_int_Scalar <= var_NE_0d_int_Scalar; var_i_0d_int_Scalar++) {
          bool aux_i_read = true;
          cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NL , 0 / { a } { l = 1 to NL } ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          // assign expression to variable T
          var_T_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_T_read = true;
          validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
          aux_last_type_read_for_T = SCALAR_DOUBLE;
          // assign expression to variable E
          var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
          validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
          aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
          // assign expression to variable LT
          var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LT_read = true;
          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
          aux_last_type_read_for_LT = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NL
          var_NL_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
          validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
          aux_last_type_read_for_NL = NESTEDVECTOR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body
            ptr_a_2d_idx0 = var_a_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

            for (int var_l_0d_int_Scalar = 1;
               var_l_0d_int_Scalar <= var_NL_1d_int_NestedVector[var_i_0d_int_Scalar]; var_l_0d_int_Scalar++) {
              bool aux_l_read = true;
              // read LIST body
              // assign expression to variable a
              ptr_a_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("a", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_a);
              aux_last_type_read_for_a = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(2)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2 ( energy_table )";
          // read TAB2 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NE
          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NE_read = true;
          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
          aux_last_type_read_for_NE = SCALAR_INT;
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            if ((! cpp_parent_dict.contains("energy_table"))) {
              cpp_parent_dict["energy_table"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict["energy_table"];
            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            // variable declarations
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
              cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
            }
            if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
              cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
            }
            cpp_current_dict = cpp_parent_dict;
          }

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_NE_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NR , NP / mu / f ] TAB1 ( angtable [ i ] )";
            // read TAB1 record
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // assign expression to variable T
            var_T_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_T_read = true;
            validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
            aux_last_type_read_for_T = SCALAR_DOUBLE;
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            // assign expression to variable LT
            var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LT_read = true;
            validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
            aux_last_type_read_for_LT = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              if ((! cpp_parent_dict.contains("angtable"))) {
                cpp_parent_dict["angtable"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict["angtable"];
              if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              // variable declarations
              std::vector<double> var_mu_0d_floatvec_Scalar;
              bool aux_mu_read = false;
              vartype aux_last_type_read_for_mu = UNKNOWN;
              std::vector<double> var_f_0d_floatvec_Scalar;
              bool aux_f_read = false;
              vartype aux_last_type_read_for_f = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                // assign expression to variable mu
                var_mu_0d_floatvec_Scalar = tab_body.X;
                aux_mu_read = true;
                validate_vartype_consistency("mu", SCALAR_FLOATVEC, aux_last_type_read_for_mu);
                aux_last_type_read_for_mu = SCALAR_FLOATVEC;
                // assign expression to variable f
                var_f_0d_floatvec_Scalar = tab_body.Y;
                aux_f_read = true;
                validate_vartype_consistency("f", SCALAR_FLOATVEC, aux_last_type_read_for_f);
                aux_last_type_read_for_f = SCALAR_FLOATVEC;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              // store data in Python dictionary
              if (((aux_last_type_read_for_mu == SCALAR_FLOATVEC) && (aux_mu_read == true))) {
                cpp_current_dict["mu"] = var_mu_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_f == SCALAR_FLOATVEC) && (aux_f_read == true))) {
                cpp_current_dict["f"] = var_f_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
              }
              if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(3)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE1 / Eint ] TAB2 ( leg_int )";
          // read TAB2 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NE1
          var_NE1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NE1_read = true;
          validate_vartype_consistency("NE1", SCALAR_INT, aux_last_type_read_for_NE1);
          aux_last_type_read_for_NE1 = SCALAR_INT;
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            if ((! cpp_parent_dict.contains("leg_int"))) {
              cpp_parent_dict["leg_int"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict["leg_int"];
            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            // variable declarations
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
              cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
            }
            if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
              cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
            }
            cpp_current_dict = cpp_parent_dict;
          }

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_NE1_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NL , 0 / \n { al } { j = 1 to NL } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            // assign expression to variable T
            var_T_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_T_read = true;
            validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
            aux_last_type_read_for_T = SCALAR_DOUBLE;
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            // assign expression to variable LT
            var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LT_read = true;
            validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
            aux_last_type_read_for_LT = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable NL
            var_NL_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
            validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
            aux_last_type_read_for_NL = NESTEDVECTOR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body
              ptr_al_2d_idx0 = var_al_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NL_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                // read LIST body
                // assign expression to variable al
                ptr_al_2d_idx0->set(var_j_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("al", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_al);
                aux_last_type_read_for_al = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
          }
          cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE2 / Eint ] TAB2 ( ang_int )";
          // read TAB2 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NE2
          var_NE2_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NE2_read = true;
          validate_vartype_consistency("NE2", SCALAR_INT, aux_last_type_read_for_NE2);
          aux_last_type_read_for_NE2 = SCALAR_INT;
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            if ((! cpp_parent_dict.contains("ang_int"))) {
              cpp_parent_dict["ang_int"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict["ang_int"];
            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            // variable declarations
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
              cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
            }
            if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
              cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
            }
            cpp_current_dict = cpp_parent_dict;
          }

          for (int var_i_0d_int_Scalar = var_NE1_0d_int_Scalar;
             var_i_0d_int_Scalar <= ((var_NE1_0d_int_Scalar+var_NE2_0d_int_Scalar)-1); var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NR , NP / mu / f ] TAB1 ( angtable [ i ] )";
            // read TAB1 record
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            if ((! (aux_T_read == true))) {
              // assign expression to variable T
              var_T_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
              aux_T_read = true;
              validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
              aux_last_type_read_for_T = SCALAR_DOUBLE;
            } else {
              cpp_validate_field(var_T_0d_double_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "T",
                cpp_template, cpp_line, parse_opts);
            }
            if ((! var_E_1d_double_NestedVector.contains(var_i_0d_int_Scalar))) {
              // assign expression to variable E
              var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            } else {
              cpp_validate_field(var_E_1d_double_NestedVector[var_i_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "E",
                cpp_template, cpp_line, parse_opts);
            }
            if ((! (aux_LT_read == true))) {
              // assign expression to variable LT
              var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LT_read = true;
              validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
              aux_last_type_read_for_LT = SCALAR_INT;
            } else {
              cpp_validate_field(var_LT_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "LT",
                cpp_template, cpp_line, parse_opts);
            }
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              if ((! cpp_parent_dict.contains("angtable"))) {
                cpp_parent_dict["angtable"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict["angtable"];
              if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              // variable declarations
              std::vector<double> var_mu_0d_floatvec_Scalar;
              bool aux_mu_read = false;
              vartype aux_last_type_read_for_mu = UNKNOWN;
              std::vector<double> var_f_0d_floatvec_Scalar;
              bool aux_f_read = false;
              vartype aux_last_type_read_for_f = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                // assign expression to variable mu
                var_mu_0d_floatvec_Scalar = tab_body.X;
                aux_mu_read = true;
                validate_vartype_consistency("mu", SCALAR_FLOATVEC, aux_last_type_read_for_mu);
                aux_last_type_read_for_mu = SCALAR_FLOATVEC;
                // assign expression to variable f
                var_f_0d_floatvec_Scalar = tab_body.Y;
                aux_f_read = true;
                validate_vartype_consistency("f", SCALAR_FLOATVEC, aux_last_type_read_for_f);
                aux_last_type_read_for_f = SCALAR_FLOATVEC;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              // store data in Python dictionary
              if (((aux_last_type_read_for_mu == SCALAR_FLOATVEC) && (aux_mu_read == true))) {
                cpp_current_dict["mu"] = var_mu_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_f == SCALAR_FLOATVEC) && (aux_f_read == true))) {
                cpp_current_dict["f"] = var_f_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
              }
              if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LTT == SCALAR_INT) && (aux_LTT_read == true))) {
    cpp_current_dict["LTT"] = var_LTT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LI == SCALAR_INT) && (aux_LI_read == true))) {
    cpp_current_dict["LI"] = var_LI_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LCT == SCALAR_INT) && (aux_LCT_read == true))) {
    cpp_current_dict["LCT"] = var_LCT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NM == SCALAR_INT) && (aux_NM_read == true))) {
    cpp_current_dict["NM"] = var_NM_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
    cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_T == SCALAR_DOUBLE) && (aux_T_read == true))) {
    cpp_current_dict["T"] = var_T_0d_double_Scalar;
  }
  if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_E_1d_double_NestedVector;
    cpp_current_dict["E"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["E"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if (((aux_last_type_read_for_LT == SCALAR_INT) && (aux_LT_read == true))) {
    cpp_current_dict["LT"] = var_LT_0d_int_Scalar;
  }
  if ((var_NL_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_NL_1d_int_NestedVector;
    cpp_current_dict["NL"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["NL"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_a_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_a_2d_double_NestedVector;
    cpp_current_dict["a"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["a"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if (((aux_last_type_read_for_NE1 == SCALAR_INT) && (aux_NE1_read == true))) {
    cpp_current_dict["NE1"] = var_NE1_0d_int_Scalar;
  }
  if ((var_al_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_al_2d_double_NestedVector;
    cpp_current_dict["al"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["al"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if (((aux_last_type_read_for_NE2 == SCALAR_INT) && (aux_NE2_read == true))) {
    cpp_current_dict["NE2"] = var_NE2_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 63861c67fded34c8e694d0399677c11f
// MD5 hash of the following function definition: 67d69ba7f9af49d564c7efd13457629c
py::dict parse_mf5_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 5;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 5;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 5 , MT / ZA , AWR , 0 , 0 , NK , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section contribution
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      if ((! cpp_parent_dict.contains("contribution"))) {
        cpp_parent_dict["contribution"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict["contribution"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      int var_LF_0d_int_Scalar;
      bool aux_LF_read = false;
      vartype aux_last_type_read_for_LF = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      NestedVector<double> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      double var_U_0d_double_Scalar;
      bool aux_U_read = false;
      vartype aux_last_type_read_for_U = UNKNOWN;
      std::vector<double> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      std::vector<double> var_p_0d_floatvec_Scalar;
      bool aux_p_read = false;
      vartype aux_last_type_read_for_p = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            std::streampos cpp_old_streampos = cont.tellg();
            {
              // variable declarations
              int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
              int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
              bool& glob_aux_LF_read = aux_LF_read;
              bool aux_LF_read = glob_aux_LF_read;
              vartype aux_last_type_read_for_LF = UNKNOWN;
              cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
              // read TAB1 record
              cpp_line = cpp_read_raw_line(cont);
              // assign expression to variable LF
              var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LF_read = true;
              validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
              aux_last_type_read_for_LF = SCALAR_INT;
              if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(1)))))))) {
                cpp_found_match = true;
              }
              cont.seekg(cpp_old_streampos);
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
              // read TAB1 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable LF
              var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LF_read = true;
              validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
              aux_last_type_read_for_LF = SCALAR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                if ((! cpp_parent_dict.contains("p_table"))) {
                  cpp_parent_dict["p_table"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict["p_table"];
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                // variable declarations
                std::vector<double> var_E_0d_floatvec_Scalar;
                bool aux_E_read = false;
                vartype aux_last_type_read_for_E = UNKNOWN;
                std::vector<double> var_p_0d_floatvec_Scalar;
                bool aux_p_read = false;
                vartype aux_last_type_read_for_p = UNKNOWN;
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                  // assign expression to variable E
                  var_E_0d_floatvec_Scalar = tab_body.X;
                  aux_E_read = true;
                  validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                  cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                }
                if (((aux_last_type_read_for_p == SCALAR_FLOATVEC) && (aux_p_read == true))) {
                  cpp_current_dict["p"] = var_p_0d_floatvec_Scalar;
                }
                if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                  cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                }
                if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                  cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                }
                cpp_current_dict = cpp_parent_dict;
              }
              cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E ] TAB2 ( E_interp )";
              // read TAB2 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                if ((! cpp_parent_dict.contains("E_interp"))) {
                  cpp_parent_dict["E_interp"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict["E_interp"];
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                // variable declarations
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                  cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                }
                if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                  cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                }
                cpp_current_dict = cpp_parent_dict;
              }

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NE_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                cpp_template = "[ MAT , 5 , MT / 0.0 , E , 0 , 0 , NR , NF / Eout / g ] TAB1 ( spectrum [ l ] )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  if ((! cpp_parent_dict.contains("spectrum"))) {
                    cpp_parent_dict["spectrum"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict["spectrum"];
                  if ((! cpp_current_dict.contains(py::cast(var_l_0d_int_Scalar)))) {
                    cpp_current_dict[py::cast(var_l_0d_int_Scalar)] = py::dict();
                  }
                  cpp_current_dict = cpp_current_dict[py::cast(var_l_0d_int_Scalar)];
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<double> var_Eout_0d_floatvec_Scalar;
                  bool aux_Eout_read = false;
                  vartype aux_last_type_read_for_Eout = UNKNOWN;
                  std::vector<double> var_g_0d_floatvec_Scalar;
                  bool aux_g_read = false;
                  vartype aux_last_type_read_for_g = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable Eout
                    var_Eout_0d_floatvec_Scalar = tab_body.X;
                    aux_Eout_read = true;
                    validate_vartype_consistency("Eout", SCALAR_FLOATVEC, aux_last_type_read_for_Eout);
                    aux_last_type_read_for_Eout = SCALAR_FLOATVEC;
                    // assign expression to variable g
                    var_g_0d_floatvec_Scalar = tab_body.Y;
                    aux_g_read = true;
                    validate_vartype_consistency("g", SCALAR_FLOATVEC, aux_last_type_read_for_g);
                    aux_last_type_read_for_g = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_Eout == SCALAR_FLOATVEC) && (aux_Eout_read == true))) {
                    cpp_current_dict["Eout"] = var_Eout_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_g == SCALAR_FLOATVEC) && (aux_g_read == true))) {
                    cpp_current_dict["g"] = var_g_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              std::streampos cpp_old_streampos = cont.tellg();
              {
                // variable declarations
                double& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                double var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_line = cpp_read_raw_line(cont);
                // assign expression to variable U
                var_U_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(5)))))))) {
                  cpp_found_match = true;
                }
                cont.seekg(cpp_old_streampos);
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  if ((! cpp_parent_dict.contains("p_table"))) {
                    cpp_parent_dict["p_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict["p_table"];
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<double> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<double> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_p == SCALAR_FLOATVEC) && (aux_p_read == true))) {
                    cpp_current_dict["p"] = var_p_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E / theta ] TAB1 ( theta_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  if ((! cpp_parent_dict.contains("theta_table"))) {
                    cpp_parent_dict["theta_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict["theta_table"];
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<double> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<double> var_theta_0d_floatvec_Scalar;
                  bool aux_theta_read = false;
                  vartype aux_last_type_read_for_theta = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable theta
                    var_theta_0d_floatvec_Scalar = tab_body.Y;
                    aux_theta_read = true;
                    validate_vartype_consistency("theta", SCALAR_FLOATVEC, aux_last_type_read_for_theta);
                    aux_last_type_read_for_theta = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_theta == SCALAR_FLOATVEC) && (aux_theta_read == true))) {
                    cpp_current_dict["theta"] = var_theta_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NF / x / g ] TAB1 ( g_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  if ((! cpp_parent_dict.contains("g_table"))) {
                    cpp_parent_dict["g_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict["g_table"];
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<double> var_x_0d_floatvec_Scalar;
                  bool aux_x_read = false;
                  vartype aux_last_type_read_for_x = UNKNOWN;
                  std::vector<double> var_g_0d_floatvec_Scalar;
                  bool aux_g_read = false;
                  vartype aux_last_type_read_for_g = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable x
                    var_x_0d_floatvec_Scalar = tab_body.X;
                    aux_x_read = true;
                    validate_vartype_consistency("x", SCALAR_FLOATVEC, aux_last_type_read_for_x);
                    aux_last_type_read_for_x = SCALAR_FLOATVEC;
                    // assign expression to variable g
                    var_g_0d_floatvec_Scalar = tab_body.Y;
                    aux_g_read = true;
                    validate_vartype_consistency("g", SCALAR_FLOATVEC, aux_last_type_read_for_g);
                    aux_last_type_read_for_g = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_x == SCALAR_FLOATVEC) && (aux_x_read == true))) {
                    cpp_current_dict["x"] = var_x_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_g == SCALAR_FLOATVEC) && (aux_g_read == true))) {
                    cpp_current_dict["g"] = var_g_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              std::streampos cpp_old_streampos = cont.tellg();
              {
                // variable declarations
                double& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                double var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_line = cpp_read_raw_line(cont);
                // assign expression to variable U
                var_U_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(7)))))))) {
                  cpp_found_match = true;
                }
                cont.seekg(cpp_old_streampos);
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  if ((! cpp_parent_dict.contains("p_table"))) {
                    cpp_parent_dict["p_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict["p_table"];
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<double> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<double> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_p == SCALAR_FLOATVEC) && (aux_p_read == true))) {
                    cpp_current_dict["p"] = var_p_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E / theta ] TAB1 ( theta_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  if ((! cpp_parent_dict.contains("theta_table"))) {
                    cpp_parent_dict["theta_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict["theta_table"];
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<double> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<double> var_theta_0d_floatvec_Scalar;
                  bool aux_theta_read = false;
                  vartype aux_last_type_read_for_theta = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable theta
                    var_theta_0d_floatvec_Scalar = tab_body.Y;
                    aux_theta_read = true;
                    validate_vartype_consistency("theta", SCALAR_FLOATVEC, aux_last_type_read_for_theta);
                    aux_last_type_read_for_theta = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_theta == SCALAR_FLOATVEC) && (aux_theta_read == true))) {
                    cpp_current_dict["theta"] = var_theta_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              std::streampos cpp_old_streampos = cont.tellg();
              {
                // variable declarations
                double& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                double var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_line = cpp_read_raw_line(cont);
                // assign expression to variable U
                var_U_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(9)))))))) {
                  cpp_found_match = true;
                }
                cont.seekg(cpp_old_streampos);
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  if ((! cpp_parent_dict.contains("p_table"))) {
                    cpp_parent_dict["p_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict["p_table"];
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<double> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<double> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_p == SCALAR_FLOATVEC) && (aux_p_read == true))) {
                    cpp_current_dict["p"] = var_p_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E / theta ] TAB1 ( theta_table )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  if ((! cpp_parent_dict.contains("theta_table"))) {
                    cpp_parent_dict["theta_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict["theta_table"];
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<double> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<double> var_theta_0d_floatvec_Scalar;
                  bool aux_theta_read = false;
                  vartype aux_last_type_read_for_theta = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable theta
                    var_theta_0d_floatvec_Scalar = tab_body.Y;
                    aux_theta_read = true;
                    validate_vartype_consistency("theta", SCALAR_FLOATVEC, aux_last_type_read_for_theta);
                    aux_last_type_read_for_theta = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
                    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_theta == SCALAR_FLOATVEC) && (aux_theta_read == true))) {
                    cpp_current_dict["theta"] = var_theta_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              std::streampos cpp_old_streampos = cont.tellg();
              {
                // variable declarations
                double& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                double var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1";
                // read TAB1 record
                cpp_line = cpp_read_raw_line(cont);
                // assign expression to variable U
                var_U_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(11)))))))) {
                  cpp_found_match = true;
                }
                cont.seekg(cpp_old_streampos);
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                {
                  Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                  // assign expression to variable E
                  var_E_0d_floatvec_Scalar = tab_body.X;
                  aux_E_read = true;
                  validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              std::streampos cpp_old_streampos = cont.tellg();
              {
                // variable declarations
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1";
                // read TAB1 record
                cpp_line = cpp_read_raw_line(cont);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(12)))))))) {
                  cpp_found_match = true;
                }
                cont.seekg(cpp_old_streampos);
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                {
                  Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                  // assign expression to variable E
                  var_E_0d_floatvec_Scalar = tab_body.X;
                  aux_E_read = true;
                  validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
              }
            }
          }
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_LF == SCALAR_INT) && (aux_LF_read == true))) {
        cpp_current_dict["LF"] = var_LF_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
        cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
      }
      if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_E_1d_double_NestedVector;
        cpp_current_dict["E"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["E"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if (((aux_last_type_read_for_U == SCALAR_DOUBLE) && (aux_U_read == true))) {
        cpp_current_dict["U"] = var_U_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
        cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_p == SCALAR_FLOATVEC) && (aux_p_read == true))) {
        cpp_current_dict["p"] = var_p_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NK == SCALAR_INT) && (aux_NK_read == true))) {
    cpp_current_dict["NK"] = var_NK_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: ca82cdd58bd8081afe9c01f911284492
// MD5 hash of the following function definition: da23da46fa60d1290e4df6950f740ba3
py::dict parse_mf6_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_JP_0d_int_Scalar;
  bool aux_JP_read = false;
  vartype aux_last_type_read_for_JP = UNKNOWN;
  int var_LCT_0d_int_Scalar;
  bool aux_LCT_read = false;
  vartype aux_last_type_read_for_LCT = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 6;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 6;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 6 , MT / ZA , AWR , JP , LCT , NK , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable JP
  var_JP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_JP_read = true;
  validate_vartype_consistency("JP", SCALAR_INT, aux_last_type_read_for_JP);
  aux_last_type_read_for_JP = SCALAR_INT;
  // assign expression to variable LCT
  var_LCT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LCT_read = true;
  validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
  aux_last_type_read_for_LCT = SCALAR_INT;
  // assign expression to variable NK
  var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NK_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      if ((! cpp_parent_dict.contains("subsection"))) {
        cpp_parent_dict["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
      // variable declarations
      double var_ZAP_0d_double_Scalar;
      bool aux_ZAP_read = false;
      vartype aux_last_type_read_for_ZAP = UNKNOWN;
      double var_AWP_0d_double_Scalar;
      bool aux_AWP_read = false;
      vartype aux_last_type_read_for_AWP = UNKNOWN;
      int var_LIP_0d_int_Scalar;
      bool aux_LIP_read = false;
      vartype aux_last_type_read_for_LIP = UNKNOWN;
      int var_LAW_0d_int_Scalar;
      bool aux_LAW_read = false;
      vartype aux_last_type_read_for_LAW = UNKNOWN;
      int var_LANG_0d_int_Scalar;
      bool aux_LANG_read = false;
      vartype aux_last_type_read_for_LANG = UNKNOWN;
      int var_LEP_0d_int_Scalar;
      bool aux_LEP_read = false;
      vartype aux_last_type_read_for_LEP = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      NestedVector<double> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      NestedVector<int> var_ND_1d_int_NestedVector;
      vartype aux_last_type_read_for_ND = UNKNOWN;
      NestedVector<int> var_NA_1d_int_NestedVector;
      vartype aux_last_type_read_for_NA = UNKNOWN;
      int cpp_int_val;
      bool aux_cpp_int_val_read = false;
      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
      NestedVector<int> var_NEP_1d_int_NestedVector;
      vartype aux_last_type_read_for_NEP = UNKNOWN;
      NestedVector<NestedVector<double>> var_Ep_2d_double_NestedVector;
      NestedVector<double>* ptr_Ep_2d_idx0;
      vartype aux_last_type_read_for_Ep = UNKNOWN;
      NestedVector<NestedVector<NestedVector<double>>> var_b_3d_double_NestedVector;
      NestedVector<double>* ptr_b_3d_idx1;
      NestedVector<NestedVector<double>>* ptr_b_3d_idx0;
      vartype aux_last_type_read_for_b = UNKNOWN;
      NestedVector<int> var_NLW_1d_int_NestedVector;
      vartype aux_last_type_read_for_NLW = UNKNOWN;
      NestedVector<int> var_NL_1d_int_NestedVector;
      vartype aux_last_type_read_for_NL = UNKNOWN;
      NestedVector<NestedVector<double>> var_A_2d_double_NestedVector;
      NestedVector<double>* ptr_A_2d_idx0;
      vartype aux_last_type_read_for_A = UNKNOWN;
      double var_SPI_0d_double_Scalar;
      bool aux_SPI_read = false;
      vartype aux_last_type_read_for_SPI = UNKNOWN;
      int var_LIDP_0d_int_Scalar;
      bool aux_LIDP_read = false;
      vartype aux_last_type_read_for_LIDP = UNKNOWN;
      NestedVector<int> var_LTP_1d_int_NestedVector;
      vartype aux_last_type_read_for_LTP = UNKNOWN;
      NestedVector<int> var_NW_1d_int_NestedVector;
      vartype aux_last_type_read_for_NW = UNKNOWN;
      double var_APSX_0d_double_Scalar;
      bool aux_APSX_read = false;
      vartype aux_last_type_read_for_APSX = UNKNOWN;
      int var_NPSX_0d_int_Scalar;
      bool aux_NPSX_read = false;
      vartype aux_last_type_read_for_NPSX = UNKNOWN;
      NestedVector<int> var_NMU_1d_int_NestedVector;
      vartype aux_last_type_read_for_NMU = UNKNOWN;
      NestedVector<NestedVector<double>> var_mu_2d_double_NestedVector;
      NestedVector<double>* ptr_mu_2d_idx0;
      vartype aux_last_type_read_for_mu = UNKNOWN;
      cpp_template = "[ MAT , 6 , MT / ZAP , AWP , LIP , LAW , NR , NP / Eint / yi ] TAB1 ( yields )";
      // read TAB1 record
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // assign expression to variable ZAP
      var_ZAP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
      aux_ZAP_read = true;
      validate_vartype_consistency("ZAP", SCALAR_DOUBLE, aux_last_type_read_for_ZAP);
      aux_last_type_read_for_ZAP = SCALAR_DOUBLE;
      // assign expression to variable AWP
      var_AWP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
      aux_AWP_read = true;
      validate_vartype_consistency("AWP", SCALAR_DOUBLE, aux_last_type_read_for_AWP);
      aux_last_type_read_for_AWP = SCALAR_DOUBLE;
      // assign expression to variable LIP
      var_LIP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
      aux_LIP_read = true;
      validate_vartype_consistency("LIP", SCALAR_INT, aux_last_type_read_for_LIP);
      aux_last_type_read_for_LIP = SCALAR_INT;
      // assign expression to variable LAW
      var_LAW_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LAW_read = true;
      validate_vartype_consistency("LAW", SCALAR_INT, aux_last_type_read_for_LAW);
      aux_last_type_read_for_LAW = SCALAR_INT;
      {
        py::dict cpp_parent_dict = cpp_current_dict;
        if ((! cpp_parent_dict.contains("yields"))) {
          cpp_parent_dict["yields"] = py::dict();
        }
        py::dict cpp_current_dict = cpp_parent_dict["yields"];
        cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
        // variable declarations
        std::vector<double> var_Eint_0d_floatvec_Scalar;
        bool aux_Eint_read = false;
        vartype aux_last_type_read_for_Eint = UNKNOWN;
        std::vector<double> var_yi_0d_floatvec_Scalar;
        bool aux_yi_read = false;
        vartype aux_last_type_read_for_yi = UNKNOWN;
        std::vector<int> var_INT_0d_intvec_Scalar;
        bool aux_INT_read = false;
        vartype aux_last_type_read_for_INT = UNKNOWN;
        std::vector<int> var_NBT_0d_intvec_Scalar;
        bool aux_NBT_read = false;
        vartype aux_last_type_read_for_NBT = UNKNOWN;
        {
          Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
          // assign expression to variable Eint
          var_Eint_0d_floatvec_Scalar = tab_body.X;
          aux_Eint_read = true;
          validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
          aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
          // assign expression to variable yi
          var_yi_0d_floatvec_Scalar = tab_body.Y;
          aux_yi_read = true;
          validate_vartype_consistency("yi", SCALAR_FLOATVEC, aux_last_type_read_for_yi);
          aux_last_type_read_for_yi = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
        // store data in Python dictionary
        if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
          cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
        }
        if (((aux_last_type_read_for_yi == SCALAR_FLOATVEC) && (aux_yi_read == true))) {
          cpp_current_dict["yi"] = var_yi_0d_floatvec_Scalar;
        }
        if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
          cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
        }
        if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
          cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
        }
        cpp_current_dict = cpp_parent_dict;
      }
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(1)))))))) {
            // if statement evaluation
            cpp_found_match = true;
            cpp_template = "[ MAT , 6 , MT / 0.0 , 0.0 , LANG , LEP , NR , NE / Eint ] TAB2";
            // read TAB2 record
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable LANG
            var_LANG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LANG_read = true;
            validate_vartype_consistency("LANG", SCALAR_INT, aux_last_type_read_for_LANG);
            aux_last_type_read_for_LANG = SCALAR_INT;
            // assign expression to variable LEP
            var_LEP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LEP_read = true;
            validate_vartype_consistency("LEP", SCALAR_INT, aux_last_type_read_for_LEP);
            aux_last_type_read_for_LEP = SCALAR_INT;
            // assign expression to variable NE
            var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NE_read = true;
            validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
            aux_last_type_read_for_NE = SCALAR_INT;
            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            {
              Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }

            for (int var_j_0d_int_Scalar = 1;
               var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
              bool aux_j_read = true;
              cpp_template = "[ MAT , 6 , MT / 0.0 , E , ND , NA , NW , NEP / \n { Ep , { b } { m = 0 to NA } } { k = 1 to NEP } ] LIST";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST record
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable E
              var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
              // assign expression to variable ND
              var_ND_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
              validate_vartype_consistency("ND", NESTEDVECTOR_INT, aux_last_type_read_for_ND);
              aux_last_type_read_for_ND = NESTEDVECTOR_INT;
              // assign expression to variable NA
              var_NA_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
              validate_vartype_consistency("NA", NESTEDVECTOR_INT, aux_last_type_read_for_NA);
              aux_last_type_read_for_NA = NESTEDVECTOR_INT;
              // assign expression to variable cpp_int_val
              cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NEP
              var_NEP_1d_int_NestedVector.set(var_j_0d_int_Scalar, (cpp_int_val/(var_NA_1d_int_NestedVector[var_j_0d_int_Scalar]+2)));
              validate_vartype_consistency("NEP", NESTEDVECTOR_INT, aux_last_type_read_for_NEP);
              aux_last_type_read_for_NEP = NESTEDVECTOR_INT;
              if ((! var_NEP_1d_int_NestedVector.contains(var_j_0d_int_Scalar))) {
                // assign expression to variable NEP
                var_NEP_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                validate_vartype_consistency("NEP", NESTEDVECTOR_INT, aux_last_type_read_for_NEP);
                aux_last_type_read_for_NEP = NESTEDVECTOR_INT;
              } else {
                cpp_validate_field(var_NEP_1d_int_NestedVector[var_j_0d_int_Scalar], cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NEP",
                  cpp_template, cpp_line, parse_opts);
              }
              {
                int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST body
                ptr_Ep_2d_idx0 = var_Ep_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);
                ptr_b_3d_idx0 = var_b_3d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                for (int var_k_0d_int_Scalar = 1;
                   var_k_0d_int_Scalar <= var_NEP_1d_int_NestedVector[var_j_0d_int_Scalar]; var_k_0d_int_Scalar++) {
                  bool aux_k_read = true;
                  // read LIST body
                  // assign expression to variable Ep
                  ptr_Ep_2d_idx0->set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                  validate_vartype_consistency("Ep", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ep);
                  aux_last_type_read_for_Ep = NESTEDVECTOR_DOUBLE;
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  ptr_b_3d_idx1 = ptr_b_3d_idx0->prepare(var_k_0d_int_Scalar);

                  for (int var_m_0d_int_Scalar = 0;
                     var_m_0d_int_Scalar <= var_NA_1d_int_NestedVector[var_j_0d_int_Scalar]; var_m_0d_int_Scalar++) {
                    bool aux_m_read = true;
                    // read LIST body
                    // assign expression to variable b
                    ptr_b_3d_idx1->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                    validate_vartype_consistency("b", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_b);
                    aux_last_type_read_for_b = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      cpp_j = 0;
                    }
                  }
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(2)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
              // read TAB2 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              {
                Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                cpp_template = "[ MAT , 6 , MT / 0.0 , E , LANG , 0 , NLW , NL / { A } { l = 1 to NLW } ] LIST";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST record
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                // assign expression to variable LANG
                var_LANG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                aux_LANG_read = true;
                validate_vartype_consistency("LANG", SCALAR_INT, aux_last_type_read_for_LANG);
                aux_last_type_read_for_LANG = SCALAR_INT;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable NLW
                var_NLW_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
                validate_vartype_consistency("NLW", NESTEDVECTOR_INT, aux_last_type_read_for_NLW);
                aux_last_type_read_for_NLW = NESTEDVECTOR_INT;
                // assign expression to variable NL
                var_NL_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = NESTEDVECTOR_INT;
                {
                  int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST body
                  ptr_A_2d_idx0 = var_A_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                  for (int var_l_0d_int_Scalar = 1;
                     var_l_0d_int_Scalar <= var_NLW_1d_int_NestedVector[var_j_0d_int_Scalar]; var_l_0d_int_Scalar++) {
                    bool aux_l_read = true;
                    // read LIST body
                    // assign expression to variable A
                    ptr_A_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                    validate_vartype_consistency("A", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_A);
                    aux_last_type_read_for_A = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      cpp_j = 0;
                    }
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(5)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / SPI , 0.0 , LIDP , 0 , NR , NE / Eint ] TAB2";
              // read TAB2 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // assign expression to variable SPI
              var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
              aux_SPI_read = true;
              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable LIDP
              var_LIDP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LIDP_read = true;
              validate_vartype_consistency("LIDP", SCALAR_INT, aux_last_type_read_for_LIDP);
              aux_last_type_read_for_LIDP = SCALAR_INT;
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              {
                Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                cpp_template = "[ MAT , 6 , MT / 0.0 , E , LTP , 0 , NW , NL / \n { A } { k = 1 to NW } ] LIST";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST record
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                // assign expression to variable LTP
                var_LTP_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
                validate_vartype_consistency("LTP", NESTEDVECTOR_INT, aux_last_type_read_for_LTP);
                aux_last_type_read_for_LTP = NESTEDVECTOR_INT;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable NW
                var_NW_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
                validate_vartype_consistency("NW", NESTEDVECTOR_INT, aux_last_type_read_for_NW);
                aux_last_type_read_for_NW = NESTEDVECTOR_INT;
                // assign expression to variable NL
                var_NL_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = NESTEDVECTOR_INT;
                {
                  int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST body
                  ptr_A_2d_idx0 = var_A_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                  for (int var_k_0d_int_Scalar = 1;
                     var_k_0d_int_Scalar <= var_NW_1d_int_NestedVector[var_j_0d_int_Scalar]; var_k_0d_int_Scalar++) {
                    bool aux_k_read = true;
                    // read LIST body
                    // assign expression to variable A
                    ptr_A_2d_idx0->set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                    validate_vartype_consistency("A", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_A);
                    aux_last_type_read_for_A = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      cpp_j = 0;
                    }
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(6)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / APSX , 0.0 , 0 , 0 , 0 , NPSX ] CONT";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read CONT record
              // assign expression to variable APSX
              var_APSX_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
              aux_APSX_read = true;
              validate_vartype_consistency("APSX", SCALAR_DOUBLE, aux_last_type_read_for_APSX);
              aux_last_type_read_for_APSX = SCALAR_DOUBLE;
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NPSX
              var_NPSX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NPSX_read = true;
              validate_vartype_consistency("NPSX", SCALAR_INT, aux_last_type_read_for_NPSX);
              aux_last_type_read_for_NPSX = SCALAR_INT;
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(7)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E ] TAB2 ( E_interpol )";
              // read TAB2 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                if ((! cpp_parent_dict.contains("E_interpol"))) {
                  cpp_parent_dict["E_interpol"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict["E_interpol"];
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                // variable declarations
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                  cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                }
                if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                  cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                }
                cpp_current_dict = cpp_parent_dict;
              }

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                cpp_template = "[ MAT , 6 , MT / 0.0 , E , 0 , 0 , NRM , NMU / mu ] TAB2 ( mu_interpol [ j ] )";
                // read TAB2 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable NMU
                var_NMU_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                validate_vartype_consistency("NMU", NESTEDVECTOR_INT, aux_last_type_read_for_NMU);
                aux_last_type_read_for_NMU = NESTEDVECTOR_INT;
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  if ((! cpp_parent_dict.contains("mu_interpol"))) {
                    cpp_parent_dict["mu_interpol"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict["mu_interpol"];
                  if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
                    cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
                  }
                  cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  // variable declarations
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
                ptr_mu_2d_idx0 = var_mu_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                for (int var_k_0d_int_Scalar = 1;
                   var_k_0d_int_Scalar <= var_NMU_1d_int_NestedVector[var_j_0d_int_Scalar]; var_k_0d_int_Scalar++) {
                  bool aux_k_read = true;
                  cpp_template = "[ MAT , 6 , MT / 0.0 , mu , 0 , 0 , NRP , NEP / Ep / f ] TAB1 ( table [ j , k ] )";
                  // read TAB1 record
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable mu
                  ptr_mu_2d_idx0->set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
                  validate_vartype_consistency("mu", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_mu);
                  aux_last_type_read_for_mu = NESTEDVECTOR_DOUBLE;
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  {
                    py::dict cpp_parent_dict = cpp_current_dict;
                    if ((! cpp_parent_dict.contains("table"))) {
                      cpp_parent_dict["table"] = py::dict();
                    }
                    py::dict cpp_current_dict = cpp_parent_dict["table"];
                    if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
                      cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
                    }
                    cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
                    if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                      cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                    }
                    cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                    cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    // variable declarations
                    std::vector<double> var_Ep_0d_floatvec_Scalar;
                    bool aux_Ep_read = false;
                    vartype aux_last_type_read_for_Ep = UNKNOWN;
                    std::vector<double> var_f_0d_floatvec_Scalar;
                    bool aux_f_read = false;
                    vartype aux_last_type_read_for_f = UNKNOWN;
                    std::vector<int> var_INT_0d_intvec_Scalar;
                    bool aux_INT_read = false;
                    vartype aux_last_type_read_for_INT = UNKNOWN;
                    std::vector<int> var_NBT_0d_intvec_Scalar;
                    bool aux_NBT_read = false;
                    vartype aux_last_type_read_for_NBT = UNKNOWN;
                    {
                      Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                      // assign expression to variable Ep
                      var_Ep_0d_floatvec_Scalar = tab_body.X;
                      aux_Ep_read = true;
                      validate_vartype_consistency("Ep", SCALAR_FLOATVEC, aux_last_type_read_for_Ep);
                      aux_last_type_read_for_Ep = SCALAR_FLOATVEC;
                      // assign expression to variable f
                      var_f_0d_floatvec_Scalar = tab_body.Y;
                      aux_f_read = true;
                      validate_vartype_consistency("f", SCALAR_FLOATVEC, aux_last_type_read_for_f);
                      aux_last_type_read_for_f = SCALAR_FLOATVEC;
                      // assign expression to variable INT
                      var_INT_0d_intvec_Scalar = tab_body.INT;
                      aux_INT_read = true;
                      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                      aux_last_type_read_for_INT = SCALAR_INTVEC;
                      // assign expression to variable NBT
                      var_NBT_0d_intvec_Scalar = tab_body.NBT;
                      aux_NBT_read = true;
                      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                      aux_last_type_read_for_NBT = SCALAR_INTVEC;
                    }
                    // store data in Python dictionary
                    if (((aux_last_type_read_for_Ep == SCALAR_FLOATVEC) && (aux_Ep_read == true))) {
                      cpp_current_dict["Ep"] = var_Ep_0d_floatvec_Scalar;
                    }
                    if (((aux_last_type_read_for_f == SCALAR_FLOATVEC) && (aux_f_read == true))) {
                      cpp_current_dict["f"] = var_f_0d_floatvec_Scalar;
                    }
                    if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                      cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                    }
                    if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                      cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                    }
                    cpp_current_dict = cpp_parent_dict;
                  }
                }
              }
            }
          }
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_ZAP == SCALAR_DOUBLE) && (aux_ZAP_read == true))) {
        cpp_current_dict["ZAP"] = var_ZAP_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_AWP == SCALAR_DOUBLE) && (aux_AWP_read == true))) {
        cpp_current_dict["AWP"] = var_AWP_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_LIP == SCALAR_INT) && (aux_LIP_read == true))) {
        cpp_current_dict["LIP"] = var_LIP_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LAW == SCALAR_INT) && (aux_LAW_read == true))) {
        cpp_current_dict["LAW"] = var_LAW_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LANG == SCALAR_INT) && (aux_LANG_read == true))) {
        cpp_current_dict["LANG"] = var_LANG_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LEP == SCALAR_INT) && (aux_LEP_read == true))) {
        cpp_current_dict["LEP"] = var_LEP_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
        cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_E_1d_double_NestedVector;
        cpp_current_dict["E"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["E"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if ((var_ND_1d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_ND_1d_int_NestedVector;
        cpp_current_dict["ND"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["ND"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if ((var_NA_1d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_NA_1d_int_NestedVector;
        cpp_current_dict["NA"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["NA"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if ((var_NEP_1d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_NEP_1d_int_NestedVector;
        cpp_current_dict["NEP"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["NEP"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if ((var_Ep_2d_double_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_Ep_2d_double_NestedVector;
        cpp_current_dict["Ep"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["Ep"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
          cpp_curdict0[py::cast(cpp_i1)] = py::dict();
          py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
          for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
            cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
          }
        }
      }
      if ((var_b_3d_double_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_b_3d_double_NestedVector;
        cpp_current_dict["b"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["b"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
          cpp_curdict0[py::cast(cpp_i1)] = py::dict();
          py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
          for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
            auto& cpp_curvar2 = cpp_curvar1[cpp_i2];
            cpp_curdict1[py::cast(cpp_i2)] = py::dict();
            py::dict cpp_curdict2 = cpp_curdict1[py::cast(cpp_i2)];
            for (int cpp_i3 = cpp_curvar2.get_start_index(); cpp_i3 <= cpp_curvar2.get_last_index(); cpp_i3++) {
              cpp_curdict2[py::cast(cpp_i3)] = cpp_curvar2[cpp_i3];
            }
          }
        }
      }
      if ((var_NLW_1d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_NLW_1d_int_NestedVector;
        cpp_current_dict["NLW"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["NLW"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if ((var_NL_1d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_NL_1d_int_NestedVector;
        cpp_current_dict["NL"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["NL"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if ((var_A_2d_double_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_A_2d_double_NestedVector;
        cpp_current_dict["A"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["A"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
          cpp_curdict0[py::cast(cpp_i1)] = py::dict();
          py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
          for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
            cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
          }
        }
      }
      if (((aux_last_type_read_for_SPI == SCALAR_DOUBLE) && (aux_SPI_read == true))) {
        cpp_current_dict["SPI"] = var_SPI_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_LIDP == SCALAR_INT) && (aux_LIDP_read == true))) {
        cpp_current_dict["LIDP"] = var_LIDP_0d_int_Scalar;
      }
      if ((var_LTP_1d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_LTP_1d_int_NestedVector;
        cpp_current_dict["LTP"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["LTP"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if ((var_NW_1d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_NW_1d_int_NestedVector;
        cpp_current_dict["NW"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["NW"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if (((aux_last_type_read_for_APSX == SCALAR_DOUBLE) && (aux_APSX_read == true))) {
        cpp_current_dict["APSX"] = var_APSX_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_NPSX == SCALAR_INT) && (aux_NPSX_read == true))) {
        cpp_current_dict["NPSX"] = var_NPSX_0d_int_Scalar;
      }
      if ((var_NMU_1d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_NMU_1d_int_NestedVector;
        cpp_current_dict["NMU"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["NMU"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if ((var_mu_2d_double_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_mu_2d_double_NestedVector;
        cpp_current_dict["mu"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["mu"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
          cpp_curdict0[py::cast(cpp_i1)] = py::dict();
          py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
          for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
            cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
          }
        }
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_JP == SCALAR_INT) && (aux_JP_read == true))) {
    cpp_current_dict["JP"] = var_JP_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LCT == SCALAR_INT) && (aux_LCT_read == true))) {
    cpp_current_dict["LCT"] = var_LCT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NK == SCALAR_INT) && (aux_NK_read == true))) {
    cpp_current_dict["NK"] = var_NK_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: bd9c9da4de018928918c4acb82f32a0a
// MD5 hash of the following function definition: 53816a09cb4c12afb8e1a5f9332284b7
py::dict parse_mf7mt2_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LTHR_0d_int_Scalar;
  bool aux_LTHR_read = false;
  vartype aux_last_type_read_for_LTHR = UNKNOWN;
  double var_T0_0d_double_Scalar;
  bool aux_T0_read = false;
  vartype aux_last_type_read_for_T0 = UNKNOWN;
  int var_LT_0d_int_Scalar;
  bool aux_LT_read = false;
  vartype aux_last_type_read_for_LT = UNKNOWN;
  NestedVector<double> var_T_1d_double_NestedVector;
  vartype aux_last_type_read_for_T = UNKNOWN;
  int var_LI_0d_int_Scalar;
  bool aux_LI_read = false;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_NP_0d_int_Scalar;
  bool aux_NP_read = false;
  vartype aux_last_type_read_for_NP = UNKNOWN;
  NestedVector<NestedVector<double>> var_S_2d_double_NestedVector;
  NestedVector<double>* ptr_S_2d_idx0;
  vartype aux_last_type_read_for_S = UNKNOWN;
  double var_SB_0d_double_Scalar;
  bool aux_SB_read = false;
  vartype aux_last_type_read_for_SB = UNKNOWN;
  std::vector<double> var_Tint_0d_floatvec_Scalar;
  bool aux_Tint_read = false;
  vartype aux_last_type_read_for_Tint = UNKNOWN;
  std::vector<double> var_Wp_0d_floatvec_Scalar;
  bool aux_Wp_read = false;
  vartype aux_last_type_read_for_Wp = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 7;
  int mt = 2;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 7;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 2;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 7 , 2 / ZA , AWR , LTHR , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LTHR
  var_LTHR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LTHR_read = true;
  validate_vartype_consistency("LTHR", SCALAR_INT, aux_last_type_read_for_LTHR);
  aux_last_type_read_for_LTHR = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_LTHR_read == true)) && ((var_LTHR_0d_int_Scalar)==(1)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 2 / T0 , 0.0 , LT , 0 , NR , NP / Eint / S ] TAB1 ( S_T0_table )";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        // assign expression to variable T0
        var_T0_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
        aux_T0_read = true;
        validate_vartype_consistency("T0", SCALAR_DOUBLE, aux_last_type_read_for_T0);
        aux_last_type_read_for_T0 = SCALAR_DOUBLE;
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        // assign expression to variable LT
        var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
        aux_LT_read = true;
        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
        aux_last_type_read_for_LT = SCALAR_INT;
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          if ((! cpp_parent_dict.contains("S_T0_table"))) {
            cpp_parent_dict["S_T0_table"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict["S_T0_table"];
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          // variable declarations
          std::vector<double> var_Eint_0d_floatvec_Scalar;
          bool aux_Eint_read = false;
          vartype aux_last_type_read_for_Eint = UNKNOWN;
          std::vector<double> var_S_0d_floatvec_Scalar;
          bool aux_S_read = false;
          vartype aux_last_type_read_for_S = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Eint
            var_Eint_0d_floatvec_Scalar = tab_body.X;
            aux_Eint_read = true;
            validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
            aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
            // assign expression to variable S
            var_S_0d_floatvec_Scalar = tab_body.Y;
            aux_S_read = true;
            validate_vartype_consistency("S", SCALAR_FLOATVEC, aux_last_type_read_for_S);
            aux_last_type_read_for_S = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
            cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_S == SCALAR_FLOATVEC) && (aux_S_read == true))) {
            cpp_current_dict["S"] = var_S_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
            cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
          }
          if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
            cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
          }
          cpp_current_dict = cpp_parent_dict;
        }

        for (int var_i_0d_int_Scalar = 1;
           var_i_0d_int_Scalar <= var_LT_0d_int_Scalar; var_i_0d_int_Scalar++) {
          bool aux_i_read = true;
          cpp_template = "[ MAT , 7 , 2 / T , 0.0 , LI , 0 , NP , 0 / \n { S } { q = 1 to NP } ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          // assign expression to variable T
          var_T_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts));
          validate_vartype_consistency("T", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_T);
          aux_last_type_read_for_T = NESTEDVECTOR_DOUBLE;
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable LI
          var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NP
          var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NP_read = true;
          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
          aux_last_type_read_for_NP = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body

            for (int var_q_0d_int_Scalar = 1;
               var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
              bool aux_q_read = true;
              // read LIST body
              // assign expression to variable S
              ptr_S_2d_idx0 = var_S_2d_double_NestedVector.prepare(var_q_0d_int_Scalar);
              ptr_S_2d_idx0->set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("S", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_S);
              aux_last_type_read_for_S = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LTHR_read == true)) && ((var_LTHR_0d_int_Scalar)==(2)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 7 , 2 / SB , 0.0 , 0 , 0 , NR , NP / Tint / Wp ] TAB1";
          // read TAB1 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // assign expression to variable SB
          var_SB_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_SB_read = true;
          validate_vartype_consistency("SB", SCALAR_DOUBLE, aux_last_type_read_for_SB);
          aux_last_type_read_for_SB = SCALAR_DOUBLE;
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          {
            Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Wp
            var_Wp_0d_floatvec_Scalar = tab_body.Y;
            aux_Wp_read = true;
            validate_vartype_consistency("Wp", SCALAR_FLOATVEC, aux_last_type_read_for_Wp);
            aux_last_type_read_for_Wp = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LTHR_read == true)) && ((var_LTHR_0d_int_Scalar)==(3)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 7 , 2 / T0 , 0.0 , LT , 0 , NR , NP / Eint / S ] TAB1 ( S_T0_table )";
          // read TAB1 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // assign expression to variable T0
          var_T0_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_T0_read = true;
          validate_vartype_consistency("T0", SCALAR_DOUBLE, aux_last_type_read_for_T0);
          aux_last_type_read_for_T0 = SCALAR_DOUBLE;
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable LT
          var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LT_read = true;
          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
          aux_last_type_read_for_LT = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            if ((! cpp_parent_dict.contains("S_T0_table"))) {
              cpp_parent_dict["S_T0_table"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict["S_T0_table"];
            cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            // variable declarations
            std::vector<double> var_Eint_0d_floatvec_Scalar;
            bool aux_Eint_read = false;
            vartype aux_last_type_read_for_Eint = UNKNOWN;
            std::vector<double> var_S_0d_floatvec_Scalar;
            bool aux_S_read = false;
            vartype aux_last_type_read_for_S = UNKNOWN;
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
              // assign expression to variable Eint
              var_Eint_0d_floatvec_Scalar = tab_body.X;
              aux_Eint_read = true;
              validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
              aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
              // assign expression to variable S
              var_S_0d_floatvec_Scalar = tab_body.Y;
              aux_S_read = true;
              validate_vartype_consistency("S", SCALAR_FLOATVEC, aux_last_type_read_for_S);
              aux_last_type_read_for_S = SCALAR_FLOATVEC;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
              cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
            }
            if (((aux_last_type_read_for_S == SCALAR_FLOATVEC) && (aux_S_read == true))) {
              cpp_current_dict["S"] = var_S_0d_floatvec_Scalar;
            }
            if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
              cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
            }
            if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
              cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
            }
            cpp_current_dict = cpp_parent_dict;
          }

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_LT_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 7 , 2 / T , 0.0 , LI , 0 , NP , 0 / \n { S } { q = 1 to NP } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            // assign expression to variable T
            var_T_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts));
            validate_vartype_consistency("T", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_T);
            aux_last_type_read_for_T = NESTEDVECTOR_DOUBLE;
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable LI
            var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // assign expression to variable NP
            var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NP_read = true;
            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
            aux_last_type_read_for_NP = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body

              for (int var_q_0d_int_Scalar = 1;
                 var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
                bool aux_q_read = true;
                // read LIST body
                // assign expression to variable S
                ptr_S_2d_idx0 = var_S_2d_double_NestedVector.prepare(var_q_0d_int_Scalar);
                ptr_S_2d_idx0->set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("S", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_S);
                aux_last_type_read_for_S = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
          }
          cpp_template = "[ MAT , 7 , 2 / SB , 0.0 , 0 , 0 , NR , NP / Tint / Wp ] TAB1";
          // read TAB1 record
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // assign expression to variable SB
          var_SB_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_SB_read = true;
          validate_vartype_consistency("SB", SCALAR_DOUBLE, aux_last_type_read_for_SB);
          aux_last_type_read_for_SB = SCALAR_DOUBLE;
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          {
            Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Wp
            var_Wp_0d_floatvec_Scalar = tab_body.Y;
            aux_Wp_read = true;
            validate_vartype_consistency("Wp", SCALAR_FLOATVEC, aux_last_type_read_for_Wp);
            aux_last_type_read_for_Wp = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LTHR == SCALAR_INT) && (aux_LTHR_read == true))) {
    cpp_current_dict["LTHR"] = var_LTHR_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_T0 == SCALAR_DOUBLE) && (aux_T0_read == true))) {
    cpp_current_dict["T0"] = var_T0_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LT == SCALAR_INT) && (aux_LT_read == true))) {
    cpp_current_dict["LT"] = var_LT_0d_int_Scalar;
  }
  if ((var_T_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_T_1d_double_NestedVector;
    cpp_current_dict["T"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["T"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if (((aux_last_type_read_for_LI == SCALAR_INT) && (aux_LI_read == true))) {
    cpp_current_dict["LI"] = var_LI_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NP == SCALAR_INT) && (aux_NP_read == true))) {
    cpp_current_dict["NP"] = var_NP_0d_int_Scalar;
  }
  if ((var_S_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_S_2d_double_NestedVector;
    cpp_current_dict["S"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["S"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if (((aux_last_type_read_for_SB == SCALAR_DOUBLE) && (aux_SB_read == true))) {
    cpp_current_dict["SB"] = var_SB_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_Tint == SCALAR_FLOATVEC) && (aux_Tint_read == true))) {
    cpp_current_dict["Tint"] = var_Tint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_Wp == SCALAR_FLOATVEC) && (aux_Wp_read == true))) {
    cpp_current_dict["Wp"] = var_Wp_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: a3934a161c54e232c57d90823e77ee29
// MD5 hash of the following function definition: 3c52690623b89342f83bfe0201c4f244
py::dict parse_mf7mt4_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LAT_0d_int_Scalar;
  bool aux_LAT_read = false;
  vartype aux_last_type_read_for_LAT = UNKNOWN;
  int var_LASYM_0d_int_Scalar;
  bool aux_LASYM_read = false;
  vartype aux_last_type_read_for_LASYM = UNKNOWN;
  int var_LLN_0d_int_Scalar;
  bool aux_LLN_read = false;
  vartype aux_last_type_read_for_LLN = UNKNOWN;
  int var_NI_0d_int_Scalar;
  bool aux_NI_read = false;
  vartype aux_last_type_read_for_NI = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  NestedVector<double> var_B_1d_double_NestedVector;
  vartype aux_last_type_read_for_B = UNKNOWN;
  int var_NB_0d_int_Scalar;
  bool aux_NB_read = false;
  vartype aux_last_type_read_for_NB = UNKNOWN;
  double var_T0_0d_double_Scalar;
  bool aux_T0_read = false;
  vartype aux_last_type_read_for_T0 = UNKNOWN;
  NestedVector<double> var_beta_1d_double_NestedVector;
  vartype aux_last_type_read_for_beta = UNKNOWN;
  NestedVector<int> var_LT_1d_int_NestedVector;
  vartype aux_last_type_read_for_LT = UNKNOWN;
  NestedVector<double> var_T_1d_double_NestedVector;
  vartype aux_last_type_read_for_T = UNKNOWN;
  NestedVector<int> var_LI_1d_int_NestedVector;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_NP_0d_int_Scalar;
  bool aux_NP_read = false;
  vartype aux_last_type_read_for_NP = UNKNOWN;
  NestedVector<NestedVector<NestedVector<double>>> var_S_3d_double_NestedVector;
  NestedVector<double>* ptr_S_3d_idx1;
  NestedVector<NestedVector<double>>* ptr_S_3d_idx0;
  vartype aux_last_type_read_for_S = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 7;
  int mt = 4;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 7;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 4;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 7 , 4 / ZA , AWR , 0 , LAT , LASYM , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LAT
  var_LAT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LAT_read = true;
  validate_vartype_consistency("LAT", SCALAR_INT, aux_last_type_read_for_LAT);
  aux_last_type_read_for_LAT = SCALAR_INT;
  // assign expression to variable LASYM
  var_LASYM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_LASYM_read = true;
  validate_vartype_consistency("LASYM", SCALAR_INT, aux_last_type_read_for_LASYM);
  aux_last_type_read_for_LASYM = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , LLN , 0 , NI , NS / { B } { n = 1 to NI } ] LIST";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read LIST record
  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LLN
  var_LLN_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LLN_read = true;
  validate_vartype_consistency("LLN", SCALAR_INT, aux_last_type_read_for_LLN);
  aux_last_type_read_for_LLN = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NI
  var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NI_read = true;
  validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
  aux_last_type_read_for_NI = SCALAR_INT;
  // assign expression to variable NS
  var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  {
    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST body

    for (int var_n_0d_int_Scalar = 1;
       var_n_0d_int_Scalar <= var_NI_0d_int_Scalar; var_n_0d_int_Scalar++) {
      bool aux_n_read = true;
      // read LIST body
      // assign expression to variable B
      var_B_1d_double_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("B", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_B);
      aux_last_type_read_for_B = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }
  cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NB / beta_int ] TAB2 ( beta_interp )";
  // read TAB2 record
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NB
  var_NB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NB_read = true;
  validate_vartype_consistency("NB", SCALAR_INT, aux_last_type_read_for_NB);
  aux_last_type_read_for_NB = SCALAR_INT;
  {
    py::dict cpp_parent_dict = cpp_current_dict;
    if ((! cpp_parent_dict.contains("beta_interp"))) {
      cpp_parent_dict["beta_interp"] = py::dict();
    }
    py::dict cpp_current_dict = cpp_parent_dict["beta_interp"];
    cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    // variable declarations
    std::vector<int> var_INT_0d_intvec_Scalar;
    bool aux_INT_read = false;
    vartype aux_last_type_read_for_INT = UNKNOWN;
    std::vector<int> var_NBT_0d_intvec_Scalar;
    bool aux_NBT_read = false;
    vartype aux_last_type_read_for_NBT = UNKNOWN;
    {
      Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
      // assign expression to variable INT
      var_INT_0d_intvec_Scalar = tab_body.INT;
      aux_INT_read = true;
      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
      aux_last_type_read_for_INT = SCALAR_INTVEC;
      // assign expression to variable NBT
      var_NBT_0d_intvec_Scalar = tab_body.NBT;
      aux_NBT_read = true;
      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
      aux_last_type_read_for_NBT = SCALAR_INTVEC;
    }
    // store data in Python dictionary
    if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
      cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
    }
    if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
      cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
    }
    cpp_current_dict = cpp_parent_dict;
  }

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NB_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 7 , 4 / T0 , beta , LT , 0 , NR , NP / alpha / S ] TAB1 ( S_table [ i ] )";
    // read TAB1 record
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // assign expression to variable T0
    var_T0_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
    aux_T0_read = true;
    validate_vartype_consistency("T0", SCALAR_DOUBLE, aux_last_type_read_for_T0);
    aux_last_type_read_for_T0 = SCALAR_DOUBLE;
    // assign expression to variable beta
    var_beta_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
    validate_vartype_consistency("beta", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_beta);
    aux_last_type_read_for_beta = NESTEDVECTOR_DOUBLE;
    // assign expression to variable LT
    var_LT_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
    validate_vartype_consistency("LT", NESTEDVECTOR_INT, aux_last_type_read_for_LT);
    aux_last_type_read_for_LT = NESTEDVECTOR_INT;
    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
      cpp_template, cpp_line, parse_opts);
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      if ((! cpp_parent_dict.contains("S_table"))) {
        cpp_parent_dict["S_table"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict["S_table"];
      if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
      cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
      // variable declarations
      std::vector<double> var_alpha_0d_floatvec_Scalar;
      bool aux_alpha_read = false;
      vartype aux_last_type_read_for_alpha = UNKNOWN;
      std::vector<double> var_S_0d_floatvec_Scalar;
      bool aux_S_read = false;
      vartype aux_last_type_read_for_S = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      {
        Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
        // assign expression to variable alpha
        var_alpha_0d_floatvec_Scalar = tab_body.X;
        aux_alpha_read = true;
        validate_vartype_consistency("alpha", SCALAR_FLOATVEC, aux_last_type_read_for_alpha);
        aux_last_type_read_for_alpha = SCALAR_FLOATVEC;
        // assign expression to variable S
        var_S_0d_floatvec_Scalar = tab_body.Y;
        aux_S_read = true;
        validate_vartype_consistency("S", SCALAR_FLOATVEC, aux_last_type_read_for_S);
        aux_last_type_read_for_S = SCALAR_FLOATVEC;
        // assign expression to variable INT
        var_INT_0d_intvec_Scalar = tab_body.INT;
        aux_INT_read = true;
        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
        aux_last_type_read_for_INT = SCALAR_INTVEC;
        // assign expression to variable NBT
        var_NBT_0d_intvec_Scalar = tab_body.NBT;
        aux_NBT_read = true;
        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
        aux_last_type_read_for_NBT = SCALAR_INTVEC;
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_alpha == SCALAR_FLOATVEC) && (aux_alpha_read == true))) {
        cpp_current_dict["alpha"] = var_alpha_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_S == SCALAR_FLOATVEC) && (aux_S_read == true))) {
        cpp_current_dict["S"] = var_S_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }

    for (int var_j_0d_int_Scalar = 1;
       var_j_0d_int_Scalar <= var_LT_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
      bool aux_j_read = true;
      cpp_template = "[ MAT , 7 , 4 / T , beta , LI , 0 , NP , 0 / { S } { q = 1 to NP } ] LIST";
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read LIST record
      // assign expression to variable T
      var_T_1d_double_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts));
      validate_vartype_consistency("T", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_T);
      aux_last_type_read_for_T = NESTEDVECTOR_DOUBLE;
      if ((! var_beta_1d_double_NestedVector.contains(var_i_0d_int_Scalar))) {
        // assign expression to variable beta
        var_beta_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
        validate_vartype_consistency("beta", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_beta);
        aux_last_type_read_for_beta = NESTEDVECTOR_DOUBLE;
      } else {
        cpp_validate_field(var_beta_1d_double_NestedVector[var_i_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "beta",
          cpp_template, cpp_line, parse_opts);
      }
      // assign expression to variable LI
      var_LI_1d_int_NestedVector.set(var_j_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
      validate_vartype_consistency("LI", NESTEDVECTOR_INT, aux_last_type_read_for_LI);
      aux_last_type_read_for_LI = NESTEDVECTOR_INT;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
      // assign expression to variable NP
      var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      aux_NP_read = true;
      validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
      aux_last_type_read_for_NP = SCALAR_INT;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
      {
        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        int cpp_i = 0;
        int cpp_j = 0;
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        // read LIST body

        for (int var_q_0d_int_Scalar = 1;
           var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
          bool aux_q_read = true;
          // read LIST body
          // assign expression to variable S
          ptr_S_3d_idx0 = var_S_3d_double_NestedVector.prepare(var_q_0d_int_Scalar);
          ptr_S_3d_idx1 = ptr_S_3d_idx0->prepare(var_i_0d_int_Scalar);
          ptr_S_3d_idx1->set(var_j_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("S", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_S);
          aux_last_type_read_for_S = NESTEDVECTOR_DOUBLE;
          cpp_i++;
          cpp_j++;
          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            cpp_j = 0;
          }
        }
        if (cpp_i != cpp_npl) {
          throw std::runtime_error("not exactly NPL elements consumed");
        }
      }
    }
  }
  cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff0 ] TAB1 ( teff0_table )";
  // read TAB1 record
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  {
    py::dict cpp_parent_dict = cpp_current_dict;
    if ((! cpp_parent_dict.contains("teff0_table"))) {
      cpp_parent_dict["teff0_table"] = py::dict();
    }
    py::dict cpp_current_dict = cpp_parent_dict["teff0_table"];
    cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
    // variable declarations
    std::vector<double> var_Tint_0d_floatvec_Scalar;
    bool aux_Tint_read = false;
    vartype aux_last_type_read_for_Tint = UNKNOWN;
    std::vector<double> var_Teff0_0d_floatvec_Scalar;
    bool aux_Teff0_read = false;
    vartype aux_last_type_read_for_Teff0 = UNKNOWN;
    std::vector<int> var_INT_0d_intvec_Scalar;
    bool aux_INT_read = false;
    vartype aux_last_type_read_for_INT = UNKNOWN;
    std::vector<int> var_NBT_0d_intvec_Scalar;
    bool aux_NBT_read = false;
    vartype aux_last_type_read_for_NBT = UNKNOWN;
    {
      Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
      // assign expression to variable Tint
      var_Tint_0d_floatvec_Scalar = tab_body.X;
      aux_Tint_read = true;
      validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
      aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
      // assign expression to variable Teff0
      var_Teff0_0d_floatvec_Scalar = tab_body.Y;
      aux_Teff0_read = true;
      validate_vartype_consistency("Teff0", SCALAR_FLOATVEC, aux_last_type_read_for_Teff0);
      aux_last_type_read_for_Teff0 = SCALAR_FLOATVEC;
      // assign expression to variable INT
      var_INT_0d_intvec_Scalar = tab_body.INT;
      aux_INT_read = true;
      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
      aux_last_type_read_for_INT = SCALAR_INTVEC;
      // assign expression to variable NBT
      var_NBT_0d_intvec_Scalar = tab_body.NBT;
      aux_NBT_read = true;
      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
      aux_last_type_read_for_NBT = SCALAR_INTVEC;
    }
    // store data in Python dictionary
    if (((aux_last_type_read_for_Tint == SCALAR_FLOATVEC) && (aux_Tint_read == true))) {
      cpp_current_dict["Tint"] = var_Tint_0d_floatvec_Scalar;
    }
    if (((aux_last_type_read_for_Teff0 == SCALAR_FLOATVEC) && (aux_Teff0_read == true))) {
      cpp_current_dict["Teff0"] = var_Teff0_0d_floatvec_Scalar;
    }
    if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
      cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
    }
    if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
      cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
    }
    cpp_current_dict = cpp_parent_dict;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_NI_read == true)) && ((var_NI_0d_int_Scalar)>=(7)))))&&(((var_B_1d_double_NestedVector.contains(7)) && ((var_B_1d_double_NestedVector[7])==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff1 ] TAB1 ( teff1_table )";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          if ((! cpp_parent_dict.contains("teff1_table"))) {
            cpp_parent_dict["teff1_table"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict["teff1_table"];
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          // variable declarations
          std::vector<double> var_Tint_0d_floatvec_Scalar;
          bool aux_Tint_read = false;
          vartype aux_last_type_read_for_Tint = UNKNOWN;
          std::vector<double> var_Teff1_0d_floatvec_Scalar;
          bool aux_Teff1_read = false;
          vartype aux_last_type_read_for_Teff1 = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Teff1
            var_Teff1_0d_floatvec_Scalar = tab_body.Y;
            aux_Teff1_read = true;
            validate_vartype_consistency("Teff1", SCALAR_FLOATVEC, aux_last_type_read_for_Teff1);
            aux_last_type_read_for_Teff1 = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_Tint == SCALAR_FLOATVEC) && (aux_Tint_read == true))) {
            cpp_current_dict["Tint"] = var_Tint_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_Teff1 == SCALAR_FLOATVEC) && (aux_Teff1_read == true))) {
            cpp_current_dict["Teff1"] = var_Teff1_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
            cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
          }
          if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
            cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
    }
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_NI_read == true)) && ((var_NI_0d_int_Scalar)>=(13)))))&&(((var_B_1d_double_NestedVector.contains(13)) && ((var_B_1d_double_NestedVector[13])==(0.0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff2 ] TAB1 ( teff2_table )";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          if ((! cpp_parent_dict.contains("teff2_table"))) {
            cpp_parent_dict["teff2_table"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict["teff2_table"];
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          // variable declarations
          std::vector<double> var_Tint_0d_floatvec_Scalar;
          bool aux_Tint_read = false;
          vartype aux_last_type_read_for_Tint = UNKNOWN;
          std::vector<double> var_Teff2_0d_floatvec_Scalar;
          bool aux_Teff2_read = false;
          vartype aux_last_type_read_for_Teff2 = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Teff2
            var_Teff2_0d_floatvec_Scalar = tab_body.Y;
            aux_Teff2_read = true;
            validate_vartype_consistency("Teff2", SCALAR_FLOATVEC, aux_last_type_read_for_Teff2);
            aux_last_type_read_for_Teff2 = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_Tint == SCALAR_FLOATVEC) && (aux_Tint_read == true))) {
            cpp_current_dict["Tint"] = var_Tint_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_Teff2 == SCALAR_FLOATVEC) && (aux_Teff2_read == true))) {
            cpp_current_dict["Teff2"] = var_Teff2_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
            cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
          }
          if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
            cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
    }
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_NI_read == true)) && ((var_NI_0d_int_Scalar)>=(19)))))&&(((var_B_1d_double_NestedVector.contains(19)) && ((var_B_1d_double_NestedVector[19])==(0.0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff3 ] TAB1 ( teff3_table )";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          if ((! cpp_parent_dict.contains("teff3_table"))) {
            cpp_parent_dict["teff3_table"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict["teff3_table"];
          cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          // variable declarations
          std::vector<double> var_Tint_0d_floatvec_Scalar;
          bool aux_Tint_read = false;
          vartype aux_last_type_read_for_Tint = UNKNOWN;
          std::vector<double> var_Teff3_0d_floatvec_Scalar;
          bool aux_Teff3_read = false;
          vartype aux_last_type_read_for_Teff3 = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Teff3
            var_Teff3_0d_floatvec_Scalar = tab_body.Y;
            aux_Teff3_read = true;
            validate_vartype_consistency("Teff3", SCALAR_FLOATVEC, aux_last_type_read_for_Teff3);
            aux_last_type_read_for_Teff3 = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_Tint == SCALAR_FLOATVEC) && (aux_Tint_read == true))) {
            cpp_current_dict["Tint"] = var_Tint_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_Teff3 == SCALAR_FLOATVEC) && (aux_Teff3_read == true))) {
            cpp_current_dict["Teff3"] = var_Teff3_0d_floatvec_Scalar;
          }
          if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
            cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
          }
          if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
            cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LAT == SCALAR_INT) && (aux_LAT_read == true))) {
    cpp_current_dict["LAT"] = var_LAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LASYM == SCALAR_INT) && (aux_LASYM_read == true))) {
    cpp_current_dict["LASYM"] = var_LASYM_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LLN == SCALAR_INT) && (aux_LLN_read == true))) {
    cpp_current_dict["LLN"] = var_LLN_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NI == SCALAR_INT) && (aux_NI_read == true))) {
    cpp_current_dict["NI"] = var_NI_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NS == SCALAR_INT) && (aux_NS_read == true))) {
    cpp_current_dict["NS"] = var_NS_0d_int_Scalar;
  }
  if ((var_B_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_B_1d_double_NestedVector;
    cpp_current_dict["B"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["B"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if (((aux_last_type_read_for_NB == SCALAR_INT) && (aux_NB_read == true))) {
    cpp_current_dict["NB"] = var_NB_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_T0 == SCALAR_DOUBLE) && (aux_T0_read == true))) {
    cpp_current_dict["T0"] = var_T0_0d_double_Scalar;
  }
  if ((var_beta_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_beta_1d_double_NestedVector;
    cpp_current_dict["beta"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["beta"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_LT_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_LT_1d_int_NestedVector;
    cpp_current_dict["LT"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["LT"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_T_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_T_1d_double_NestedVector;
    cpp_current_dict["T"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["T"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_LI_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_LI_1d_int_NestedVector;
    cpp_current_dict["LI"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["LI"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if (((aux_last_type_read_for_NP == SCALAR_INT) && (aux_NP_read == true))) {
    cpp_current_dict["NP"] = var_NP_0d_int_Scalar;
  }
  if ((var_S_3d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_S_3d_double_NestedVector;
    cpp_current_dict["S"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["S"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        auto& cpp_curvar2 = cpp_curvar1[cpp_i2];
        cpp_curdict1[py::cast(cpp_i2)] = py::dict();
        py::dict cpp_curdict2 = cpp_curdict1[py::cast(cpp_i2)];
        for (int cpp_i3 = cpp_curvar2.get_start_index(); cpp_i3 <= cpp_curvar2.get_last_index(); cpp_i3++) {
          cpp_curdict2[py::cast(cpp_i3)] = cpp_curvar2[cpp_i3];
        }
      }
    }
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 0468c7052e96f983d6f680ae2b54c677
// MD5 hash of the following function definition: c521117e9495e8edc3a49a181d62606d
py::dict parse_mf7mt451_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NA_0d_int_Scalar;
  bool aux_NA_read = false;
  vartype aux_last_type_read_for_NA = UNKNOWN;
  int var_NAS_0d_int_Scalar;
  bool aux_NAS_read = false;
  vartype aux_last_type_read_for_NAS = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<int> var_NI_1d_int_NestedVector;
  vartype aux_last_type_read_for_NI = UNKNOWN;
  NestedVector<NestedVector<double>> var_ZAI_2d_double_NestedVector;
  NestedVector<double>* ptr_ZAI_2d_idx0;
  vartype aux_last_type_read_for_ZAI = UNKNOWN;
  NestedVector<NestedVector<double>> var_LISI_2d_double_NestedVector;
  NestedVector<double>* ptr_LISI_2d_idx0;
  vartype aux_last_type_read_for_LISI = UNKNOWN;
  NestedVector<NestedVector<double>> var_AFI_2d_double_NestedVector;
  NestedVector<double>* ptr_AFI_2d_idx0;
  vartype aux_last_type_read_for_AFI = UNKNOWN;
  NestedVector<NestedVector<double>> var_AWRI_2d_double_NestedVector;
  NestedVector<double>* ptr_AWRI_2d_idx0;
  vartype aux_last_type_read_for_AWRI = UNKNOWN;
  NestedVector<NestedVector<double>> var_SFI_2d_double_NestedVector;
  NestedVector<double>* ptr_SFI_2d_idx0;
  vartype aux_last_type_read_for_SFI = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 7;
  int mt = 451;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 7;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 451;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 7 , 451 / ZA , AWR , NA , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable NA
  var_NA_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_NA_read = true;
  validate_vartype_consistency("NA", SCALAR_INT, aux_last_type_read_for_NA);
  aux_last_type_read_for_NA = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NA_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 7 , 451 / 0 , 0 , NAS , 0 , (6*NI) , NI / \n { ZAI , LISI , AFI , AWRI , SFI , 0 } { j = 1 to NI } ] LIST";
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST record
    cpp_validate_field(0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0",
      cpp_template, cpp_line, parse_opts);
    cpp_validate_field(0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0",
      cpp_template, cpp_line, parse_opts);
    // assign expression to variable NAS
    var_NAS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
    aux_NAS_read = true;
    validate_vartype_consistency("NAS", SCALAR_INT, aux_last_type_read_for_NAS);
    aux_last_type_read_for_NAS = SCALAR_INT;
    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
      cpp_template, cpp_line, parse_opts);
    // assign expression to variable cpp_int_val
    cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    aux_cpp_int_val_read = true;
    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
    // assign expression to variable NI
    var_NI_1d_int_NestedVector.set(var_i_0d_int_Scalar, (cpp_int_val/6));
    validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
    aux_last_type_read_for_NI = NESTEDVECTOR_INT;
    if ((! var_NI_1d_int_NestedVector.contains(var_i_0d_int_Scalar))) {
      // assign expression to variable NI
      var_NI_1d_int_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
      validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
      aux_last_type_read_for_NI = NESTEDVECTOR_INT;
    } else {
      cpp_validate_field(var_NI_1d_int_NestedVector[var_i_0d_int_Scalar], cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NI",
        cpp_template, cpp_line, parse_opts);
    }
    {
      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      int cpp_i = 0;
      int cpp_j = 0;
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read LIST body
      ptr_ZAI_2d_idx0 = var_ZAI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_LISI_2d_idx0 = var_LISI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_AFI_2d_idx0 = var_AFI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_AWRI_2d_idx0 = var_AWRI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_SFI_2d_idx0 = var_SFI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

      for (int var_j_0d_int_Scalar = 1;
         var_j_0d_int_Scalar <= var_NI_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
        bool aux_j_read = true;
        // read LIST body
        // assign expression to variable ZAI
        ptr_ZAI_2d_idx0->set(var_j_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
        validate_vartype_consistency("ZAI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAI);
        aux_last_type_read_for_ZAI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        // assign expression to variable LISI
        ptr_LISI_2d_idx0->set(var_j_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
        validate_vartype_consistency("LISI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_LISI);
        aux_last_type_read_for_LISI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        // assign expression to variable AFI
        ptr_AFI_2d_idx0->set(var_j_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
        validate_vartype_consistency("AFI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AFI);
        aux_last_type_read_for_AFI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        // assign expression to variable AWRI
        ptr_AWRI_2d_idx0->set(var_j_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
        validate_vartype_consistency("AWRI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AWRI);
        aux_last_type_read_for_AWRI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        // assign expression to variable SFI
        ptr_SFI_2d_idx0->set(var_j_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
        validate_vartype_consistency("SFI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SFI);
        aux_last_type_read_for_SFI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        cpp_validate_field(0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
      }
      if (cpp_i != cpp_npl) {
        throw std::runtime_error("not exactly NPL elements consumed");
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NA == SCALAR_INT) && (aux_NA_read == true))) {
    cpp_current_dict["NA"] = var_NA_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NAS == SCALAR_INT) && (aux_NAS_read == true))) {
    cpp_current_dict["NAS"] = var_NAS_0d_int_Scalar;
  }
  if ((var_NI_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_NI_1d_int_NestedVector;
    cpp_current_dict["NI"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["NI"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_ZAI_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_ZAI_2d_double_NestedVector;
    cpp_current_dict["ZAI"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["ZAI"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_LISI_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_LISI_2d_double_NestedVector;
    cpp_current_dict["LISI"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["LISI"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_AFI_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_AFI_2d_double_NestedVector;
    cpp_current_dict["AFI"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["AFI"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_AWRI_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_AWRI_2d_double_NestedVector;
    cpp_current_dict["AWRI"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["AWRI"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_SFI_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_SFI_2d_double_NestedVector;
    cpp_current_dict["SFI"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["SFI"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: e0fff507053b212e2ece7181a9f7fb15
// MD5 hash of the following function definition: 69d3515848c2ed87c40c9e9e4bc36b88
py::dict parse_mf8_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_LISO_0d_int_Scalar;
  bool aux_LISO_read = false;
  vartype aux_last_type_read_for_LISO = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  int var_NO_0d_int_Scalar;
  bool aux_NO_read = false;
  vartype aux_last_type_read_for_NO = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 8;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 8 , MT / ZA , AWR , LIS , LISO , NS , NO ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  // assign expression to variable LISO
  var_LISO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LISO_read = true;
  validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
  aux_last_type_read_for_LISO = SCALAR_INT;
  // assign expression to variable NS
  var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  // assign expression to variable NO
  var_NO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NO_read = true;
  validate_vartype_consistency("NO", SCALAR_INT, aux_last_type_read_for_NO);
  aux_last_type_read_for_NO = SCALAR_INT;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_NO_read == true)) && ((var_NO_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;

        for (int var_k_0d_int_Scalar = 1;
           var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
          bool aux_k_read = true;
          // open section subsection
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            if ((! cpp_parent_dict.contains("subsection"))) {
              cpp_parent_dict["subsection"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict["subsection"];
            if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
              cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
            }
            cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
            // variable declarations
            double var_ZAP_0d_double_Scalar;
            bool aux_ZAP_read = false;
            vartype aux_last_type_read_for_ZAP = UNKNOWN;
            double var_ELFS_0d_double_Scalar;
            bool aux_ELFS_read = false;
            vartype aux_last_type_read_for_ELFS = UNKNOWN;
            int var_LMF_0d_int_Scalar;
            bool aux_LMF_read = false;
            vartype aux_last_type_read_for_LMF = UNKNOWN;
            int var_LFS_0d_int_Scalar;
            bool aux_LFS_read = false;
            vartype aux_last_type_read_for_LFS = UNKNOWN;
            int cpp_int_val;
            bool aux_cpp_int_val_read = false;
            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
            int var_ND_0d_int_Scalar;
            bool aux_ND_read = false;
            vartype aux_last_type_read_for_ND = UNKNOWN;
            NestedVector<double> var_HL_1d_double_NestedVector;
            vartype aux_last_type_read_for_HL = UNKNOWN;
            NestedVector<double> var_RTYP_1d_double_NestedVector;
            vartype aux_last_type_read_for_RTYP = UNKNOWN;
            NestedVector<double> var_ZAN_1d_double_NestedVector;
            vartype aux_last_type_read_for_ZAN = UNKNOWN;
            NestedVector<double> var_BR_1d_double_NestedVector;
            vartype aux_last_type_read_for_BR = UNKNOWN;
            NestedVector<double> var_END_1d_double_NestedVector;
            vartype aux_last_type_read_for_END = UNKNOWN;
            NestedVector<double> var_CT_1d_double_NestedVector;
            vartype aux_last_type_read_for_CT = UNKNOWN;
            cpp_template = "[ MAT , 8 , MT / ZAP , ELFS , LMF , LFS , (6*ND) , 0 / \n { HL , RTYP , ZAN , BR , END , CT } { l = 1 to ND } ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            // assign expression to variable ZAP
            var_ZAP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZAP_read = true;
            validate_vartype_consistency("ZAP", SCALAR_DOUBLE, aux_last_type_read_for_ZAP);
            aux_last_type_read_for_ZAP = SCALAR_DOUBLE;
            // assign expression to variable ELFS
            var_ELFS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_ELFS_read = true;
            validate_vartype_consistency("ELFS", SCALAR_DOUBLE, aux_last_type_read_for_ELFS);
            aux_last_type_read_for_ELFS = SCALAR_DOUBLE;
            // assign expression to variable LMF
            var_LMF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LMF_read = true;
            validate_vartype_consistency("LMF", SCALAR_INT, aux_last_type_read_for_LMF);
            aux_last_type_read_for_LMF = SCALAR_INT;
            // assign expression to variable LFS
            var_LFS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LFS_read = true;
            validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
            aux_last_type_read_for_LFS = SCALAR_INT;
            // assign expression to variable cpp_int_val
            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_cpp_int_val_read = true;
            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
            // assign expression to variable ND
            var_ND_0d_int_Scalar = (cpp_int_val/6);
            aux_ND_read = true;
            validate_vartype_consistency("ND", SCALAR_INT, aux_last_type_read_for_ND);
            aux_last_type_read_for_ND = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_ND_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                // read LIST body
                // assign expression to variable HL
                var_HL_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("HL", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_HL);
                aux_last_type_read_for_HL = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable RTYP
                var_RTYP_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("RTYP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_RTYP);
                aux_last_type_read_for_RTYP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable ZAN
                var_ZAN_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("ZAN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAN);
                aux_last_type_read_for_ZAN = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable BR
                var_BR_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("BR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BR);
                aux_last_type_read_for_BR = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable END
                var_END_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("END", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_END);
                aux_last_type_read_for_END = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable CT
                var_CT_1d_double_NestedVector.set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                validate_vartype_consistency("CT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_CT);
                aux_last_type_read_for_CT = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_ZAP == SCALAR_DOUBLE) && (aux_ZAP_read == true))) {
              cpp_current_dict["ZAP"] = var_ZAP_0d_double_Scalar;
            }
            if (((aux_last_type_read_for_ELFS == SCALAR_DOUBLE) && (aux_ELFS_read == true))) {
              cpp_current_dict["ELFS"] = var_ELFS_0d_double_Scalar;
            }
            if (((aux_last_type_read_for_LMF == SCALAR_INT) && (aux_LMF_read == true))) {
              cpp_current_dict["LMF"] = var_LMF_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_LFS == SCALAR_INT) && (aux_LFS_read == true))) {
              cpp_current_dict["LFS"] = var_LFS_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_ND == SCALAR_INT) && (aux_ND_read == true))) {
              cpp_current_dict["ND"] = var_ND_0d_int_Scalar;
            }
            if ((var_HL_1d_double_NestedVector.get_last_index() != -1)) {
              auto& cpp_curvar0 = var_HL_1d_double_NestedVector;
              cpp_current_dict["HL"] = py::dict();
              py::dict cpp_curdict0 = cpp_current_dict["HL"];
              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
              }
            }
            if ((var_RTYP_1d_double_NestedVector.get_last_index() != -1)) {
              auto& cpp_curvar0 = var_RTYP_1d_double_NestedVector;
              cpp_current_dict["RTYP"] = py::dict();
              py::dict cpp_curdict0 = cpp_current_dict["RTYP"];
              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
              }
            }
            if ((var_ZAN_1d_double_NestedVector.get_last_index() != -1)) {
              auto& cpp_curvar0 = var_ZAN_1d_double_NestedVector;
              cpp_current_dict["ZAN"] = py::dict();
              py::dict cpp_curdict0 = cpp_current_dict["ZAN"];
              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
              }
            }
            if ((var_BR_1d_double_NestedVector.get_last_index() != -1)) {
              auto& cpp_curvar0 = var_BR_1d_double_NestedVector;
              cpp_current_dict["BR"] = py::dict();
              py::dict cpp_curdict0 = cpp_current_dict["BR"];
              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
              }
            }
            if ((var_END_1d_double_NestedVector.get_last_index() != -1)) {
              auto& cpp_curvar0 = var_END_1d_double_NestedVector;
              cpp_current_dict["END"] = py::dict();
              py::dict cpp_curdict0 = cpp_current_dict["END"];
              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
              }
            }
            if ((var_CT_1d_double_NestedVector.get_last_index() != -1)) {
              auto& cpp_curvar0 = var_CT_1d_double_NestedVector;
              cpp_current_dict["CT"] = py::dict();
              py::dict cpp_curdict0 = cpp_current_dict["CT"];
              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
              }
            }
            cpp_current_dict = cpp_parent_dict;
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_NO_read == true)) && ((var_NO_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // open section subsection
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              if ((! cpp_parent_dict.contains("subsection"))) {
                cpp_parent_dict["subsection"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict["subsection"];
              if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
              // variable declarations
              double var_ZAP_0d_double_Scalar;
              bool aux_ZAP_read = false;
              vartype aux_last_type_read_for_ZAP = UNKNOWN;
              double var_ELFS_0d_double_Scalar;
              bool aux_ELFS_read = false;
              vartype aux_last_type_read_for_ELFS = UNKNOWN;
              int var_LMF_0d_int_Scalar;
              bool aux_LMF_read = false;
              vartype aux_last_type_read_for_LMF = UNKNOWN;
              int var_LFS_0d_int_Scalar;
              bool aux_LFS_read = false;
              vartype aux_last_type_read_for_LFS = UNKNOWN;
              cpp_template = "[ MAT , 8 , MT / ZAP , ELFS , LMF , LFS , 0 , 0 ] CONT";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read CONT record
              // assign expression to variable ZAP
              var_ZAP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
              aux_ZAP_read = true;
              validate_vartype_consistency("ZAP", SCALAR_DOUBLE, aux_last_type_read_for_ZAP);
              aux_last_type_read_for_ZAP = SCALAR_DOUBLE;
              // assign expression to variable ELFS
              var_ELFS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
              aux_ELFS_read = true;
              validate_vartype_consistency("ELFS", SCALAR_DOUBLE, aux_last_type_read_for_ELFS);
              aux_last_type_read_for_ELFS = SCALAR_DOUBLE;
              // assign expression to variable LMF
              var_LMF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LMF_read = true;
              validate_vartype_consistency("LMF", SCALAR_INT, aux_last_type_read_for_LMF);
              aux_last_type_read_for_LMF = SCALAR_INT;
              // assign expression to variable LFS
              var_LFS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LFS_read = true;
              validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
              aux_last_type_read_for_LFS = SCALAR_INT;
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // store data in Python dictionary
              if (((aux_last_type_read_for_ZAP == SCALAR_DOUBLE) && (aux_ZAP_read == true))) {
                cpp_current_dict["ZAP"] = var_ZAP_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_ELFS == SCALAR_DOUBLE) && (aux_ELFS_read == true))) {
                cpp_current_dict["ELFS"] = var_ELFS_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_LMF == SCALAR_INT) && (aux_LMF_read == true))) {
                cpp_current_dict["LMF"] = var_LMF_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_LFS == SCALAR_INT) && (aux_LFS_read == true))) {
                cpp_current_dict["LFS"] = var_LFS_0d_int_Scalar;
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LIS == SCALAR_INT) && (aux_LIS_read == true))) {
    cpp_current_dict["LIS"] = var_LIS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LISO == SCALAR_INT) && (aux_LISO_read == true))) {
    cpp_current_dict["LISO"] = var_LISO_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NS == SCALAR_INT) && (aux_NS_read == true))) {
    cpp_current_dict["NS"] = var_NS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NO == SCALAR_INT) && (aux_NO_read == true))) {
    cpp_current_dict["NO"] = var_NO_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 2c946085e67d919e399440582cef277e
// MD5 hash of the following function definition: ad4b9fe04269e628363ad580c7b94f16
py::dict parse_mf8mt454_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_LE_0d_int_Scalar;
  bool aux_LE_read = false;
  vartype aux_last_type_read_for_LE = UNKNOWN;
  NestedVector<double> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<int> var_NN_1d_int_NestedVector;
  vartype aux_last_type_read_for_NN = UNKNOWN;
  NestedVector<int> var_NFP_1d_int_NestedVector;
  vartype aux_last_type_read_for_NFP = UNKNOWN;
  NestedVector<NestedVector<double>> var_ZAFP_2d_double_NestedVector;
  NestedVector<double>* ptr_ZAFP_2d_idx0;
  vartype aux_last_type_read_for_ZAFP = UNKNOWN;
  NestedVector<NestedVector<double>> var_FPS_2d_double_NestedVector;
  NestedVector<double>* ptr_FPS_2d_idx0;
  vartype aux_last_type_read_for_FPS = UNKNOWN;
  NestedVector<NestedVector<double>> var_YI_2d_double_NestedVector;
  NestedVector<double>* ptr_YI_2d_idx0;
  vartype aux_last_type_read_for_YI = UNKNOWN;
  NestedVector<NestedVector<double>> var_DYI_2d_double_NestedVector;
  NestedVector<double>* ptr_DYI_2d_idx0;
  vartype aux_last_type_read_for_DYI = UNKNOWN;
  NestedVector<int> var_I_1d_int_NestedVector;
  vartype aux_last_type_read_for_I = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 8;
  int mt = 454;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 454;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 8 , MT / ZA , AWR , (LE+1) , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable cpp_int_val
  cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_cpp_int_val_read = true;
  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
  // assign expression to variable LE
  var_LE_0d_int_Scalar = (cpp_int_val+(-1));
  aux_LE_read = true;
  validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
  aux_last_type_read_for_LE = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_template = "[ MAT , 8 , MT / E , 0.0 , LE , 0 , NN , NFP / \n { ZAFP , FPS , YI , DYI } { m = 1 to NFP } ] LIST";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read LIST record
  // assign expression to variable E
  var_E_1d_double_NestedVector.set(0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts));
  validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
  aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  if ((! (aux_LE_read == true))) {
    // assign expression to variable LE
    var_LE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
    aux_LE_read = true;
    validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
    aux_last_type_read_for_LE = SCALAR_INT;
  } else {
    cpp_validate_field(var_LE_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "LE",
      cpp_template, cpp_line, parse_opts);
  }
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NN
  var_NN_1d_int_NestedVector.set(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
  validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
  aux_last_type_read_for_NN = NESTEDVECTOR_INT;
  // assign expression to variable NFP
  var_NFP_1d_int_NestedVector.set(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
  validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
  aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
  {
    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST body
    ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(0);
    ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(0);
    ptr_YI_2d_idx0 = var_YI_2d_double_NestedVector.prepare(0);
    ptr_DYI_2d_idx0 = var_DYI_2d_double_NestedVector.prepare(0);

    for (int var_m_0d_int_Scalar = 1;
       var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[0]; var_m_0d_int_Scalar++) {
      bool aux_m_read = true;
      // read LIST body
      // assign expression to variable ZAFP
      ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
      aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
      // assign expression to variable FPS
      ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
      aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
      // assign expression to variable YI
      ptr_YI_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("YI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YI);
      aux_last_type_read_for_YI = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
      // assign expression to variable DYI
      ptr_DYI_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("DYI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYI);
      aux_last_type_read_for_DYI = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_LE_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    cpp_template = "[ MAT , 8 , MT / E , 0.0 , I , 0 , NN , NFP / \n { ZAFP , FPS , YI , DYI } { m = 1 to NFP } ] LIST";
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST record
    if ((! var_E_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable E
      var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts));
      validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
      aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
    } else {
      cpp_validate_field(var_E_1d_double_NestedVector[var_k_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "E",
        cpp_template, cpp_line, parse_opts);
    }
    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
      cpp_template, cpp_line, parse_opts);
    // assign expression to variable I
    var_I_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
    validate_vartype_consistency("I", NESTEDVECTOR_INT, aux_last_type_read_for_I);
    aux_last_type_read_for_I = NESTEDVECTOR_INT;
    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
      cpp_template, cpp_line, parse_opts);
    if ((! var_NN_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NN
      var_NN_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
      validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
      aux_last_type_read_for_NN = NESTEDVECTOR_INT;
    } else {
      cpp_validate_field(var_NN_1d_int_NestedVector[var_k_0d_int_Scalar], cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NN",
        cpp_template, cpp_line, parse_opts);
    }
    if ((! var_NFP_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NFP
      var_NFP_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
      validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
      aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
    } else {
      cpp_validate_field(var_NFP_1d_int_NestedVector[var_k_0d_int_Scalar], cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NFP",
        cpp_template, cpp_line, parse_opts);
    }
    {
      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      int cpp_i = 0;
      int cpp_j = 0;
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read LIST body
      ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_YI_2d_idx0 = var_YI_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_DYI_2d_idx0 = var_DYI_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

      for (int var_m_0d_int_Scalar = 1;
         var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[var_k_0d_int_Scalar]; var_m_0d_int_Scalar++) {
        bool aux_m_read = true;
        // read LIST body
        if ((! (var_ZAFP_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_ZAFP_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable ZAFP
          ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
          aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_ZAFP_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "ZAFP",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        if ((! (var_FPS_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_FPS_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable FPS
          ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
          aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_FPS_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "FPS",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        if ((! (var_YI_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_YI_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable YI
          ptr_YI_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("YI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YI);
          aux_last_type_read_for_YI = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_YI_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "YI",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        if ((! (var_DYI_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_DYI_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable DYI
          ptr_DYI_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("DYI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYI);
          aux_last_type_read_for_DYI = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_DYI_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "DYI",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
      }
      if (cpp_i != cpp_npl) {
        throw std::runtime_error("not exactly NPL elements consumed");
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LE == SCALAR_INT) && (aux_LE_read == true))) {
    cpp_current_dict["LE"] = var_LE_0d_int_Scalar;
  }
  if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_E_1d_double_NestedVector;
    cpp_current_dict["E"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["E"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_NN_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_NN_1d_int_NestedVector;
    cpp_current_dict["NN"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["NN"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_NFP_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_NFP_1d_int_NestedVector;
    cpp_current_dict["NFP"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["NFP"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_ZAFP_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_ZAFP_2d_double_NestedVector;
    cpp_current_dict["ZAFP"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["ZAFP"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_FPS_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_FPS_2d_double_NestedVector;
    cpp_current_dict["FPS"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["FPS"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_YI_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_YI_2d_double_NestedVector;
    cpp_current_dict["YI"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["YI"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_DYI_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_DYI_2d_double_NestedVector;
    cpp_current_dict["DYI"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["DYI"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_I_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_I_1d_int_NestedVector;
    cpp_current_dict["I"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["I"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 938fd3d870f297fe0f3b2ca86b863542
// MD5 hash of the following function definition: e654e37a50150a3e005b92715b943164
py::dict parse_mf8mt457_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_LISO_0d_int_Scalar;
  bool aux_LISO_read = false;
  vartype aux_last_type_read_for_LISO = UNKNOWN;
  int var_NST_0d_int_Scalar;
  bool aux_NST_read = false;
  vartype aux_last_type_read_for_NST = UNKNOWN;
  int var_NSP_0d_int_Scalar;
  bool aux_NSP_read = false;
  vartype aux_last_type_read_for_NSP = UNKNOWN;
  double var_Thalf_0d_double_Scalar;
  bool aux_Thalf_read = false;
  vartype aux_last_type_read_for_Thalf = UNKNOWN;
  double var_dThalf_0d_double_Scalar;
  bool aux_dThalf_read = false;
  vartype aux_last_type_read_for_dThalf = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  NestedVector<double> var_Ebar_x_1d_double_NestedVector;
  vartype aux_last_type_read_for_Ebar_x = UNKNOWN;
  NestedVector<double> var_dEbar_x_1d_double_NestedVector;
  vartype aux_last_type_read_for_dEbar_x = UNKNOWN;
  double var_SPI_0d_double_Scalar;
  bool aux_SPI_read = false;
  vartype aux_last_type_read_for_SPI = UNKNOWN;
  double var_PAR_0d_double_Scalar;
  bool aux_PAR_read = false;
  vartype aux_last_type_read_for_PAR = UNKNOWN;
  int var_NDK_0d_int_Scalar;
  bool aux_NDK_read = false;
  vartype aux_last_type_read_for_NDK = UNKNOWN;
  NestedVector<double> var_RTYP_1d_double_NestedVector;
  vartype aux_last_type_read_for_RTYP = UNKNOWN;
  NestedVector<double> var_RFS_1d_double_NestedVector;
  vartype aux_last_type_read_for_RFS = UNKNOWN;
  NestedVector<double> var_Q_1d_double_NestedVector;
  vartype aux_last_type_read_for_Q = UNKNOWN;
  NestedVector<double> var_dQ_1d_double_NestedVector;
  vartype aux_last_type_read_for_dQ = UNKNOWN;
  NestedVector<double> var_BR_1d_double_NestedVector;
  vartype aux_last_type_read_for_BR = UNKNOWN;
  NestedVector<double> var_dBR_1d_double_NestedVector;
  vartype aux_last_type_read_for_dBR = UNKNOWN;
  int var_JENDL_LIST_NPL_0d_int_Scalar;
  bool aux_JENDL_LIST_NPL_read = false;
  vartype aux_last_type_read_for_JENDL_LIST_NPL = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 8;
  int mt = 457;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 457;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        std::streampos cpp_old_streampos = cont.tellg();
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LIS_0d_int_Scalar = var_LIS_0d_int_Scalar;
          int var_LIS_0d_int_Scalar = glob_var_LIS_0d_int_Scalar;
          bool& glob_aux_LIS_read = aux_LIS_read;
          bool aux_LIS_read = glob_aux_LIS_read;
          vartype aux_last_type_read_for_LIS = UNKNOWN;
          int& glob_var_LISO_0d_int_Scalar = var_LISO_0d_int_Scalar;
          int var_LISO_0d_int_Scalar = glob_var_LISO_0d_int_Scalar;
          bool& glob_aux_LISO_read = aux_LISO_read;
          bool aux_LISO_read = glob_aux_LISO_read;
          vartype aux_last_type_read_for_LISO = UNKNOWN;
          int& glob_var_NST_0d_int_Scalar = var_NST_0d_int_Scalar;
          int var_NST_0d_int_Scalar = glob_var_NST_0d_int_Scalar;
          bool& glob_aux_NST_read = aux_NST_read;
          bool aux_NST_read = glob_aux_NST_read;
          vartype aux_last_type_read_for_NST = UNKNOWN;
          int& glob_var_NSP_0d_int_Scalar = var_NSP_0d_int_Scalar;
          int var_NSP_0d_int_Scalar = glob_var_NSP_0d_int_Scalar;
          bool& glob_aux_NSP_read = aux_NSP_read;
          bool aux_NSP_read = glob_aux_NSP_read;
          vartype aux_last_type_read_for_NSP = UNKNOWN;
          cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , NSP ] HEAD";
          cpp_line = cpp_read_raw_line(cont);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LIS
          var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LIS_read = true;
          validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
          aux_last_type_read_for_LIS = SCALAR_INT;
          // assign expression to variable LISO
          var_LISO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_LISO_read = true;
          validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
          aux_last_type_read_for_LISO = SCALAR_INT;
          // assign expression to variable NST
          var_NST_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NST_read = true;
          validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
          aux_last_type_read_for_NST = SCALAR_INT;
          // assign expression to variable NSP
          var_NSP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NSP_read = true;
          validate_vartype_consistency("NSP", SCALAR_INT, aux_last_type_read_for_NSP);
          aux_last_type_read_for_NSP = SCALAR_INT;
          if ((((((((aux_NST_read == true)) && ((var_NST_0d_int_Scalar)==(0)))))))) {
            cpp_found_match = true;
          }
          cont.seekg(cpp_old_streampos);
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , NSP ] HEAD";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LIS
          var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LIS_read = true;
          validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
          aux_last_type_read_for_LIS = SCALAR_INT;
          // assign expression to variable LISO
          var_LISO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_LISO_read = true;
          validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
          aux_last_type_read_for_LISO = SCALAR_INT;
          // assign expression to variable NST
          var_NST_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NST_read = true;
          validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
          aux_last_type_read_for_NST = SCALAR_INT;
          // assign expression to variable NSP
          var_NSP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NSP_read = true;
          validate_vartype_consistency("NSP", SCALAR_INT, aux_last_type_read_for_NSP);
          aux_last_type_read_for_NSP = SCALAR_INT;
          cpp_template = "[ MAT , 8 , 457 / Thalf , dThalf , 0 , 0 , (2*NC) , 0 / \n { Ebar_x , dEbar_x } { k = 1 to NC } ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          // assign expression to variable Thalf
          var_Thalf_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_Thalf_read = true;
          validate_vartype_consistency("Thalf", SCALAR_DOUBLE, aux_last_type_read_for_Thalf);
          aux_last_type_read_for_Thalf = SCALAR_DOUBLE;
          // assign expression to variable dThalf
          var_dThalf_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_dThalf_read = true;
          validate_vartype_consistency("dThalf", SCALAR_DOUBLE, aux_last_type_read_for_dThalf);
          aux_last_type_read_for_dThalf = SCALAR_DOUBLE;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable cpp_int_val
          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_cpp_int_val_read = true;
          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
          // assign expression to variable NC
          var_NC_0d_int_Scalar = (cpp_int_val/2);
          aux_NC_read = true;
          validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
          aux_last_type_read_for_NC = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NC_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              // assign expression to variable Ebar_x
              var_Ebar_x_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("Ebar_x", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ebar_x);
              aux_last_type_read_for_Ebar_x = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dEbar_x
              var_dEbar_x_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("dEbar_x", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dEbar_x);
              aux_last_type_read_for_dEbar_x = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , (6*NDK) , NDK / \n { RTYP , RFS , Q , dQ , BR , dBR } { k = 1 to NDK } ] LIST";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read LIST record
          // assign expression to variable SPI
          var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_SPI_read = true;
          validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
          aux_last_type_read_for_SPI = SCALAR_DOUBLE;
          // assign expression to variable PAR
          var_PAR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_PAR_read = true;
          validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
          aux_last_type_read_for_PAR = SCALAR_DOUBLE;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable cpp_int_val
          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_cpp_int_val_read = true;
          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
          // assign expression to variable NDK
          var_NDK_0d_int_Scalar = (cpp_int_val/6);
          aux_NDK_read = true;
          validate_vartype_consistency("NDK", SCALAR_INT, aux_last_type_read_for_NDK);
          aux_last_type_read_for_NDK = SCALAR_INT;
          if ((! (aux_NDK_read == true))) {
            // assign expression to variable NDK
            var_NDK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NDK_read = true;
            validate_vartype_consistency("NDK", SCALAR_INT, aux_last_type_read_for_NDK);
            aux_last_type_read_for_NDK = SCALAR_INT;
          } else {
            cpp_validate_field(var_NDK_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NDK",
              cpp_template, cpp_line, parse_opts);
          }
          {
            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NDK_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              // assign expression to variable RTYP
              var_RTYP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("RTYP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_RTYP);
              aux_last_type_read_for_RTYP = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable RFS
              var_RFS_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("RFS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_RFS);
              aux_last_type_read_for_RFS = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable Q
              var_Q_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("Q", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Q);
              aux_last_type_read_for_Q = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dQ
              var_dQ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("dQ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dQ);
              aux_last_type_read_for_dQ = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable BR
              var_BR_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("BR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BR);
              aux_last_type_read_for_BR = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              // assign expression to variable dBR
              var_dBR_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
              validate_vartype_consistency("dBR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dBR);
              aux_last_type_read_for_dBR = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NSP_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // open section spectrum
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              if ((! cpp_parent_dict.contains("spectrum"))) {
                cpp_parent_dict["spectrum"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict["spectrum"];
              if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
              // variable declarations
              double var_STYP_0d_double_Scalar;
              bool aux_STYP_read = false;
              vartype aux_last_type_read_for_STYP = UNKNOWN;
              int var_LCON_0d_int_Scalar;
              bool aux_LCON_read = false;
              vartype aux_last_type_read_for_LCON = UNKNOWN;
              int var_LCOV_0d_int_Scalar;
              bool aux_LCOV_read = false;
              vartype aux_last_type_read_for_LCOV = UNKNOWN;
              int var_NER_0d_int_Scalar;
              bool aux_NER_read = false;
              vartype aux_last_type_read_for_NER = UNKNOWN;
              double var_FD_0d_double_Scalar;
              bool aux_FD_read = false;
              vartype aux_last_type_read_for_FD = UNKNOWN;
              double var_dFD_0d_double_Scalar;
              bool aux_dFD_read = false;
              vartype aux_last_type_read_for_dFD = UNKNOWN;
              double var_ERAV_0d_double_Scalar;
              bool aux_ERAV_read = false;
              vartype aux_last_type_read_for_ERAV = UNKNOWN;
              double var_dERAV_0d_double_Scalar;
              bool aux_dERAV_read = false;
              vartype aux_last_type_read_for_dERAV = UNKNOWN;
              double var_FC_0d_double_Scalar;
              bool aux_FC_read = false;
              vartype aux_last_type_read_for_FC = UNKNOWN;
              double var_dFC_0d_double_Scalar;
              bool aux_dFC_read = false;
              vartype aux_last_type_read_for_dFC = UNKNOWN;
              cpp_template = "[ MAT , 8 , 457 / 0.0 , STYP , LCON , LCOV , 6 , NER / \n FD , dFD , ERAV , dERAV , FC , dFC ] LIST";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST record
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable STYP
              var_STYP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
              aux_STYP_read = true;
              validate_vartype_consistency("STYP", SCALAR_DOUBLE, aux_last_type_read_for_STYP);
              aux_last_type_read_for_STYP = SCALAR_DOUBLE;
              // assign expression to variable LCON
              var_LCON_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LCON_read = true;
              validate_vartype_consistency("LCON", SCALAR_INT, aux_last_type_read_for_LCON);
              aux_last_type_read_for_LCON = SCALAR_INT;
              // assign expression to variable LCOV
              var_LCOV_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LCOV_read = true;
              validate_vartype_consistency("LCOV", SCALAR_INT, aux_last_type_read_for_LCOV);
              aux_last_type_read_for_LCOV = SCALAR_INT;
              cpp_validate_field(6, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "6",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NER
              var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NER_read = true;
              validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
              aux_last_type_read_for_NER = SCALAR_INT;
              {
                int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST body
                // assign expression to variable FD
                var_FD_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                aux_FD_read = true;
                validate_vartype_consistency("FD", SCALAR_DOUBLE, aux_last_type_read_for_FD);
                aux_last_type_read_for_FD = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dFD
                var_dFD_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                aux_dFD_read = true;
                validate_vartype_consistency("dFD", SCALAR_DOUBLE, aux_last_type_read_for_dFD);
                aux_last_type_read_for_dFD = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable ERAV
                var_ERAV_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                aux_ERAV_read = true;
                validate_vartype_consistency("ERAV", SCALAR_DOUBLE, aux_last_type_read_for_ERAV);
                aux_last_type_read_for_ERAV = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dERAV
                var_dERAV_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                aux_dERAV_read = true;
                validate_vartype_consistency("dERAV", SCALAR_DOUBLE, aux_last_type_read_for_dERAV);
                aux_last_type_read_for_dERAV = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable FC
                var_FC_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                aux_FC_read = true;
                validate_vartype_consistency("FC", SCALAR_DOUBLE, aux_last_type_read_for_FC);
                aux_last_type_read_for_FC = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                // assign expression to variable dFC
                var_dFC_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                aux_dFC_read = true;
                validate_vartype_consistency("dFC", SCALAR_DOUBLE, aux_last_type_read_for_dFC);
                aux_last_type_read_for_dFC = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  cpp_j = 0;
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if ((((((((aux_LCON_read == true)) && ((var_LCON_0d_int_Scalar)!=(1)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section discrete
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      if ((! cpp_parent_dict.contains("discrete"))) {
                        cpp_parent_dict["discrete"] = py::dict();
                      }
                      py::dict cpp_current_dict = cpp_parent_dict["discrete"];
                      // variable declarations

                      for (int var_i_0d_int_Scalar = 1;
                         var_i_0d_int_Scalar <= var_NER_0d_int_Scalar; var_i_0d_int_Scalar++) {
                        bool aux_i_read = true;
                        // open section energysec
                        {
                          py::dict cpp_parent_dict = cpp_current_dict;
                          if ((! cpp_parent_dict.contains("energysec"))) {
                            cpp_parent_dict["energysec"] = py::dict();
                          }
                          py::dict cpp_current_dict = cpp_parent_dict["energysec"];
                          if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
                            cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
                          }
                          cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
                          // variable declarations
                          double var_ER_0d_double_Scalar;
                          bool aux_ER_read = false;
                          vartype aux_last_type_read_for_ER = UNKNOWN;
                          double var_dER_0d_double_Scalar;
                          bool aux_dER_read = false;
                          vartype aux_last_type_read_for_dER = UNKNOWN;
                          int var_NT_0d_int_Scalar;
                          bool aux_NT_read = false;
                          vartype aux_last_type_read_for_NT = UNKNOWN;
                          double var_RTYP_0d_double_Scalar;
                          bool aux_RTYP_read = false;
                          vartype aux_last_type_read_for_RTYP = UNKNOWN;
                          double var_TYPE_0d_double_Scalar;
                          bool aux_TYPE_read = false;
                          vartype aux_last_type_read_for_TYPE = UNKNOWN;
                          double var_RI_0d_double_Scalar;
                          bool aux_RI_read = false;
                          vartype aux_last_type_read_for_RI = UNKNOWN;
                          double var_dRI_0d_double_Scalar;
                          bool aux_dRI_read = false;
                          vartype aux_last_type_read_for_dRI = UNKNOWN;
                          double var_RIS_0d_double_Scalar;
                          bool aux_RIS_read = false;
                          vartype aux_last_type_read_for_RIS = UNKNOWN;
                          double var_dRIS_0d_double_Scalar;
                          bool aux_dRIS_read = false;
                          vartype aux_last_type_read_for_dRIS = UNKNOWN;
                          double var_RICC_0d_double_Scalar;
                          bool aux_RICC_read = false;
                          vartype aux_last_type_read_for_RICC = UNKNOWN;
                          double var_dRICC_0d_double_Scalar;
                          bool aux_dRICC_read = false;
                          vartype aux_last_type_read_for_dRICC = UNKNOWN;
                          double var_RICK_0d_double_Scalar;
                          bool aux_RICK_read = false;
                          vartype aux_last_type_read_for_RICK = UNKNOWN;
                          double var_dRICK_0d_double_Scalar;
                          bool aux_dRICK_read = false;
                          vartype aux_last_type_read_for_dRICK = UNKNOWN;
                          double var_RICL_0d_double_Scalar;
                          bool aux_RICL_read = false;
                          vartype aux_last_type_read_for_RICL = UNKNOWN;
                          double var_dRICL_0d_double_Scalar;
                          bool aux_dRICL_read = false;
                          vartype aux_last_type_read_for_dRICL = UNKNOWN;
                          // evaluate if-elif-else clause
                          {
                            bool cpp_found_match = false;
                            if (! cpp_found_match) {
                              // if statement evaluation with lookahead
                              {
                                std::streampos cpp_old_streampos = cont.tellg();
                                {
                                  // variable declarations
                                  double& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                  double var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                  bool& glob_aux_ER_read = aux_ER_read;
                                  bool aux_ER_read = glob_aux_ER_read;
                                  vartype aux_last_type_read_for_ER = UNKNOWN;
                                  double& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                  double var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                  bool& glob_aux_dER_read = aux_dER_read;
                                  bool aux_dER_read = glob_aux_dER_read;
                                  vartype aux_last_type_read_for_dER = UNKNOWN;
                                  int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                  int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                  bool& glob_aux_NT_read = aux_NT_read;
                                  bool aux_NT_read = glob_aux_NT_read;
                                  vartype aux_last_type_read_for_NT = UNKNOWN;
                                  cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI ] LIST";
                                  cpp_line = cpp_read_raw_line(cont);
                                  // read LIST record
                                  // assign expression to variable ER
                                  var_ER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                  aux_ER_read = true;
                                  validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                  aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                  // assign expression to variable dER
                                  var_dER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                                  aux_dER_read = true;
                                  validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                  aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                  // assign expression to variable NT
                                  var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                  aux_NT_read = true;
                                  validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                  aux_last_type_read_for_NT = SCALAR_INT;
                                  if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(4)))))))) {
                                    cpp_found_match = true;
                                  }
                                  cont.seekg(cpp_old_streampos);
                                }
                                if (cpp_found_match) {
                                  cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI ] LIST";
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  // read LIST record
                                  // assign expression to variable ER
                                  var_ER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                  aux_ER_read = true;
                                  validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                  aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                  // assign expression to variable dER
                                  var_dER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                                  aux_dER_read = true;
                                  validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                  aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                    cpp_template, cpp_line, parse_opts);
                                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                    cpp_template, cpp_line, parse_opts);
                                  // assign expression to variable NT
                                  var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                  aux_NT_read = true;
                                  validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                  aux_last_type_read_for_NT = SCALAR_INT;
                                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                    cpp_template, cpp_line, parse_opts);
                                  {
                                    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    int cpp_i = 0;
                                    int cpp_j = 0;
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST body
                                    // assign expression to variable RTYP
                                    var_RTYP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_RTYP_read = true;
                                    validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                    aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable TYPE
                                    var_TYPE_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_TYPE_read = true;
                                    validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                    aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable RI
                                    var_RI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_RI_read = true;
                                    validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                    aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    // assign expression to variable dRI
                                    var_dRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                    aux_dRI_read = true;
                                    validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                    aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      cpp_j = 0;
                                    }
                                    if (cpp_i != cpp_npl) {
                                      throw std::runtime_error("not exactly NPL elements consumed");
                                    }
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  std::streampos cpp_old_streampos = cont.tellg();
                                  {
                                    // variable declarations
                                    double& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    double var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    double& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    double var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS ] LIST";
                                    cpp_line = cpp_read_raw_line(cont);
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(6)))))))) {
                                      cpp_found_match = true;
                                    }
                                    cont.seekg(cpp_old_streampos);
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS ] LIST";
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    {
                                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      // read LIST body
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  std::streampos cpp_old_streampos = cont.tellg();
                                  {
                                    // variable declarations
                                    double& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    double var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    double& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    double var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC ] LIST";
                                    cpp_line = cpp_read_raw_line(cont);
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(8)))))))) {
                                      cpp_found_match = true;
                                    }
                                    cont.seekg(cpp_old_streampos);
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC ] LIST";
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    {
                                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      // read LIST body
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RICC
                                      var_RICC_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RICC_read = true;
                                      validate_vartype_consistency("RICC", SCALAR_DOUBLE, aux_last_type_read_for_RICC);
                                      aux_last_type_read_for_RICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRICC
                                      var_dRICC_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRICC_read = true;
                                      validate_vartype_consistency("dRICC", SCALAR_DOUBLE, aux_last_type_read_for_dRICC);
                                      aux_last_type_read_for_dRICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  std::streampos cpp_old_streampos = cont.tellg();
                                  {
                                    // variable declarations
                                    double& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    double var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    double& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    double var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK ] LIST";
                                    cpp_line = cpp_read_raw_line(cont);
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(10)))))))) {
                                      cpp_found_match = true;
                                    }
                                    cont.seekg(cpp_old_streampos);
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK ] LIST";
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    {
                                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      // read LIST body
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RICC
                                      var_RICC_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RICC_read = true;
                                      validate_vartype_consistency("RICC", SCALAR_DOUBLE, aux_last_type_read_for_RICC);
                                      aux_last_type_read_for_RICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRICC
                                      var_dRICC_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRICC_read = true;
                                      validate_vartype_consistency("dRICC", SCALAR_DOUBLE, aux_last_type_read_for_dRICC);
                                      aux_last_type_read_for_dRICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RICK
                                      var_RICK_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RICK_read = true;
                                      validate_vartype_consistency("RICK", SCALAR_DOUBLE, aux_last_type_read_for_RICK);
                                      aux_last_type_read_for_RICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRICK
                                      var_dRICK_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRICK_read = true;
                                      validate_vartype_consistency("dRICK", SCALAR_DOUBLE, aux_last_type_read_for_dRICK);
                                      aux_last_type_read_for_dRICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  std::streampos cpp_old_streampos = cont.tellg();
                                  {
                                    // variable declarations
                                    double& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    double var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    double& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    double var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK , RICL , dRICL ] LIST";
                                    cpp_line = cpp_read_raw_line(cont);
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(12)))))))) {
                                      cpp_found_match = true;
                                    }
                                    cont.seekg(cpp_old_streampos);
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK , RICL , dRICL ] LIST";
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                                      cpp_template, cpp_line, parse_opts);
                                    {
                                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                      // read LIST body
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RICC
                                      var_RICC_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RICC_read = true;
                                      validate_vartype_consistency("RICC", SCALAR_DOUBLE, aux_last_type_read_for_RICC);
                                      aux_last_type_read_for_RICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRICC
                                      var_dRICC_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRICC_read = true;
                                      validate_vartype_consistency("dRICC", SCALAR_DOUBLE, aux_last_type_read_for_dRICC);
                                      aux_last_type_read_for_dRICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RICK
                                      var_RICK_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RICK_read = true;
                                      validate_vartype_consistency("RICK", SCALAR_DOUBLE, aux_last_type_read_for_RICK);
                                      aux_last_type_read_for_RICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRICK
                                      var_dRICK_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRICK_read = true;
                                      validate_vartype_consistency("dRICK", SCALAR_DOUBLE, aux_last_type_read_for_dRICK);
                                      aux_last_type_read_for_dRICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable RICL
                                      var_RICL_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_RICL_read = true;
                                      validate_vartype_consistency("RICL", SCALAR_DOUBLE, aux_last_type_read_for_RICL);
                                      aux_last_type_read_for_RICL = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      // assign expression to variable dRICL
                                      var_dRICL_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                      aux_dRICL_read = true;
                                      validate_vartype_consistency("dRICL", SCALAR_DOUBLE, aux_last_type_read_for_dRICL);
                                      aux_last_type_read_for_dRICL = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                          // store data in Python dictionary
                          if (((aux_last_type_read_for_ER == SCALAR_DOUBLE) && (aux_ER_read == true))) {
                            cpp_current_dict["ER"] = var_ER_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_dER == SCALAR_DOUBLE) && (aux_dER_read == true))) {
                            cpp_current_dict["dER"] = var_dER_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_NT == SCALAR_INT) && (aux_NT_read == true))) {
                            cpp_current_dict["NT"] = var_NT_0d_int_Scalar;
                          }
                          if (((aux_last_type_read_for_RTYP == SCALAR_DOUBLE) && (aux_RTYP_read == true))) {
                            cpp_current_dict["RTYP"] = var_RTYP_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_TYPE == SCALAR_DOUBLE) && (aux_TYPE_read == true))) {
                            cpp_current_dict["TYPE"] = var_TYPE_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_RI == SCALAR_DOUBLE) && (aux_RI_read == true))) {
                            cpp_current_dict["RI"] = var_RI_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_dRI == SCALAR_DOUBLE) && (aux_dRI_read == true))) {
                            cpp_current_dict["dRI"] = var_dRI_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_RIS == SCALAR_DOUBLE) && (aux_RIS_read == true))) {
                            cpp_current_dict["RIS"] = var_RIS_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_dRIS == SCALAR_DOUBLE) && (aux_dRIS_read == true))) {
                            cpp_current_dict["dRIS"] = var_dRIS_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_RICC == SCALAR_DOUBLE) && (aux_RICC_read == true))) {
                            cpp_current_dict["RICC"] = var_RICC_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_dRICC == SCALAR_DOUBLE) && (aux_dRICC_read == true))) {
                            cpp_current_dict["dRICC"] = var_dRICC_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_RICK == SCALAR_DOUBLE) && (aux_RICK_read == true))) {
                            cpp_current_dict["RICK"] = var_RICK_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_dRICK == SCALAR_DOUBLE) && (aux_dRICK_read == true))) {
                            cpp_current_dict["dRICK"] = var_dRICK_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_RICL == SCALAR_DOUBLE) && (aux_RICL_read == true))) {
                            cpp_current_dict["RICL"] = var_RICL_0d_double_Scalar;
                          }
                          if (((aux_last_type_read_for_dRICL == SCALAR_DOUBLE) && (aux_dRICL_read == true))) {
                            cpp_current_dict["dRICL"] = var_dRICL_0d_double_Scalar;
                          }
                          cpp_current_dict = cpp_parent_dict;
                        }
                      }
                      // store data in Python dictionary
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if ((((((((aux_LCON_read == true)) && ((var_LCON_0d_int_Scalar)!=(0)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section continuous
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      if ((! cpp_parent_dict.contains("continuous"))) {
                        cpp_parent_dict["continuous"] = py::dict();
                      }
                      py::dict cpp_current_dict = cpp_parent_dict["continuous"];
                      // variable declarations
                      double var_RTYP_0d_double_Scalar;
                      bool aux_RTYP_read = false;
                      vartype aux_last_type_read_for_RTYP = UNKNOWN;
                      std::vector<double> var_Eint_0d_floatvec_Scalar;
                      bool aux_Eint_read = false;
                      vartype aux_last_type_read_for_Eint = UNKNOWN;
                      std::vector<double> var_RP_0d_floatvec_Scalar;
                      bool aux_RP_read = false;
                      vartype aux_last_type_read_for_RP = UNKNOWN;
                      std::vector<int> var_INT_0d_intvec_Scalar;
                      bool aux_INT_read = false;
                      vartype aux_last_type_read_for_INT = UNKNOWN;
                      std::vector<int> var_NBT_0d_intvec_Scalar;
                      bool aux_NBT_read = false;
                      vartype aux_last_type_read_for_NBT = UNKNOWN;
                      cpp_template = "[ MAT , 8 , 457 / RTYP , 0.0 , 0 , 0 , NR , NP / Eint / RP ] TAB1";
                      // read TAB1 record
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // assign expression to variable RTYP
                      var_RTYP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                      aux_RTYP_read = true;
                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                      cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      {
                        Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                        // assign expression to variable Eint
                        var_Eint_0d_floatvec_Scalar = tab_body.X;
                        aux_Eint_read = true;
                        validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                        aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                        // assign expression to variable RP
                        var_RP_0d_floatvec_Scalar = tab_body.Y;
                        aux_RP_read = true;
                        validate_vartype_consistency("RP", SCALAR_FLOATVEC, aux_last_type_read_for_RP);
                        aux_last_type_read_for_RP = SCALAR_FLOATVEC;
                        // assign expression to variable INT
                        var_INT_0d_intvec_Scalar = tab_body.INT;
                        aux_INT_read = true;
                        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                        aux_last_type_read_for_INT = SCALAR_INTVEC;
                        // assign expression to variable NBT
                        var_NBT_0d_intvec_Scalar = tab_body.NBT;
                        aux_NBT_read = true;
                        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                        aux_last_type_read_for_NBT = SCALAR_INTVEC;
                      }
                      // store data in Python dictionary
                      if (((aux_last_type_read_for_RTYP == SCALAR_DOUBLE) && (aux_RTYP_read == true))) {
                        cpp_current_dict["RTYP"] = var_RTYP_0d_double_Scalar;
                      }
                      if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
                        cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
                      }
                      if (((aux_last_type_read_for_RP == SCALAR_FLOATVEC) && (aux_RP_read == true))) {
                        cpp_current_dict["RP"] = var_RP_0d_floatvec_Scalar;
                      }
                      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                      }
                      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                      }
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if ((((((((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(0)))))&&((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(2)))))&&((((aux_LCON_read == true)) && ((var_LCON_0d_int_Scalar)!=(0)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section continuous
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      if ((! cpp_parent_dict.contains("continuous"))) {
                        cpp_parent_dict["continuous"] = py::dict();
                      }
                      py::dict cpp_current_dict = cpp_parent_dict["continuous"];
                      // variable declarations
                      int cpp_int_val;
                      bool aux_cpp_int_val_read = false;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int var_NPP_0d_int_Scalar;
                      bool aux_NPP_read = false;
                      vartype aux_last_type_read_for_NPP = UNKNOWN;
                      NestedVector<double> var_E_1d_double_NestedVector;
                      vartype aux_last_type_read_for_E = UNKNOWN;
                      NestedVector<double> var_F_1d_double_NestedVector;
                      vartype aux_last_type_read_for_F = UNKNOWN;
                      cpp_template = "[ MAT , 8 , 457 / 0.0 , 0.0 , 0 , 2 , (2*NPP) , NPP / { E , F } { m = 1 to NPP } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(2, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "2",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NPP
                      var_NPP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NPP_read = true;
                      validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                      aux_last_type_read_for_NPP = SCALAR_INT;
                      if ((! (aux_NPP_read == true))) {
                        // assign expression to variable NPP
                        var_NPP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NPP_read = true;
                        validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                        aux_last_type_read_for_NPP = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NPP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NPP",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NPP_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // read LIST body
                          // assign expression to variable E
                          var_E_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                          aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable F
                          var_F_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                          aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      // store data in Python dictionary
                      if (((aux_last_type_read_for_NPP == SCALAR_INT) && (aux_NPP_read == true))) {
                        cpp_current_dict["NPP"] = var_NPP_0d_int_Scalar;
                      }
                      if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_E_1d_double_NestedVector;
                        cpp_current_dict["E"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["E"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_F_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_F_1d_double_NestedVector;
                        cpp_current_dict["F"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["F"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if (((((((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(0)))))&&((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(1)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section discrete
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      if ((! cpp_parent_dict.contains("discrete"))) {
                        cpp_parent_dict["discrete"] = py::dict();
                      }
                      py::dict cpp_current_dict = cpp_parent_dict["discrete"];
                      // variable declarations
                      // open section cov
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        if ((! cpp_parent_dict.contains("cov"))) {
                          cpp_parent_dict["cov"] = py::dict();
                        }
                        py::dict cpp_current_dict = cpp_parent_dict["cov"];
                        // variable declarations
                        int var_LS_0d_int_Scalar;
                        bool aux_LS_read = false;
                        vartype aux_last_type_read_for_LS = UNKNOWN;
                        int var_NE_0d_int_Scalar;
                        bool aux_NE_read = false;
                        vartype aux_last_type_read_for_NE = UNKNOWN;
                        int var_NERP_0d_int_Scalar;
                        bool aux_NERP_read = false;
                        vartype aux_last_type_read_for_NERP = UNKNOWN;
                        NestedVector<double> var_E_1d_double_NestedVector;
                        vartype aux_last_type_read_for_E = UNKNOWN;
                        Matrix2d<double> var_F_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_F = UNKNOWN;
                        cpp_template = "[ MAT , 8 , 457 / 0.0 , 0.0 , LS , 5 , NE , NERP / \n { E } { m = 1 to NERP } , { { F } { n = m to (NERP-2) } } { m = 1 to (NERP-2) } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        cpp_validate_field(5, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "5",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        // assign expression to variable NERP
                        var_NERP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NERP_read = true;
                        validate_vartype_consistency("NERP", SCALAR_INT, aux_last_type_read_for_NERP);
                        aux_last_type_read_for_NERP = SCALAR_INT;
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= var_NERP_0d_int_Scalar; var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NERP_0d_int_Scalar-2), 1, (var_NERP_0d_int_Scalar-2), true, false);

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= (var_NERP_0d_int_Scalar-2); var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body

                            for (int var_n_0d_int_Scalar = var_m_0d_int_Scalar;
                               var_n_0d_int_Scalar <= (var_NERP_0d_int_Scalar-2); var_n_0d_int_Scalar++) {
                              bool aux_n_read = true;
                              // read LIST body
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        // store data in Python dictionary
                        if (((aux_last_type_read_for_LS == SCALAR_INT) && (aux_LS_read == true))) {
                          cpp_current_dict["LS"] = var_LS_0d_int_Scalar;
                        }
                        if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
                          cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
                        }
                        if (((aux_last_type_read_for_NERP == SCALAR_INT) && (aux_NERP_read == true))) {
                          cpp_current_dict["NERP"] = var_NERP_0d_int_Scalar;
                        }
                        if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_E_1d_double_NestedVector;
                          cpp_current_dict["E"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["E"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if (var_F_2d_double_Matrix2d.did_read()) {
                            cpp_current_dict["F"] = py::dict();
                            py::dict cpp_curdict0 = cpp_current_dict["F"];
                            for (int cpp_i1 = var_F_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_F_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
                              cpp_curdict0[py::cast(cpp_i1)] = py::dict();
                              py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
                              for (int cpp_i2 = var_F_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_F_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
                                cpp_curdict1[py::cast(cpp_i2)] = var_F_2d_double_Matrix2d(cpp_i1, cpp_i2);
                              }
                            }
                        }
                        cpp_current_dict = cpp_parent_dict;
                      }
                      // store data in Python dictionary
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
              // store data in Python dictionary
              if (((aux_last_type_read_for_STYP == SCALAR_DOUBLE) && (aux_STYP_read == true))) {
                cpp_current_dict["STYP"] = var_STYP_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_LCON == SCALAR_INT) && (aux_LCON_read == true))) {
                cpp_current_dict["LCON"] = var_LCON_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_LCOV == SCALAR_INT) && (aux_LCOV_read == true))) {
                cpp_current_dict["LCOV"] = var_LCOV_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_NER == SCALAR_INT) && (aux_NER_read == true))) {
                cpp_current_dict["NER"] = var_NER_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_FD == SCALAR_DOUBLE) && (aux_FD_read == true))) {
                cpp_current_dict["FD"] = var_FD_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_dFD == SCALAR_DOUBLE) && (aux_dFD_read == true))) {
                cpp_current_dict["dFD"] = var_dFD_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_ERAV == SCALAR_DOUBLE) && (aux_ERAV_read == true))) {
                cpp_current_dict["ERAV"] = var_ERAV_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_dERAV == SCALAR_DOUBLE) && (aux_dERAV_read == true))) {
                cpp_current_dict["dERAV"] = var_dERAV_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_FC == SCALAR_DOUBLE) && (aux_FC_read == true))) {
                cpp_current_dict["FC"] = var_FC_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_dFC == SCALAR_DOUBLE) && (aux_dFC_read == true))) {
                cpp_current_dict["dFC"] = var_dFC_0d_double_Scalar;
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LIS_0d_int_Scalar = var_LIS_0d_int_Scalar;
            int var_LIS_0d_int_Scalar = glob_var_LIS_0d_int_Scalar;
            bool& glob_aux_LIS_read = aux_LIS_read;
            bool aux_LIS_read = glob_aux_LIS_read;
            vartype aux_last_type_read_for_LIS = UNKNOWN;
            int& glob_var_LISO_0d_int_Scalar = var_LISO_0d_int_Scalar;
            int var_LISO_0d_int_Scalar = glob_var_LISO_0d_int_Scalar;
            bool& glob_aux_LISO_read = aux_LISO_read;
            bool aux_LISO_read = glob_aux_LISO_read;
            vartype aux_last_type_read_for_LISO = UNKNOWN;
            int& glob_var_NST_0d_int_Scalar = var_NST_0d_int_Scalar;
            int var_NST_0d_int_Scalar = glob_var_NST_0d_int_Scalar;
            bool& glob_aux_NST_read = aux_NST_read;
            bool aux_NST_read = glob_aux_NST_read;
            vartype aux_last_type_read_for_NST = UNKNOWN;
            cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , 0 ] HEAD";
            cpp_line = cpp_read_raw_line(cont);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LIS
            var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LIS_read = true;
            validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
            aux_last_type_read_for_LIS = SCALAR_INT;
            // assign expression to variable LISO
            var_LISO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LISO_read = true;
            validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
            aux_last_type_read_for_LISO = SCALAR_INT;
            // assign expression to variable NST
            var_NST_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NST_read = true;
            validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
            aux_last_type_read_for_NST = SCALAR_INT;
            if ((((((((aux_NST_read == true)) && ((var_NST_0d_int_Scalar)==(1)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , 0 ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LIS
            var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LIS_read = true;
            validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
            aux_last_type_read_for_LIS = SCALAR_INT;
            // assign expression to variable LISO
            var_LISO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LISO_read = true;
            validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
            aux_last_type_read_for_LISO = SCALAR_INT;
            // assign expression to variable NST
            var_NST_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NST_read = true;
            validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
            aux_last_type_read_for_NST = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_template = "[ MAT , 8 , 457 / 0.0 , 0.0 , 0 , 0 , 6 , 0 / \n 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ] LIST";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read LIST record
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(6, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "6",
              cpp_template, cpp_line, parse_opts);
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            {
              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST body
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_j = 0;
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            // evaluate if-elif-else clause
            {
              bool cpp_found_match = false;
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
                    int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
                    bool& glob_aux_MAT_read = aux_MAT_read;
                    bool aux_MAT_read = glob_aux_MAT_read;
                    vartype aux_last_type_read_for_MAT = UNKNOWN;
                    int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
                    int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
                    bool& glob_aux_MF_read = aux_MF_read;
                    bool aux_MF_read = glob_aux_MF_read;
                    vartype aux_last_type_read_for_MF = UNKNOWN;
                    int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
                    int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
                    bool& glob_aux_MT_read = aux_MT_read;
                    bool aux_MT_read = glob_aux_MT_read;
                    vartype aux_last_type_read_for_MT = UNKNOWN;
                    double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
                    double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
                    bool& glob_aux_ZA_read = aux_ZA_read;
                    bool aux_ZA_read = glob_aux_ZA_read;
                    vartype aux_last_type_read_for_ZA = UNKNOWN;
                    double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
                    double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
                    bool& glob_aux_AWR_read = aux_AWR_read;
                    bool aux_AWR_read = glob_aux_AWR_read;
                    vartype aux_last_type_read_for_AWR = UNKNOWN;
                    int& glob_var_LIS_0d_int_Scalar = var_LIS_0d_int_Scalar;
                    int var_LIS_0d_int_Scalar = glob_var_LIS_0d_int_Scalar;
                    bool& glob_aux_LIS_read = aux_LIS_read;
                    bool aux_LIS_read = glob_aux_LIS_read;
                    vartype aux_last_type_read_for_LIS = UNKNOWN;
                    int& glob_var_LISO_0d_int_Scalar = var_LISO_0d_int_Scalar;
                    int var_LISO_0d_int_Scalar = glob_var_LISO_0d_int_Scalar;
                    bool& glob_aux_LISO_read = aux_LISO_read;
                    bool aux_LISO_read = glob_aux_LISO_read;
                    vartype aux_last_type_read_for_LISO = UNKNOWN;
                    int& glob_var_NST_0d_int_Scalar = var_NST_0d_int_Scalar;
                    int var_NST_0d_int_Scalar = glob_var_NST_0d_int_Scalar;
                    bool& glob_aux_NST_read = aux_NST_read;
                    bool aux_NST_read = glob_aux_NST_read;
                    vartype aux_last_type_read_for_NST = UNKNOWN;
                    double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    double& glob_var_PAR_0d_double_Scalar = var_PAR_0d_double_Scalar;
                    double var_PAR_0d_double_Scalar = glob_var_PAR_0d_double_Scalar;
                    bool& glob_aux_PAR_read = aux_PAR_read;
                    bool aux_PAR_read = glob_aux_PAR_read;
                    vartype aux_last_type_read_for_PAR = UNKNOWN;
                    int& glob_var_JENDL_LIST_NPL_0d_int_Scalar = var_JENDL_LIST_NPL_0d_int_Scalar;
                    int var_JENDL_LIST_NPL_0d_int_Scalar = glob_var_JENDL_LIST_NPL_0d_int_Scalar;
                    bool& glob_aux_JENDL_LIST_NPL_read = aux_JENDL_LIST_NPL_read;
                    bool aux_JENDL_LIST_NPL_read = glob_aux_JENDL_LIST_NPL_read;
                    vartype aux_last_type_read_for_JENDL_LIST_NPL = UNKNOWN;
                    cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , JENDL_LIST_NPL , 0 / \n { 0.0 } { k = 1 to JENDL_LIST_NPL } ] LIST";
                    cpp_line = cpp_read_raw_line(cont);
                    // read LIST record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable PAR
                    var_PAR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                    aux_PAR_read = true;
                    validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
                    aux_last_type_read_for_PAR = SCALAR_DOUBLE;
                    // assign expression to variable JENDL_LIST_NPL
                    var_JENDL_LIST_NPL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_JENDL_LIST_NPL_read = true;
                    validate_vartype_consistency("JENDL_LIST_NPL", SCALAR_INT, aux_last_type_read_for_JENDL_LIST_NPL);
                    aux_last_type_read_for_JENDL_LIST_NPL = SCALAR_INT;
                    if ((((((((aux_JENDL_LIST_NPL_read == true)) && ((var_JENDL_LIST_NPL_0d_int_Scalar)!=(6)))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , JENDL_LIST_NPL , 0 / \n { 0.0 } { k = 1 to JENDL_LIST_NPL } ] LIST";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable PAR
                    var_PAR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                    aux_PAR_read = true;
                    validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
                    aux_last_type_read_for_PAR = SCALAR_DOUBLE;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable JENDL_LIST_NPL
                    var_JENDL_LIST_NPL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_JENDL_LIST_NPL_read = true;
                    validate_vartype_consistency("JENDL_LIST_NPL", SCALAR_INT, aux_last_type_read_for_JENDL_LIST_NPL);
                    aux_last_type_read_for_JENDL_LIST_NPL = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    {
                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_JENDL_LIST_NPL_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                  }
                }
              }
              if (! cpp_found_match) {
                cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , 6 , 0 / \n 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ] LIST";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST record
                // assign expression to variable SPI
                var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                aux_SPI_read = true;
                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                // assign expression to variable PAR
                var_PAR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                aux_PAR_read = true;
                validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
                aux_last_type_read_for_PAR = SCALAR_DOUBLE;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(6, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "6",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST body
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LIS == SCALAR_INT) && (aux_LIS_read == true))) {
    cpp_current_dict["LIS"] = var_LIS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LISO == SCALAR_INT) && (aux_LISO_read == true))) {
    cpp_current_dict["LISO"] = var_LISO_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NST == SCALAR_INT) && (aux_NST_read == true))) {
    cpp_current_dict["NST"] = var_NST_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NSP == SCALAR_INT) && (aux_NSP_read == true))) {
    cpp_current_dict["NSP"] = var_NSP_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_Thalf == SCALAR_DOUBLE) && (aux_Thalf_read == true))) {
    cpp_current_dict["Thalf"] = var_Thalf_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_dThalf == SCALAR_DOUBLE) && (aux_dThalf_read == true))) {
    cpp_current_dict["dThalf"] = var_dThalf_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
    cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
  }
  if ((var_Ebar_x_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_Ebar_x_1d_double_NestedVector;
    cpp_current_dict["Ebar_x"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["Ebar_x"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_dEbar_x_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_dEbar_x_1d_double_NestedVector;
    cpp_current_dict["dEbar_x"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["dEbar_x"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if (((aux_last_type_read_for_SPI == SCALAR_DOUBLE) && (aux_SPI_read == true))) {
    cpp_current_dict["SPI"] = var_SPI_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_PAR == SCALAR_DOUBLE) && (aux_PAR_read == true))) {
    cpp_current_dict["PAR"] = var_PAR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NDK == SCALAR_INT) && (aux_NDK_read == true))) {
    cpp_current_dict["NDK"] = var_NDK_0d_int_Scalar;
  }
  if ((var_RTYP_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_RTYP_1d_double_NestedVector;
    cpp_current_dict["RTYP"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["RTYP"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_RFS_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_RFS_1d_double_NestedVector;
    cpp_current_dict["RFS"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["RFS"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_Q_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_Q_1d_double_NestedVector;
    cpp_current_dict["Q"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["Q"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_dQ_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_dQ_1d_double_NestedVector;
    cpp_current_dict["dQ"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["dQ"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_BR_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_BR_1d_double_NestedVector;
    cpp_current_dict["BR"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["BR"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_dBR_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_dBR_1d_double_NestedVector;
    cpp_current_dict["dBR"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["dBR"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if (((aux_last_type_read_for_JENDL_LIST_NPL == SCALAR_INT) && (aux_JENDL_LIST_NPL_read == true))) {
    cpp_current_dict["JENDL_LIST_NPL"] = var_JENDL_LIST_NPL_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 9b44a8a45cec90ea92aa701b596f413f
// MD5 hash of the following function definition: 98f6319e99d0a4a8b9f08e732e1ee6b4
py::dict parse_mf8mt459_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_LE_0d_int_Scalar;
  bool aux_LE_read = false;
  vartype aux_last_type_read_for_LE = UNKNOWN;
  NestedVector<double> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<int> var_NN_1d_int_NestedVector;
  vartype aux_last_type_read_for_NN = UNKNOWN;
  NestedVector<int> var_NFP_1d_int_NestedVector;
  vartype aux_last_type_read_for_NFP = UNKNOWN;
  NestedVector<NestedVector<double>> var_ZAFP_2d_double_NestedVector;
  NestedVector<double>* ptr_ZAFP_2d_idx0;
  vartype aux_last_type_read_for_ZAFP = UNKNOWN;
  NestedVector<NestedVector<double>> var_FPS_2d_double_NestedVector;
  NestedVector<double>* ptr_FPS_2d_idx0;
  vartype aux_last_type_read_for_FPS = UNKNOWN;
  NestedVector<NestedVector<double>> var_YC_2d_double_NestedVector;
  NestedVector<double>* ptr_YC_2d_idx0;
  vartype aux_last_type_read_for_YC = UNKNOWN;
  NestedVector<NestedVector<double>> var_DYC_2d_double_NestedVector;
  NestedVector<double>* ptr_DYC_2d_idx0;
  vartype aux_last_type_read_for_DYC = UNKNOWN;
  NestedVector<int> var_I_1d_int_NestedVector;
  vartype aux_last_type_read_for_I = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 8;
  int mt = 459;
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 459;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 8 , MT / ZA , AWR , (LE+1) , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable cpp_int_val
  cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_cpp_int_val_read = true;
  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
  // assign expression to variable LE
  var_LE_0d_int_Scalar = (cpp_int_val+(-1));
  aux_LE_read = true;
  validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
  aux_last_type_read_for_LE = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_template = "[ MAT , 8 , MT / E , 0.0 , LE , 0 , NN , NFP / \n { ZAFP , FPS , YC , DYC } { m = 1 to NFP } ] LIST";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read LIST record
  // assign expression to variable E
  var_E_1d_double_NestedVector.set(0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts));
  validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
  aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  if ((! (aux_LE_read == true))) {
    // assign expression to variable LE
    var_LE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
    aux_LE_read = true;
    validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
    aux_last_type_read_for_LE = SCALAR_INT;
  } else {
    cpp_validate_field(var_LE_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "LE",
      cpp_template, cpp_line, parse_opts);
  }
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NN
  var_NN_1d_int_NestedVector.set(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
  validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
  aux_last_type_read_for_NN = NESTEDVECTOR_INT;
  // assign expression to variable NFP
  var_NFP_1d_int_NestedVector.set(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
  validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
  aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
  {
    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST body
    ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(0);
    ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(0);
    ptr_YC_2d_idx0 = var_YC_2d_double_NestedVector.prepare(0);
    ptr_DYC_2d_idx0 = var_DYC_2d_double_NestedVector.prepare(0);

    for (int var_m_0d_int_Scalar = 1;
       var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[0]; var_m_0d_int_Scalar++) {
      bool aux_m_read = true;
      // read LIST body
      // assign expression to variable ZAFP
      ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
      aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
      // assign expression to variable FPS
      ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
      aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
      // assign expression to variable YC
      ptr_YC_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("YC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YC);
      aux_last_type_read_for_YC = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
      // assign expression to variable DYC
      ptr_DYC_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
      validate_vartype_consistency("DYC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYC);
      aux_last_type_read_for_DYC = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_LE_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    cpp_template = "[ MAT , 8 , MT / E , 0.0 , I , 0 , NN , NFP / \n { ZAFP , FPS , YC , DYC } { m = 1 to NFP } ] LIST";
    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
    // read LIST record
    if ((! var_E_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable E
      var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts));
      validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
      aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
    } else {
      cpp_validate_field(var_E_1d_double_NestedVector[var_k_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "E",
        cpp_template, cpp_line, parse_opts);
    }
    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
      cpp_template, cpp_line, parse_opts);
    // assign expression to variable I
    var_I_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
    validate_vartype_consistency("I", NESTEDVECTOR_INT, aux_last_type_read_for_I);
    aux_last_type_read_for_I = NESTEDVECTOR_INT;
    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
      cpp_template, cpp_line, parse_opts);
    if ((! var_NN_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NN
      var_NN_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
      validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
      aux_last_type_read_for_NN = NESTEDVECTOR_INT;
    } else {
      cpp_validate_field(var_NN_1d_int_NestedVector[var_k_0d_int_Scalar], cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "NN",
        cpp_template, cpp_line, parse_opts);
    }
    if ((! var_NFP_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NFP
      var_NFP_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
      validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
      aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
    } else {
      cpp_validate_field(var_NFP_1d_int_NestedVector[var_k_0d_int_Scalar], cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NFP",
        cpp_template, cpp_line, parse_opts);
    }
    {
      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      int cpp_i = 0;
      int cpp_j = 0;
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read LIST body
      ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_YC_2d_idx0 = var_YC_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_DYC_2d_idx0 = var_DYC_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

      for (int var_m_0d_int_Scalar = 1;
         var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[var_k_0d_int_Scalar]; var_m_0d_int_Scalar++) {
        bool aux_m_read = true;
        // read LIST body
        if ((! (var_ZAFP_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_ZAFP_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable ZAFP
          ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
          aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_ZAFP_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "ZAFP",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        if ((! (var_FPS_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_FPS_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable FPS
          ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
          aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_FPS_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "FPS",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        if ((! (var_YC_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_YC_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable YC
          ptr_YC_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("YC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YC);
          aux_last_type_read_for_YC = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_YC_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "YC",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
        if ((! (var_DYC_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_DYC_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable DYC
          ptr_DYC_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
          validate_vartype_consistency("DYC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYC);
          aux_last_type_read_for_DYC = NESTEDVECTOR_DOUBLE;
        } else {
          cpp_validate_field(var_DYC_2d_double_NestedVector[var_k_0d_int_Scalar][var_m_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  true, false, false, "DYC",
            cpp_template, cpp_line, parse_opts);
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          cpp_j = 0;
        }
      }
      if (cpp_i != cpp_npl) {
        throw std::runtime_error("not exactly NPL elements consumed");
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LE == SCALAR_INT) && (aux_LE_read == true))) {
    cpp_current_dict["LE"] = var_LE_0d_int_Scalar;
  }
  if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_E_1d_double_NestedVector;
    cpp_current_dict["E"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["E"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_NN_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_NN_1d_int_NestedVector;
    cpp_current_dict["NN"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["NN"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_NFP_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_NFP_1d_int_NestedVector;
    cpp_current_dict["NFP"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["NFP"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_ZAFP_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_ZAFP_2d_double_NestedVector;
    cpp_current_dict["ZAFP"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["ZAFP"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_FPS_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_FPS_2d_double_NestedVector;
    cpp_current_dict["FPS"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["FPS"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_YC_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_YC_2d_double_NestedVector;
    cpp_current_dict["YC"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["YC"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_DYC_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_DYC_2d_double_NestedVector;
    cpp_current_dict["DYC"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["DYC"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_I_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_I_1d_int_NestedVector;
    cpp_current_dict["I"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["I"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 1db3e473b7f130d4f0683e6401196b22
// MD5 hash of the following function definition: ab971128db92eb94ae17caf8f9a520bb
py::dict parse_mf9_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 9;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 9;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 9 , MT / ZA , AWR , LIS , 0 , NS , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      if ((! cpp_parent_dict.contains("subsection"))) {
        cpp_parent_dict["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      double var_QM_0d_double_Scalar;
      bool aux_QM_read = false;
      vartype aux_last_type_read_for_QM = UNKNOWN;
      double var_QI_0d_double_Scalar;
      bool aux_QI_read = false;
      vartype aux_last_type_read_for_QI = UNKNOWN;
      int var_IZAP_0d_int_Scalar;
      bool aux_IZAP_read = false;
      vartype aux_last_type_read_for_IZAP = UNKNOWN;
      int var_LFS_0d_int_Scalar;
      bool aux_LFS_read = false;
      vartype aux_last_type_read_for_LFS = UNKNOWN;
      std::vector<double> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      vartype aux_last_type_read_for_E = UNKNOWN;
      std::vector<double> var_Y_0d_floatvec_Scalar;
      bool aux_Y_read = false;
      vartype aux_last_type_read_for_Y = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      cpp_template = "[ MAT , 9 , MT / QM , QI , IZAP , LFS , NR , NP / E / Y ] TAB1";
      // read TAB1 record
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // assign expression to variable QM
      var_QM_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
      aux_QM_read = true;
      validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
      aux_last_type_read_for_QM = SCALAR_DOUBLE;
      // assign expression to variable QI
      var_QI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
      aux_QI_read = true;
      validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
      aux_last_type_read_for_QI = SCALAR_DOUBLE;
      // assign expression to variable IZAP
      var_IZAP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
      aux_IZAP_read = true;
      validate_vartype_consistency("IZAP", SCALAR_INT, aux_last_type_read_for_IZAP);
      aux_last_type_read_for_IZAP = SCALAR_INT;
      // assign expression to variable LFS
      var_LFS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LFS_read = true;
      validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
      aux_last_type_read_for_LFS = SCALAR_INT;
      cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
      {
        Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
        // assign expression to variable E
        var_E_0d_floatvec_Scalar = tab_body.X;
        aux_E_read = true;
        validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
        aux_last_type_read_for_E = SCALAR_FLOATVEC;
        // assign expression to variable Y
        var_Y_0d_floatvec_Scalar = tab_body.Y;
        aux_Y_read = true;
        validate_vartype_consistency("Y", SCALAR_FLOATVEC, aux_last_type_read_for_Y);
        aux_last_type_read_for_Y = SCALAR_FLOATVEC;
        // assign expression to variable INT
        var_INT_0d_intvec_Scalar = tab_body.INT;
        aux_INT_read = true;
        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
        aux_last_type_read_for_INT = SCALAR_INTVEC;
        // assign expression to variable NBT
        var_NBT_0d_intvec_Scalar = tab_body.NBT;
        aux_NBT_read = true;
        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
        aux_last_type_read_for_NBT = SCALAR_INTVEC;
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_QM == SCALAR_DOUBLE) && (aux_QM_read == true))) {
        cpp_current_dict["QM"] = var_QM_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_QI == SCALAR_DOUBLE) && (aux_QI_read == true))) {
        cpp_current_dict["QI"] = var_QI_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_IZAP == SCALAR_INT) && (aux_IZAP_read == true))) {
        cpp_current_dict["IZAP"] = var_IZAP_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LFS == SCALAR_INT) && (aux_LFS_read == true))) {
        cpp_current_dict["LFS"] = var_LFS_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
        cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_Y == SCALAR_FLOATVEC) && (aux_Y_read == true))) {
        cpp_current_dict["Y"] = var_Y_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LIS == SCALAR_INT) && (aux_LIS_read == true))) {
    cpp_current_dict["LIS"] = var_LIS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NS == SCALAR_INT) && (aux_NS_read == true))) {
    cpp_current_dict["NS"] = var_NS_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: b5ce883fcd2a78e1dee22fd8e5f23c84
// MD5 hash of the following function definition: 6873a49a5e681ee4f05ca7cc29c77b9d
py::dict parse_mf10_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 10;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 10;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 10 , MT / ZA , AWR , LIS , 0 , NS , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      if ((! cpp_parent_dict.contains("subsection"))) {
        cpp_parent_dict["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      double var_QM_0d_double_Scalar;
      bool aux_QM_read = false;
      vartype aux_last_type_read_for_QM = UNKNOWN;
      double var_QI_0d_double_Scalar;
      bool aux_QI_read = false;
      vartype aux_last_type_read_for_QI = UNKNOWN;
      int var_IZAP_0d_int_Scalar;
      bool aux_IZAP_read = false;
      vartype aux_last_type_read_for_IZAP = UNKNOWN;
      int var_LFS_0d_int_Scalar;
      bool aux_LFS_read = false;
      vartype aux_last_type_read_for_LFS = UNKNOWN;
      std::vector<double> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      vartype aux_last_type_read_for_E = UNKNOWN;
      std::vector<double> var_sigma_0d_floatvec_Scalar;
      bool aux_sigma_read = false;
      vartype aux_last_type_read_for_sigma = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      cpp_template = "[ MAT , 10 , MT / QM , QI , IZAP , LFS , NR , NP / E / sigma ] TAB1";
      // read TAB1 record
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // assign expression to variable QM
      var_QM_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
      aux_QM_read = true;
      validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
      aux_last_type_read_for_QM = SCALAR_DOUBLE;
      // assign expression to variable QI
      var_QI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
      aux_QI_read = true;
      validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
      aux_last_type_read_for_QI = SCALAR_DOUBLE;
      // assign expression to variable IZAP
      var_IZAP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
      aux_IZAP_read = true;
      validate_vartype_consistency("IZAP", SCALAR_INT, aux_last_type_read_for_IZAP);
      aux_last_type_read_for_IZAP = SCALAR_INT;
      // assign expression to variable LFS
      var_LFS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LFS_read = true;
      validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
      aux_last_type_read_for_LFS = SCALAR_INT;
      cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
      {
        Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
        // assign expression to variable E
        var_E_0d_floatvec_Scalar = tab_body.X;
        aux_E_read = true;
        validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
        aux_last_type_read_for_E = SCALAR_FLOATVEC;
        // assign expression to variable sigma
        var_sigma_0d_floatvec_Scalar = tab_body.Y;
        aux_sigma_read = true;
        validate_vartype_consistency("sigma", SCALAR_FLOATVEC, aux_last_type_read_for_sigma);
        aux_last_type_read_for_sigma = SCALAR_FLOATVEC;
        // assign expression to variable INT
        var_INT_0d_intvec_Scalar = tab_body.INT;
        aux_INT_read = true;
        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
        aux_last_type_read_for_INT = SCALAR_INTVEC;
        // assign expression to variable NBT
        var_NBT_0d_intvec_Scalar = tab_body.NBT;
        aux_NBT_read = true;
        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
        aux_last_type_read_for_NBT = SCALAR_INTVEC;
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_QM == SCALAR_DOUBLE) && (aux_QM_read == true))) {
        cpp_current_dict["QM"] = var_QM_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_QI == SCALAR_DOUBLE) && (aux_QI_read == true))) {
        cpp_current_dict["QI"] = var_QI_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_IZAP == SCALAR_INT) && (aux_IZAP_read == true))) {
        cpp_current_dict["IZAP"] = var_IZAP_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LFS == SCALAR_INT) && (aux_LFS_read == true))) {
        cpp_current_dict["LFS"] = var_LFS_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
        cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_sigma == SCALAR_FLOATVEC) && (aux_sigma_read == true))) {
        cpp_current_dict["sigma"] = var_sigma_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LIS == SCALAR_INT) && (aux_LIS_read == true))) {
    cpp_current_dict["LIS"] = var_LIS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NS == SCALAR_INT) && (aux_NS_read == true))) {
    cpp_current_dict["NS"] = var_NS_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: e54487563cbd4b212af001ef1d061333
// MD5 hash of the following function definition: ae60b28e1f6020acffbdaf131f1bda6f
py::dict parse_mf12_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LO_0d_int_Scalar;
  bool aux_LO_read = false;
  vartype aux_last_type_read_for_LO = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::vector<double> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<double> var_Y_0d_floatvec_Scalar;
  bool aux_Y_read = false;
  vartype aux_last_type_read_for_Y = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  NestedVector<double> var_Eg_1d_double_NestedVector;
  vartype aux_last_type_read_for_Eg = UNKNOWN;
  NestedVector<double> var_ES_1d_double_NestedVector;
  vartype aux_last_type_read_for_ES = UNKNOWN;
  NestedVector<int> var_LP_1d_int_NestedVector;
  vartype aux_last_type_read_for_LP = UNKNOWN;
  NestedVector<int> var_LF_1d_int_NestedVector;
  vartype aux_last_type_read_for_LF = UNKNOWN;
  int var_LG_0d_int_Scalar;
  bool aux_LG_read = false;
  vartype aux_last_type_read_for_LG = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  double var_ES_NS_0d_double_Scalar;
  bool aux_ES_NS_read = false;
  vartype aux_last_type_read_for_ES_NS = UNKNOWN;
  int var_LP_0d_int_Scalar;
  bool aux_LP_read = false;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_NT_0d_int_Scalar;
  bool aux_NT_read = false;
  vartype aux_last_type_read_for_NT = UNKNOWN;
  NestedVector<double> var_TP_1d_double_NestedVector;
  vartype aux_last_type_read_for_TP = UNKNOWN;
  NestedVector<double> var_GP_1d_double_NestedVector;
  vartype aux_last_type_read_for_GP = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 12;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 12;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        std::streampos cpp_old_streampos = cont.tellg();
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
          int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
          bool& glob_aux_LO_read = aux_LO_read;
          bool aux_LO_read = glob_aux_LO_read;
          vartype aux_last_type_read_for_LO = UNKNOWN;
          int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
          int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
          bool& glob_aux_NK_read = aux_NK_read;
          bool aux_NK_read = glob_aux_NK_read;
          vartype aux_last_type_read_for_NK = UNKNOWN;
          cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , 0 , NK , 0 ] HEAD";
          cpp_line = cpp_read_raw_line(cont);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LO
          var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LO_read = true;
          validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
          aux_last_type_read_for_LO = SCALAR_INT;
          // assign expression to variable NK
          var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NK_read = true;
          validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
          aux_last_type_read_for_NK = SCALAR_INT;
          if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(1)))))))) {
            cpp_found_match = true;
          }
          cont.seekg(cpp_old_streampos);
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , 0 , NK , 0 ] HEAD";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LO
          var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LO_read = true;
          validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
          aux_last_type_read_for_LO = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NK
          var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NK_read = true;
          validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
          aux_last_type_read_for_NK = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((aux_NK_read == true)) && ((var_NK_0d_int_Scalar)>(1)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                cpp_template = "[ MAT , 12 , MT / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / Y ] TAB1";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                {
                  Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                  // assign expression to variable Y
                  var_Y_0d_floatvec_Scalar = tab_body.Y;
                  aux_Y_read = true;
                  validate_vartype_consistency("Y", SCALAR_FLOATVEC, aux_last_type_read_for_Y);
                  aux_last_type_read_for_Y = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
              }
            }
          }

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            cpp_template = "[ MAT , 12 , MT / Eg , ES , LP , LF , NR , NP / Eint / y ] TAB1 ( table [ k ] )";
            // read TAB1 record
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // assign expression to variable Eg
            var_Eg_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts));
            validate_vartype_consistency("Eg", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Eg);
            aux_last_type_read_for_Eg = NESTEDVECTOR_DOUBLE;
            // assign expression to variable ES
            var_ES_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
            validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
            aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
            // assign expression to variable LP
            var_LP_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
            validate_vartype_consistency("LP", NESTEDVECTOR_INT, aux_last_type_read_for_LP);
            aux_last_type_read_for_LP = NESTEDVECTOR_INT;
            // assign expression to variable LF
            var_LF_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
            validate_vartype_consistency("LF", NESTEDVECTOR_INT, aux_last_type_read_for_LF);
            aux_last_type_read_for_LF = NESTEDVECTOR_INT;
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              if ((! cpp_parent_dict.contains("table"))) {
                cpp_parent_dict["table"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict["table"];
              if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              // variable declarations
              std::vector<double> var_Eint_0d_floatvec_Scalar;
              bool aux_Eint_read = false;
              vartype aux_last_type_read_for_Eint = UNKNOWN;
              std::vector<double> var_y_0d_floatvec_Scalar;
              bool aux_y_read = false;
              vartype aux_last_type_read_for_y = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                if ((! (aux_Eint_read == true))) {
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                } else {
                  cpp_validate_field(var_Eint_0d_floatvec_Scalar, tab_body.X,  true, false, false, "Eint",
                    cpp_template, cpp_line, parse_opts);
                }
                // assign expression to variable y
                var_y_0d_floatvec_Scalar = tab_body.Y;
                aux_y_read = true;
                validate_vartype_consistency("y", SCALAR_FLOATVEC, aux_last_type_read_for_y);
                aux_last_type_read_for_y = SCALAR_FLOATVEC;
                if ((! (aux_INT_read == true))) {
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                } else {
                  cpp_validate_field(var_INT_0d_intvec_Scalar, tab_body.INT,  true, false, false, "INT",
                    cpp_template, cpp_line, parse_opts);
                }
                if ((! (aux_NBT_read == true))) {
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                } else {
                  cpp_validate_field(var_NBT_0d_intvec_Scalar, tab_body.NBT,  true, false, false, "NBT",
                    cpp_template, cpp_line, parse_opts);
                }
              }
              // store data in Python dictionary
              if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
                cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_y == SCALAR_FLOATVEC) && (aux_y_read == true))) {
                cpp_current_dict["y"] = var_y_0d_floatvec_Scalar;
              }
              if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
              }
              if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
            int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
            bool& glob_aux_LO_read = aux_LO_read;
            bool aux_LO_read = glob_aux_LO_read;
            vartype aux_last_type_read_for_LO = UNKNOWN;
            int& glob_var_LG_0d_int_Scalar = var_LG_0d_int_Scalar;
            int var_LG_0d_int_Scalar = glob_var_LG_0d_int_Scalar;
            bool& glob_aux_LG_read = aux_LG_read;
            bool aux_LG_read = glob_aux_LG_read;
            vartype aux_last_type_read_for_LG = UNKNOWN;
            int& glob_var_NS_0d_int_Scalar = var_NS_0d_int_Scalar;
            int var_NS_0d_int_Scalar = glob_var_NS_0d_int_Scalar;
            bool& glob_aux_NS_read = aux_NS_read;
            bool aux_NS_read = glob_aux_NS_read;
            vartype aux_last_type_read_for_NS = UNKNOWN;
            cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , LG , NS , 0 ] HEAD";
            cpp_line = cpp_read_raw_line(cont);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LO
            var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            // assign expression to variable LG
            var_LG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LG_read = true;
            validate_vartype_consistency("LG", SCALAR_INT, aux_last_type_read_for_LG);
            aux_last_type_read_for_LG = SCALAR_INT;
            // assign expression to variable NS
            var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NS_read = true;
            validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
            aux_last_type_read_for_NS = SCALAR_INT;
            if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(2)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , LG , NS , 0 ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LO
            var_LO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            // assign expression to variable LG
            var_LG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LG_read = true;
            validate_vartype_consistency("LG", SCALAR_INT, aux_last_type_read_for_LG);
            aux_last_type_read_for_LG = SCALAR_INT;
            // assign expression to variable NS
            var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NS_read = true;
            validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
            aux_last_type_read_for_NS = SCALAR_INT;
            cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
              cpp_template, cpp_line, parse_opts);
            // evaluate if-elif-else clause
            {
              bool cpp_found_match = false;
              if (! cpp_found_match) {
                if ((((((((aux_LG_read == true)) && ((var_LG_0d_int_Scalar)==(1)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  cpp_template = "[ MAT , 12 , MT / ES_NS , 0.0 , LP , 0 , (2*NT) , NT / \n { ES , TP } { i = 1 to NT } ] LIST";
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST record
                  // assign expression to variable ES_NS
                  var_ES_NS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                  aux_ES_NS_read = true;
                  validate_vartype_consistency("ES_NS", SCALAR_DOUBLE, aux_last_type_read_for_ES_NS);
                  aux_last_type_read_for_ES_NS = SCALAR_DOUBLE;
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable LP
                  var_LP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                  aux_LP_read = true;
                  validate_vartype_consistency("LP", SCALAR_INT, aux_last_type_read_for_LP);
                  aux_last_type_read_for_LP = SCALAR_INT;
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable cpp_int_val
                  cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  aux_cpp_int_val_read = true;
                  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                  // assign expression to variable NT
                  var_NT_0d_int_Scalar = (cpp_int_val/2);
                  aux_NT_read = true;
                  validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                  aux_last_type_read_for_NT = SCALAR_INT;
                  if ((! (aux_NT_read == true))) {
                    // assign expression to variable NT
                    var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_NT_read = true;
                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                    aux_last_type_read_for_NT = SCALAR_INT;
                  } else {
                    cpp_validate_field(var_NT_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NT",
                      cpp_template, cpp_line, parse_opts);
                  }
                  {
                    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    int cpp_i = 0;
                    int cpp_j = 0;
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST body

                    for (int var_i_0d_int_Scalar = 1;
                       var_i_0d_int_Scalar <= var_NT_0d_int_Scalar; var_i_0d_int_Scalar++) {
                      bool aux_i_read = true;
                      // read LIST body
                      // assign expression to variable ES
                      var_ES_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                      validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                      aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                      cpp_i++;
                      cpp_j++;
                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        cpp_j = 0;
                      }
                      // assign expression to variable TP
                      var_TP_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                      validate_vartype_consistency("TP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_TP);
                      aux_last_type_read_for_TP = NESTEDVECTOR_DOUBLE;
                      cpp_i++;
                      cpp_j++;
                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        cpp_j = 0;
                      }
                    }
                    if (cpp_i != cpp_npl) {
                      throw std::runtime_error("not exactly NPL elements consumed");
                    }
                  }
                }
              }
              if (! cpp_found_match) {
                if (! cpp_found_match) {
                  if ((((((((aux_LG_read == true)) && ((var_LG_0d_int_Scalar)==(2)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    cpp_template = "[ MAT , 12 , MT / ES_NS , 0.0 , LP , 0 , ((LG+1)*NT) , NT / \n { ES , TP , GP } { i = 1 to NT } ] LIST";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST record
                    // assign expression to variable ES_NS
                    var_ES_NS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_ES_NS_read = true;
                    validate_vartype_consistency("ES_NS", SCALAR_DOUBLE, aux_last_type_read_for_ES_NS);
                    aux_last_type_read_for_ES_NS = SCALAR_DOUBLE;
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable LP
                    var_LP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_LP_read = true;
                    validate_vartype_consistency("LP", SCALAR_INT, aux_last_type_read_for_LP);
                    aux_last_type_read_for_LP = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable cpp_int_val
                    cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_cpp_int_val_read = true;
                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                    // assign expression to variable NT
                    var_NT_0d_int_Scalar = (cpp_int_val/(var_LG_0d_int_Scalar+1));
                    aux_NT_read = true;
                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                    aux_last_type_read_for_NT = SCALAR_INT;
                    if ((! (aux_NT_read == true))) {
                      // assign expression to variable NT
                      var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_NT_read = true;
                      validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                      aux_last_type_read_for_NT = SCALAR_INT;
                    } else {
                      cpp_validate_field(var_NT_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NT",
                        cpp_template, cpp_line, parse_opts);
                    }
                    {
                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST body

                      for (int var_i_0d_int_Scalar = 1;
                         var_i_0d_int_Scalar <= var_NT_0d_int_Scalar; var_i_0d_int_Scalar++) {
                        bool aux_i_read = true;
                        // read LIST body
                        // assign expression to variable ES
                        var_ES_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                        aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable TP
                        var_TP_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("TP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_TP);
                        aux_last_type_read_for_TP = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GP
                        var_GP_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GP);
                        aux_last_type_read_for_GP = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LO == SCALAR_INT) && (aux_LO_read == true))) {
    cpp_current_dict["LO"] = var_LO_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NK == SCALAR_INT) && (aux_NK_read == true))) {
    cpp_current_dict["NK"] = var_NK_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
    cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_Y == SCALAR_FLOATVEC) && (aux_Y_read == true))) {
    cpp_current_dict["Y"] = var_Y_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  if ((var_Eg_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_Eg_1d_double_NestedVector;
    cpp_current_dict["Eg"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["Eg"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_ES_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_ES_1d_double_NestedVector;
    cpp_current_dict["ES"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["ES"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_LP_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_LP_1d_int_NestedVector;
    cpp_current_dict["LP"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["LP"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_LF_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_LF_1d_int_NestedVector;
    cpp_current_dict["LF"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["LF"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if (((aux_last_type_read_for_LG == SCALAR_INT) && (aux_LG_read == true))) {
    cpp_current_dict["LG"] = var_LG_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NS == SCALAR_INT) && (aux_NS_read == true))) {
    cpp_current_dict["NS"] = var_NS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ES_NS == SCALAR_DOUBLE) && (aux_ES_NS_read == true))) {
    cpp_current_dict["ES_NS"] = var_ES_NS_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LP == SCALAR_INT) && (aux_LP_read == true))) {
    cpp_current_dict["LP"] = var_LP_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NT == SCALAR_INT) && (aux_NT_read == true))) {
    cpp_current_dict["NT"] = var_NT_0d_int_Scalar;
  }
  if ((var_TP_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_TP_1d_double_NestedVector;
    cpp_current_dict["TP"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["TP"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_GP_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_GP_1d_double_NestedVector;
    cpp_current_dict["GP"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["GP"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 0244722dd783f7feb5112a1d869b898f
// MD5 hash of the following function definition: da4869199021520ebd4f09fc9ee39acc
py::dict parse_mf13_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::vector<double> var_E_0d_floatvec_Scalar;
  bool aux_E_read = false;
  vartype aux_last_type_read_for_E = UNKNOWN;
  std::vector<double> var_sigma_tot_0d_floatvec_Scalar;
  bool aux_sigma_tot_read = false;
  vartype aux_last_type_read_for_sigma_tot = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 13;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 13;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 13 , MT / ZA , AWR , 0 , 0 , NK , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_NK_read == true)) && ((var_NK_0d_int_Scalar)>(1)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 13 , MT / 0.0 , 0.0 , 0 , 0 , NR , NP / E / sigma_tot ] TAB1";
        // read TAB1 record
        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
          cpp_template, cpp_line, parse_opts);
        cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
        cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
        {
          Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
          // assign expression to variable E
          var_E_0d_floatvec_Scalar = tab_body.X;
          aux_E_read = true;
          validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
          aux_last_type_read_for_E = SCALAR_FLOATVEC;
          // assign expression to variable sigma_tot
          var_sigma_tot_0d_floatvec_Scalar = tab_body.Y;
          aux_sigma_tot_read = true;
          validate_vartype_consistency("sigma_tot", SCALAR_FLOATVEC, aux_last_type_read_for_sigma_tot);
          aux_last_type_read_for_sigma_tot = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
      }
    }
  }

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      if ((! cpp_parent_dict.contains("subsection"))) {
        cpp_parent_dict["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      double var_EG_0d_double_Scalar;
      bool aux_EG_read = false;
      vartype aux_last_type_read_for_EG = UNKNOWN;
      double var_ES_0d_double_Scalar;
      bool aux_ES_read = false;
      vartype aux_last_type_read_for_ES = UNKNOWN;
      int var_LP_0d_int_Scalar;
      bool aux_LP_read = false;
      vartype aux_last_type_read_for_LP = UNKNOWN;
      int var_LF_0d_int_Scalar;
      bool aux_LF_read = false;
      vartype aux_last_type_read_for_LF = UNKNOWN;
      std::vector<double> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      vartype aux_last_type_read_for_E = UNKNOWN;
      std::vector<double> var_sigma_0d_floatvec_Scalar;
      bool aux_sigma_read = false;
      vartype aux_last_type_read_for_sigma = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      cpp_template = "[ MAT , 13 , MT / EG , ES , LP , LF , NR , NP / E / sigma ] TAB1";
      // read TAB1 record
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // assign expression to variable EG
      var_EG_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
      aux_EG_read = true;
      validate_vartype_consistency("EG", SCALAR_DOUBLE, aux_last_type_read_for_EG);
      aux_last_type_read_for_EG = SCALAR_DOUBLE;
      // assign expression to variable ES
      var_ES_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
      aux_ES_read = true;
      validate_vartype_consistency("ES", SCALAR_DOUBLE, aux_last_type_read_for_ES);
      aux_last_type_read_for_ES = SCALAR_DOUBLE;
      // assign expression to variable LP
      var_LP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
      aux_LP_read = true;
      validate_vartype_consistency("LP", SCALAR_INT, aux_last_type_read_for_LP);
      aux_last_type_read_for_LP = SCALAR_INT;
      // assign expression to variable LF
      var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LF_read = true;
      validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
      aux_last_type_read_for_LF = SCALAR_INT;
      cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
      {
        Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
        if ((! (aux_E_read == true))) {
          // assign expression to variable E
          var_E_0d_floatvec_Scalar = tab_body.X;
          aux_E_read = true;
          validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
          aux_last_type_read_for_E = SCALAR_FLOATVEC;
        } else {
          cpp_validate_field(var_E_0d_floatvec_Scalar, tab_body.X,  true, false, false, "E",
            cpp_template, cpp_line, parse_opts);
        }
        // assign expression to variable sigma
        var_sigma_0d_floatvec_Scalar = tab_body.Y;
        aux_sigma_read = true;
        validate_vartype_consistency("sigma", SCALAR_FLOATVEC, aux_last_type_read_for_sigma);
        aux_last_type_read_for_sigma = SCALAR_FLOATVEC;
        if ((! (aux_INT_read == true))) {
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
        } else {
          cpp_validate_field(var_INT_0d_intvec_Scalar, tab_body.INT,  true, false, false, "INT",
            cpp_template, cpp_line, parse_opts);
        }
        if ((! (aux_NBT_read == true))) {
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        } else {
          cpp_validate_field(var_NBT_0d_intvec_Scalar, tab_body.NBT,  true, false, false, "NBT",
            cpp_template, cpp_line, parse_opts);
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_EG == SCALAR_DOUBLE) && (aux_EG_read == true))) {
        cpp_current_dict["EG"] = var_EG_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_ES == SCALAR_DOUBLE) && (aux_ES_read == true))) {
        cpp_current_dict["ES"] = var_ES_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_LP == SCALAR_INT) && (aux_LP_read == true))) {
        cpp_current_dict["LP"] = var_LP_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LF == SCALAR_INT) && (aux_LF_read == true))) {
        cpp_current_dict["LF"] = var_LF_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
        cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_sigma == SCALAR_FLOATVEC) && (aux_sigma_read == true))) {
        cpp_current_dict["sigma"] = var_sigma_0d_floatvec_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NK == SCALAR_INT) && (aux_NK_read == true))) {
    cpp_current_dict["NK"] = var_NK_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_E == SCALAR_FLOATVEC) && (aux_E_read == true))) {
    cpp_current_dict["E"] = var_E_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_sigma_tot == SCALAR_FLOATVEC) && (aux_sigma_tot_read == true))) {
    cpp_current_dict["sigma_tot"] = var_sigma_tot_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: cbb953767d4afb465ff9cee335ea03ef
// MD5 hash of the following function definition: bf42b03f450e91040d9c8f09677f73b4
py::dict parse_mf14_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LI_0d_int_Scalar;
  bool aux_LI_read = false;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  int var_LTT_0d_int_Scalar;
  bool aux_LTT_read = false;
  vartype aux_last_type_read_for_LTT = UNKNOWN;
  int var_NI_0d_int_Scalar;
  bool aux_NI_read = false;
  vartype aux_last_type_read_for_NI = UNKNOWN;
  NestedVector<double> var_EG_1d_double_NestedVector;
  vartype aux_last_type_read_for_EG = UNKNOWN;
  NestedVector<double> var_ES_1d_double_NestedVector;
  vartype aux_last_type_read_for_ES = UNKNOWN;
  NestedVector<int> var_NE_1d_int_NestedVector;
  vartype aux_last_type_read_for_NE = UNKNOWN;
  NestedVector<NestedVector<double>> var_E_2d_double_NestedVector;
  NestedVector<double>* ptr_E_2d_idx0;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<NestedVector<int>> var_NL_2d_int_NestedVector;
  NestedVector<int>* ptr_NL_2d_idx0;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  NestedVector<NestedVector<NestedVector<double>>> var_a_3d_double_NestedVector;
  NestedVector<double>* ptr_a_3d_idx1;
  NestedVector<NestedVector<double>>* ptr_a_3d_idx0;
  vartype aux_last_type_read_for_a = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 14;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 14;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        std::streampos cpp_old_streampos = cont.tellg();
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
          int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
          bool& glob_aux_LI_read = aux_LI_read;
          bool aux_LI_read = glob_aux_LI_read;
          vartype aux_last_type_read_for_LI = UNKNOWN;
          int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
          int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
          bool& glob_aux_NK_read = aux_NK_read;
          bool aux_NK_read = glob_aux_NK_read;
          vartype aux_last_type_read_for_NK = UNKNOWN;
          cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , 0 , NK , 0 ] HEAD";
          cpp_line = cpp_read_raw_line(cont);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LI
          var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          // assign expression to variable NK
          var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NK_read = true;
          validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
          aux_last_type_read_for_NK = SCALAR_INT;
          if ((((((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(1)))))))) {
            cpp_found_match = true;
          }
          cont.seekg(cpp_old_streampos);
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , 0 , NK , 0 ] HEAD";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LI
          var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable NK
          var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NK_read = true;
          validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
          aux_last_type_read_for_NK = SCALAR_INT;
          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
            cpp_template, cpp_line, parse_opts);
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
            int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
            bool& glob_aux_LI_read = aux_LI_read;
            bool aux_LI_read = glob_aux_LI_read;
            vartype aux_last_type_read_for_LI = UNKNOWN;
            int& glob_var_LTT_0d_int_Scalar = var_LTT_0d_int_Scalar;
            int var_LTT_0d_int_Scalar = glob_var_LTT_0d_int_Scalar;
            bool& glob_aux_LTT_read = aux_LTT_read;
            bool aux_LTT_read = glob_aux_LTT_read;
            vartype aux_last_type_read_for_LTT = UNKNOWN;
            int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
            int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
            bool& glob_aux_NK_read = aux_NK_read;
            bool aux_NK_read = glob_aux_NK_read;
            vartype aux_last_type_read_for_NK = UNKNOWN;
            int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
            int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
            bool& glob_aux_NI_read = aux_NI_read;
            bool aux_NI_read = glob_aux_NI_read;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
            cpp_line = cpp_read_raw_line(cont);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LI
            var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            // assign expression to variable LTT
            var_LTT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LTT_read = true;
            validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
            aux_last_type_read_for_LTT = SCALAR_INT;
            // assign expression to variable NK
            var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
            // assign expression to variable NI
            var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
            if (((((((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))&&((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(1)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LI
            var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            // assign expression to variable LTT
            var_LTT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LTT_read = true;
            validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
            aux_last_type_read_for_LTT = SCALAR_INT;
            // assign expression to variable NK
            var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
            // assign expression to variable NI
            var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NI_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              cpp_template = "[ MAT , 14 , MT / EG , ES , 0 , 0 , 0 , 0 ] CONT";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read CONT record
              // assign expression to variable EG
              var_EG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts));
              validate_vartype_consistency("EG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EG);
              aux_last_type_read_for_EG = NESTEDVECTOR_DOUBLE;
              // assign expression to variable ES
              var_ES_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
              validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
              aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
            }

            for (int var_k_0d_int_Scalar = (var_NI_0d_int_Scalar+1);
               var_k_0d_int_Scalar <= (var_NI_0d_int_Scalar+(var_NK_0d_int_Scalar-var_NI_0d_int_Scalar)); var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              cpp_template = "[ MAT , 14 , MT / EG , ES , 0 , 0 , NR , NE / E ] TAB2 ( E_interpol [ k ] )";
              // read TAB2 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              if ((! var_EG_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
                // assign expression to variable EG
                var_EG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts));
                validate_vartype_consistency("EG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EG);
                aux_last_type_read_for_EG = NESTEDVECTOR_DOUBLE;
              } else {
                cpp_validate_field(var_EG_1d_double_NestedVector[var_k_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  true, false, false, "EG",
                  cpp_template, cpp_line, parse_opts);
              }
              if ((! var_ES_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
                // assign expression to variable ES
                var_ES_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
              } else {
                cpp_validate_field(var_ES_1d_double_NestedVector[var_k_0d_int_Scalar], cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  true, false, false, "ES",
                  cpp_template, cpp_line, parse_opts);
              }
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NE
              var_NE_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
              validate_vartype_consistency("NE", NESTEDVECTOR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = NESTEDVECTOR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                if ((! cpp_parent_dict.contains("E_interpol"))) {
                  cpp_parent_dict["E_interpol"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict["E_interpol"];
                if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                  cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                }
                cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                // variable declarations
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                  cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                }
                if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                  cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                }
                cpp_current_dict = cpp_parent_dict;
              }
              ptr_E_2d_idx0 = var_E_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
              ptr_a_3d_idx0 = var_a_3d_double_NestedVector.prepare(var_k_0d_int_Scalar);

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NE_1d_int_NestedVector[var_k_0d_int_Scalar]; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                cpp_template = "[ MAT , 14 , MT / 0.0 , E , 0 , 0 , NL , 0 / \n { a } { m = 1 to NL } ] LIST";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST record
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable E
                ptr_E_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable NL
                ptr_NL_2d_idx0 = var_NL_2d_int_NestedVector.prepare(var_k_0d_int_Scalar);
                ptr_NL_2d_idx0->set(var_l_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
                validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = NESTEDVECTOR_INT;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST body
                  ptr_a_3d_idx1 = ptr_a_3d_idx0->prepare(var_l_0d_int_Scalar);

                  for (int var_m_0d_int_Scalar = 1;
                     var_m_0d_int_Scalar <= var_NL_2d_int_NestedVector[var_k_0d_int_Scalar][var_l_0d_int_Scalar]; var_m_0d_int_Scalar++) {
                    bool aux_m_read = true;
                    // read LIST body
                    // assign expression to variable a
                    ptr_a_3d_idx1->set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                    validate_vartype_consistency("a", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_a);
                    aux_last_type_read_for_a = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      cpp_j = 0;
                    }
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
              }
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          std::streampos cpp_old_streampos = cont.tellg();
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
            int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
            bool& glob_aux_LI_read = aux_LI_read;
            bool aux_LI_read = glob_aux_LI_read;
            vartype aux_last_type_read_for_LI = UNKNOWN;
            int& glob_var_LTT_0d_int_Scalar = var_LTT_0d_int_Scalar;
            int var_LTT_0d_int_Scalar = glob_var_LTT_0d_int_Scalar;
            bool& glob_aux_LTT_read = aux_LTT_read;
            bool aux_LTT_read = glob_aux_LTT_read;
            vartype aux_last_type_read_for_LTT = UNKNOWN;
            int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
            int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
            bool& glob_aux_NK_read = aux_NK_read;
            bool aux_NK_read = glob_aux_NK_read;
            vartype aux_last_type_read_for_NK = UNKNOWN;
            int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
            int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
            bool& glob_aux_NI_read = aux_NI_read;
            bool aux_NI_read = glob_aux_NI_read;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
            cpp_line = cpp_read_raw_line(cont);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LI
            var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            // assign expression to variable LTT
            var_LTT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LTT_read = true;
            validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
            aux_last_type_read_for_LTT = SCALAR_INT;
            // assign expression to variable NK
            var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
            // assign expression to variable NI
            var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
            if (((((((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))&&((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(2)))))))) {
              cpp_found_match = true;
            }
            cont.seekg(cpp_old_streampos);
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LI
            var_LI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            // assign expression to variable LTT
            var_LTT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_LTT_read = true;
            validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
            aux_last_type_read_for_LTT = SCALAR_INT;
            // assign expression to variable NK
            var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
            // assign expression to variable NI
            var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LI == SCALAR_INT) && (aux_LI_read == true))) {
    cpp_current_dict["LI"] = var_LI_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NK == SCALAR_INT) && (aux_NK_read == true))) {
    cpp_current_dict["NK"] = var_NK_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_LTT == SCALAR_INT) && (aux_LTT_read == true))) {
    cpp_current_dict["LTT"] = var_LTT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NI == SCALAR_INT) && (aux_NI_read == true))) {
    cpp_current_dict["NI"] = var_NI_0d_int_Scalar;
  }
  if ((var_EG_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_EG_1d_double_NestedVector;
    cpp_current_dict["EG"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["EG"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_ES_1d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_ES_1d_double_NestedVector;
    cpp_current_dict["ES"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["ES"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_NE_1d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_NE_1d_int_NestedVector;
    cpp_current_dict["NE"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["NE"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
    }
  }
  if ((var_E_2d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_E_2d_double_NestedVector;
    cpp_current_dict["E"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["E"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_NL_2d_int_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_NL_2d_int_NestedVector;
    cpp_current_dict["NL"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["NL"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
      }
    }
  }
  if ((var_a_3d_double_NestedVector.get_last_index() != -1)) {
    auto& cpp_curvar0 = var_a_3d_double_NestedVector;
    cpp_current_dict["a"] = py::dict();
    py::dict cpp_curdict0 = cpp_current_dict["a"];
    for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
      auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
      for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
        auto& cpp_curvar2 = cpp_curvar1[cpp_i2];
        cpp_curdict1[py::cast(cpp_i2)] = py::dict();
        py::dict cpp_curdict2 = cpp_curdict1[py::cast(cpp_i2)];
        for (int cpp_i3 = cpp_curvar2.get_start_index(); cpp_i3 <= cpp_curvar2.get_last_index(); cpp_i3++) {
          cpp_curdict2[py::cast(cpp_i3)] = cpp_curvar2[cpp_i3];
        }
      }
    }
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: d686a05ea85d12021bed42716983796f
// MD5 hash of the following function definition: 16f65d489e056f596b751b4a7d6cdddc
py::dict parse_mf15_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 15;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 15;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 15 , MT / ZA , AWR , 0 , 0 , NC , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NC
  var_NC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NC_read = true;
  validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
  aux_last_type_read_for_NC = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_j_0d_int_Scalar = 1;
     var_j_0d_int_Scalar <= var_NC_0d_int_Scalar; var_j_0d_int_Scalar++) {
    bool aux_j_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      if ((! cpp_parent_dict.contains("subsection"))) {
        cpp_parent_dict["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
      // variable declarations
      int var_LF_0d_int_Scalar;
      bool aux_LF_read = false;
      vartype aux_last_type_read_for_LF = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      NestedVector<double> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            std::streampos cpp_old_streampos = cont.tellg();
            {
              // variable declarations
              int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
              int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
              bool& glob_aux_LF_read = aux_LF_read;
              bool aux_LF_read = glob_aux_LF_read;
              vartype aux_last_type_read_for_LF = UNKNOWN;
              cpp_template = "[ MAT , 15 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / Eint / p ] TAB1 ( rtfm_tab1 )";
              // read TAB1 record
              cpp_line = cpp_read_raw_line(cont);
              // assign expression to variable LF
              var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LF_read = true;
              validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
              aux_last_type_read_for_LF = SCALAR_INT;
              if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(1)))))))) {
                cpp_found_match = true;
              }
              cont.seekg(cpp_old_streampos);
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 15 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / Eint / p ] TAB1 ( rtfm_tab1 )";
              // read TAB1 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable LF
              var_LF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LF_read = true;
              validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
              aux_last_type_read_for_LF = SCALAR_INT;
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                if ((! cpp_parent_dict.contains("rtfm_tab1"))) {
                  cpp_parent_dict["rtfm_tab1"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict["rtfm_tab1"];
                cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                // variable declarations
                std::vector<double> var_Eint_0d_floatvec_Scalar;
                bool aux_Eint_read = false;
                vartype aux_last_type_read_for_Eint = UNKNOWN;
                std::vector<double> var_p_0d_floatvec_Scalar;
                bool aux_p_read = false;
                vartype aux_last_type_read_for_p = UNKNOWN;
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
                  cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
                }
                if (((aux_last_type_read_for_p == SCALAR_FLOATVEC) && (aux_p_read == true))) {
                  cpp_current_dict["p"] = var_p_0d_floatvec_Scalar;
                }
                if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                  cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                }
                if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                  cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                }
                cpp_current_dict = cpp_parent_dict;
              }
              cpp_template = "[ MAT , 15 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
              // read TAB2 record
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              {
                Tab2Body tab_body = read_tab2_body_debug(cont, cpp_line, cpp_nr_val, mat, mf, mt, parse_opts);
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }

              for (int var_k_0d_int_Scalar = 1;
                 var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                bool aux_k_read = true;
                cpp_template = "[ MAT , 15 , MT / 0.0 , E , 0 , 0 , NR , NP / Egamma / g ] TAB1 ( rtfm1_tab [ k ] )";
                // read TAB1 record
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                {
                  py::dict cpp_parent_dict = cpp_current_dict;
                  if ((! cpp_parent_dict.contains("rtfm1_tab"))) {
                    cpp_parent_dict["rtfm1_tab"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict["rtfm1_tab"];
                  if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                    cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                  }
                  cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  // variable declarations
                  std::vector<double> var_Egamma_0d_floatvec_Scalar;
                  bool aux_Egamma_read = false;
                  vartype aux_last_type_read_for_Egamma = UNKNOWN;
                  std::vector<double> var_g_0d_floatvec_Scalar;
                  bool aux_g_read = false;
                  vartype aux_last_type_read_for_g = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
                    // assign expression to variable Egamma
                    var_Egamma_0d_floatvec_Scalar = tab_body.X;
                    aux_Egamma_read = true;
                    validate_vartype_consistency("Egamma", SCALAR_FLOATVEC, aux_last_type_read_for_Egamma);
                    aux_last_type_read_for_Egamma = SCALAR_FLOATVEC;
                    // assign expression to variable g
                    var_g_0d_floatvec_Scalar = tab_body.Y;
                    aux_g_read = true;
                    validate_vartype_consistency("g", SCALAR_FLOATVEC, aux_last_type_read_for_g);
                    aux_last_type_read_for_g = SCALAR_FLOATVEC;
                    if ((! (aux_INT_read == true))) {
                      // assign expression to variable INT
                      var_INT_0d_intvec_Scalar = tab_body.INT;
                      aux_INT_read = true;
                      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                      aux_last_type_read_for_INT = SCALAR_INTVEC;
                    } else {
                      cpp_validate_field(var_INT_0d_intvec_Scalar, tab_body.INT,  true, false, false, "INT",
                        cpp_template, cpp_line, parse_opts);
                    }
                    if ((! (aux_NBT_read == true))) {
                      // assign expression to variable NBT
                      var_NBT_0d_intvec_Scalar = tab_body.NBT;
                      aux_NBT_read = true;
                      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                      aux_last_type_read_for_NBT = SCALAR_INTVEC;
                    } else {
                      cpp_validate_field(var_NBT_0d_intvec_Scalar, tab_body.NBT,  true, false, false, "NBT",
                        cpp_template, cpp_line, parse_opts);
                    }
                  }
                  // store data in Python dictionary
                  if (((aux_last_type_read_for_Egamma == SCALAR_FLOATVEC) && (aux_Egamma_read == true))) {
                    cpp_current_dict["Egamma"] = var_Egamma_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_g == SCALAR_FLOATVEC) && (aux_g_read == true))) {
                    cpp_current_dict["g"] = var_g_0d_floatvec_Scalar;
                  }
                  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
                    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
                  }
                  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
                    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
                  }
                  cpp_current_dict = cpp_parent_dict;
                }
              }
            }
          }
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_LF == SCALAR_INT) && (aux_LF_read == true))) {
        cpp_current_dict["LF"] = var_LF_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
        cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
        cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
      }
      if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
        cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
      }
      if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_E_1d_double_NestedVector;
        cpp_current_dict["E"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["E"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
    cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 5557baba7f951e2762c63f317ba874b9
// MD5 hash of the following function definition: 0a1607c53c110117f54fc7891a5cb1ac
py::dict parse_mf23_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  double var_EPE_0d_double_Scalar;
  bool aux_EPE_read = false;
  vartype aux_last_type_read_for_EPE = UNKNOWN;
  double var_EFL_0d_double_Scalar;
  bool aux_EFL_read = false;
  vartype aux_last_type_read_for_EFL = UNKNOWN;
  std::vector<double> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<double> var_sigma_0d_floatvec_Scalar;
  bool aux_sigma_read = false;
  vartype aux_last_type_read_for_sigma = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 23;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 23;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 23 , MT / ZA , AWR , 0 , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_template = "[ MAT , 23 , MT / EPE , EFL , 0 , 0 , NR , NP / Eint / sigma ] TAB1";
  // read TAB1 record
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // assign expression to variable EPE
  var_EPE_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_EPE_read = true;
  validate_vartype_consistency("EPE", SCALAR_DOUBLE, aux_last_type_read_for_EPE);
  aux_last_type_read_for_EPE = SCALAR_DOUBLE;
  // assign expression to variable EFL
  var_EFL_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_EFL_read = true;
  validate_vartype_consistency("EFL", SCALAR_DOUBLE, aux_last_type_read_for_EFL);
  aux_last_type_read_for_EFL = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  {
    Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
    // assign expression to variable Eint
    var_Eint_0d_floatvec_Scalar = tab_body.X;
    aux_Eint_read = true;
    validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
    aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
    // assign expression to variable sigma
    var_sigma_0d_floatvec_Scalar = tab_body.Y;
    aux_sigma_read = true;
    validate_vartype_consistency("sigma", SCALAR_FLOATVEC, aux_last_type_read_for_sigma);
    aux_last_type_read_for_sigma = SCALAR_FLOATVEC;
    // assign expression to variable INT
    var_INT_0d_intvec_Scalar = tab_body.INT;
    aux_INT_read = true;
    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
    aux_last_type_read_for_INT = SCALAR_INTVEC;
    // assign expression to variable NBT
    var_NBT_0d_intvec_Scalar = tab_body.NBT;
    aux_NBT_read = true;
    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
    aux_last_type_read_for_NBT = SCALAR_INTVEC;
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_EPE == SCALAR_DOUBLE) && (aux_EPE_read == true))) {
    cpp_current_dict["EPE"] = var_EPE_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_EFL == SCALAR_DOUBLE) && (aux_EFL_read == true))) {
    cpp_current_dict["EFL"] = var_EFL_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_Eint == SCALAR_FLOATVEC) && (aux_Eint_read == true))) {
    cpp_current_dict["Eint"] = var_Eint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_sigma == SCALAR_FLOATVEC) && (aux_sigma_read == true))) {
    cpp_current_dict["sigma"] = var_sigma_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 3f70d967823f46b1bb1f3b072c33eced
// MD5 hash of the following function definition: 145edaadc737ba5beb17e2b43039e906
py::dict parse_mf26_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 26;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 26;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 20ce9f620fd87cc4c048529da1906a0e
// MD5 hash of the following function definition: 89c2987602ed2bfdab0c71dab21402e3
py::dict parse_mf27_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  double var_Z_0d_double_Scalar;
  bool aux_Z_read = false;
  vartype aux_last_type_read_for_Z = UNKNOWN;
  std::vector<double> var_xint_0d_floatvec_Scalar;
  bool aux_xint_read = false;
  vartype aux_last_type_read_for_xint = UNKNOWN;
  std::vector<double> var_H_0d_floatvec_Scalar;
  bool aux_H_read = false;
  vartype aux_last_type_read_for_H = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 27;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 27;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 27 , MT / ZA , AWR , 0 , 0 , 0 , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_template = "[ MAT , 27 , MT / 0.0 , Z , 0 , 0 , NR , NP / xint / H ] TAB1";
  // read TAB1 record
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable Z
  var_Z_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_Z_read = true;
  validate_vartype_consistency("Z", SCALAR_DOUBLE, aux_last_type_read_for_Z);
  aux_last_type_read_for_Z = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_nr_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  cpp_np_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  {
    Tab1Body tab_body = read_tab1_body_debug(cont, cpp_line, cpp_nr_val, cpp_np_val, mat, mf, mt, parse_opts);
    // assign expression to variable xint
    var_xint_0d_floatvec_Scalar = tab_body.X;
    aux_xint_read = true;
    validate_vartype_consistency("xint", SCALAR_FLOATVEC, aux_last_type_read_for_xint);
    aux_last_type_read_for_xint = SCALAR_FLOATVEC;
    // assign expression to variable H
    var_H_0d_floatvec_Scalar = tab_body.Y;
    aux_H_read = true;
    validate_vartype_consistency("H", SCALAR_FLOATVEC, aux_last_type_read_for_H);
    aux_last_type_read_for_H = SCALAR_FLOATVEC;
    // assign expression to variable INT
    var_INT_0d_intvec_Scalar = tab_body.INT;
    aux_INT_read = true;
    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
    aux_last_type_read_for_INT = SCALAR_INTVEC;
    // assign expression to variable NBT
    var_NBT_0d_intvec_Scalar = tab_body.NBT;
    aux_NBT_read = true;
    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
    aux_last_type_read_for_NBT = SCALAR_INTVEC;
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_Z == SCALAR_DOUBLE) && (aux_Z_read == true))) {
    cpp_current_dict["Z"] = var_Z_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_xint == SCALAR_FLOATVEC) && (aux_xint_read == true))) {
    cpp_current_dict["xint"] = var_xint_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_H == SCALAR_FLOATVEC) && (aux_H_read == true))) {
    cpp_current_dict["H"] = var_H_0d_floatvec_Scalar;
  }
  if (((aux_last_type_read_for_INT == SCALAR_INTVEC) && (aux_INT_read == true))) {
    cpp_current_dict["INT"] = var_INT_0d_intvec_Scalar;
  }
  if (((aux_last_type_read_for_NBT == SCALAR_INTVEC) && (aux_NBT_read == true))) {
    cpp_current_dict["NBT"] = var_NBT_0d_intvec_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 04f3c92d2aa669d9b265ca0bc15b6e1f
// MD5 hash of the following function definition: 495e7eb7d1833129e0077d6c6cf9728a
py::dict parse_mf28_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 28;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 28;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 485a4917898fb80f8e6522571893a9e5
// MD5 hash of the following function definition: d0ff94a44f47b0635825087ee799edcb
py::dict parse_mf31_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_MTL_0d_int_Scalar;
  bool aux_MTL_read = false;
  vartype aux_last_type_read_for_MTL = UNKNOWN;
  int var_NL_0d_int_Scalar;
  bool aux_NL_read = false;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 31;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 31;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 31 , MT / ZA , AWR , 0 , MTL , 0 , NL ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable MTL
  var_MTL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_MTL_read = true;
  validate_vartype_consistency("MTL", SCALAR_INT, aux_last_type_read_for_MTL);
  aux_last_type_read_for_MTL = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NL
  var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NL_read = true;
  validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
  aux_last_type_read_for_NL = SCALAR_INT;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_MTL_read == true)) && ((var_MTL_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;

        for (int var_n_0d_int_Scalar = 1;
           var_n_0d_int_Scalar <= var_NL_0d_int_Scalar; var_n_0d_int_Scalar++) {
          bool aux_n_read = true;
          // open section subsection
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            if ((! cpp_parent_dict.contains("subsection"))) {
              cpp_parent_dict["subsection"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict["subsection"];
            if ((! cpp_current_dict.contains(py::cast(var_n_0d_int_Scalar)))) {
              cpp_current_dict[py::cast(var_n_0d_int_Scalar)] = py::dict();
            }
            cpp_current_dict = cpp_current_dict[py::cast(var_n_0d_int_Scalar)];
            // variable declarations
            double var_XMF1_0d_double_Scalar;
            bool aux_XMF1_read = false;
            vartype aux_last_type_read_for_XMF1 = UNKNOWN;
            double var_XLFS1_0d_double_Scalar;
            bool aux_XLFS1_read = false;
            vartype aux_last_type_read_for_XLFS1 = UNKNOWN;
            int var_MAT1_0d_int_Scalar;
            bool aux_MAT1_read = false;
            vartype aux_last_type_read_for_MAT1 = UNKNOWN;
            int var_MT1_0d_int_Scalar;
            bool aux_MT1_read = false;
            vartype aux_last_type_read_for_MT1 = UNKNOWN;
            int var_NC_0d_int_Scalar;
            bool aux_NC_read = false;
            vartype aux_last_type_read_for_NC = UNKNOWN;
            int var_NI_0d_int_Scalar;
            bool aux_NI_read = false;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            cpp_template = "[ MAT , 31 , MT / XMF1 , XLFS1 , MAT1 , MT1 , NC , NI ] CONT";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable XMF1
            var_XMF1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_XMF1_read = true;
            validate_vartype_consistency("XMF1", SCALAR_DOUBLE, aux_last_type_read_for_XMF1);
            aux_last_type_read_for_XMF1 = SCALAR_DOUBLE;
            // assign expression to variable XLFS1
            var_XLFS1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_XLFS1_read = true;
            validate_vartype_consistency("XLFS1", SCALAR_DOUBLE, aux_last_type_read_for_XLFS1);
            aux_last_type_read_for_XLFS1 = SCALAR_DOUBLE;
            // assign expression to variable MAT1
            var_MAT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_MAT1_read = true;
            validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
            aux_last_type_read_for_MAT1 = SCALAR_INT;
            // assign expression to variable MT1
            var_MT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_MT1_read = true;
            validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
            aux_last_type_read_for_MT1 = SCALAR_INT;
            // assign expression to variable NC
            var_NC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NC_read = true;
            validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
            aux_last_type_read_for_NC = SCALAR_INT;
            // assign expression to variable NI
            var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NC_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section nc_subsection
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                if ((! cpp_parent_dict.contains("nc_subsection"))) {
                  cpp_parent_dict["nc_subsection"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict["nc_subsection"];
                if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                  cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                }
                cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                // variable declarations
                int var_LTY_0d_int_Scalar;
                bool aux_LTY_read = false;
                vartype aux_last_type_read_for_LTY = UNKNOWN;
                double var_E1_0d_double_Scalar;
                bool aux_E1_read = false;
                vartype aux_last_type_read_for_E1 = UNKNOWN;
                double var_E2_0d_double_Scalar;
                bool aux_E2_read = false;
                vartype aux_last_type_read_for_E2 = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NCI_0d_int_Scalar;
                bool aux_NCI_read = false;
                vartype aux_last_type_read_for_NCI = UNKNOWN;
                NestedVector<double> var_C_1d_double_NestedVector;
                vartype aux_last_type_read_for_C = UNKNOWN;
                NestedVector<double> var_XMT_1d_double_NestedVector;
                vartype aux_last_type_read_for_XMT = UNKNOWN;
                int var_MATS_0d_int_Scalar;
                bool aux_MATS_read = false;
                vartype aux_last_type_read_for_MATS = UNKNOWN;
                int var_MTS_0d_int_Scalar;
                bool aux_MTS_read = false;
                vartype aux_last_type_read_for_MTS = UNKNOWN;
                int var_NEI_0d_int_Scalar;
                bool aux_NEI_read = false;
                vartype aux_last_type_read_for_NEI = UNKNOWN;
                double var_XMFS_0d_double_Scalar;
                bool aux_XMFS_read = false;
                vartype aux_last_type_read_for_XMFS = UNKNOWN;
                double var_XLFSS_0d_double_Scalar;
                bool aux_XLFSS_read = false;
                vartype aux_last_type_read_for_XLFSS = UNKNOWN;
                NestedVector<double> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                NestedVector<double> var_WE_1d_double_NestedVector;
                vartype aux_last_type_read_for_WE = UNKNOWN;
                cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read CONT record
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LTY
                var_LTY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LTY_read = true;
                validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                aux_last_type_read_for_LTY = SCALAR_INT;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if ((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(0)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      cpp_template = "[ MAT , 31 , MT / E1 , E2 , 0 , 0 , (2*NCI) , NCI / \n { C , XMT } { i = 1 to NCI } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      // assign expression to variable E1
                      var_E1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                      aux_E1_read = true;
                      validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                      aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                      // assign expression to variable E2
                      var_E2_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                      aux_E2_read = true;
                      validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                      aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NCI
                      var_NCI_0d_int_Scalar = (cpp_int_val/2);
                      aux_NCI_read = true;
                      validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                      aux_last_type_read_for_NCI = SCALAR_INT;
                      if ((! (aux_NCI_read == true))) {
                        // assign expression to variable NCI
                        var_NCI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NCI_read = true;
                        validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                        aux_last_type_read_for_NCI = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NCI_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NCI",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_i_0d_int_Scalar = 1;
                           var_i_0d_int_Scalar <= var_NCI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                          bool aux_i_read = true;
                          // read LIST body
                          // assign expression to variable C
                          var_C_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
                          aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable XMT
                          var_XMT_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("XMT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_XMT);
                          aux_last_type_read_for_XMT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if (((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)>=(1)))))&&((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)<=(3)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 31 , MT / E1 , E2 , MATS , MTS , ((2*NEI)+2) , NEI / \n XMFS , XLFSS , { E , WE } { i = 1 to NEI } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        // assign expression to variable E1
                        var_E1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                        aux_E1_read = true;
                        validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                        aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                        // assign expression to variable E2
                        var_E2_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                        aux_E2_read = true;
                        validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                        aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                        // assign expression to variable MATS
                        var_MATS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_MATS_read = true;
                        validate_vartype_consistency("MATS", SCALAR_INT, aux_last_type_read_for_MATS);
                        aux_last_type_read_for_MATS = SCALAR_INT;
                        // assign expression to variable MTS
                        var_MTS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_MTS_read = true;
                        validate_vartype_consistency("MTS", SCALAR_INT, aux_last_type_read_for_MTS);
                        aux_last_type_read_for_MTS = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NEI
                        var_NEI_0d_int_Scalar = ((cpp_int_val+(-2))/2);
                        aux_NEI_read = true;
                        validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                        aux_last_type_read_for_NEI = SCALAR_INT;
                        if ((! (aux_NEI_read == true))) {
                          // assign expression to variable NEI
                          var_NEI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NEI_read = true;
                          validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                          aux_last_type_read_for_NEI = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NEI_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NEI",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body
                          // assign expression to variable XMFS
                          var_XMFS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                          aux_XMFS_read = true;
                          validate_vartype_consistency("XMFS", SCALAR_DOUBLE, aux_last_type_read_for_XMFS);
                          aux_last_type_read_for_XMFS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable XLFSS
                          var_XLFSS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                          aux_XLFSS_read = true;
                          validate_vartype_consistency("XLFSS", SCALAR_DOUBLE, aux_last_type_read_for_XLFSS);
                          aux_last_type_read_for_XLFSS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }

                          for (int var_i_0d_int_Scalar = 1;
                             var_i_0d_int_Scalar <= var_NEI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                            bool aux_i_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable WE
                            var_WE_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("WE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_WE);
                            aux_last_type_read_for_WE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_LTY == SCALAR_INT) && (aux_LTY_read == true))) {
                  cpp_current_dict["LTY"] = var_LTY_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_E1 == SCALAR_DOUBLE) && (aux_E1_read == true))) {
                  cpp_current_dict["E1"] = var_E1_0d_double_Scalar;
                }
                if (((aux_last_type_read_for_E2 == SCALAR_DOUBLE) && (aux_E2_read == true))) {
                  cpp_current_dict["E2"] = var_E2_0d_double_Scalar;
                }
                if (((aux_last_type_read_for_NCI == SCALAR_INT) && (aux_NCI_read == true))) {
                  cpp_current_dict["NCI"] = var_NCI_0d_int_Scalar;
                }
                if ((var_C_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_C_1d_double_NestedVector;
                  cpp_current_dict["C"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["C"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_XMT_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_XMT_1d_double_NestedVector;
                  cpp_current_dict["XMT"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["XMT"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if (((aux_last_type_read_for_MATS == SCALAR_INT) && (aux_MATS_read == true))) {
                  cpp_current_dict["MATS"] = var_MATS_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_MTS == SCALAR_INT) && (aux_MTS_read == true))) {
                  cpp_current_dict["MTS"] = var_MTS_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NEI == SCALAR_INT) && (aux_NEI_read == true))) {
                  cpp_current_dict["NEI"] = var_NEI_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_XMFS == SCALAR_DOUBLE) && (aux_XMFS_read == true))) {
                  cpp_current_dict["XMFS"] = var_XMFS_0d_double_Scalar;
                }
                if (((aux_last_type_read_for_XLFSS == SCALAR_DOUBLE) && (aux_XLFSS_read == true))) {
                  cpp_current_dict["XLFSS"] = var_XLFSS_0d_double_Scalar;
                }
                if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_E_1d_double_NestedVector;
                  cpp_current_dict["E"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["E"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_WE_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_WE_1d_double_NestedVector;
                  cpp_current_dict["WE"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["WE"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NI_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section ni_subsection
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                if ((! cpp_parent_dict.contains("ni_subsection"))) {
                  cpp_parent_dict["ni_subsection"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict["ni_subsection"];
                if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                  cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                }
                cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                // variable declarations
                int var_LT_0d_int_Scalar;
                bool aux_LT_read = false;
                vartype aux_last_type_read_for_LT = UNKNOWN;
                int var_LB_0d_int_Scalar;
                bool aux_LB_read = false;
                vartype aux_last_type_read_for_LB = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NP_0d_int_Scalar;
                bool aux_NP_read = false;
                vartype aux_last_type_read_for_NP = UNKNOWN;
                NestedVector<double> var_Ek_1d_double_NestedVector;
                vartype aux_last_type_read_for_Ek = UNKNOWN;
                NestedVector<double> var_Fk_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fk = UNKNOWN;
                NestedVector<double> var_El_1d_double_NestedVector;
                vartype aux_last_type_read_for_El = UNKNOWN;
                NestedVector<double> var_Fl_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fl = UNKNOWN;
                int var_LS_0d_int_Scalar;
                bool aux_LS_read = false;
                vartype aux_last_type_read_for_LS = UNKNOWN;
                int var_NE_0d_int_Scalar;
                bool aux_NE_read = false;
                vartype aux_last_type_read_for_NE = UNKNOWN;
                NestedVector<double> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                Matrix2d<double> var_F_2d_double_Matrix2d;
                vartype aux_last_type_read_for_F = UNKNOWN;
                int var_NER_0d_int_Scalar;
                bool aux_NER_read = false;
                vartype aux_last_type_read_for_NER = UNKNOWN;
                int var_NEC_0d_int_Scalar;
                bool aux_NEC_read = false;
                vartype aux_last_type_read_for_NEC = UNKNOWN;
                NestedVector<double> var_ER_1d_double_NestedVector;
                vartype aux_last_type_read_for_ER = UNKNOWN;
                NestedVector<double> var_EC_1d_double_NestedVector;
                vartype aux_last_type_read_for_EC = UNKNOWN;
                NestedVector<double> var_F_1d_double_NestedVector;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                        int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                        bool& glob_aux_LT_read = aux_LT_read;
                        bool aux_LT_read = glob_aux_LT_read;
                        vartype aux_last_type_read_for_LT = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_cpp_int_val = cpp_int_val;
                        int cpp_int_val = glob_cpp_int_val;
                        bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                        bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                        int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                        bool& glob_aux_NP_read = aux_NP_read;
                        bool aux_NP_read = glob_aux_NP_read;
                        vartype aux_last_type_read_for_NP = UNKNOWN;
                        cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                        cpp_line = cpp_read_raw_line(cont);
                        // read LIST record
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)>=(0)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)<=(4)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NP",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= (var_NP_0d_int_Scalar-var_LT_0d_int_Scalar); var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable Ek
                            var_Ek_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Ek", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ek);
                            aux_last_type_read_for_Ek = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable Fk
                            var_Fk_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Fk", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fk);
                            aux_last_type_read_for_Fk = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_LT_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable El
                            var_El_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("El", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_El);
                            aux_last_type_read_for_El = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable Fl
                            var_Fl_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Fl", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fl);
                            aux_last_type_read_for_Fl = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE-1))+1) , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                            cpp_validate_field(((var_NE_0d_int_Scalar*(var_NE_0d_int_Scalar-1))+1), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((NE*(NE-1))+1)",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = 1;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE+1))/2) , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                            cpp_validate_field(((var_NE_0d_int_Scalar*(var_NE_0d_int_Scalar+1))/2), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((NE*(NE+1))/2)",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = var_k_0d_int_Scalar;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NER_0d_int_Scalar = var_NER_0d_int_Scalar;
                          int var_NER_0d_int_Scalar = glob_var_NER_0d_int_Scalar;
                          bool& glob_aux_NER_read = aux_NER_read;
                          bool aux_NER_read = glob_aux_NER_read;
                          vartype aux_last_type_read_for_NER = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NEC_0d_int_Scalar = var_NEC_0d_int_Scalar;
                          int var_NEC_0d_int_Scalar = glob_var_NEC_0d_int_Scalar;
                          bool& glob_aux_NEC_read = aux_NEC_read;
                          bool aux_NEC_read = glob_aux_NEC_read;
                          vartype aux_last_type_read_for_NEC = UNKNOWN;
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NEC
                          var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                          aux_NEC_read = true;
                          validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                          aux_last_type_read_for_NEC = SCALAR_INT;
                          if ((! (aux_NER_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                          } else {
                          }
                          if ((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(6)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , 0 , LB , (1+(NER*NEC)) , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NEC
                          var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                          aux_NEC_read = true;
                          validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                          aux_last_type_read_for_NEC = SCALAR_INT;
                          if ((! (aux_NER_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                          } else {
                            cpp_validate_field((1+(var_NER_0d_int_Scalar*var_NEC_0d_int_Scalar)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(1+(NER*NEC))",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NER_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable ER
                              var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                              aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NEC_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable EC
                              var_EC_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("EC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EC);
                              aux_last_type_read_for_EC = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NER_0d_int_Scalar-1), 1, (var_NEC_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NER_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_l_0d_int_Scalar = 1;
                                 var_l_0d_int_Scalar <= (var_NEC_0d_int_Scalar-1); var_l_0d_int_Scalar++) {
                                bool aux_l_read = true;
                                // read LIST body
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_l_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                          int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                          bool& glob_aux_LT_read = aux_LT_read;
                          bool aux_LT_read = glob_aux_LT_read;
                          vartype aux_last_type_read_for_LT = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                          int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                          bool& glob_aux_NP_read = aux_NP_read;
                          bool aux_NP_read = glob_aux_NP_read;
                          vartype aux_last_type_read_for_NP = UNKNOWN;
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                          if ((((((((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(8))))))||(((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(9)))))))))&&((((aux_LT_read == true)) && ((var_LT_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                            cpp_validate_field(var_NP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NP",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable F
                              var_F_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_LT == SCALAR_INT) && (aux_LT_read == true))) {
                  cpp_current_dict["LT"] = var_LT_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_LB == SCALAR_INT) && (aux_LB_read == true))) {
                  cpp_current_dict["LB"] = var_LB_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NP == SCALAR_INT) && (aux_NP_read == true))) {
                  cpp_current_dict["NP"] = var_NP_0d_int_Scalar;
                }
                if ((var_Ek_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_Ek_1d_double_NestedVector;
                  cpp_current_dict["Ek"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["Ek"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_Fk_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_Fk_1d_double_NestedVector;
                  cpp_current_dict["Fk"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["Fk"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_El_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_El_1d_double_NestedVector;
                  cpp_current_dict["El"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["El"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_Fl_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_Fl_1d_double_NestedVector;
                  cpp_current_dict["Fl"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["Fl"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if (((aux_last_type_read_for_LS == SCALAR_INT) && (aux_LS_read == true))) {
                  cpp_current_dict["LS"] = var_LS_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
                  cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
                }
                if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_E_1d_double_NestedVector;
                  cpp_current_dict["E"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["E"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if (var_F_2d_double_Matrix2d.did_read()) {
                    cpp_current_dict["F"] = py::dict();
                    py::dict cpp_curdict0 = cpp_current_dict["F"];
                    for (int cpp_i1 = var_F_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_F_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
                      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
                      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
                      for (int cpp_i2 = var_F_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_F_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
                        cpp_curdict1[py::cast(cpp_i2)] = var_F_2d_double_Matrix2d(cpp_i1, cpp_i2);
                      }
                    }
                }
                if (((aux_last_type_read_for_NER == SCALAR_INT) && (aux_NER_read == true))) {
                  cpp_current_dict["NER"] = var_NER_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NEC == SCALAR_INT) && (aux_NEC_read == true))) {
                  cpp_current_dict["NEC"] = var_NEC_0d_int_Scalar;
                }
                if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_ER_1d_double_NestedVector;
                  cpp_current_dict["ER"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["ER"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_EC_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_EC_1d_double_NestedVector;
                  cpp_current_dict["EC"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["EC"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_F_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_F_1d_double_NestedVector;
                  cpp_current_dict["F"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["F"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_XMF1 == SCALAR_DOUBLE) && (aux_XMF1_read == true))) {
              cpp_current_dict["XMF1"] = var_XMF1_0d_double_Scalar;
            }
            if (((aux_last_type_read_for_XLFS1 == SCALAR_DOUBLE) && (aux_XLFS1_read == true))) {
              cpp_current_dict["XLFS1"] = var_XLFS1_0d_double_Scalar;
            }
            if (((aux_last_type_read_for_MAT1 == SCALAR_INT) && (aux_MAT1_read == true))) {
              cpp_current_dict["MAT1"] = var_MAT1_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_MT1 == SCALAR_INT) && (aux_MT1_read == true))) {
              cpp_current_dict["MT1"] = var_MT1_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
              cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_NI == SCALAR_INT) && (aux_NI_read == true))) {
              cpp_current_dict["NI"] = var_NI_0d_int_Scalar;
            }
            cpp_current_dict = cpp_parent_dict;
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_MTL == SCALAR_INT) && (aux_MTL_read == true))) {
    cpp_current_dict["MTL"] = var_MTL_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NL == SCALAR_INT) && (aux_NL_read == true))) {
    cpp_current_dict["NL"] = var_NL_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 89a763d6f809f216a36f99ade3a07a08
// MD5 hash of the following function definition: 29cc172c92e3492434a9eba5c89b399e
py::dict parse_mf32_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NIS_0d_int_Scalar;
  bool aux_NIS_read = false;
  vartype aux_last_type_read_for_NIS = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 32;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 32;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 32 , 151 / ZA , AWR , 0 , 0 , NIS , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NIS
  var_NIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NIS_read = true;
  validate_vartype_consistency("NIS", SCALAR_INT, aux_last_type_read_for_NIS);
  aux_last_type_read_for_NIS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NIS_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    // open section isotope
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      if ((! cpp_parent_dict.contains("isotope"))) {
        cpp_parent_dict["isotope"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict["isotope"];
      if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
      // variable declarations
      double var_ZAI_0d_double_Scalar;
      bool aux_ZAI_read = false;
      vartype aux_last_type_read_for_ZAI = UNKNOWN;
      double var_ABN_0d_double_Scalar;
      bool aux_ABN_read = false;
      vartype aux_last_type_read_for_ABN = UNKNOWN;
      int var_LFW_0d_int_Scalar;
      bool aux_LFW_read = false;
      vartype aux_last_type_read_for_LFW = UNKNOWN;
      int var_NER_0d_int_Scalar;
      bool aux_NER_read = false;
      vartype aux_last_type_read_for_NER = UNKNOWN;
      cpp_template = "[ MAT , 32 , 151 / ZAI , ABN , 0 , LFW , NER , 0 ] CONT";
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read CONT record
      // assign expression to variable ZAI
      var_ZAI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
      aux_ZAI_read = true;
      validate_vartype_consistency("ZAI", SCALAR_DOUBLE, aux_last_type_read_for_ZAI);
      aux_last_type_read_for_ZAI = SCALAR_DOUBLE;
      // assign expression to variable ABN
      var_ABN_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
      aux_ABN_read = true;
      validate_vartype_consistency("ABN", SCALAR_DOUBLE, aux_last_type_read_for_ABN);
      aux_last_type_read_for_ABN = SCALAR_DOUBLE;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
      // assign expression to variable LFW
      var_LFW_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LFW_read = true;
      validate_vartype_consistency("LFW", SCALAR_INT, aux_last_type_read_for_LFW);
      aux_last_type_read_for_LFW = SCALAR_INT;
      // assign expression to variable NER
      var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
      aux_NER_read = true;
      validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
      aux_last_type_read_for_NER = SCALAR_INT;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);

      for (int var_j_0d_int_Scalar = 1;
         var_j_0d_int_Scalar <= var_NER_0d_int_Scalar; var_j_0d_int_Scalar++) {
        bool aux_j_read = true;
        // open section range
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          if ((! cpp_parent_dict.contains("range"))) {
            cpp_parent_dict["range"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict["range"];
          if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
            cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
          }
          cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
          // variable declarations
          double var_EL_0d_double_Scalar;
          bool aux_EL_read = false;
          vartype aux_last_type_read_for_EL = UNKNOWN;
          double var_EH_0d_double_Scalar;
          bool aux_EH_read = false;
          vartype aux_last_type_read_for_EH = UNKNOWN;
          int var_LRU_0d_int_Scalar;
          bool aux_LRU_read = false;
          vartype aux_last_type_read_for_LRU = UNKNOWN;
          int var_LRF_0d_int_Scalar;
          bool aux_LRF_read = false;
          vartype aux_last_type_read_for_LRF = UNKNOWN;
          int var_NRO_0d_int_Scalar;
          bool aux_NRO_read = false;
          vartype aux_last_type_read_for_NRO = UNKNOWN;
          int var_NAPS_0d_int_Scalar;
          bool aux_NAPS_read = false;
          vartype aux_last_type_read_for_NAPS = UNKNOWN;
          int var_NI_0d_int_Scalar;
          bool aux_NI_read = false;
          vartype aux_last_type_read_for_NI = UNKNOWN;
          double var_SPI_0d_double_Scalar;
          bool aux_SPI_read = false;
          vartype aux_last_type_read_for_SPI = UNKNOWN;
          double var_AP_0d_double_Scalar;
          bool aux_AP_read = false;
          vartype aux_last_type_read_for_AP = UNKNOWN;
          int var_LCOMP_0d_int_Scalar;
          bool aux_LCOMP_read = false;
          vartype aux_last_type_read_for_LCOMP = UNKNOWN;
          int var_NLS_0d_int_Scalar;
          bool aux_NLS_read = false;
          vartype aux_last_type_read_for_NLS = UNKNOWN;
          int var_ISR_0d_int_Scalar;
          bool aux_ISR_read = false;
          vartype aux_last_type_read_for_ISR = UNKNOWN;
          double var_DAP_0d_double_Scalar;
          bool aux_DAP_read = false;
          vartype aux_last_type_read_for_DAP = UNKNOWN;
          double var_AWRI_0d_double_Scalar;
          bool aux_AWRI_read = false;
          vartype aux_last_type_read_for_AWRI = UNKNOWN;
          int var_NSRS_0d_int_Scalar;
          bool aux_NSRS_read = false;
          vartype aux_last_type_read_for_NSRS = UNKNOWN;
          int var_NLRS_0d_int_Scalar;
          bool aux_NLRS_read = false;
          vartype aux_last_type_read_for_NLRS = UNKNOWN;
          int var_MLS_0d_int_Scalar;
          bool aux_MLS_read = false;
          vartype aux_last_type_read_for_MLS = UNKNOWN;
          NestedVector<double> var_DAP_1d_double_NestedVector;
          int var_JCH_0d_int_Scalar;
          bool aux_JCH_read = false;
          vartype aux_last_type_read_for_JCH = UNKNOWN;
          int cpp_int_val;
          bool aux_cpp_int_val_read = false;
          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
          int var_NCH_0d_int_Scalar;
          bool aux_NCH_read = false;
          vartype aux_last_type_read_for_NCH = UNKNOWN;
          Matrix2d<double> var_DAP_2d_double_Matrix2d;
          double var_QX_0d_double_Scalar;
          bool aux_QX_read = false;
          vartype aux_last_type_read_for_QX = UNKNOWN;
          int var_LRX_0d_int_Scalar;
          bool aux_LRX_read = false;
          vartype aux_last_type_read_for_LRX = UNKNOWN;
          int var_NRSA_0d_int_Scalar;
          bool aux_NRSA_read = false;
          vartype aux_last_type_read_for_NRSA = UNKNOWN;
          NestedVector<double> var_ER_1d_double_NestedVector;
          vartype aux_last_type_read_for_ER = UNKNOWN;
          NestedVector<double> var_AJ_1d_double_NestedVector;
          vartype aux_last_type_read_for_AJ = UNKNOWN;
          NestedVector<double> var_GT_1d_double_NestedVector;
          vartype aux_last_type_read_for_GT = UNKNOWN;
          NestedVector<double> var_GN_1d_double_NestedVector;
          vartype aux_last_type_read_for_GN = UNKNOWN;
          NestedVector<double> var_GG_1d_double_NestedVector;
          vartype aux_last_type_read_for_GG = UNKNOWN;
          NestedVector<double> var_GF_1d_double_NestedVector;
          vartype aux_last_type_read_for_GF = UNKNOWN;
          NestedVector<double> var_DER_1d_double_NestedVector;
          vartype aux_last_type_read_for_DER = UNKNOWN;
          NestedVector<double> var_DGN_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGN = UNKNOWN;
          NestedVector<double> var_DGG_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGG = UNKNOWN;
          NestedVector<double> var_DGF_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGF = UNKNOWN;
          int var_NDIGIT_0d_int_Scalar;
          bool aux_NDIGIT_read = false;
          vartype aux_last_type_read_for_NDIGIT = UNKNOWN;
          int var_NNN_0d_int_Scalar;
          bool aux_NNN_read = false;
          vartype aux_last_type_read_for_NNN = UNKNOWN;
          int var_NM_0d_int_Scalar;
          bool aux_NM_read = false;
          vartype aux_last_type_read_for_NM = UNKNOWN;
          NestedVector<int> var_II_1d_int_NestedVector;
          vartype aux_last_type_read_for_II = UNKNOWN;
          NestedVector<int> var_JJ_1d_int_NestedVector;
          vartype aux_last_type_read_for_JJ = UNKNOWN;
          NestedVector<std::vector<int>> var_KIJ_1d_intvec_NestedVector;
          vartype aux_last_type_read_for_KIJ = UNKNOWN;
          int var_LAD_0d_int_Scalar;
          bool aux_LAD_read = false;
          vartype aux_last_type_read_for_LAD = UNKNOWN;
          double var_APL_0d_double_Scalar;
          bool aux_APL_read = false;
          vartype aux_last_type_read_for_APL = UNKNOWN;
          NestedVector<double> var_GFA_1d_double_NestedVector;
          vartype aux_last_type_read_for_GFA = UNKNOWN;
          NestedVector<double> var_GFB_1d_double_NestedVector;
          vartype aux_last_type_read_for_GFB = UNKNOWN;
          NestedVector<double> var_DGFA_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGFA = UNKNOWN;
          NestedVector<double> var_DGFB_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGFB = UNKNOWN;
          int var_IFG_0d_int_Scalar;
          bool aux_IFG_read = false;
          vartype aux_last_type_read_for_IFG = UNKNOWN;
          int var_NJS_0d_int_Scalar;
          bool aux_NJS_read = false;
          vartype aux_last_type_read_for_NJS = UNKNOWN;
          int var_NJCH_0d_int_Scalar;
          bool aux_NJCH_read = false;
          vartype aux_last_type_read_for_NJCH = UNKNOWN;
          int var_NPP_0d_int_Scalar;
          bool aux_NPP_read = false;
          vartype aux_last_type_read_for_NPP = UNKNOWN;
          int var_NJSX_0d_int_Scalar;
          bool aux_NJSX_read = false;
          vartype aux_last_type_read_for_NJSX = UNKNOWN;
          NestedVector<double> var_MA_1d_double_NestedVector;
          vartype aux_last_type_read_for_MA = UNKNOWN;
          NestedVector<double> var_MB_1d_double_NestedVector;
          vartype aux_last_type_read_for_MB = UNKNOWN;
          NestedVector<double> var_ZA_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          NestedVector<double> var_ZB_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZB = UNKNOWN;
          NestedVector<double> var_IA_1d_double_NestedVector;
          vartype aux_last_type_read_for_IA = UNKNOWN;
          NestedVector<double> var_IB_1d_double_NestedVector;
          vartype aux_last_type_read_for_IB = UNKNOWN;
          NestedVector<double> var_Q_1d_double_NestedVector;
          vartype aux_last_type_read_for_Q = UNKNOWN;
          NestedVector<double> var_PNT_1d_double_NestedVector;
          vartype aux_last_type_read_for_PNT = UNKNOWN;
          NestedVector<double> var_SHF_1d_double_NestedVector;
          vartype aux_last_type_read_for_SHF = UNKNOWN;
          NestedVector<double> var_MT_1d_double_NestedVector;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          NestedVector<double> var_PA_1d_double_NestedVector;
          vartype aux_last_type_read_for_PA = UNKNOWN;
          NestedVector<double> var_PB_1d_double_NestedVector;
          vartype aux_last_type_read_for_PB = UNKNOWN;
          int var_MPAR_0d_int_Scalar;
          bool aux_MPAR_read = false;
          vartype aux_last_type_read_for_MPAR = UNKNOWN;
          int var_NPAR_0d_int_Scalar;
          bool aux_NPAR_read = false;
          vartype aux_last_type_read_for_NPAR = UNKNOWN;
          Matrix2d<double> var_RV_2d_double_Matrix2d;
          vartype aux_last_type_read_for_RV = UNKNOWN;
          cpp_template = "[ MAT , 32 , 151 / EL , EH , LRU , LRF , NRO , NAPS ] CONT";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable EL
          var_EL_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_EL_read = true;
          validate_vartype_consistency("EL", SCALAR_DOUBLE, aux_last_type_read_for_EL);
          aux_last_type_read_for_EL = SCALAR_DOUBLE;
          // assign expression to variable EH
          var_EH_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_EH_read = true;
          validate_vartype_consistency("EH", SCALAR_DOUBLE, aux_last_type_read_for_EH);
          aux_last_type_read_for_EH = SCALAR_DOUBLE;
          // assign expression to variable LRU
          var_LRU_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_LRU_read = true;
          validate_vartype_consistency("LRU", SCALAR_INT, aux_last_type_read_for_LRU);
          aux_last_type_read_for_LRU = SCALAR_INT;
          // assign expression to variable LRF
          var_LRF_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_LRF_read = true;
          validate_vartype_consistency("LRF", SCALAR_INT, aux_last_type_read_for_LRF);
          aux_last_type_read_for_LRF = SCALAR_INT;
          // assign expression to variable NRO
          var_NRO_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NRO_read = true;
          validate_vartype_consistency("NRO", SCALAR_INT, aux_last_type_read_for_NRO);
          aux_last_type_read_for_NRO = SCALAR_INT;
          // assign expression to variable NAPS
          var_NAPS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NAPS_read = true;
          validate_vartype_consistency("NAPS", SCALAR_INT, aux_last_type_read_for_NAPS);
          aux_last_type_read_for_NAPS = SCALAR_INT;
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , 0 , NI ] CONT";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read CONT record
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable NI
                var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                aux_NI_read = true;
                validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
                aux_last_type_read_for_NI = SCALAR_INT;
              }
            }
          }
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              // if statement evaluation with lookahead
              {
                std::streampos cpp_old_streampos = cont.tellg();
                {
                  // variable declarations
                  double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                  double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                  bool& glob_aux_EL_read = aux_EL_read;
                  bool aux_EL_read = glob_aux_EL_read;
                  vartype aux_last_type_read_for_EL = UNKNOWN;
                  double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                  double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                  bool& glob_aux_EH_read = aux_EH_read;
                  bool aux_EH_read = glob_aux_EH_read;
                  vartype aux_last_type_read_for_EH = UNKNOWN;
                  int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                  int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                  bool& glob_aux_LRU_read = aux_LRU_read;
                  bool aux_LRU_read = glob_aux_LRU_read;
                  vartype aux_last_type_read_for_LRU = UNKNOWN;
                  int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                  int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                  bool& glob_aux_LRF_read = aux_LRF_read;
                  bool aux_LRF_read = glob_aux_LRF_read;
                  vartype aux_last_type_read_for_LRF = UNKNOWN;
                  int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                  int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                  bool& glob_aux_NRO_read = aux_NRO_read;
                  bool aux_NRO_read = glob_aux_NRO_read;
                  vartype aux_last_type_read_for_NRO = UNKNOWN;
                  int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                  int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                  bool& glob_aux_NAPS_read = aux_NAPS_read;
                  bool aux_NAPS_read = glob_aux_NAPS_read;
                  vartype aux_last_type_read_for_NAPS = UNKNOWN;
                  int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                  int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                  bool& glob_aux_NI_read = aux_NI_read;
                  bool aux_NI_read = glob_aux_NI_read;
                  vartype aux_last_type_read_for_NI = UNKNOWN;
                  double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                  double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                  bool& glob_aux_SPI_read = aux_SPI_read;
                  bool aux_SPI_read = glob_aux_SPI_read;
                  vartype aux_last_type_read_for_SPI = UNKNOWN;
                  double& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                  double var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                  bool& glob_aux_AP_read = aux_AP_read;
                  bool aux_AP_read = glob_aux_AP_read;
                  vartype aux_last_type_read_for_AP = UNKNOWN;
                  int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                  int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                  bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                  bool aux_LCOMP_read = glob_aux_LCOMP_read;
                  vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                  int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                  int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                  bool& glob_aux_NLS_read = aux_NLS_read;
                  bool aux_NLS_read = glob_aux_NLS_read;
                  vartype aux_last_type_read_for_NLS = UNKNOWN;
                  int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                  int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                  bool& glob_aux_ISR_read = aux_ISR_read;
                  bool aux_ISR_read = glob_aux_ISR_read;
                  vartype aux_last_type_read_for_ISR = UNKNOWN;
                  cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                  cpp_line = cpp_read_raw_line(cont);
                  // read CONT record
                  // assign expression to variable SPI
                  var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                  aux_SPI_read = true;
                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                  // assign expression to variable AP
                  var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                  aux_AP_read = true;
                  validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                  aux_last_type_read_for_AP = SCALAR_DOUBLE;
                  // assign expression to variable LCOMP
                  var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                  aux_LCOMP_read = true;
                  validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                  aux_last_type_read_for_LCOMP = SCALAR_INT;
                  // assign expression to variable NLS
                  var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  aux_NLS_read = true;
                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                  aux_last_type_read_for_NLS = SCALAR_INT;
                  // assign expression to variable ISR
                  var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  aux_ISR_read = true;
                  validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                  aux_last_type_read_for_ISR = SCALAR_INT;
                  if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(0)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&(((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))))))) {
                    cpp_found_match = true;
                  }
                  cont.seekg(cpp_old_streampos);
                }
                if (cpp_found_match) {
                  cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read CONT record
                  // assign expression to variable SPI
                  var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                  aux_SPI_read = true;
                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                  // assign expression to variable AP
                  var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                  aux_AP_read = true;
                  validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                  aux_last_type_read_for_AP = SCALAR_DOUBLE;
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable LCOMP
                  var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                  aux_LCOMP_read = true;
                  validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                  aux_last_type_read_for_LCOMP = SCALAR_INT;
                  // assign expression to variable NLS
                  var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  aux_NLS_read = true;
                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                  aux_last_type_read_for_NLS = SCALAR_INT;
                  // assign expression to variable ISR
                  var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  aux_ISR_read = true;
                  validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                  aux_last_type_read_for_ISR = SCALAR_INT;
                  // evaluate if-elif-else clause
                  {
                    bool cpp_found_match = false;
                    if (! cpp_found_match) {
                      if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)!=(0)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , DAP , 0 , 0 , 0 , 0 ] CONT";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read CONT record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable DAP
                        var_DAP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                        aux_DAP_read = true;
                        validate_vartype_consistency("DAP", SCALAR_DOUBLE, aux_last_type_read_for_DAP);
                        aux_last_type_read_for_DAP = SCALAR_DOUBLE;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                      }
                    }
                  }

                  for (int var_k_0d_int_Scalar = 1;
                     var_k_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                    bool aux_k_read = true;
                    // open section somesec
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      if ((! cpp_parent_dict.contains("somesec"))) {
                        cpp_parent_dict["somesec"] = py::dict();
                      }
                      py::dict cpp_current_dict = cpp_parent_dict["somesec"];
                      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                      }
                      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                      // variable declarations
                      double var_AWRI_0d_double_Scalar;
                      bool aux_AWRI_read = false;
                      vartype aux_last_type_read_for_AWRI = UNKNOWN;
                      int var_L_0d_int_Scalar;
                      bool aux_L_read = false;
                      vartype aux_last_type_read_for_L = UNKNOWN;
                      int cpp_int_val;
                      bool aux_cpp_int_val_read = false;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int var_NRS_0d_int_Scalar;
                      bool aux_NRS_read = false;
                      vartype aux_last_type_read_for_NRS = UNKNOWN;
                      NestedVector<double> var_ER_1d_double_NestedVector;
                      vartype aux_last_type_read_for_ER = UNKNOWN;
                      NestedVector<double> var_AJ_1d_double_NestedVector;
                      vartype aux_last_type_read_for_AJ = UNKNOWN;
                      NestedVector<double> var_GT_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GT = UNKNOWN;
                      NestedVector<double> var_GN_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GN = UNKNOWN;
                      NestedVector<double> var_GG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GG = UNKNOWN;
                      NestedVector<double> var_GF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GF = UNKNOWN;
                      NestedVector<double> var_DE2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DE2 = UNKNOWN;
                      NestedVector<double> var_DN2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DN2 = UNKNOWN;
                      NestedVector<double> var_DNDG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DNDG = UNKNOWN;
                      NestedVector<double> var_DG2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DG2 = UNKNOWN;
                      NestedVector<double> var_DNDF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DNDF = UNKNOWN;
                      NestedVector<double> var_DGDF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DGDF = UNKNOWN;
                      NestedVector<double> var_DF2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DF2 = UNKNOWN;
                      NestedVector<double> var_DJDN_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJDN = UNKNOWN;
                      NestedVector<double> var_DJDG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJDG = UNKNOWN;
                      NestedVector<double> var_DJDF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJDF = UNKNOWN;
                      NestedVector<double> var_DJ2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJ2 = UNKNOWN;
                      cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , L , 0 , (18*NRS) , NRS / \n { ER , AJ , GT , GN , GG , GF , \n DE2 , DN2 , DNDG , DG2 , DNDF , DGDF , \n DF2 , DJDN , DJDG , DJDF , DJ2 , 0.0 } { m = 1 to NRS } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      // assign expression to variable AWRI
                      var_AWRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                      aux_AWRI_read = true;
                      validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                      aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                      cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable L
                      var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                      aux_L_read = true;
                      validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                      aux_last_type_read_for_L = SCALAR_INT;
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NRS
                      var_NRS_0d_int_Scalar = (cpp_int_val/18);
                      aux_NRS_read = true;
                      validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                      aux_last_type_read_for_NRS = SCALAR_INT;
                      if ((! (aux_NRS_read == true))) {
                        // assign expression to variable NRS
                        var_NRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NRS_read = true;
                        validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                        aux_last_type_read_for_NRS = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NRS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NRS",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // read LIST body
                          // assign expression to variable ER
                          var_ER_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                          aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable AJ
                          var_AJ_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                          aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GT
                          var_GT_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                          aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GN
                          var_GN_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                          aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GG
                          var_GG_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                          aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GF
                          var_GF_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                          aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DE2
                          var_DE2_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DE2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DE2);
                          aux_last_type_read_for_DE2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DN2
                          var_DN2_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DN2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DN2);
                          aux_last_type_read_for_DN2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DNDG
                          var_DNDG_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DNDG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DNDG);
                          aux_last_type_read_for_DNDG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DG2
                          var_DG2_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DG2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DG2);
                          aux_last_type_read_for_DG2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DNDF
                          var_DNDF_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DNDF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DNDF);
                          aux_last_type_read_for_DNDF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DGDF
                          var_DGDF_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DGDF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGDF);
                          aux_last_type_read_for_DGDF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DF2
                          var_DF2_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DF2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DF2);
                          aux_last_type_read_for_DF2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DJDN
                          var_DJDN_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DJDN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJDN);
                          aux_last_type_read_for_DJDN = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DJDG
                          var_DJDG_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DJDG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJDG);
                          aux_last_type_read_for_DJDG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DJDF
                          var_DJDF_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DJDF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJDF);
                          aux_last_type_read_for_DJDF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable DJ2
                          var_DJ2_1d_double_NestedVector.set(var_m_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("DJ2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJ2);
                          aux_last_type_read_for_DJ2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      // store data in Python dictionary
                      if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                        cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                      }
                      if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                        cpp_current_dict["L"] = var_L_0d_int_Scalar;
                      }
                      if (((aux_last_type_read_for_NRS == SCALAR_INT) && (aux_NRS_read == true))) {
                        cpp_current_dict["NRS"] = var_NRS_0d_int_Scalar;
                      }
                      if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_ER_1d_double_NestedVector;
                        cpp_current_dict["ER"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["ER"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_AJ_1d_double_NestedVector;
                        cpp_current_dict["AJ"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["AJ"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_GT_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_GT_1d_double_NestedVector;
                        cpp_current_dict["GT"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["GT"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_GN_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_GN_1d_double_NestedVector;
                        cpp_current_dict["GN"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["GN"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_GG_1d_double_NestedVector;
                        cpp_current_dict["GG"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["GG"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_GF_1d_double_NestedVector;
                        cpp_current_dict["GF"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["GF"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_DE2_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_DE2_1d_double_NestedVector;
                        cpp_current_dict["DE2"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["DE2"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_DN2_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_DN2_1d_double_NestedVector;
                        cpp_current_dict["DN2"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["DN2"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_DNDG_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_DNDG_1d_double_NestedVector;
                        cpp_current_dict["DNDG"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["DNDG"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_DG2_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_DG2_1d_double_NestedVector;
                        cpp_current_dict["DG2"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["DG2"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_DNDF_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_DNDF_1d_double_NestedVector;
                        cpp_current_dict["DNDF"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["DNDF"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_DGDF_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_DGDF_1d_double_NestedVector;
                        cpp_current_dict["DGDF"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["DGDF"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_DF2_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_DF2_1d_double_NestedVector;
                        cpp_current_dict["DF2"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["DF2"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_DJDN_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_DJDN_1d_double_NestedVector;
                        cpp_current_dict["DJDN"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["DJDN"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_DJDG_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_DJDG_1d_double_NestedVector;
                        cpp_current_dict["DJDG"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["DJDG"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_DJDF_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_DJDF_1d_double_NestedVector;
                        cpp_current_dict["DJDF"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["DJDF"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_DJ2_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_DJ2_1d_double_NestedVector;
                        cpp_current_dict["DJ2"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["DJ2"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    double& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    double var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                    int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                    bool& glob_aux_NLS_read = aux_NLS_read;
                    bool aux_NLS_read = glob_aux_NLS_read;
                    vartype aux_last_type_read_for_NLS = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    cpp_line = cpp_read_raw_line(cont);
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(1)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&(((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , DAP , 0 , 0 , 0 , 0 ] CONT";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read CONT record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable DAP
                          var_DAP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                          aux_DAP_read = true;
                          validate_vartype_consistency("DAP", SCALAR_DOUBLE, aux_last_type_read_for_DAP);
                          aux_last_type_read_for_DAP = SCALAR_DOUBLE;
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , 0 , 0 , NSRS , NLRS ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NSRS
                    var_NSRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NSRS_read = true;
                    validate_vartype_consistency("NSRS", SCALAR_INT, aux_last_type_read_for_NSRS);
                    aux_last_type_read_for_NSRS = SCALAR_INT;
                    // assign expression to variable NLRS
                    var_NLRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_NLRS_read = true;
                    validate_vartype_consistency("NLRS", SCALAR_INT, aux_last_type_read_for_NLRS);
                    aux_last_type_read_for_NLRS = SCALAR_INT;

                    for (int var_p_0d_int_Scalar = 1;
                       var_p_0d_int_Scalar <= var_NSRS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                      bool aux_p_read = true;
                      // open section nsrs_subsec
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        if ((! cpp_parent_dict.contains("nsrs_subsec"))) {
                          cpp_parent_dict["nsrs_subsec"] = py::dict();
                        }
                        py::dict cpp_current_dict = cpp_parent_dict["nsrs_subsec"];
                        if ((! cpp_current_dict.contains(py::cast(var_p_0d_int_Scalar)))) {
                          cpp_current_dict[py::cast(var_p_0d_int_Scalar)] = py::dict();
                        }
                        cpp_current_dict = cpp_current_dict[py::cast(var_p_0d_int_Scalar)];
                        // variable declarations
                        int var_MPAR_0d_int_Scalar;
                        bool aux_MPAR_read = false;
                        vartype aux_last_type_read_for_MPAR = UNKNOWN;
                        int var_NRB_0d_int_Scalar;
                        bool aux_NRB_read = false;
                        vartype aux_last_type_read_for_NRB = UNKNOWN;
                        NestedVector<double> var_ER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_ER = UNKNOWN;
                        NestedVector<double> var_AJ_1d_double_NestedVector;
                        vartype aux_last_type_read_for_AJ = UNKNOWN;
                        NestedVector<double> var_GT_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GT = UNKNOWN;
                        NestedVector<double> var_GN_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GN = UNKNOWN;
                        NestedVector<double> var_GG_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GG = UNKNOWN;
                        NestedVector<double> var_GF_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GF = UNKNOWN;
                        Matrix2d<double> var_V_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_V = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , MPAR , 0 , ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2)) , NRB / \n { ER , AJ , GT , GN , GG , GF } { k = 1 to NRB } , \n { { V } { n = m to (MPAR*NRB) } } { m = 1 to (MPAR*NRB) } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable MPAR
                        var_MPAR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_MPAR_read = true;
                        validate_vartype_consistency("MPAR", SCALAR_INT, aux_last_type_read_for_MPAR);
                        aux_last_type_read_for_MPAR = SCALAR_INT;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable NRB
                        var_NRB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NRB_read = true;
                        validate_vartype_consistency("NRB", SCALAR_INT, aux_last_type_read_for_NRB);
                        aux_last_type_read_for_NRB = SCALAR_INT;
                        if ((! (aux_MPAR_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for MPAR because this variable could not be isolated.");
                        } else {
                          cpp_validate_field(((6*var_NRB_0d_int_Scalar)+(((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)*((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)+1))/2)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))",
                            cpp_template, cpp_line, parse_opts);
                        }
                        if ((! (aux_NRB_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for NRB because this variable could not be isolated.");
                        } else {
                          cpp_validate_field(((6*var_NRB_0d_int_Scalar)+(((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)*((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)+1))/2)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NRB_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable AJ
                            var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                            aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GT
                            var_GT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                            aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GN
                            var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                            aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GG
                            var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                            aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GF
                            var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                            aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          var_V_2d_double_Matrix2d.init(1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), 1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), true, false);

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body

                            for (int var_n_0d_int_Scalar = var_m_0d_int_Scalar;
                               var_n_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_n_0d_int_Scalar++) {
                              bool aux_n_read = true;
                              // read LIST body
                              // assign expression to variable V
                              var_V_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("V", MATRIX2D_DOUBLE, aux_last_type_read_for_V);
                              aux_last_type_read_for_V = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        // store data in Python dictionary
                        if (((aux_last_type_read_for_MPAR == SCALAR_INT) && (aux_MPAR_read == true))) {
                          cpp_current_dict["MPAR"] = var_MPAR_0d_int_Scalar;
                        }
                        if (((aux_last_type_read_for_NRB == SCALAR_INT) && (aux_NRB_read == true))) {
                          cpp_current_dict["NRB"] = var_NRB_0d_int_Scalar;
                        }
                        if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_ER_1d_double_NestedVector;
                          cpp_current_dict["ER"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["ER"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_AJ_1d_double_NestedVector;
                          cpp_current_dict["AJ"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["AJ"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_GT_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_GT_1d_double_NestedVector;
                          cpp_current_dict["GT"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["GT"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_GN_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_GN_1d_double_NestedVector;
                          cpp_current_dict["GN"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["GN"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_GG_1d_double_NestedVector;
                          cpp_current_dict["GG"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["GG"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_GF_1d_double_NestedVector;
                          cpp_current_dict["GF"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["GF"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if (var_V_2d_double_Matrix2d.did_read()) {
                            cpp_current_dict["V"] = py::dict();
                            py::dict cpp_curdict0 = cpp_current_dict["V"];
                            for (int cpp_i1 = var_V_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_V_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
                              cpp_curdict0[py::cast(cpp_i1)] = py::dict();
                              py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
                              for (int cpp_i2 = var_V_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_V_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
                                cpp_curdict1[py::cast(cpp_i2)] = var_V_2d_double_Matrix2d(cpp_i1, cpp_i2);
                              }
                            }
                        }
                        cpp_current_dict = cpp_parent_dict;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    double& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    double var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                    int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                    bool& glob_aux_NLS_read = aux_NLS_read;
                    bool aux_NLS_read = glob_aux_NLS_read;
                    vartype aux_last_type_read_for_NLS = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    cpp_line = cpp_read_raw_line(cont);
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(1)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(3)))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , MLS , 1 / \n { DAP } { k = 1 to MLS } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable MLS
                          var_MLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_MLS_read = true;
                          validate_vartype_consistency("MLS", SCALAR_INT, aux_last_type_read_for_MLS);
                          aux_last_type_read_for_MLS = SCALAR_INT;
                          cpp_validate_field(1, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "1",
                            cpp_template, cpp_line, parse_opts);
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_MLS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable DAP
                              var_DAP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("DAP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DAP);
                              aux_last_type_read_for_DAP = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , 0 , 0 , NSRS , NLRS ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NSRS
                    var_NSRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NSRS_read = true;
                    validate_vartype_consistency("NSRS", SCALAR_INT, aux_last_type_read_for_NSRS);
                    aux_last_type_read_for_NSRS = SCALAR_INT;
                    // assign expression to variable NLRS
                    var_NLRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_NLRS_read = true;
                    validate_vartype_consistency("NLRS", SCALAR_INT, aux_last_type_read_for_NLRS);
                    aux_last_type_read_for_NLRS = SCALAR_INT;

                    for (int var_p_0d_int_Scalar = 1;
                       var_p_0d_int_Scalar <= var_NSRS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                      bool aux_p_read = true;
                      // open section nsrs_subsec
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        if ((! cpp_parent_dict.contains("nsrs_subsec"))) {
                          cpp_parent_dict["nsrs_subsec"] = py::dict();
                        }
                        py::dict cpp_current_dict = cpp_parent_dict["nsrs_subsec"];
                        if ((! cpp_current_dict.contains(py::cast(var_p_0d_int_Scalar)))) {
                          cpp_current_dict[py::cast(var_p_0d_int_Scalar)] = py::dict();
                        }
                        cpp_current_dict = cpp_current_dict[py::cast(var_p_0d_int_Scalar)];
                        // variable declarations
                        int var_MPAR_0d_int_Scalar;
                        bool aux_MPAR_read = false;
                        vartype aux_last_type_read_for_MPAR = UNKNOWN;
                        int var_NRB_0d_int_Scalar;
                        bool aux_NRB_read = false;
                        vartype aux_last_type_read_for_NRB = UNKNOWN;
                        NestedVector<double> var_ER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_ER = UNKNOWN;
                        NestedVector<double> var_AJ_1d_double_NestedVector;
                        vartype aux_last_type_read_for_AJ = UNKNOWN;
                        NestedVector<double> var_GN_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GN = UNKNOWN;
                        NestedVector<double> var_GG_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GG = UNKNOWN;
                        NestedVector<double> var_GFA_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GFA = UNKNOWN;
                        NestedVector<double> var_GFB_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GFB = UNKNOWN;
                        Matrix2d<double> var_V_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_V = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , MPAR , 0 , ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2)) , NRB / \n { ER , AJ , GN , GG , GFA , GFB } { k = 1 to NRB } , \n { { V } { n = m to (MPAR*NRB) } } { m = 1 to (MPAR*NRB) } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable MPAR
                        var_MPAR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_MPAR_read = true;
                        validate_vartype_consistency("MPAR", SCALAR_INT, aux_last_type_read_for_MPAR);
                        aux_last_type_read_for_MPAR = SCALAR_INT;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable NRB
                        var_NRB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NRB_read = true;
                        validate_vartype_consistency("NRB", SCALAR_INT, aux_last_type_read_for_NRB);
                        aux_last_type_read_for_NRB = SCALAR_INT;
                        if ((! (aux_MPAR_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for MPAR because this variable could not be isolated.");
                        } else {
                          cpp_validate_field(((6*var_NRB_0d_int_Scalar)+(((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)*((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)+1))/2)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))",
                            cpp_template, cpp_line, parse_opts);
                        }
                        if ((! (aux_NRB_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for NRB because this variable could not be isolated.");
                        } else {
                          cpp_validate_field(((6*var_NRB_0d_int_Scalar)+(((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)*((var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar)+1))/2)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NRB_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable AJ
                            var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                            aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GN
                            var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                            aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GG
                            var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                            aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GFA
                            var_GFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFA);
                            aux_last_type_read_for_GFA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable GFB
                            var_GFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("GFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFB);
                            aux_last_type_read_for_GFB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          var_V_2d_double_Matrix2d.init(1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), 1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), true, false);

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body

                            for (int var_n_0d_int_Scalar = var_m_0d_int_Scalar;
                               var_n_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_n_0d_int_Scalar++) {
                              bool aux_n_read = true;
                              // read LIST body
                              // assign expression to variable V
                              var_V_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("V", MATRIX2D_DOUBLE, aux_last_type_read_for_V);
                              aux_last_type_read_for_V = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        // store data in Python dictionary
                        if (((aux_last_type_read_for_MPAR == SCALAR_INT) && (aux_MPAR_read == true))) {
                          cpp_current_dict["MPAR"] = var_MPAR_0d_int_Scalar;
                        }
                        if (((aux_last_type_read_for_NRB == SCALAR_INT) && (aux_NRB_read == true))) {
                          cpp_current_dict["NRB"] = var_NRB_0d_int_Scalar;
                        }
                        if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_ER_1d_double_NestedVector;
                          cpp_current_dict["ER"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["ER"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_AJ_1d_double_NestedVector;
                          cpp_current_dict["AJ"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["AJ"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_GN_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_GN_1d_double_NestedVector;
                          cpp_current_dict["GN"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["GN"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_GG_1d_double_NestedVector;
                          cpp_current_dict["GG"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["GG"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_GFA_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_GFA_1d_double_NestedVector;
                          cpp_current_dict["GFA"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["GFA"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_GFB_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_GFB_1d_double_NestedVector;
                          cpp_current_dict["GFB"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["GFB"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if (var_V_2d_double_Matrix2d.did_read()) {
                            cpp_current_dict["V"] = py::dict();
                            py::dict cpp_curdict0 = cpp_current_dict["V"];
                            for (int cpp_i1 = var_V_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_V_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
                              cpp_curdict0[py::cast(cpp_i1)] = py::dict();
                              py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
                              for (int cpp_i2 = var_V_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_V_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
                                cpp_curdict1[py::cast(cpp_i2)] = var_V_2d_double_Matrix2d(cpp_i1, cpp_i2);
                              }
                            }
                        }
                        cpp_current_dict = cpp_parent_dict;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , LCOMP , 0 , ISR ] CONT";
                    cpp_line = cpp_read_raw_line(cont);
                    // read CONT record
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(1)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(7)))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , LCOMP , 0 , ISR ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , JCH , (1+((NCH-1)/6)) / \n { { DAP } { n = 1 to NCH } } { m = 1 to (JCH/NCH) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable JCH
                          var_JCH_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_JCH_read = true;
                          validate_vartype_consistency("JCH", SCALAR_INT, aux_last_type_read_for_JCH);
                          aux_last_type_read_for_JCH = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NCH
                          var_NCH_0d_int_Scalar = ((((((1/6)*(-1))+1)*(-1))+cpp_int_val)/(1/6));
                          aux_NCH_read = true;
                          validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                          aux_last_type_read_for_NCH = SCALAR_INT;
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body
                            var_DAP_2d_double_Matrix2d.init(1, (var_JCH_0d_int_Scalar/var_NCH_0d_int_Scalar), 1, var_NCH_0d_int_Scalar, false, false);

                            for (int var_m_0d_int_Scalar = 1;
                               var_m_0d_int_Scalar <= (var_JCH_0d_int_Scalar/var_NCH_0d_int_Scalar); var_m_0d_int_Scalar++) {
                              bool aux_m_read = true;
                              // read LIST body

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // read LIST body
                                // assign expression to variable DAP
                                var_DAP_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("DAP", MATRIX2D_DOUBLE, aux_last_type_read_for_DAP);
                                aux_last_type_read_for_DAP = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , 0 , 0 , NSRS , 0 ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NSRS
                    var_NSRS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NSRS_read = true;
                    validate_vartype_consistency("NSRS", SCALAR_INT, aux_last_type_read_for_NSRS);
                    aux_last_type_read_for_NSRS = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);

                    for (int var_k_0d_int_Scalar = 1;
                       var_k_0d_int_Scalar <= var_NSRS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                      bool aux_k_read = true;
                      // open section nsrs_subsec
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        if ((! cpp_parent_dict.contains("nsrs_subsec"))) {
                          cpp_parent_dict["nsrs_subsec"] = py::dict();
                        }
                        py::dict cpp_current_dict = cpp_parent_dict["nsrs_subsec"];
                        if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                          cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                        }
                        cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                        // variable declarations
                        int var_NJSX_0d_int_Scalar;
                        bool aux_NJSX_read = false;
                        vartype aux_last_type_read_for_NJSX = UNKNOWN;
                        int var_N_0d_int_Scalar;
                        bool aux_N_read = false;
                        vartype aux_last_type_read_for_N = UNKNOWN;
                        int var_NPARB_0d_int_Scalar;
                        bool aux_NPARB_read = false;
                        vartype aux_last_type_read_for_NPARB = UNKNOWN;
                        Matrix2d<double> var_V_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_V = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NJSX , 0 , 0 , 0 ] CONT";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read CONT record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable NJSX
                        var_NJSX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_NJSX_read = true;
                        validate_vartype_consistency("NJSX", SCALAR_INT, aux_last_type_read_for_NJSX);
                        aux_last_type_read_for_NJSX = SCALAR_INT;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NJSX_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // open section J_pi_group
                          {
                            py::dict cpp_parent_dict = cpp_current_dict;
                            if ((! cpp_parent_dict.contains("J_pi_group"))) {
                              cpp_parent_dict["J_pi_group"] = py::dict();
                            }
                            py::dict cpp_current_dict = cpp_parent_dict["J_pi_group"];
                            if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                              cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                            }
                            cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                            // variable declarations
                            int var_NCH_0d_int_Scalar;
                            bool aux_NCH_read = false;
                            vartype aux_last_type_read_for_NCH = UNKNOWN;
                            int var_NRB_0d_int_Scalar;
                            bool aux_NRB_read = false;
                            vartype aux_last_type_read_for_NRB = UNKNOWN;
                            NestedVector<double> var_ER_1d_double_NestedVector;
                            vartype aux_last_type_read_for_ER = UNKNOWN;
                            Matrix2d<double> var_GAM_2d_double_Matrix2d;
                            vartype aux_last_type_read_for_GAM = UNKNOWN;
                            cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NCH , NRB , (6*NX) , NX / \n { ER , { GAM } { q = 1 to NCH } \n { 0.0 } { r = 1 to num_zeros } } { p = 1 to NRB } ] LIST";
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST record
                            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                              cpp_template, cpp_line, parse_opts);
                            cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                              cpp_template, cpp_line, parse_opts);
                            if ((! (aux_NCH_read == true))) {
                              // assign expression to variable NCH
                              var_NCH_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                              aux_NCH_read = true;
                              validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                              aux_last_type_read_for_NCH = SCALAR_INT;
                            } else {
                              cpp_validate_field(var_NCH_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  true, false, false, "NCH",
                                cpp_template, cpp_line, parse_opts);
                            }
                            // assign expression to variable NRB
                            var_NRB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                            aux_NRB_read = true;
                            validate_vartype_consistency("NRB", SCALAR_INT, aux_last_type_read_for_NRB);
                            aux_last_type_read_for_NRB = SCALAR_INT;
                            if ((! (aux_NCH_read == true))) {
                              throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRB)/6))==value cannot be solved for NCH because the modulo operator is not supported.");
                            } else {
                              cpp_validate_field((6*((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRB_0d_int_Scalar)/6)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(6*((((1+NCH)+((5-NCH)%6))*NRB)/6))",
                                cpp_template, cpp_line, parse_opts);
                            }
                            if ((! (aux_NRB_read == true))) {
                              throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRB)/6))==value cannot be solved for NRB because the modulo operator is not supported.");
                            } else {
                              cpp_validate_field((6*((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRB_0d_int_Scalar)/6)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(6*((((1+NCH)+((5-NCH)%6))*NRB)/6))",
                                cpp_template, cpp_line, parse_opts);
                            }
                            if ((! (aux_NCH_read == true))) {
                              throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRB)/6)==value cannot be solved for NCH because the modulo operator is not supported.");
                            } else {
                              cpp_validate_field(((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRB_0d_int_Scalar)/6), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "((((1+NCH)+((5-NCH)%6))*NRB)/6)",
                                cpp_template, cpp_line, parse_opts);
                            }
                            if ((! (aux_NRB_read == true))) {
                              throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRB)/6)==value cannot be solved for NRB because the modulo operator is not supported.");
                            } else {
                              cpp_validate_field(((((1+var_NCH_0d_int_Scalar)+((5-var_NCH_0d_int_Scalar)%6))*var_NRB_0d_int_Scalar)/6), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "((((1+NCH)+((5-NCH)%6))*NRB)/6)",
                                cpp_template, cpp_line, parse_opts);
                            }
                            {
                              int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              // read LIST body
                              var_GAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRB_0d_int_Scalar, false, false);

                              for (int var_p_0d_int_Scalar = 1;
                                 var_p_0d_int_Scalar <= var_NRB_0d_int_Scalar; var_p_0d_int_Scalar++) {
                                bool aux_p_read = true;
                                // read LIST body
                                // assign expression to variable ER
                                var_ER_1d_double_NestedVector.set(var_p_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                                validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                                aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }

                                for (int var_q_0d_int_Scalar = 1;
                                   var_q_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_q_0d_int_Scalar++) {
                                  bool aux_q_read = true;
                                  // read LIST body
                                  // assign expression to variable GAM
                                  var_GAM_2d_double_Matrix2d(var_q_0d_int_Scalar, var_p_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                  validate_vartype_consistency("GAM", MATRIX2D_DOUBLE, aux_last_type_read_for_GAM);
                                  aux_last_type_read_for_GAM = MATRIX2D_DOUBLE;
                                  cpp_i++;
                                  cpp_j++;
                                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    cpp_j = 0;
                                  }
                                }

                                for (int var_r_0d_int_Scalar = 1;
                                   var_r_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_r_0d_int_Scalar++) {
                                  bool aux_r_read = true;
                                  // read LIST body
                                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                    cpp_template, cpp_line, parse_opts);
                                  cpp_i++;
                                  cpp_j++;
                                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                    cpp_j = 0;
                                  }
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            // store data in Python dictionary
                            if (((aux_last_type_read_for_NCH == SCALAR_INT) && (aux_NCH_read == true))) {
                              cpp_current_dict["NCH"] = var_NCH_0d_int_Scalar;
                            }
                            if (((aux_last_type_read_for_NRB == SCALAR_INT) && (aux_NRB_read == true))) {
                              cpp_current_dict["NRB"] = var_NRB_0d_int_Scalar;
                            }
                            if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                              auto& cpp_curvar0 = var_ER_1d_double_NestedVector;
                              cpp_current_dict["ER"] = py::dict();
                              py::dict cpp_curdict0 = cpp_current_dict["ER"];
                              for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                                cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                              }
                            }
                            if (var_GAM_2d_double_Matrix2d.did_read()) {
                                cpp_current_dict["GAM"] = py::dict();
                                py::dict cpp_curdict0 = cpp_current_dict["GAM"];
                                for (int cpp_i1 = var_GAM_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_GAM_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
                                  cpp_curdict0[py::cast(cpp_i1)] = py::dict();
                                  py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
                                  for (int cpp_i2 = var_GAM_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_GAM_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
                                    cpp_curdict1[py::cast(cpp_i2)] = var_GAM_2d_double_Matrix2d(cpp_i1, cpp_i2);
                                  }
                                }
                            }
                            cpp_current_dict = cpp_parent_dict;
                          }
                        }
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , N , NPARB / \n { { V } { q = p to NPARB } } { p = 1 to NPARB } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable N
                        var_N_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_N_read = true;
                        validate_vartype_consistency("N", SCALAR_INT, aux_last_type_read_for_N);
                        aux_last_type_read_for_N = SCALAR_INT;
                        // assign expression to variable NPARB
                        var_NPARB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NPARB_read = true;
                        validate_vartype_consistency("NPARB", SCALAR_INT, aux_last_type_read_for_NPARB);
                        aux_last_type_read_for_NPARB = SCALAR_INT;
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body
                          var_V_2d_double_Matrix2d.init(1, var_NPARB_0d_int_Scalar, 1, var_NPARB_0d_int_Scalar, true, false);

                          for (int var_p_0d_int_Scalar = 1;
                             var_p_0d_int_Scalar <= var_NPARB_0d_int_Scalar; var_p_0d_int_Scalar++) {
                            bool aux_p_read = true;
                            // read LIST body

                            for (int var_q_0d_int_Scalar = var_p_0d_int_Scalar;
                               var_q_0d_int_Scalar <= var_NPARB_0d_int_Scalar; var_q_0d_int_Scalar++) {
                              bool aux_q_read = true;
                              // read LIST body
                              // assign expression to variable V
                              var_V_2d_double_Matrix2d(var_p_0d_int_Scalar, var_q_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("V", MATRIX2D_DOUBLE, aux_last_type_read_for_V);
                              aux_last_type_read_for_V = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        // store data in Python dictionary
                        if (((aux_last_type_read_for_NJSX == SCALAR_INT) && (aux_NJSX_read == true))) {
                          cpp_current_dict["NJSX"] = var_NJSX_0d_int_Scalar;
                        }
                        if (((aux_last_type_read_for_N == SCALAR_INT) && (aux_N_read == true))) {
                          cpp_current_dict["N"] = var_N_0d_int_Scalar;
                        }
                        if (((aux_last_type_read_for_NPARB == SCALAR_INT) && (aux_NPARB_read == true))) {
                          cpp_current_dict["NPARB"] = var_NPARB_0d_int_Scalar;
                        }
                        if (var_V_2d_double_Matrix2d.did_read()) {
                            cpp_current_dict["V"] = py::dict();
                            py::dict cpp_curdict0 = cpp_current_dict["V"];
                            for (int cpp_i1 = var_V_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_V_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
                              cpp_curdict0[py::cast(cpp_i1)] = py::dict();
                              py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
                              for (int cpp_i2 = var_V_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_V_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
                                cpp_curdict1[py::cast(cpp_i2)] = var_V_2d_double_Matrix2d(cpp_i1, cpp_i2);
                              }
                            }
                        }
                        cpp_current_dict = cpp_parent_dict;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    double& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    double var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , 0 , ISR ] CONT";
                    cpp_line = cpp_read_raw_line(cont);
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(2)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&(((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , 0 , ISR ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , DAP , 0 , 0 , 0 , 0 ] CONT";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read CONT record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable DAP
                          var_DAP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                          aux_DAP_read = true;
                          validate_vartype_consistency("DAP", SCALAR_DOUBLE, aux_last_type_read_for_DAP);
                          aux_last_type_read_for_DAP = SCALAR_DOUBLE;
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , QX , 0 , LRX , (12*NRSA) , NRSA / \n { ER , AJ , GT , GN , GG , GF , \n DER , 0.0 , 0.0 , DGN , DGG , DGF } { k = 1 to NRSA } ] LIST";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST record
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    // assign expression to variable QX
                    var_QX_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                    aux_QX_read = true;
                    validate_vartype_consistency("QX", SCALAR_DOUBLE, aux_last_type_read_for_QX);
                    aux_last_type_read_for_QX = SCALAR_DOUBLE;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable LRX
                    var_LRX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LRX_read = true;
                    validate_vartype_consistency("LRX", SCALAR_INT, aux_last_type_read_for_LRX);
                    aux_last_type_read_for_LRX = SCALAR_INT;
                    // assign expression to variable cpp_int_val
                    cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_cpp_int_val_read = true;
                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                    // assign expression to variable NRSA
                    var_NRSA_0d_int_Scalar = (cpp_int_val/12);
                    aux_NRSA_read = true;
                    validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                    aux_last_type_read_for_NRSA = SCALAR_INT;
                    if ((! (aux_NRSA_read == true))) {
                      // assign expression to variable NRSA
                      var_NRSA_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_NRSA_read = true;
                      validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                      aux_last_type_read_for_NRSA = SCALAR_INT;
                    } else {
                      cpp_validate_field(var_NRSA_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NRSA",
                        cpp_template, cpp_line, parse_opts);
                    }
                    {
                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_NRSA_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        // assign expression to variable ER
                        var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                        aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable AJ
                        var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                        aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GT
                        var_GT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                        aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GN
                        var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                        aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GG
                        var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                        aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GF
                        var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                        aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DER
                        var_DER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DER);
                        aux_last_type_read_for_DER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGN
                        var_DGN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGN);
                        aux_last_type_read_for_DGN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGG
                        var_DGG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGG);
                        aux_last_type_read_for_DGG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGF
                        var_DGF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGF);
                        aux_last_type_read_for_DGF = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NDIGIT , NNN , NM , 0 ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NDIGIT
                    var_NDIGIT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_NDIGIT_read = true;
                    validate_vartype_consistency("NDIGIT", SCALAR_INT, aux_last_type_read_for_NDIGIT);
                    aux_last_type_read_for_NDIGIT = SCALAR_INT;
                    // assign expression to variable NNN
                    var_NNN_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_NNN_read = true;
                    validate_vartype_consistency("NNN", SCALAR_INT, aux_last_type_read_for_NNN);
                    aux_last_type_read_for_NNN = SCALAR_INT;
                    // assign expression to variable NM
                    var_NM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NM_read = true;
                    validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
                    aux_last_type_read_for_NM = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);

                    for (int var_k_0d_int_Scalar = 1;
                       var_k_0d_int_Scalar <= var_NM_0d_int_Scalar; var_k_0d_int_Scalar++) {
                      bool aux_k_read = true;
                      {
                        cpp_template = "[ MAT , 32 , 151 / II , JJ , KIJ { NDIGIT } ] INTG";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        int cpp_ndigit = var_NDIGIT_0d_int_Scalar;
                        if ((cpp_ndigit < 2 || cpp_ndigit > 6)) {
                          throw std::runtime_error("invalid NDIGIT (must be between 2 and 6)");
                        }
                        // assign expression to variable II
                        var_II_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_custom_int_field(cpp_line.c_str(), 0, 5));
                        validate_vartype_consistency("II", NESTEDVECTOR_INT, aux_last_type_read_for_II);
                        aux_last_type_read_for_II = NESTEDVECTOR_INT;
                        // assign expression to variable JJ
                        var_JJ_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_custom_int_field(cpp_line.c_str(), 5, 5));
                        validate_vartype_consistency("JJ", NESTEDVECTOR_INT, aux_last_type_read_for_JJ);
                        aux_last_type_read_for_JJ = NESTEDVECTOR_INT;
                        int cpp_step = cpp_ndigit + 1;
                        int cpp_end = 65;
                        int cpp_start;
                        if (cpp_ndigit <= 5) {
                          cpp_start = 11;
                        } else {
                          cpp_start = 10;
                        }
                        std::vector<int> cpp_intvec;
                        int elpos = 0;
                        for (int cpp_i = cpp_start; cpp_i < cpp_end; cpp_i += cpp_step) {
                          cpp_intvec.push_back(cpp_read_custom_int_field(cpp_line.c_str(), cpp_i, cpp_step));
                          elpos++;
                        }
                        // assign expression to variable KIJ
                        var_KIJ_1d_intvec_NestedVector.set(var_k_0d_int_Scalar, cpp_intvec);
                        validate_vartype_consistency("KIJ", NESTEDVECTOR_INTVEC, aux_last_type_read_for_KIJ);
                        aux_last_type_read_for_KIJ = NESTEDVECTOR_INTVEC;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    double& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    double var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LAD_0d_int_Scalar = var_LAD_0d_int_Scalar;
                    int var_LAD_0d_int_Scalar = glob_var_LAD_0d_int_Scalar;
                    bool& glob_aux_LAD_read = aux_LAD_read;
                    bool aux_LAD_read = glob_aux_LAD_read;
                    vartype aux_last_type_read_for_LAD = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , LAD , LCOMP , 0 , ISR ] CONT";
                    cpp_line = cpp_read_raw_line(cont);
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    // assign expression to variable LAD
                    var_LAD_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_LAD_read = true;
                    validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                    aux_last_type_read_for_LAD = SCALAR_INT;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(2)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(3)))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , LAD , LCOMP , 0 , ISR ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    // assign expression to variable LAD
                    var_LAD_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_LAD_read = true;
                    validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                    aux_last_type_read_for_LAD = SCALAR_INT;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , MLS , 1 / \n { DAP } { k = 1 to MLS } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable MLS
                          var_MLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_MLS_read = true;
                          validate_vartype_consistency("MLS", SCALAR_INT, aux_last_type_read_for_MLS);
                          aux_last_type_read_for_MLS = SCALAR_INT;
                          cpp_validate_field(1, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "1",
                            cpp_template, cpp_line, parse_opts);
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_MLS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable DAP
                              var_DAP_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("DAP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DAP);
                              aux_last_type_read_for_DAP = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , APL , 0 , 0 , (12*NRSA) , NRSA / \n { ER , AJ , GN , GG , GFA , GFB , \n DER , 0.0 , DGN , DGG , DGFA , DGFB } { k = 1 to NRSA } ] LIST";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST record
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    // assign expression to variable APL
                    var_APL_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                    aux_APL_read = true;
                    validate_vartype_consistency("APL", SCALAR_DOUBLE, aux_last_type_read_for_APL);
                    aux_last_type_read_for_APL = SCALAR_DOUBLE;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable cpp_int_val
                    cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_cpp_int_val_read = true;
                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                    // assign expression to variable NRSA
                    var_NRSA_0d_int_Scalar = (cpp_int_val/12);
                    aux_NRSA_read = true;
                    validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                    aux_last_type_read_for_NRSA = SCALAR_INT;
                    if ((! (aux_NRSA_read == true))) {
                      // assign expression to variable NRSA
                      var_NRSA_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_NRSA_read = true;
                      validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                      aux_last_type_read_for_NRSA = SCALAR_INT;
                    } else {
                      cpp_validate_field(var_NRSA_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NRSA",
                        cpp_template, cpp_line, parse_opts);
                    }
                    {
                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_NRSA_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        // assign expression to variable ER
                        var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                        aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable AJ
                        var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                        aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GN
                        var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                        aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GG
                        var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                        aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GFA
                        var_GFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFA);
                        aux_last_type_read_for_GFA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable GFB
                        var_GFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("GFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFB);
                        aux_last_type_read_for_GFB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DER
                        var_DER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DER);
                        aux_last_type_read_for_DER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGN
                        var_DGN_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGN);
                        aux_last_type_read_for_DGN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGG
                        var_DGG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGG);
                        aux_last_type_read_for_DGG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGFA
                        var_DGFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGFA);
                        aux_last_type_read_for_DGFA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable DGFB
                        var_DGFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("DGFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGFB);
                        aux_last_type_read_for_DGFB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NDIGIT , NNN , NM , 0 ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NDIGIT
                    var_NDIGIT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_NDIGIT_read = true;
                    validate_vartype_consistency("NDIGIT", SCALAR_INT, aux_last_type_read_for_NDIGIT);
                    aux_last_type_read_for_NDIGIT = SCALAR_INT;
                    // assign expression to variable NNN
                    var_NNN_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_NNN_read = true;
                    validate_vartype_consistency("NNN", SCALAR_INT, aux_last_type_read_for_NNN);
                    aux_last_type_read_for_NNN = SCALAR_INT;
                    // assign expression to variable NM
                    var_NM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NM_read = true;
                    validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
                    aux_last_type_read_for_NM = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);

                    for (int var_k_0d_int_Scalar = 1;
                       var_k_0d_int_Scalar <= var_NM_0d_int_Scalar; var_k_0d_int_Scalar++) {
                      bool aux_k_read = true;
                      {
                        cpp_template = "[ MAT , 32 , 151 / II , JJ , KIJ { NDIGIT } ] INTG";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        int cpp_ndigit = var_NDIGIT_0d_int_Scalar;
                        if ((cpp_ndigit < 2 || cpp_ndigit > 6)) {
                          throw std::runtime_error("invalid NDIGIT (must be between 2 and 6)");
                        }
                        // assign expression to variable II
                        var_II_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_custom_int_field(cpp_line.c_str(), 0, 5));
                        validate_vartype_consistency("II", NESTEDVECTOR_INT, aux_last_type_read_for_II);
                        aux_last_type_read_for_II = NESTEDVECTOR_INT;
                        // assign expression to variable JJ
                        var_JJ_1d_int_NestedVector.set(var_k_0d_int_Scalar, cpp_read_custom_int_field(cpp_line.c_str(), 5, 5));
                        validate_vartype_consistency("JJ", NESTEDVECTOR_INT, aux_last_type_read_for_JJ);
                        aux_last_type_read_for_JJ = NESTEDVECTOR_INT;
                        int cpp_step = cpp_ndigit + 1;
                        int cpp_end = 65;
                        int cpp_start;
                        if (cpp_ndigit <= 5) {
                          cpp_start = 11;
                        } else {
                          cpp_start = 10;
                        }
                        std::vector<int> cpp_intvec;
                        int elpos = 0;
                        for (int cpp_i = cpp_start; cpp_i < cpp_end; cpp_i += cpp_step) {
                          cpp_intvec.push_back(cpp_read_custom_int_field(cpp_line.c_str(), cpp_i, cpp_step));
                          elpos++;
                        }
                        // assign expression to variable KIJ
                        var_KIJ_1d_intvec_NestedVector.set(var_k_0d_int_Scalar, cpp_intvec);
                        validate_vartype_consistency("KIJ", NESTEDVECTOR_INTVEC, aux_last_type_read_for_KIJ);
                        aux_last_type_read_for_KIJ = NESTEDVECTOR_INTVEC;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  std::streampos cpp_old_streampos = cont.tellg();
                  {
                    // variable declarations
                    double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    int& glob_var_IFG_0d_int_Scalar = var_IFG_0d_int_Scalar;
                    int var_IFG_0d_int_Scalar = glob_var_IFG_0d_int_Scalar;
                    bool& glob_aux_IFG_read = aux_IFG_read;
                    bool aux_IFG_read = glob_aux_IFG_read;
                    vartype aux_last_type_read_for_IFG = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_NJS_0d_int_Scalar = var_NJS_0d_int_Scalar;
                    int var_NJS_0d_int_Scalar = glob_var_NJS_0d_int_Scalar;
                    bool& glob_aux_NJS_read = aux_NJS_read;
                    bool aux_NJS_read = glob_aux_NJS_read;
                    vartype aux_last_type_read_for_NJS = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , IFG , LCOMP , NJS , ISR ] CONT";
                    cpp_line = cpp_read_raw_line(cont);
                    // read CONT record
                    // assign expression to variable IFG
                    var_IFG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_IFG_read = true;
                    validate_vartype_consistency("IFG", SCALAR_INT, aux_last_type_read_for_IFG);
                    aux_last_type_read_for_IFG = SCALAR_INT;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NJS
                    var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NJS_read = true;
                    validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                    aux_last_type_read_for_NJS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(2)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(7)))))))) {
                      cpp_found_match = true;
                    }
                    cont.seekg(cpp_old_streampos);
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , IFG , LCOMP , NJS , ISR ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable IFG
                    var_IFG_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_IFG_read = true;
                    validate_vartype_consistency("IFG", SCALAR_INT, aux_last_type_read_for_IFG);
                    aux_last_type_read_for_IFG = SCALAR_INT;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NJS
                    var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NJS_read = true;
                    validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                    aux_last_type_read_for_NJS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , NJCH , (1+((NJCH-1)/6)) / \n { { DAP } { n = 1 to (NJCH/NJS) } } { m = 1 to (NJCH/NJS) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable NJCH
                          var_NJCH_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_NJCH_read = true;
                          validate_vartype_consistency("NJCH", SCALAR_INT, aux_last_type_read_for_NJCH);
                          aux_last_type_read_for_NJCH = SCALAR_INT;
                          if ((! (aux_NJCH_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NJCH
                            var_NJCH_0d_int_Scalar = ((((((1/6)*(-1))+1)*(-1))+cpp_int_val)/(1/6));
                            aux_NJCH_read = true;
                            validate_vartype_consistency("NJCH", SCALAR_INT, aux_last_type_read_for_NJCH);
                            aux_last_type_read_for_NJCH = SCALAR_INT;
                          } else {
                            cpp_validate_field((1+((var_NJCH_0d_int_Scalar-1)/6)), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "(1+((NJCH-1)/6))",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body
                            var_DAP_2d_double_Matrix2d.init(1, (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar), 1, (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar), false, false);

                            for (int var_m_0d_int_Scalar = 1;
                               var_m_0d_int_Scalar <= (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar); var_m_0d_int_Scalar++) {
                              bool aux_m_read = true;
                              // read LIST body

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar); var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // read LIST body
                                // assign expression to variable DAP
                                var_DAP_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("DAP", MATRIX2D_DOUBLE, aux_last_type_read_for_DAP);
                                aux_last_type_read_for_DAP = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NPP , NJSX , (12*NPP) , (2*NPP) / \n { MA , MB , ZA , ZB , IA , IB , \n Q , PNT , SHF , MT , PA , PB } { k = 1 to NPP } ] LIST";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST record
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NPP
                    var_NPP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_NPP_read = true;
                    validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                    aux_last_type_read_for_NPP = SCALAR_INT;
                    // assign expression to variable NJSX
                    var_NJSX_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_NJSX_read = true;
                    validate_vartype_consistency("NJSX", SCALAR_INT, aux_last_type_read_for_NJSX);
                    aux_last_type_read_for_NJSX = SCALAR_INT;
                    if ((! (aux_NPP_read == true))) {
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NPP
                      var_NPP_0d_int_Scalar = (cpp_int_val/12);
                      aux_NPP_read = true;
                      validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                      aux_last_type_read_for_NPP = SCALAR_INT;
                    } else {
                      cpp_validate_field((12*var_NPP_0d_int_Scalar), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(12*NPP)",
                        cpp_template, cpp_line, parse_opts);
                    }
                    if ((! (aux_NPP_read == true))) {
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NPP
                      var_NPP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NPP_read = true;
                      validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                      aux_last_type_read_for_NPP = SCALAR_INT;
                    } else {
                      cpp_validate_field((2*var_NPP_0d_int_Scalar), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "(2*NPP)",
                        cpp_template, cpp_line, parse_opts);
                    }
                    {
                      int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_NPP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        // assign expression to variable MA
                        var_MA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("MA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MA);
                        aux_last_type_read_for_MA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable MB
                        var_MB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("MB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MB);
                        aux_last_type_read_for_MB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable ZA
                        var_ZA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("ZA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZA);
                        aux_last_type_read_for_ZA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable ZB
                        var_ZB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("ZB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZB);
                        aux_last_type_read_for_ZB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable IA
                        var_IA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("IA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IA);
                        aux_last_type_read_for_IA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable IB
                        var_IB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("IB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IB);
                        aux_last_type_read_for_IB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable Q
                        var_Q_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("Q", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Q);
                        aux_last_type_read_for_Q = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable PNT
                        var_PNT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("PNT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PNT);
                        aux_last_type_read_for_PNT = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable SHF
                        var_SHF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("SHF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SHF);
                        aux_last_type_read_for_SHF = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable MT
                        var_MT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("MT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MT);
                        aux_last_type_read_for_MT = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable PA
                        var_PA_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("PA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PA);
                        aux_last_type_read_for_PA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                        // assign expression to variable PB
                        var_PB_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                        validate_vartype_consistency("PB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PB);
                        aux_last_type_read_for_PB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }

                    for (int var_q_0d_int_Scalar = 1;
                       var_q_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_q_0d_int_Scalar++) {
                      bool aux_q_read = true;
                      // open section somesec
                      {
                        py::dict cpp_parent_dict = cpp_current_dict;
                        if ((! cpp_parent_dict.contains("somesec"))) {
                          cpp_parent_dict["somesec"] = py::dict();
                        }
                        py::dict cpp_current_dict = cpp_parent_dict["somesec"];
                        if ((! cpp_current_dict.contains(py::cast(var_q_0d_int_Scalar)))) {
                          cpp_current_dict[py::cast(var_q_0d_int_Scalar)] = py::dict();
                        }
                        cpp_current_dict = cpp_current_dict[py::cast(var_q_0d_int_Scalar)];
                        // variable declarations
                        double var_AJ_0d_double_Scalar;
                        bool aux_AJ_read = false;
                        vartype aux_last_type_read_for_AJ = UNKNOWN;
                        double var_PJ_0d_double_Scalar;
                        bool aux_PJ_read = false;
                        vartype aux_last_type_read_for_PJ = UNKNOWN;
                        int cpp_int_val;
                        bool aux_cpp_int_val_read = false;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int var_NCH_0d_int_Scalar;
                        bool aux_NCH_read = false;
                        vartype aux_last_type_read_for_NCH = UNKNOWN;
                        NestedVector<double> var_PPI_1d_double_NestedVector;
                        vartype aux_last_type_read_for_PPI = UNKNOWN;
                        NestedVector<double> var_L_1d_double_NestedVector;
                        vartype aux_last_type_read_for_L = UNKNOWN;
                        NestedVector<double> var_SCH_1d_double_NestedVector;
                        vartype aux_last_type_read_for_SCH = UNKNOWN;
                        NestedVector<double> var_BND_1d_double_NestedVector;
                        vartype aux_last_type_read_for_BND = UNKNOWN;
                        NestedVector<double> var_APE_1d_double_NestedVector;
                        vartype aux_last_type_read_for_APE = UNKNOWN;
                        NestedVector<double> var_APT_1d_double_NestedVector;
                        vartype aux_last_type_read_for_APT = UNKNOWN;
                        int var_NRSA_0d_int_Scalar;
                        bool aux_NRSA_read = false;
                        vartype aux_last_type_read_for_NRSA = UNKNOWN;
                        NestedVector<double> var_ER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_ER = UNKNOWN;
                        Matrix2d<double> var_GAM_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_GAM = UNKNOWN;
                        NestedVector<double> var_DER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_DER = UNKNOWN;
                        Matrix2d<double> var_DGAM_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_DGAM = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / AJ , PJ , 0 , 0 , (6*NCH) , NCH / \n { PPI , L , SCH , BND , APE , APT } { k = 1 to NCH } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        // assign expression to variable AJ
                        var_AJ_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                        aux_AJ_read = true;
                        validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                        aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                        // assign expression to variable PJ
                        var_PJ_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                        aux_PJ_read = true;
                        validate_vartype_consistency("PJ", SCALAR_DOUBLE, aux_last_type_read_for_PJ);
                        aux_last_type_read_for_PJ = SCALAR_DOUBLE;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NCH
                        var_NCH_0d_int_Scalar = (cpp_int_val/6);
                        aux_NCH_read = true;
                        validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                        aux_last_type_read_for_NCH = SCALAR_INT;
                        if ((! (aux_NCH_read == true))) {
                          // assign expression to variable NCH
                          var_NCH_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NCH_read = true;
                          validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                          aux_last_type_read_for_NCH = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NCH_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NCH",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable PPI
                            var_PPI_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("PPI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PPI);
                            aux_last_type_read_for_PPI = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable L
                            var_L_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("L", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_L);
                            aux_last_type_read_for_L = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable SCH
                            var_SCH_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("SCH", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SCH);
                            aux_last_type_read_for_SCH = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable BND
                            var_BND_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("BND", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BND);
                            aux_last_type_read_for_BND = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable APE
                            var_APE_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("APE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APE);
                            aux_last_type_read_for_APE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable APT
                            var_APT_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("APT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APT);
                            aux_last_type_read_for_APT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , NRSA , (12*NX) , NX / \n { ER , { GAM } { p = 1 to NCH } , { 0.0 } { r = 1 to num_zeros } \n DER , { DGAM } { p = 1 to NCH } , { 0.0 } { r = 1 to num_zeros } \n } { k = 1 to NRSA } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable NRSA
                        var_NRSA_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_NRSA_read = true;
                        validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                        aux_last_type_read_for_NRSA = SCALAR_INT;
                        if ((! (aux_NCH_read == true))) {
                          throw std::runtime_error("The equation (12*((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12))==value cannot be solved for NCH because the modulo operator is not supported.");
                        } else {
                          cpp_validate_field((12*((((2*(var_NCH_0d_int_Scalar+1))+(2*((5-var_NCH_0d_int_Scalar)%6)))*var_NRSA_0d_int_Scalar)/12)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(12*((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12))",
                            cpp_template, cpp_line, parse_opts);
                        }
                        if ((! (aux_NRSA_read == true))) {
                          throw std::runtime_error("The equation (12*((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12))==value cannot be solved for NRSA because the modulo operator is not supported.");
                        } else {
                          cpp_validate_field((12*((((2*(var_NCH_0d_int_Scalar+1))+(2*((5-var_NCH_0d_int_Scalar)%6)))*var_NRSA_0d_int_Scalar)/12)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(12*((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12))",
                            cpp_template, cpp_line, parse_opts);
                        }
                        if ((! (aux_NCH_read == true))) {
                          throw std::runtime_error("The equation ((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12)==value cannot be solved for NCH because the modulo operator is not supported.");
                        } else {
                          cpp_validate_field(((((2*(var_NCH_0d_int_Scalar+1))+(2*((5-var_NCH_0d_int_Scalar)%6)))*var_NRSA_0d_int_Scalar)/12), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12)",
                            cpp_template, cpp_line, parse_opts);
                        }
                        if ((! (aux_NRSA_read == true))) {
                          throw std::runtime_error("The equation ((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12)==value cannot be solved for NRSA because the modulo operator is not supported.");
                        } else {
                          cpp_validate_field(((((2*(var_NCH_0d_int_Scalar+1))+(2*((5-var_NCH_0d_int_Scalar)%6)))*var_NRSA_0d_int_Scalar)/12), cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12)",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body
                          var_GAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRSA_0d_int_Scalar, false, false);
                          var_DGAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRSA_0d_int_Scalar, false, false);

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NRSA_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }

                            for (int var_p_0d_int_Scalar = 1;
                               var_p_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_p_0d_int_Scalar++) {
                              bool aux_p_read = true;
                              // read LIST body
                              // assign expression to variable GAM
                              var_GAM_2d_double_Matrix2d(var_p_0d_int_Scalar, var_k_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("GAM", MATRIX2D_DOUBLE, aux_last_type_read_for_GAM);
                              aux_last_type_read_for_GAM = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }

                            for (int var_r_0d_int_Scalar = 1;
                               var_r_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_r_0d_int_Scalar++) {
                              bool aux_r_read = true;
                              // read LIST body
                              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            // assign expression to variable DER
                            var_DER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("DER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DER);
                            aux_last_type_read_for_DER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }

                            for (int var_p_0d_int_Scalar = 1;
                               var_p_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_p_0d_int_Scalar++) {
                              bool aux_p_read = true;
                              // read LIST body
                              // assign expression to variable DGAM
                              var_DGAM_2d_double_Matrix2d(var_p_0d_int_Scalar, var_k_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("DGAM", MATRIX2D_DOUBLE, aux_last_type_read_for_DGAM);
                              aux_last_type_read_for_DGAM = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }

                            for (int var_r_0d_int_Scalar = 1;
                               var_r_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_r_0d_int_Scalar++) {
                              bool aux_r_read = true;
                              // read LIST body
                              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts),  false, false, false, "0.0",
                                cpp_template, cpp_line, parse_opts);
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        // store data in Python dictionary
                        if (((aux_last_type_read_for_AJ == SCALAR_DOUBLE) && (aux_AJ_read == true))) {
                          cpp_current_dict["AJ"] = var_AJ_0d_double_Scalar;
                        }
                        if (((aux_last_type_read_for_PJ == SCALAR_DOUBLE) && (aux_PJ_read == true))) {
                          cpp_current_dict["PJ"] = var_PJ_0d_double_Scalar;
                        }
                        if (((aux_last_type_read_for_NCH == SCALAR_INT) && (aux_NCH_read == true))) {
                          cpp_current_dict["NCH"] = var_NCH_0d_int_Scalar;
                        }
                        if ((var_PPI_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_PPI_1d_double_NestedVector;
                          cpp_current_dict["PPI"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["PPI"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_L_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_L_1d_double_NestedVector;
                          cpp_current_dict["L"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["L"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_SCH_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_SCH_1d_double_NestedVector;
                          cpp_current_dict["SCH"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["SCH"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_BND_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_BND_1d_double_NestedVector;
                          cpp_current_dict["BND"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["BND"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_APE_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_APE_1d_double_NestedVector;
                          cpp_current_dict["APE"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["APE"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if ((var_APT_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_APT_1d_double_NestedVector;
                          cpp_current_dict["APT"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["APT"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if (((aux_last_type_read_for_NRSA == SCALAR_INT) && (aux_NRSA_read == true))) {
                          cpp_current_dict["NRSA"] = var_NRSA_0d_int_Scalar;
                        }
                        if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_ER_1d_double_NestedVector;
                          cpp_current_dict["ER"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["ER"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if (var_GAM_2d_double_Matrix2d.did_read()) {
                            cpp_current_dict["GAM"] = py::dict();
                            py::dict cpp_curdict0 = cpp_current_dict["GAM"];
                            for (int cpp_i1 = var_GAM_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_GAM_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
                              cpp_curdict0[py::cast(cpp_i1)] = py::dict();
                              py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
                              for (int cpp_i2 = var_GAM_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_GAM_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
                                cpp_curdict1[py::cast(cpp_i2)] = var_GAM_2d_double_Matrix2d(cpp_i1, cpp_i2);
                              }
                            }
                        }
                        if ((var_DER_1d_double_NestedVector.get_last_index() != -1)) {
                          auto& cpp_curvar0 = var_DER_1d_double_NestedVector;
                          cpp_current_dict["DER"] = py::dict();
                          py::dict cpp_curdict0 = cpp_current_dict["DER"];
                          for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                            cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                          }
                        }
                        if (var_DGAM_2d_double_Matrix2d.did_read()) {
                            cpp_current_dict["DGAM"] = py::dict();
                            py::dict cpp_curdict0 = cpp_current_dict["DGAM"];
                            for (int cpp_i1 = var_DGAM_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_DGAM_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
                              cpp_curdict0[py::cast(cpp_i1)] = py::dict();
                              py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
                              for (int cpp_i2 = var_DGAM_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_DGAM_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
                                cpp_curdict1[py::cast(cpp_i2)] = var_DGAM_2d_double_Matrix2d(cpp_i1, cpp_i2);
                              }
                            }
                        }
                        cpp_current_dict = cpp_parent_dict;
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NDIGIT , NNN , NM , 0 ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NDIGIT
                    var_NDIGIT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                    aux_NDIGIT_read = true;
                    validate_vartype_consistency("NDIGIT", SCALAR_INT, aux_last_type_read_for_NDIGIT);
                    aux_last_type_read_for_NDIGIT = SCALAR_INT;
                    // assign expression to variable NNN
                    var_NNN_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                    aux_NNN_read = true;
                    validate_vartype_consistency("NNN", SCALAR_INT, aux_last_type_read_for_NNN);
                    aux_last_type_read_for_NNN = SCALAR_INT;
                    // assign expression to variable NM
                    var_NM_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    aux_NM_read = true;
                    validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
                    aux_last_type_read_for_NM = SCALAR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);

                    for (int var_q_0d_int_Scalar = 1;
                       var_q_0d_int_Scalar <= var_NM_0d_int_Scalar; var_q_0d_int_Scalar++) {
                      bool aux_q_read = true;
                      {
                        cpp_template = "[ MAT , 32 , 151 / II , JJ , KIJ { NDIGIT } ] INTG";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        int cpp_ndigit = var_NDIGIT_0d_int_Scalar;
                        if ((cpp_ndigit < 2 || cpp_ndigit > 6)) {
                          throw std::runtime_error("invalid NDIGIT (must be between 2 and 6)");
                        }
                        // assign expression to variable II
                        var_II_1d_int_NestedVector.set(var_q_0d_int_Scalar, cpp_read_custom_int_field(cpp_line.c_str(), 0, 5));
                        validate_vartype_consistency("II", NESTEDVECTOR_INT, aux_last_type_read_for_II);
                        aux_last_type_read_for_II = NESTEDVECTOR_INT;
                        // assign expression to variable JJ
                        var_JJ_1d_int_NestedVector.set(var_q_0d_int_Scalar, cpp_read_custom_int_field(cpp_line.c_str(), 5, 5));
                        validate_vartype_consistency("JJ", NESTEDVECTOR_INT, aux_last_type_read_for_JJ);
                        aux_last_type_read_for_JJ = NESTEDVECTOR_INT;
                        int cpp_step = cpp_ndigit + 1;
                        int cpp_end = 65;
                        int cpp_start;
                        if (cpp_ndigit <= 5) {
                          cpp_start = 11;
                        } else {
                          cpp_start = 10;
                        }
                        std::vector<int> cpp_intvec;
                        int elpos = 0;
                        for (int cpp_i = cpp_start; cpp_i < cpp_end; cpp_i += cpp_step) {
                          cpp_intvec.push_back(cpp_read_custom_int_field(cpp_line.c_str(), cpp_i, cpp_step));
                          elpos++;
                        }
                        // assign expression to variable KIJ
                        var_KIJ_1d_intvec_NestedVector.set(var_q_0d_int_Scalar, cpp_intvec);
                        validate_vartype_consistency("KIJ", NESTEDVECTOR_INTVEC, aux_last_type_read_for_KIJ);
                        aux_last_type_read_for_KIJ = NESTEDVECTOR_INTVEC;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                if ((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(2)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read CONT record
                  // assign expression to variable SPI
                  var_SPI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                  aux_SPI_read = true;
                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                  // assign expression to variable AP
                  var_AP_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                  aux_AP_read = true;
                  validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                  aux_last_type_read_for_AP = SCALAR_DOUBLE;
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable NLS
                  var_NLS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  aux_NLS_read = true;
                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                  aux_last_type_read_for_NLS = SCALAR_INT;
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);

                  for (int var_q_0d_int_Scalar = 1;
                     var_q_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_q_0d_int_Scalar++) {
                    bool aux_q_read = true;
                    // open section l_group
                    {
                      py::dict cpp_parent_dict = cpp_current_dict;
                      if ((! cpp_parent_dict.contains("l_group"))) {
                        cpp_parent_dict["l_group"] = py::dict();
                      }
                      py::dict cpp_current_dict = cpp_parent_dict["l_group"];
                      if ((! cpp_current_dict.contains(py::cast(var_q_0d_int_Scalar)))) {
                        cpp_current_dict[py::cast(var_q_0d_int_Scalar)] = py::dict();
                      }
                      cpp_current_dict = cpp_current_dict[py::cast(var_q_0d_int_Scalar)];
                      // variable declarations
                      double var_AWRI_0d_double_Scalar;
                      bool aux_AWRI_read = false;
                      vartype aux_last_type_read_for_AWRI = UNKNOWN;
                      int var_L_0d_int_Scalar;
                      bool aux_L_read = false;
                      vartype aux_last_type_read_for_L = UNKNOWN;
                      int cpp_int_val;
                      bool aux_cpp_int_val_read = false;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int var_NJS_0d_int_Scalar;
                      bool aux_NJS_read = false;
                      vartype aux_last_type_read_for_NJS = UNKNOWN;
                      NestedVector<double> var_D_1d_double_NestedVector;
                      vartype aux_last_type_read_for_D = UNKNOWN;
                      NestedVector<double> var_AJ_1d_double_NestedVector;
                      vartype aux_last_type_read_for_AJ = UNKNOWN;
                      NestedVector<double> var_GNO_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GNO = UNKNOWN;
                      NestedVector<double> var_GG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GG = UNKNOWN;
                      NestedVector<double> var_GF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GF = UNKNOWN;
                      NestedVector<double> var_GX_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GX = UNKNOWN;
                      cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , L , 0 , (6*NJS) , NJS / \n { D , AJ , GNO , GG , GF , GX } { k = 1 to NJS } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      // assign expression to variable AWRI
                      var_AWRI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                      aux_AWRI_read = true;
                      validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                      aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                      cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable L
                      var_L_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                      aux_L_read = true;
                      validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                      aux_last_type_read_for_L = SCALAR_INT;
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NJS
                      var_NJS_0d_int_Scalar = (cpp_int_val/6);
                      aux_NJS_read = true;
                      validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                      aux_last_type_read_for_NJS = SCALAR_INT;
                      if ((! (aux_NJS_read == true))) {
                        // assign expression to variable NJS
                        var_NJS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NJS_read = true;
                        validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                        aux_last_type_read_for_NJS = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NJS_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NJS",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_k_0d_int_Scalar = 1;
                           var_k_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                          bool aux_k_read = true;
                          // read LIST body
                          // assign expression to variable D
                          var_D_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("D", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_D);
                          aux_last_type_read_for_D = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable AJ
                          var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                          aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GNO
                          var_GNO_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GNO", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GNO);
                          aux_last_type_read_for_GNO = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GG
                          var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                          aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GF
                          var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                          aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable GX
                          var_GX_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("GX", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GX);
                          aux_last_type_read_for_GX = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      // store data in Python dictionary
                      if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
                        cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
                      }
                      if (((aux_last_type_read_for_L == SCALAR_INT) && (aux_L_read == true))) {
                        cpp_current_dict["L"] = var_L_0d_int_Scalar;
                      }
                      if (((aux_last_type_read_for_NJS == SCALAR_INT) && (aux_NJS_read == true))) {
                        cpp_current_dict["NJS"] = var_NJS_0d_int_Scalar;
                      }
                      if ((var_D_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_D_1d_double_NestedVector;
                        cpp_current_dict["D"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["D"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_AJ_1d_double_NestedVector;
                        cpp_current_dict["AJ"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["AJ"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_GNO_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_GNO_1d_double_NestedVector;
                        cpp_current_dict["GNO"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["GNO"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_GG_1d_double_NestedVector;
                        cpp_current_dict["GG"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["GG"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_GF_1d_double_NestedVector;
                        cpp_current_dict["GF"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["GF"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      if ((var_GX_1d_double_NestedVector.get_last_index() != -1)) {
                        auto& cpp_curvar0 = var_GX_1d_double_NestedVector;
                        cpp_current_dict["GX"] = py::dict();
                        py::dict cpp_curdict0 = cpp_current_dict["GX"];
                        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                        }
                      }
                      cpp_current_dict = cpp_parent_dict;
                    }
                  }
                  cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , MPAR , 0 , ((NPAR*(NPAR+1))/2) , NPAR / \n { { RV } { q = p to NPAR } } { p = 1 to NPAR } ] LIST";
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST record
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable MPAR
                  var_MPAR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                  aux_MPAR_read = true;
                  validate_vartype_consistency("MPAR", SCALAR_INT, aux_last_type_read_for_MPAR);
                  aux_last_type_read_for_MPAR = SCALAR_INT;
                  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable NPAR
                  var_NPAR_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                  aux_NPAR_read = true;
                  validate_vartype_consistency("NPAR", SCALAR_INT, aux_last_type_read_for_NPAR);
                  aux_last_type_read_for_NPAR = SCALAR_INT;
                  if ((! (aux_NPAR_read == true))) {
                    throw std::runtime_error("The equation ((NPAR*(NPAR+1))/2)==value cannot be solved for NPAR because this variable could not be isolated.");
                  } else {
                    cpp_validate_field(((var_NPAR_0d_int_Scalar*(var_NPAR_0d_int_Scalar+1))/2), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((NPAR*(NPAR+1))/2)",
                      cpp_template, cpp_line, parse_opts);
                  }
                  {
                    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    int cpp_i = 0;
                    int cpp_j = 0;
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST body
                    var_RV_2d_double_Matrix2d.init(1, var_NPAR_0d_int_Scalar, 1, var_NPAR_0d_int_Scalar, true, false);

                    for (int var_p_0d_int_Scalar = 1;
                       var_p_0d_int_Scalar <= var_NPAR_0d_int_Scalar; var_p_0d_int_Scalar++) {
                      bool aux_p_read = true;
                      // read LIST body

                      for (int var_q_0d_int_Scalar = var_p_0d_int_Scalar;
                         var_q_0d_int_Scalar <= var_NPAR_0d_int_Scalar; var_q_0d_int_Scalar++) {
                        bool aux_q_read = true;
                        // read LIST body
                        // assign expression to variable RV
                        var_RV_2d_double_Matrix2d(var_p_0d_int_Scalar, var_q_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                        validate_vartype_consistency("RV", MATRIX2D_DOUBLE, aux_last_type_read_for_RV);
                        aux_last_type_read_for_RV = MATRIX2D_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          cpp_j = 0;
                        }
                      }
                    }
                    if (cpp_i != cpp_npl) {
                      throw std::runtime_error("not exactly NPL elements consumed");
                    }
                  }
                }
              }
            }
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_EL == SCALAR_DOUBLE) && (aux_EL_read == true))) {
            cpp_current_dict["EL"] = var_EL_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_EH == SCALAR_DOUBLE) && (aux_EH_read == true))) {
            cpp_current_dict["EH"] = var_EH_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_LRU == SCALAR_INT) && (aux_LRU_read == true))) {
            cpp_current_dict["LRU"] = var_LRU_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_LRF == SCALAR_INT) && (aux_LRF_read == true))) {
            cpp_current_dict["LRF"] = var_LRF_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NRO == SCALAR_INT) && (aux_NRO_read == true))) {
            cpp_current_dict["NRO"] = var_NRO_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NAPS == SCALAR_INT) && (aux_NAPS_read == true))) {
            cpp_current_dict["NAPS"] = var_NAPS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NI == SCALAR_INT) && (aux_NI_read == true))) {
            cpp_current_dict["NI"] = var_NI_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_SPI == SCALAR_DOUBLE) && (aux_SPI_read == true))) {
            cpp_current_dict["SPI"] = var_SPI_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_AP == SCALAR_DOUBLE) && (aux_AP_read == true))) {
            cpp_current_dict["AP"] = var_AP_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_LCOMP == SCALAR_INT) && (aux_LCOMP_read == true))) {
            cpp_current_dict["LCOMP"] = var_LCOMP_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NLS == SCALAR_INT) && (aux_NLS_read == true))) {
            cpp_current_dict["NLS"] = var_NLS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_ISR == SCALAR_INT) && (aux_ISR_read == true))) {
            cpp_current_dict["ISR"] = var_ISR_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_DAP == SCALAR_DOUBLE) && (aux_DAP_read == true))) {
            cpp_current_dict["DAP"] = var_DAP_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_AWRI == SCALAR_DOUBLE) && (aux_AWRI_read == true))) {
            cpp_current_dict["AWRI"] = var_AWRI_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_NSRS == SCALAR_INT) && (aux_NSRS_read == true))) {
            cpp_current_dict["NSRS"] = var_NSRS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NLRS == SCALAR_INT) && (aux_NLRS_read == true))) {
            cpp_current_dict["NLRS"] = var_NLRS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_MLS == SCALAR_INT) && (aux_MLS_read == true))) {
            cpp_current_dict["MLS"] = var_MLS_0d_int_Scalar;
          }
          if ((var_DAP_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_DAP_1d_double_NestedVector;
            cpp_current_dict["DAP"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["DAP"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if (((aux_last_type_read_for_JCH == SCALAR_INT) && (aux_JCH_read == true))) {
            cpp_current_dict["JCH"] = var_JCH_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NCH == SCALAR_INT) && (aux_NCH_read == true))) {
            cpp_current_dict["NCH"] = var_NCH_0d_int_Scalar;
          }
          if (var_DAP_2d_double_Matrix2d.did_read()) {
              cpp_current_dict["DAP"] = py::dict();
              py::dict cpp_curdict0 = cpp_current_dict["DAP"];
              for (int cpp_i1 = var_DAP_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_DAP_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
                cpp_curdict0[py::cast(cpp_i1)] = py::dict();
                py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
                for (int cpp_i2 = var_DAP_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_DAP_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
                  cpp_curdict1[py::cast(cpp_i2)] = var_DAP_2d_double_Matrix2d(cpp_i1, cpp_i2);
                }
              }
          }
          if (((aux_last_type_read_for_QX == SCALAR_DOUBLE) && (aux_QX_read == true))) {
            cpp_current_dict["QX"] = var_QX_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_LRX == SCALAR_INT) && (aux_LRX_read == true))) {
            cpp_current_dict["LRX"] = var_LRX_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NRSA == SCALAR_INT) && (aux_NRSA_read == true))) {
            cpp_current_dict["NRSA"] = var_NRSA_0d_int_Scalar;
          }
          if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_ER_1d_double_NestedVector;
            cpp_current_dict["ER"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["ER"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_AJ_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_AJ_1d_double_NestedVector;
            cpp_current_dict["AJ"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["AJ"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_GT_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_GT_1d_double_NestedVector;
            cpp_current_dict["GT"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["GT"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_GN_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_GN_1d_double_NestedVector;
            cpp_current_dict["GN"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["GN"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_GG_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_GG_1d_double_NestedVector;
            cpp_current_dict["GG"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["GG"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_GF_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_GF_1d_double_NestedVector;
            cpp_current_dict["GF"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["GF"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_DER_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_DER_1d_double_NestedVector;
            cpp_current_dict["DER"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["DER"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_DGN_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_DGN_1d_double_NestedVector;
            cpp_current_dict["DGN"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["DGN"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_DGG_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_DGG_1d_double_NestedVector;
            cpp_current_dict["DGG"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["DGG"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_DGF_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_DGF_1d_double_NestedVector;
            cpp_current_dict["DGF"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["DGF"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if (((aux_last_type_read_for_NDIGIT == SCALAR_INT) && (aux_NDIGIT_read == true))) {
            cpp_current_dict["NDIGIT"] = var_NDIGIT_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NNN == SCALAR_INT) && (aux_NNN_read == true))) {
            cpp_current_dict["NNN"] = var_NNN_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NM == SCALAR_INT) && (aux_NM_read == true))) {
            cpp_current_dict["NM"] = var_NM_0d_int_Scalar;
          }
          if ((var_II_1d_int_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_II_1d_int_NestedVector;
            cpp_current_dict["II"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["II"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_JJ_1d_int_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_JJ_1d_int_NestedVector;
            cpp_current_dict["JJ"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["JJ"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_KIJ_1d_intvec_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_KIJ_1d_intvec_NestedVector;
            cpp_current_dict["KIJ"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["KIJ"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if (((aux_last_type_read_for_LAD == SCALAR_INT) && (aux_LAD_read == true))) {
            cpp_current_dict["LAD"] = var_LAD_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_APL == SCALAR_DOUBLE) && (aux_APL_read == true))) {
            cpp_current_dict["APL"] = var_APL_0d_double_Scalar;
          }
          if ((var_GFA_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_GFA_1d_double_NestedVector;
            cpp_current_dict["GFA"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["GFA"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_GFB_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_GFB_1d_double_NestedVector;
            cpp_current_dict["GFB"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["GFB"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_DGFA_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_DGFA_1d_double_NestedVector;
            cpp_current_dict["DGFA"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["DGFA"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_DGFB_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_DGFB_1d_double_NestedVector;
            cpp_current_dict["DGFB"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["DGFB"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if (((aux_last_type_read_for_IFG == SCALAR_INT) && (aux_IFG_read == true))) {
            cpp_current_dict["IFG"] = var_IFG_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NJS == SCALAR_INT) && (aux_NJS_read == true))) {
            cpp_current_dict["NJS"] = var_NJS_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NJCH == SCALAR_INT) && (aux_NJCH_read == true))) {
            cpp_current_dict["NJCH"] = var_NJCH_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NPP == SCALAR_INT) && (aux_NPP_read == true))) {
            cpp_current_dict["NPP"] = var_NPP_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NJSX == SCALAR_INT) && (aux_NJSX_read == true))) {
            cpp_current_dict["NJSX"] = var_NJSX_0d_int_Scalar;
          }
          if ((var_MA_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_MA_1d_double_NestedVector;
            cpp_current_dict["MA"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["MA"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_MB_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_MB_1d_double_NestedVector;
            cpp_current_dict["MB"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["MB"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_ZA_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_ZA_1d_double_NestedVector;
            cpp_current_dict["ZA"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["ZA"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_ZB_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_ZB_1d_double_NestedVector;
            cpp_current_dict["ZB"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["ZB"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_IA_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_IA_1d_double_NestedVector;
            cpp_current_dict["IA"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["IA"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_IB_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_IB_1d_double_NestedVector;
            cpp_current_dict["IB"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["IB"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_Q_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_Q_1d_double_NestedVector;
            cpp_current_dict["Q"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["Q"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_PNT_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_PNT_1d_double_NestedVector;
            cpp_current_dict["PNT"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["PNT"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_SHF_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_SHF_1d_double_NestedVector;
            cpp_current_dict["SHF"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["SHF"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_MT_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_MT_1d_double_NestedVector;
            cpp_current_dict["MT"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["MT"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_PA_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_PA_1d_double_NestedVector;
            cpp_current_dict["PA"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["PA"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if ((var_PB_1d_double_NestedVector.get_last_index() != -1)) {
            auto& cpp_curvar0 = var_PB_1d_double_NestedVector;
            cpp_current_dict["PB"] = py::dict();
            py::dict cpp_curdict0 = cpp_current_dict["PB"];
            for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
              cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
            }
          }
          if (((aux_last_type_read_for_MPAR == SCALAR_INT) && (aux_MPAR_read == true))) {
            cpp_current_dict["MPAR"] = var_MPAR_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NPAR == SCALAR_INT) && (aux_NPAR_read == true))) {
            cpp_current_dict["NPAR"] = var_NPAR_0d_int_Scalar;
          }
          if (var_RV_2d_double_Matrix2d.did_read()) {
              cpp_current_dict["RV"] = py::dict();
              py::dict cpp_curdict0 = cpp_current_dict["RV"];
              for (int cpp_i1 = var_RV_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_RV_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
                cpp_curdict0[py::cast(cpp_i1)] = py::dict();
                py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
                for (int cpp_i2 = var_RV_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_RV_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
                  cpp_curdict1[py::cast(cpp_i2)] = var_RV_2d_double_Matrix2d(cpp_i1, cpp_i2);
                }
              }
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_ZAI == SCALAR_DOUBLE) && (aux_ZAI_read == true))) {
        cpp_current_dict["ZAI"] = var_ZAI_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_ABN == SCALAR_DOUBLE) && (aux_ABN_read == true))) {
        cpp_current_dict["ABN"] = var_ABN_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_LFW == SCALAR_INT) && (aux_LFW_read == true))) {
        cpp_current_dict["LFW"] = var_LFW_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NER == SCALAR_INT) && (aux_NER_read == true))) {
        cpp_current_dict["NER"] = var_NER_0d_int_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NIS == SCALAR_INT) && (aux_NIS_read == true))) {
    cpp_current_dict["NIS"] = var_NIS_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 284c3ace698a427c06623ccd760dca26
// MD5 hash of the following function definition: c5a06c52ea87d208024c7af0f5cc53a8
py::dict parse_mf33_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_MTL_0d_int_Scalar;
  bool aux_MTL_read = false;
  vartype aux_last_type_read_for_MTL = UNKNOWN;
  int var_NL_0d_int_Scalar;
  bool aux_NL_read = false;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 33;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 33;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 33 , MT / ZA , AWR , 0 , MTL , 0 , NL ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable MTL
  var_MTL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_MTL_read = true;
  validate_vartype_consistency("MTL", SCALAR_INT, aux_last_type_read_for_MTL);
  aux_last_type_read_for_MTL = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NL
  var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NL_read = true;
  validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
  aux_last_type_read_for_NL = SCALAR_INT;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_MTL_read == true)) && ((var_MTL_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;

        for (int var_n_0d_int_Scalar = 1;
           var_n_0d_int_Scalar <= var_NL_0d_int_Scalar; var_n_0d_int_Scalar++) {
          bool aux_n_read = true;
          // open section subsection
          {
            py::dict cpp_parent_dict = cpp_current_dict;
            if ((! cpp_parent_dict.contains("subsection"))) {
              cpp_parent_dict["subsection"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict["subsection"];
            if ((! cpp_current_dict.contains(py::cast(var_n_0d_int_Scalar)))) {
              cpp_current_dict[py::cast(var_n_0d_int_Scalar)] = py::dict();
            }
            cpp_current_dict = cpp_current_dict[py::cast(var_n_0d_int_Scalar)];
            // variable declarations
            double var_XMF1_0d_double_Scalar;
            bool aux_XMF1_read = false;
            vartype aux_last_type_read_for_XMF1 = UNKNOWN;
            double var_XLFS1_0d_double_Scalar;
            bool aux_XLFS1_read = false;
            vartype aux_last_type_read_for_XLFS1 = UNKNOWN;
            int var_MAT1_0d_int_Scalar;
            bool aux_MAT1_read = false;
            vartype aux_last_type_read_for_MAT1 = UNKNOWN;
            int var_MT1_0d_int_Scalar;
            bool aux_MT1_read = false;
            vartype aux_last_type_read_for_MT1 = UNKNOWN;
            int var_NC_0d_int_Scalar;
            bool aux_NC_read = false;
            vartype aux_last_type_read_for_NC = UNKNOWN;
            int var_NI_0d_int_Scalar;
            bool aux_NI_read = false;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            cpp_template = "[ MAT , 33 , MT / XMF1 , XLFS1 , MAT1 , MT1 , NC , NI ] CONT";
            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
            // read CONT record
            // assign expression to variable XMF1
            var_XMF1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
            aux_XMF1_read = true;
            validate_vartype_consistency("XMF1", SCALAR_DOUBLE, aux_last_type_read_for_XMF1);
            aux_last_type_read_for_XMF1 = SCALAR_DOUBLE;
            // assign expression to variable XLFS1
            var_XLFS1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
            aux_XLFS1_read = true;
            validate_vartype_consistency("XLFS1", SCALAR_DOUBLE, aux_last_type_read_for_XLFS1);
            aux_last_type_read_for_XLFS1 = SCALAR_DOUBLE;
            // assign expression to variable MAT1
            var_MAT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
            aux_MAT1_read = true;
            validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
            aux_last_type_read_for_MAT1 = SCALAR_INT;
            // assign expression to variable MT1
            var_MT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
            aux_MT1_read = true;
            validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
            aux_last_type_read_for_MT1 = SCALAR_INT;
            // assign expression to variable NC
            var_NC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
            aux_NC_read = true;
            validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
            aux_last_type_read_for_NC = SCALAR_INT;
            // assign expression to variable NI
            var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NC_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section nc_subsection
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                if ((! cpp_parent_dict.contains("nc_subsection"))) {
                  cpp_parent_dict["nc_subsection"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict["nc_subsection"];
                if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                  cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                }
                cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                // variable declarations
                int var_LTY_0d_int_Scalar;
                bool aux_LTY_read = false;
                vartype aux_last_type_read_for_LTY = UNKNOWN;
                double var_E1_0d_double_Scalar;
                bool aux_E1_read = false;
                vartype aux_last_type_read_for_E1 = UNKNOWN;
                double var_E2_0d_double_Scalar;
                bool aux_E2_read = false;
                vartype aux_last_type_read_for_E2 = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NCI_0d_int_Scalar;
                bool aux_NCI_read = false;
                vartype aux_last_type_read_for_NCI = UNKNOWN;
                NestedVector<double> var_C_1d_double_NestedVector;
                vartype aux_last_type_read_for_C = UNKNOWN;
                NestedVector<double> var_XMT_1d_double_NestedVector;
                vartype aux_last_type_read_for_XMT = UNKNOWN;
                int var_MATS_0d_int_Scalar;
                bool aux_MATS_read = false;
                vartype aux_last_type_read_for_MATS = UNKNOWN;
                int var_MTS_0d_int_Scalar;
                bool aux_MTS_read = false;
                vartype aux_last_type_read_for_MTS = UNKNOWN;
                int var_NEI_0d_int_Scalar;
                bool aux_NEI_read = false;
                vartype aux_last_type_read_for_NEI = UNKNOWN;
                double var_XMFS_0d_double_Scalar;
                bool aux_XMFS_read = false;
                vartype aux_last_type_read_for_XMFS = UNKNOWN;
                double var_XLFSS_0d_double_Scalar;
                bool aux_XLFSS_read = false;
                vartype aux_last_type_read_for_XLFSS = UNKNOWN;
                NestedVector<double> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                NestedVector<double> var_WE_1d_double_NestedVector;
                vartype aux_last_type_read_for_WE = UNKNOWN;
                cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read CONT record
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable LTY
                var_LTY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                aux_LTY_read = true;
                validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                aux_last_type_read_for_LTY = SCALAR_INT;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if ((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(0)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      cpp_template = "[ MAT , 33 , MT / E1 , E2 , 0 , 0 , (2*NCI) , NCI / \n { C , XMT } { i = 1 to NCI } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      // assign expression to variable E1
                      var_E1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                      aux_E1_read = true;
                      validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                      aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                      // assign expression to variable E2
                      var_E2_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                      aux_E2_read = true;
                      validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                      aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NCI
                      var_NCI_0d_int_Scalar = (cpp_int_val/2);
                      aux_NCI_read = true;
                      validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                      aux_last_type_read_for_NCI = SCALAR_INT;
                      if ((! (aux_NCI_read == true))) {
                        // assign expression to variable NCI
                        var_NCI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NCI_read = true;
                        validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                        aux_last_type_read_for_NCI = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NCI_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NCI",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_i_0d_int_Scalar = 1;
                           var_i_0d_int_Scalar <= var_NCI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                          bool aux_i_read = true;
                          // read LIST body
                          // assign expression to variable C
                          var_C_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
                          aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable XMT
                          var_XMT_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("XMT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_XMT);
                          aux_last_type_read_for_XMT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if (((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)>=(1)))))&&((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)<=(3)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 33 , MT / E1 , E2 , MATS , MTS , ((2*NEI)+2) , NEI / \n XMFS , XLFSS , { E , WE } { i = 1 to NEI } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        // assign expression to variable E1
                        var_E1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                        aux_E1_read = true;
                        validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                        aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                        // assign expression to variable E2
                        var_E2_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                        aux_E2_read = true;
                        validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                        aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                        // assign expression to variable MATS
                        var_MATS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_MATS_read = true;
                        validate_vartype_consistency("MATS", SCALAR_INT, aux_last_type_read_for_MATS);
                        aux_last_type_read_for_MATS = SCALAR_INT;
                        // assign expression to variable MTS
                        var_MTS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_MTS_read = true;
                        validate_vartype_consistency("MTS", SCALAR_INT, aux_last_type_read_for_MTS);
                        aux_last_type_read_for_MTS = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NEI
                        var_NEI_0d_int_Scalar = ((cpp_int_val+(-2))/2);
                        aux_NEI_read = true;
                        validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                        aux_last_type_read_for_NEI = SCALAR_INT;
                        if ((! (aux_NEI_read == true))) {
                          // assign expression to variable NEI
                          var_NEI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NEI_read = true;
                          validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                          aux_last_type_read_for_NEI = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NEI_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NEI",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body
                          // assign expression to variable XMFS
                          var_XMFS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                          aux_XMFS_read = true;
                          validate_vartype_consistency("XMFS", SCALAR_DOUBLE, aux_last_type_read_for_XMFS);
                          aux_last_type_read_for_XMFS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable XLFSS
                          var_XLFSS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                          aux_XLFSS_read = true;
                          validate_vartype_consistency("XLFSS", SCALAR_DOUBLE, aux_last_type_read_for_XLFSS);
                          aux_last_type_read_for_XLFSS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }

                          for (int var_i_0d_int_Scalar = 1;
                             var_i_0d_int_Scalar <= var_NEI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                            bool aux_i_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable WE
                            var_WE_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("WE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_WE);
                            aux_last_type_read_for_WE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_LTY == SCALAR_INT) && (aux_LTY_read == true))) {
                  cpp_current_dict["LTY"] = var_LTY_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_E1 == SCALAR_DOUBLE) && (aux_E1_read == true))) {
                  cpp_current_dict["E1"] = var_E1_0d_double_Scalar;
                }
                if (((aux_last_type_read_for_E2 == SCALAR_DOUBLE) && (aux_E2_read == true))) {
                  cpp_current_dict["E2"] = var_E2_0d_double_Scalar;
                }
                if (((aux_last_type_read_for_NCI == SCALAR_INT) && (aux_NCI_read == true))) {
                  cpp_current_dict["NCI"] = var_NCI_0d_int_Scalar;
                }
                if ((var_C_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_C_1d_double_NestedVector;
                  cpp_current_dict["C"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["C"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_XMT_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_XMT_1d_double_NestedVector;
                  cpp_current_dict["XMT"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["XMT"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if (((aux_last_type_read_for_MATS == SCALAR_INT) && (aux_MATS_read == true))) {
                  cpp_current_dict["MATS"] = var_MATS_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_MTS == SCALAR_INT) && (aux_MTS_read == true))) {
                  cpp_current_dict["MTS"] = var_MTS_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NEI == SCALAR_INT) && (aux_NEI_read == true))) {
                  cpp_current_dict["NEI"] = var_NEI_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_XMFS == SCALAR_DOUBLE) && (aux_XMFS_read == true))) {
                  cpp_current_dict["XMFS"] = var_XMFS_0d_double_Scalar;
                }
                if (((aux_last_type_read_for_XLFSS == SCALAR_DOUBLE) && (aux_XLFSS_read == true))) {
                  cpp_current_dict["XLFSS"] = var_XLFSS_0d_double_Scalar;
                }
                if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_E_1d_double_NestedVector;
                  cpp_current_dict["E"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["E"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_WE_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_WE_1d_double_NestedVector;
                  cpp_current_dict["WE"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["WE"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NI_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section ni_subsection
              {
                py::dict cpp_parent_dict = cpp_current_dict;
                if ((! cpp_parent_dict.contains("ni_subsection"))) {
                  cpp_parent_dict["ni_subsection"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict["ni_subsection"];
                if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                  cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                }
                cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                // variable declarations
                int var_LT_0d_int_Scalar;
                bool aux_LT_read = false;
                vartype aux_last_type_read_for_LT = UNKNOWN;
                int var_LB_0d_int_Scalar;
                bool aux_LB_read = false;
                vartype aux_last_type_read_for_LB = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NP_0d_int_Scalar;
                bool aux_NP_read = false;
                vartype aux_last_type_read_for_NP = UNKNOWN;
                NestedVector<double> var_Ek_1d_double_NestedVector;
                vartype aux_last_type_read_for_Ek = UNKNOWN;
                NestedVector<double> var_Fk_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fk = UNKNOWN;
                NestedVector<double> var_El_1d_double_NestedVector;
                vartype aux_last_type_read_for_El = UNKNOWN;
                NestedVector<double> var_Fl_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fl = UNKNOWN;
                int var_LS_0d_int_Scalar;
                bool aux_LS_read = false;
                vartype aux_last_type_read_for_LS = UNKNOWN;
                int var_NE_0d_int_Scalar;
                bool aux_NE_read = false;
                vartype aux_last_type_read_for_NE = UNKNOWN;
                NestedVector<double> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                Matrix2d<double> var_F_2d_double_Matrix2d;
                vartype aux_last_type_read_for_F = UNKNOWN;
                int var_NER_0d_int_Scalar;
                bool aux_NER_read = false;
                vartype aux_last_type_read_for_NER = UNKNOWN;
                int var_NEC_0d_int_Scalar;
                bool aux_NEC_read = false;
                vartype aux_last_type_read_for_NEC = UNKNOWN;
                NestedVector<double> var_ER_1d_double_NestedVector;
                vartype aux_last_type_read_for_ER = UNKNOWN;
                NestedVector<double> var_EC_1d_double_NestedVector;
                vartype aux_last_type_read_for_EC = UNKNOWN;
                NestedVector<double> var_F_1d_double_NestedVector;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                        int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                        bool& glob_aux_LT_read = aux_LT_read;
                        bool aux_LT_read = glob_aux_LT_read;
                        vartype aux_last_type_read_for_LT = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_cpp_int_val = cpp_int_val;
                        int cpp_int_val = glob_cpp_int_val;
                        bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                        bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                        int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                        bool& glob_aux_NP_read = aux_NP_read;
                        bool aux_NP_read = glob_aux_NP_read;
                        vartype aux_last_type_read_for_NP = UNKNOWN;
                        cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                        cpp_line = cpp_read_raw_line(cont);
                        // read LIST record
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)>=(0)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)<=(4)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NP",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= (var_NP_0d_int_Scalar-var_LT_0d_int_Scalar); var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable Ek
                            var_Ek_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Ek", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ek);
                            aux_last_type_read_for_Ek = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable Fk
                            var_Fk_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Fk", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fk);
                            aux_last_type_read_for_Fk = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_LT_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            // assign expression to variable El
                            var_El_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("El", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_El);
                            aux_last_type_read_for_El = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable Fl
                            var_Fl_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("Fl", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fl);
                            aux_last_type_read_for_Fl = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE-1))+1) , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                            cpp_validate_field(((var_NE_0d_int_Scalar*(var_NE_0d_int_Scalar-1))+1), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((NE*(NE-1))+1)",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = 1;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE+1))/2) , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                            cpp_validate_field(((var_NE_0d_int_Scalar*(var_NE_0d_int_Scalar+1))/2), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "((NE*(NE+1))/2)",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = var_k_0d_int_Scalar;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NER_0d_int_Scalar = var_NER_0d_int_Scalar;
                          int var_NER_0d_int_Scalar = glob_var_NER_0d_int_Scalar;
                          bool& glob_aux_NER_read = aux_NER_read;
                          bool aux_NER_read = glob_aux_NER_read;
                          vartype aux_last_type_read_for_NER = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NEC_0d_int_Scalar = var_NEC_0d_int_Scalar;
                          int var_NEC_0d_int_Scalar = glob_var_NEC_0d_int_Scalar;
                          bool& glob_aux_NEC_read = aux_NEC_read;
                          bool aux_NEC_read = glob_aux_NEC_read;
                          vartype aux_last_type_read_for_NEC = UNKNOWN;
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NEC
                          var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                          aux_NEC_read = true;
                          validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                          aux_last_type_read_for_NEC = SCALAR_INT;
                          if ((! (aux_NER_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                          } else {
                          }
                          if ((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(6)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , 0 , LB , (1+(NER*NEC)) , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NEC
                          var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                          aux_NEC_read = true;
                          validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                          aux_last_type_read_for_NEC = SCALAR_INT;
                          if ((! (aux_NER_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                          } else {
                            cpp_validate_field((1+(var_NER_0d_int_Scalar*var_NEC_0d_int_Scalar)), cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  true, false, false, "(1+(NER*NEC))",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NER_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable ER
                              var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                              aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NEC_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable EC
                              var_EC_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("EC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EC);
                              aux_last_type_read_for_EC = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NER_0d_int_Scalar-1), 1, (var_NEC_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NER_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_l_0d_int_Scalar = 1;
                                 var_l_0d_int_Scalar <= (var_NEC_0d_int_Scalar-1); var_l_0d_int_Scalar++) {
                                bool aux_l_read = true;
                                // read LIST body
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_l_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        std::streampos cpp_old_streampos = cont.tellg();
                        {
                          // variable declarations
                          int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                          int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                          bool& glob_aux_LT_read = aux_LT_read;
                          bool aux_LT_read = glob_aux_LT_read;
                          vartype aux_last_type_read_for_LT = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                          int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                          bool& glob_aux_NP_read = aux_NP_read;
                          bool aux_NP_read = glob_aux_NP_read;
                          vartype aux_last_type_read_for_NP = UNKNOWN;
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                          cpp_line = cpp_read_raw_line(cont);
                          // read LIST record
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                          if ((((((((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(8))))))||(((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(9)))))))))&&((((aux_LT_read == true)) && ((var_LT_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                          cont.seekg(cpp_old_streampos);
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST record
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                            cpp_template, cpp_line, parse_opts);
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                            cpp_validate_field(var_NP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NP",
                              cpp_template, cpp_line, parse_opts);
                          }
                          {
                            int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                              // assign expression to variable F
                              var_F_1d_double_NestedVector.set(var_k_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                              validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                        }
                      }
                    }
                  }
                }
                // store data in Python dictionary
                if (((aux_last_type_read_for_LT == SCALAR_INT) && (aux_LT_read == true))) {
                  cpp_current_dict["LT"] = var_LT_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_LB == SCALAR_INT) && (aux_LB_read == true))) {
                  cpp_current_dict["LB"] = var_LB_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NP == SCALAR_INT) && (aux_NP_read == true))) {
                  cpp_current_dict["NP"] = var_NP_0d_int_Scalar;
                }
                if ((var_Ek_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_Ek_1d_double_NestedVector;
                  cpp_current_dict["Ek"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["Ek"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_Fk_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_Fk_1d_double_NestedVector;
                  cpp_current_dict["Fk"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["Fk"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_El_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_El_1d_double_NestedVector;
                  cpp_current_dict["El"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["El"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_Fl_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_Fl_1d_double_NestedVector;
                  cpp_current_dict["Fl"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["Fl"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if (((aux_last_type_read_for_LS == SCALAR_INT) && (aux_LS_read == true))) {
                  cpp_current_dict["LS"] = var_LS_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
                  cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
                }
                if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_E_1d_double_NestedVector;
                  cpp_current_dict["E"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["E"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if (var_F_2d_double_Matrix2d.did_read()) {
                    cpp_current_dict["F"] = py::dict();
                    py::dict cpp_curdict0 = cpp_current_dict["F"];
                    for (int cpp_i1 = var_F_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_F_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
                      cpp_curdict0[py::cast(cpp_i1)] = py::dict();
                      py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
                      for (int cpp_i2 = var_F_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_F_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
                        cpp_curdict1[py::cast(cpp_i2)] = var_F_2d_double_Matrix2d(cpp_i1, cpp_i2);
                      }
                    }
                }
                if (((aux_last_type_read_for_NER == SCALAR_INT) && (aux_NER_read == true))) {
                  cpp_current_dict["NER"] = var_NER_0d_int_Scalar;
                }
                if (((aux_last_type_read_for_NEC == SCALAR_INT) && (aux_NEC_read == true))) {
                  cpp_current_dict["NEC"] = var_NEC_0d_int_Scalar;
                }
                if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_ER_1d_double_NestedVector;
                  cpp_current_dict["ER"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["ER"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_EC_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_EC_1d_double_NestedVector;
                  cpp_current_dict["EC"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["EC"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                if ((var_F_1d_double_NestedVector.get_last_index() != -1)) {
                  auto& cpp_curvar0 = var_F_1d_double_NestedVector;
                  cpp_current_dict["F"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["F"];
                  for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                  }
                }
                cpp_current_dict = cpp_parent_dict;
              }
            }
            // store data in Python dictionary
            if (((aux_last_type_read_for_XMF1 == SCALAR_DOUBLE) && (aux_XMF1_read == true))) {
              cpp_current_dict["XMF1"] = var_XMF1_0d_double_Scalar;
            }
            if (((aux_last_type_read_for_XLFS1 == SCALAR_DOUBLE) && (aux_XLFS1_read == true))) {
              cpp_current_dict["XLFS1"] = var_XLFS1_0d_double_Scalar;
            }
            if (((aux_last_type_read_for_MAT1 == SCALAR_INT) && (aux_MAT1_read == true))) {
              cpp_current_dict["MAT1"] = var_MAT1_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_MT1 == SCALAR_INT) && (aux_MT1_read == true))) {
              cpp_current_dict["MT1"] = var_MT1_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
              cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
            }
            if (((aux_last_type_read_for_NI == SCALAR_INT) && (aux_NI_read == true))) {
              cpp_current_dict["NI"] = var_NI_0d_int_Scalar;
            }
            cpp_current_dict = cpp_parent_dict;
          }
        }
      }
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_MTL == SCALAR_INT) && (aux_MTL_read == true))) {
    cpp_current_dict["MTL"] = var_MTL_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NL == SCALAR_INT) && (aux_NL_read == true))) {
    cpp_current_dict["NL"] = var_NL_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 8421256b750ec19b722b38ddb32ece21
// MD5 hash of the following function definition: 1148450a02ac40561bcc45c4398b4d27
py::dict parse_mf34_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LTT_0d_int_Scalar;
  bool aux_LTT_read = false;
  vartype aux_last_type_read_for_LTT = UNKNOWN;
  int var_NMT1_0d_int_Scalar;
  bool aux_NMT1_read = false;
  vartype aux_last_type_read_for_NMT1 = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 34;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 34;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 34 , MT / ZA , AWR , 0 , LTT , 0 , NMT1 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable LTT
  var_LTT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
  aux_LTT_read = true;
  validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
  aux_last_type_read_for_LTT = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NMT1
  var_NMT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
  aux_NMT1_read = true;
  validate_vartype_consistency("NMT1", SCALAR_INT, aux_last_type_read_for_NMT1);
  aux_last_type_read_for_NMT1 = SCALAR_INT;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NMT1_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      if ((! cpp_parent_dict.contains("subsection"))) {
        cpp_parent_dict["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      int var_MAT1_0d_int_Scalar;
      bool aux_MAT1_read = false;
      vartype aux_last_type_read_for_MAT1 = UNKNOWN;
      int var_MT1_0d_int_Scalar;
      bool aux_MT1_read = false;
      vartype aux_last_type_read_for_MT1 = UNKNOWN;
      int var_NL_0d_int_Scalar;
      bool aux_NL_read = false;
      vartype aux_last_type_read_for_NL = UNKNOWN;
      NestedVector<int> var_L_1d_int_NestedVector;
      vartype aux_last_type_read_for_L = UNKNOWN;
      NestedVector<int> var_L1_1d_int_NestedVector;
      vartype aux_last_type_read_for_L1 = UNKNOWN;
      int var_LCT_0d_int_Scalar;
      bool aux_LCT_read = false;
      vartype aux_last_type_read_for_LCT = UNKNOWN;
      NestedVector<int> var_NI_1d_int_NestedVector;
      vartype aux_last_type_read_for_NI = UNKNOWN;
      NestedVector<NestedVector<int>> var_LS_2d_int_NestedVector;
      NestedVector<int>* ptr_LS_2d_idx0;
      vartype aux_last_type_read_for_LS = UNKNOWN;
      NestedVector<NestedVector<int>> var_LB_2d_int_NestedVector;
      NestedVector<int>* ptr_LB_2d_idx0;
      vartype aux_last_type_read_for_LB = UNKNOWN;
      NestedVector<NestedVector<int>> var_NT_2d_int_NestedVector;
      NestedVector<int>* ptr_NT_2d_idx0;
      vartype aux_last_type_read_for_NT = UNKNOWN;
      NestedVector<NestedVector<int>> var_NE_2d_int_NestedVector;
      NestedVector<int>* ptr_NE_2d_idx0;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      NestedVector<NestedVector<NestedVector<double>>> var_Data_3d_double_NestedVector;
      NestedVector<double>* ptr_Data_3d_idx1;
      NestedVector<NestedVector<double>>* ptr_Data_3d_idx0;
      vartype aux_last_type_read_for_Data = UNKNOWN;
      int var_NL1_0d_int_Scalar;
      bool aux_NL1_read = false;
      vartype aux_last_type_read_for_NL1 = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            std::streampos cpp_old_streampos = cont.tellg();
            {
              // variable declarations
              int& glob_var_MAT1_0d_int_Scalar = var_MAT1_0d_int_Scalar;
              int var_MAT1_0d_int_Scalar = glob_var_MAT1_0d_int_Scalar;
              bool& glob_aux_MAT1_read = aux_MAT1_read;
              bool aux_MAT1_read = glob_aux_MAT1_read;
              vartype aux_last_type_read_for_MAT1 = UNKNOWN;
              int& glob_var_MT1_0d_int_Scalar = var_MT1_0d_int_Scalar;
              int var_MT1_0d_int_Scalar = glob_var_MT1_0d_int_Scalar;
              bool& glob_aux_MT1_read = aux_MT1_read;
              bool aux_MT1_read = glob_aux_MT1_read;
              vartype aux_last_type_read_for_MT1 = UNKNOWN;
              int& glob_var_NL_0d_int_Scalar = var_NL_0d_int_Scalar;
              int var_NL_0d_int_Scalar = glob_var_NL_0d_int_Scalar;
              bool& glob_aux_NL_read = aux_NL_read;
              bool aux_NL_read = glob_aux_NL_read;
              vartype aux_last_type_read_for_NL = UNKNOWN;
              cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , MAT1 , MT1 , NL , NL ] CONT";
              cpp_line = cpp_read_raw_line(cont);
              // read CONT record
              // assign expression to variable MAT1
              var_MAT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_MAT1_read = true;
              validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
              aux_last_type_read_for_MAT1 = SCALAR_INT;
              // assign expression to variable MT1
              var_MT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_MT1_read = true;
              validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
              aux_last_type_read_for_MT1 = SCALAR_INT;
              // assign expression to variable NL
              var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_NL_read = true;
              validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
              aux_last_type_read_for_NL = SCALAR_INT;
              if ((! (aux_NL_read == true))) {
                // assign expression to variable NL
                var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                aux_NL_read = true;
                validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = SCALAR_INT;
              } else {
              }
              if (((((((((aux_MT1_read == true)) && ((var_MT1_0d_int_Scalar)==(0))))))||(((((aux_MT_read == true)) && ((var_MT_0d_int_Scalar)==(var_MT1_0d_int_Scalar)))))))) {
                cpp_found_match = true;
              }
              cont.seekg(cpp_old_streampos);
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , MAT1 , MT1 , NL , NL ] CONT";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read CONT record
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable MAT1
              var_MAT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_MAT1_read = true;
              validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
              aux_last_type_read_for_MAT1 = SCALAR_INT;
              // assign expression to variable MT1
              var_MT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_MT1_read = true;
              validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
              aux_last_type_read_for_MT1 = SCALAR_INT;
              // assign expression to variable NL
              var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_NL_read = true;
              validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
              aux_last_type_read_for_NL = SCALAR_INT;
              if ((! (aux_NL_read == true))) {
                // assign expression to variable NL
                var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                aux_NL_read = true;
                validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = SCALAR_INT;
              } else {
                cpp_validate_field(var_NL_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NL",
                  cpp_template, cpp_line, parse_opts);
              }

              for (int var_n_0d_int_Scalar = 1;
                 var_n_0d_int_Scalar <= ((var_NL_0d_int_Scalar*(var_NL_0d_int_Scalar+1))/2); var_n_0d_int_Scalar++) {
                bool aux_n_read = true;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if ((((((((aux_n_read == true)) && ((var_n_0d_int_Scalar)==(1)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , LCT , NI ] CONT";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read CONT record
                      cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable L
                      var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
                      validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                      aux_last_type_read_for_L = NESTEDVECTOR_INT;
                      // assign expression to variable L1
                      var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
                      validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                      aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                      // assign expression to variable LCT
                      var_LCT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_LCT_read = true;
                      validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
                      aux_last_type_read_for_LCT = SCALAR_INT;
                      // assign expression to variable NI
                      var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                      validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                      aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                    }
                  }
                  if (! cpp_found_match) {
                    cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , 0 , NI ] CONT";
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read CONT record
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable L
                    var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
                    validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                    aux_last_type_read_for_L = NESTEDVECTOR_INT;
                    // assign expression to variable L1
                    var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
                    validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                    aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                    cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                      cpp_template, cpp_line, parse_opts);
                    // assign expression to variable NI
                    var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                    validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                    aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                  }
                }
                ptr_LS_2d_idx0 = var_LS_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                ptr_LB_2d_idx0 = var_LB_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                ptr_NE_2d_idx0 = var_NE_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                ptr_Data_3d_idx0 = var_Data_3d_double_NestedVector.prepare(var_n_0d_int_Scalar);

                for (int var_m_0d_int_Scalar = 1;
                   var_m_0d_int_Scalar <= var_NI_1d_int_NestedVector[var_n_0d_int_Scalar]; var_m_0d_int_Scalar++) {
                  bool aux_m_read = true;
                  cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { Data } { q = 1 to NT } ] LIST";
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read LIST record
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable LS
                  ptr_LS_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
                  validate_vartype_consistency("LS", NESTEDVECTOR_INT, aux_last_type_read_for_LS);
                  aux_last_type_read_for_LS = NESTEDVECTOR_INT;
                  // assign expression to variable LB
                  ptr_LB_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
                  validate_vartype_consistency("LB", NESTEDVECTOR_INT, aux_last_type_read_for_LB);
                  aux_last_type_read_for_LB = NESTEDVECTOR_INT;
                  // assign expression to variable NT
                  ptr_NT_2d_idx0 = var_NT_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                  ptr_NT_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
                  validate_vartype_consistency("NT", NESTEDVECTOR_INT, aux_last_type_read_for_NT);
                  aux_last_type_read_for_NT = NESTEDVECTOR_INT;
                  // assign expression to variable NE
                  ptr_NE_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                  validate_vartype_consistency("NE", NESTEDVECTOR_INT, aux_last_type_read_for_NE);
                  aux_last_type_read_for_NE = NESTEDVECTOR_INT;
                  {
                    int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                    int cpp_i = 0;
                    int cpp_j = 0;
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    // read LIST body
                    ptr_Data_3d_idx1 = ptr_Data_3d_idx0->prepare(var_m_0d_int_Scalar);

                    for (int var_q_0d_int_Scalar = 1;
                       var_q_0d_int_Scalar <= var_NT_2d_int_NestedVector[var_n_0d_int_Scalar][var_m_0d_int_Scalar]; var_q_0d_int_Scalar++) {
                      bool aux_q_read = true;
                      // read LIST body
                      // assign expression to variable Data
                      ptr_Data_3d_idx1->set(var_q_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                      validate_vartype_consistency("Data", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Data);
                      aux_last_type_read_for_Data = NESTEDVECTOR_DOUBLE;
                      cpp_i++;
                      cpp_j++;
                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        cpp_j = 0;
                      }
                    }
                    if (cpp_i != cpp_npl) {
                      throw std::runtime_error("not exactly NPL elements consumed");
                    }
                  }
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , MAT1 , MT1 , NL , NL1 ] CONT";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
            cpp_template, cpp_line, parse_opts);
          // assign expression to variable MAT1
          var_MAT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_MAT1_read = true;
          validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
          aux_last_type_read_for_MAT1 = SCALAR_INT;
          // assign expression to variable MT1
          var_MT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_MT1_read = true;
          validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
          aux_last_type_read_for_MT1 = SCALAR_INT;
          // assign expression to variable NL
          var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NL_read = true;
          validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
          aux_last_type_read_for_NL = SCALAR_INT;
          // assign expression to variable NL1
          var_NL1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NL1_read = true;
          validate_vartype_consistency("NL1", SCALAR_INT, aux_last_type_read_for_NL1);
          aux_last_type_read_for_NL1 = SCALAR_INT;

          for (int var_n_0d_int_Scalar = 1;
             var_n_0d_int_Scalar <= (var_NL_0d_int_Scalar*var_NL1_0d_int_Scalar); var_n_0d_int_Scalar++) {
            bool aux_n_read = true;
            // evaluate if-elif-else clause
            {
              bool cpp_found_match = false;
              if (! cpp_found_match) {
                if ((((((((aux_n_read == true)) && ((var_n_0d_int_Scalar)==(1)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , LCT , NI ] CONT";
                  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                  // read CONT record
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                    cpp_template, cpp_line, parse_opts);
                  // assign expression to variable L
                  var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
                  validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                  aux_last_type_read_for_L = NESTEDVECTOR_INT;
                  // assign expression to variable L1
                  var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
                  validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                  aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                  // assign expression to variable LCT
                  var_LCT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                  aux_LCT_read = true;
                  validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
                  aux_last_type_read_for_LCT = SCALAR_INT;
                  // assign expression to variable NI
                  var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                  validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                  aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                }
              }
              if (! cpp_found_match) {
                cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , 0 , NI ] CONT";
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read CONT record
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable L
                var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
                validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                aux_last_type_read_for_L = NESTEDVECTOR_INT;
                // assign expression to variable L1
                var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
                validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                  cpp_template, cpp_line, parse_opts);
                // assign expression to variable NI
                var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
                validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                aux_last_type_read_for_NI = NESTEDVECTOR_INT;
              }
            }
            ptr_LS_2d_idx0 = var_LS_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
            ptr_LB_2d_idx0 = var_LB_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
            ptr_NE_2d_idx0 = var_NE_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
            ptr_Data_3d_idx0 = var_Data_3d_double_NestedVector.prepare(var_n_0d_int_Scalar);

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NI_1d_int_NestedVector[var_n_0d_int_Scalar]; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { Data } { q = 1 to NT } ] LIST";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST record
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                cpp_template, cpp_line, parse_opts);
              // assign expression to variable LS
              ptr_LS_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts));
              validate_vartype_consistency("LS", NESTEDVECTOR_INT, aux_last_type_read_for_LS);
              aux_last_type_read_for_LS = NESTEDVECTOR_INT;
              // assign expression to variable LB
              ptr_LB_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts));
              validate_vartype_consistency("LB", NESTEDVECTOR_INT, aux_last_type_read_for_LB);
              aux_last_type_read_for_LB = NESTEDVECTOR_INT;
              // assign expression to variable NT
              ptr_NT_2d_idx0 = var_NT_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
              ptr_NT_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts));
              validate_vartype_consistency("NT", NESTEDVECTOR_INT, aux_last_type_read_for_NT);
              aux_last_type_read_for_NT = NESTEDVECTOR_INT;
              // assign expression to variable NE
              ptr_NE_2d_idx0->set(var_m_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts));
              validate_vartype_consistency("NE", NESTEDVECTOR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = NESTEDVECTOR_INT;
              {
                int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST body
                ptr_Data_3d_idx1 = ptr_Data_3d_idx0->prepare(var_m_0d_int_Scalar);

                for (int var_q_0d_int_Scalar = 1;
                   var_q_0d_int_Scalar <= var_NT_2d_int_NestedVector[var_n_0d_int_Scalar][var_m_0d_int_Scalar]; var_q_0d_int_Scalar++) {
                  bool aux_q_read = true;
                  // read LIST body
                  // assign expression to variable Data
                  ptr_Data_3d_idx1->set(var_q_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                  validate_vartype_consistency("Data", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Data);
                  aux_last_type_read_for_Data = NESTEDVECTOR_DOUBLE;
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
            }
          }
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_MAT1 == SCALAR_INT) && (aux_MAT1_read == true))) {
        cpp_current_dict["MAT1"] = var_MAT1_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_MT1 == SCALAR_INT) && (aux_MT1_read == true))) {
        cpp_current_dict["MT1"] = var_MT1_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NL == SCALAR_INT) && (aux_NL_read == true))) {
        cpp_current_dict["NL"] = var_NL_0d_int_Scalar;
      }
      if ((var_L_1d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_L_1d_int_NestedVector;
        cpp_current_dict["L"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["L"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if ((var_L1_1d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_L1_1d_int_NestedVector;
        cpp_current_dict["L1"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["L1"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if (((aux_last_type_read_for_LCT == SCALAR_INT) && (aux_LCT_read == true))) {
        cpp_current_dict["LCT"] = var_LCT_0d_int_Scalar;
      }
      if ((var_NI_1d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_NI_1d_int_NestedVector;
        cpp_current_dict["NI"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["NI"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if ((var_LS_2d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_LS_2d_int_NestedVector;
        cpp_current_dict["LS"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["LS"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
          cpp_curdict0[py::cast(cpp_i1)] = py::dict();
          py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
          for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
            cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
          }
        }
      }
      if ((var_LB_2d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_LB_2d_int_NestedVector;
        cpp_current_dict["LB"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["LB"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
          cpp_curdict0[py::cast(cpp_i1)] = py::dict();
          py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
          for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
            cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
          }
        }
      }
      if ((var_NT_2d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_NT_2d_int_NestedVector;
        cpp_current_dict["NT"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["NT"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
          cpp_curdict0[py::cast(cpp_i1)] = py::dict();
          py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
          for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
            cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
          }
        }
      }
      if ((var_NE_2d_int_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_NE_2d_int_NestedVector;
        cpp_current_dict["NE"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["NE"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
          cpp_curdict0[py::cast(cpp_i1)] = py::dict();
          py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
          for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
            cpp_curdict1[py::cast(cpp_i2)] = cpp_curvar1[cpp_i2];
          }
        }
      }
      if ((var_Data_3d_double_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_Data_3d_double_NestedVector;
        cpp_current_dict["Data"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["Data"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          auto& cpp_curvar1 = cpp_curvar0[cpp_i1];
          cpp_curdict0[py::cast(cpp_i1)] = py::dict();
          py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
          for (int cpp_i2 = cpp_curvar1.get_start_index(); cpp_i2 <= cpp_curvar1.get_last_index(); cpp_i2++) {
            auto& cpp_curvar2 = cpp_curvar1[cpp_i2];
            cpp_curdict1[py::cast(cpp_i2)] = py::dict();
            py::dict cpp_curdict2 = cpp_curdict1[py::cast(cpp_i2)];
            for (int cpp_i3 = cpp_curvar2.get_start_index(); cpp_i3 <= cpp_curvar2.get_last_index(); cpp_i3++) {
              cpp_curdict2[py::cast(cpp_i3)] = cpp_curvar2[cpp_i3];
            }
          }
        }
      }
      if (((aux_last_type_read_for_NL1 == SCALAR_INT) && (aux_NL1_read == true))) {
        cpp_current_dict["NL1"] = var_NL1_0d_int_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LTT == SCALAR_INT) && (aux_LTT_read == true))) {
    cpp_current_dict["LTT"] = var_LTT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NMT1 == SCALAR_INT) && (aux_NMT1_read == true))) {
    cpp_current_dict["NMT1"] = var_NMT1_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: ef5fac1c99989a26cffcf79262c5c69c
// MD5 hash of the following function definition: 9dc95a3f7c6dc60b1ffe1c3c9bd3d6a7
py::dict parse_mf35_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 35;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 35;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 35 , MT / ZA , AWR , 0 , 0 , NK , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      if ((! cpp_parent_dict.contains("subsection"))) {
        cpp_parent_dict["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      double var_E1_0d_double_Scalar;
      bool aux_E1_read = false;
      vartype aux_last_type_read_for_E1 = UNKNOWN;
      double var_E2_0d_double_Scalar;
      bool aux_E2_read = false;
      vartype aux_last_type_read_for_E2 = UNKNOWN;
      int var_LS_0d_int_Scalar;
      bool aux_LS_read = false;
      vartype aux_last_type_read_for_LS = UNKNOWN;
      int var_LB_0d_int_Scalar;
      bool aux_LB_read = false;
      vartype aux_last_type_read_for_LB = UNKNOWN;
      int var_NT_0d_int_Scalar;
      bool aux_NT_read = false;
      vartype aux_last_type_read_for_NT = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      NestedVector<double> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      Matrix2d<double> var_F_2d_double_Matrix2d;
      vartype aux_last_type_read_for_F = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            std::streampos cpp_old_streampos = cont.tellg();
            {
              // variable declarations
              double& glob_var_E1_0d_double_Scalar = var_E1_0d_double_Scalar;
              double var_E1_0d_double_Scalar = glob_var_E1_0d_double_Scalar;
              bool& glob_aux_E1_read = aux_E1_read;
              bool aux_E1_read = glob_aux_E1_read;
              vartype aux_last_type_read_for_E1 = UNKNOWN;
              double& glob_var_E2_0d_double_Scalar = var_E2_0d_double_Scalar;
              double var_E2_0d_double_Scalar = glob_var_E2_0d_double_Scalar;
              bool& glob_aux_E2_read = aux_E2_read;
              bool aux_E2_read = glob_aux_E2_read;
              vartype aux_last_type_read_for_E2 = UNKNOWN;
              int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
              int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
              bool& glob_aux_LS_read = aux_LS_read;
              bool aux_LS_read = glob_aux_LS_read;
              vartype aux_last_type_read_for_LS = UNKNOWN;
              int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
              int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
              bool& glob_aux_LB_read = aux_LB_read;
              bool aux_LB_read = glob_aux_LB_read;
              vartype aux_last_type_read_for_LB = UNKNOWN;
              int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
              int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
              bool& glob_aux_NT_read = aux_NT_read;
              bool aux_NT_read = glob_aux_NT_read;
              vartype aux_last_type_read_for_NT = UNKNOWN;
              int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
              int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
              bool& glob_aux_NE_read = aux_NE_read;
              bool aux_NE_read = glob_aux_NE_read;
              vartype aux_last_type_read_for_NE = UNKNOWN;
              cpp_template = "[ MAT , 35 , MT / E1 , E2 , LS , LB , NT , NE / \n { E } { i = 1 to NE } , { { F } { j = i to (NE-1) } } { i = 1 to (NE-1) } ] LIST";
              cpp_line = cpp_read_raw_line(cont);
              // read LIST record
              // assign expression to variable E1
              var_E1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
              aux_E1_read = true;
              validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
              aux_last_type_read_for_E1 = SCALAR_DOUBLE;
              // assign expression to variable E2
              var_E2_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
              aux_E2_read = true;
              validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
              aux_last_type_read_for_E2 = SCALAR_DOUBLE;
              // assign expression to variable LS
              var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LS_read = true;
              validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
              aux_last_type_read_for_LS = SCALAR_INT;
              // assign expression to variable LB
              var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LB_read = true;
              validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
              aux_last_type_read_for_LB = SCALAR_INT;
              // assign expression to variable NT
              var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_NT_read = true;
              validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
              aux_last_type_read_for_NT = SCALAR_INT;
              // assign expression to variable NE
              var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              if (((((((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(7)))))))) {
                cpp_found_match = true;
              }
              cont.seekg(cpp_old_streampos);
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 35 , MT / E1 , E2 , LS , LB , NT , NE / \n { E } { i = 1 to NE } , { { F } { j = i to (NE-1) } } { i = 1 to (NE-1) } ] LIST";
              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
              // read LIST record
              // assign expression to variable E1
              var_E1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
              aux_E1_read = true;
              validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
              aux_last_type_read_for_E1 = SCALAR_DOUBLE;
              // assign expression to variable E2
              var_E2_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
              aux_E2_read = true;
              validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
              aux_last_type_read_for_E2 = SCALAR_DOUBLE;
              // assign expression to variable LS
              var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
              aux_LS_read = true;
              validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
              aux_last_type_read_for_LS = SCALAR_INT;
              // assign expression to variable LB
              var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
              aux_LB_read = true;
              validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
              aux_last_type_read_for_LB = SCALAR_INT;
              // assign expression to variable NT
              var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
              aux_NT_read = true;
              validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
              aux_last_type_read_for_NT = SCALAR_INT;
              // assign expression to variable NE
              var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              {
                int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                // read LIST body

                for (int var_i_0d_int_Scalar = 1;
                   var_i_0d_int_Scalar <= var_NE_0d_int_Scalar; var_i_0d_int_Scalar++) {
                  bool aux_i_read = true;
                  // read LIST body
                  // assign expression to variable E
                  var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                  validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                    cpp_j = 0;
                  }
                }
                var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                for (int var_i_0d_int_Scalar = 1;
                   var_i_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_i_0d_int_Scalar++) {
                  bool aux_i_read = true;
                  // read LIST body

                  for (int var_j_0d_int_Scalar = var_i_0d_int_Scalar;
                     var_j_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_j_0d_int_Scalar++) {
                    bool aux_j_read = true;
                    // read LIST body
                    // assign expression to variable F
                    var_F_2d_double_Matrix2d(var_i_0d_int_Scalar, var_j_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                    validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                    aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      cpp_j = 0;
                    }
                  }
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
            }
          }
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_E1 == SCALAR_DOUBLE) && (aux_E1_read == true))) {
        cpp_current_dict["E1"] = var_E1_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_E2 == SCALAR_DOUBLE) && (aux_E2_read == true))) {
        cpp_current_dict["E2"] = var_E2_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_LS == SCALAR_INT) && (aux_LS_read == true))) {
        cpp_current_dict["LS"] = var_LS_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LB == SCALAR_INT) && (aux_LB_read == true))) {
        cpp_current_dict["LB"] = var_LB_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NT == SCALAR_INT) && (aux_NT_read == true))) {
        cpp_current_dict["NT"] = var_NT_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
        cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
      }
      if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
        auto& cpp_curvar0 = var_E_1d_double_NestedVector;
        cpp_current_dict["E"] = py::dict();
        py::dict cpp_curdict0 = cpp_current_dict["E"];
        for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
          cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
        }
      }
      if (var_F_2d_double_Matrix2d.did_read()) {
          cpp_current_dict["F"] = py::dict();
          py::dict cpp_curdict0 = cpp_current_dict["F"];
          for (int cpp_i1 = var_F_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_F_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
            cpp_curdict0[py::cast(cpp_i1)] = py::dict();
            py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
            for (int cpp_i2 = var_F_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_F_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
              cpp_curdict1[py::cast(cpp_i2)] = var_F_2d_double_Matrix2d(cpp_i1, cpp_i2);
            }
          }
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_NK == SCALAR_INT) && (aux_NK_read == true))) {
    cpp_current_dict["NK"] = var_NK_0d_int_Scalar;
  }
  return cpp_current_dict;
}


// MD5 hash of ENDF recipe underlying the following function: 9762b69b4ad00343103fe284b177ae48
// MD5 hash of the following function definition: eea7dc32e2c4df128b6baf517b8e54ba
py::dict parse_mf40_istream(
  std::istream& cont, ParsingOptions &parse_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;  py::dict cpp_parent_dict;
  py::dict cpp_current_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  std::streampos cpp_startpos = cont.tellg();
  std::string cpp_temp_line;
  cpp_temp_line = cpp_read_raw_line(cont);
  int mat = cpp_read_mat_number(cpp_temp_line.c_str());
  int mf = 40;
  int mt = cpp_read_mt_number(cpp_temp_line.c_str());
  cont.seekg(cpp_startpos);
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = cpp_read_mat_number(cpp_temp_line.c_str());
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 40;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = cpp_read_mt_number(cpp_temp_line.c_str());
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  // store variable MAT in endf dictionary
  cpp_current_dict[py::cast("MAT")] = var_MAT_0d_int_Scalar;
  // store variable MF in endf dictionary
  cpp_current_dict[py::cast("MF")] = var_MF_0d_int_Scalar;
  // store variable MT in endf dictionary
  cpp_current_dict[py::cast("MT")] = var_MT_0d_int_Scalar;
  std::string cpp_line;
  cpp_template = "[ MAT , 40 , MT / ZA , AWR , LIS , 0 , NS , 0 ] HEAD";
  cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
  // read CONT record
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
    cpp_template, cpp_line, parse_opts);

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict = cpp_current_dict;
      if ((! cpp_parent_dict.contains("subsection"))) {
        cpp_parent_dict["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      double var_QM_0d_double_Scalar;
      bool aux_QM_read = false;
      vartype aux_last_type_read_for_QM = UNKNOWN;
      double var_QI_0d_double_Scalar;
      bool aux_QI_read = false;
      vartype aux_last_type_read_for_QI = UNKNOWN;
      int var_IZAP_0d_int_Scalar;
      bool aux_IZAP_read = false;
      vartype aux_last_type_read_for_IZAP = UNKNOWN;
      int var_LFS_0d_int_Scalar;
      bool aux_LFS_read = false;
      vartype aux_last_type_read_for_LFS = UNKNOWN;
      int var_NL_0d_int_Scalar;
      bool aux_NL_read = false;
      vartype aux_last_type_read_for_NL = UNKNOWN;
      cpp_template = "[ MAT , 40 , MT / QM , QI , IZAP , LFS , 0 , NL ] CONT";
      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
      // read CONT record
      // assign expression to variable QM
      var_QM_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
      aux_QM_read = true;
      validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
      aux_last_type_read_for_QM = SCALAR_DOUBLE;
      // assign expression to variable QI
      var_QI_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
      aux_QI_read = true;
      validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
      aux_last_type_read_for_QI = SCALAR_DOUBLE;
      // assign expression to variable IZAP
      var_IZAP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
      aux_IZAP_read = true;
      validate_vartype_consistency("IZAP", SCALAR_INT, aux_last_type_read_for_IZAP);
      aux_last_type_read_for_IZAP = SCALAR_INT;
      // assign expression to variable LFS
      var_LFS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
      aux_LFS_read = true;
      validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
      aux_last_type_read_for_LFS = SCALAR_INT;
      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
        cpp_template, cpp_line, parse_opts);
      // assign expression to variable NL
      var_NL_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
      aux_NL_read = true;
      validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
      aux_last_type_read_for_NL = SCALAR_INT;

      for (int var_i_0d_int_Scalar = 1;
         var_i_0d_int_Scalar <= var_NL_0d_int_Scalar; var_i_0d_int_Scalar++) {
        bool aux_i_read = true;
        // open section subsubsec
        {
          py::dict cpp_parent_dict = cpp_current_dict;
          if ((! cpp_parent_dict.contains("subsubsec"))) {
            cpp_parent_dict["subsubsec"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict["subsubsec"];
          if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
            cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
          }
          cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
          // variable declarations
          double var_XMF1_0d_double_Scalar;
          bool aux_XMF1_read = false;
          vartype aux_last_type_read_for_XMF1 = UNKNOWN;
          double var_XLFS1_0d_double_Scalar;
          bool aux_XLFS1_read = false;
          vartype aux_last_type_read_for_XLFS1 = UNKNOWN;
          int var_MAT1_0d_int_Scalar;
          bool aux_MAT1_read = false;
          vartype aux_last_type_read_for_MAT1 = UNKNOWN;
          int var_MT1_0d_int_Scalar;
          bool aux_MT1_read = false;
          vartype aux_last_type_read_for_MT1 = UNKNOWN;
          int var_NC_0d_int_Scalar;
          bool aux_NC_read = false;
          vartype aux_last_type_read_for_NC = UNKNOWN;
          int var_NI_0d_int_Scalar;
          bool aux_NI_read = false;
          vartype aux_last_type_read_for_NI = UNKNOWN;
          cpp_template = "[ MAT , 40 , MT / XMF1 , XLFS1 , MAT1 , MT1 , NC , NI ] CONT";
          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
          // read CONT record
          // assign expression to variable XMF1
          var_XMF1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
          aux_XMF1_read = true;
          validate_vartype_consistency("XMF1", SCALAR_DOUBLE, aux_last_type_read_for_XMF1);
          aux_last_type_read_for_XMF1 = SCALAR_DOUBLE;
          // assign expression to variable XLFS1
          var_XLFS1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
          aux_XLFS1_read = true;
          validate_vartype_consistency("XLFS1", SCALAR_DOUBLE, aux_last_type_read_for_XLFS1);
          aux_last_type_read_for_XLFS1 = SCALAR_DOUBLE;
          // assign expression to variable MAT1
          var_MAT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
          aux_MAT1_read = true;
          validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
          aux_last_type_read_for_MAT1 = SCALAR_INT;
          // assign expression to variable MT1
          var_MT1_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
          aux_MT1_read = true;
          validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
          aux_last_type_read_for_MT1 = SCALAR_INT;
          // assign expression to variable NC
          var_NC_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
          aux_NC_read = true;
          validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
          aux_last_type_read_for_NC = SCALAR_INT;
          // assign expression to variable NI
          var_NI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
          aux_NI_read = true;
          validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
          aux_last_type_read_for_NI = SCALAR_INT;

          for (int var_j_0d_int_Scalar = 1;
             var_j_0d_int_Scalar <= var_NC_0d_int_Scalar; var_j_0d_int_Scalar++) {
            bool aux_j_read = true;
            // open section nc_subsubsubsec
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              if ((! cpp_parent_dict.contains("nc_subsubsubsec"))) {
                cpp_parent_dict["nc_subsubsubsec"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict["nc_subsubsubsec"];
              if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
              // variable declarations
              int var_LTY_0d_int_Scalar;
              bool aux_LTY_read = false;
              vartype aux_last_type_read_for_LTY = UNKNOWN;
              double var_E1_0d_double_Scalar;
              bool aux_E1_read = false;
              vartype aux_last_type_read_for_E1 = UNKNOWN;
              double var_E2_0d_double_Scalar;
              bool aux_E2_read = false;
              vartype aux_last_type_read_for_E2 = UNKNOWN;
              int cpp_int_val;
              bool aux_cpp_int_val_read = false;
              vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
              int var_NCI_0d_int_Scalar;
              bool aux_NCI_read = false;
              vartype aux_last_type_read_for_NCI = UNKNOWN;
              NestedVector<double> var_C_1d_double_NestedVector;
              vartype aux_last_type_read_for_C = UNKNOWN;
              NestedVector<double> var_XMT_1d_double_NestedVector;
              vartype aux_last_type_read_for_XMT = UNKNOWN;
              int var_MATS_0d_int_Scalar;
              bool aux_MATS_read = false;
              vartype aux_last_type_read_for_MATS = UNKNOWN;
              int var_MTS_0d_int_Scalar;
              bool aux_MTS_read = false;
              vartype aux_last_type_read_for_MTS = UNKNOWN;
              int var_NEI_0d_int_Scalar;
              bool aux_NEI_read = false;
              vartype aux_last_type_read_for_NEI = UNKNOWN;
              double var_XMFS_0d_double_Scalar;
              bool aux_XMFS_read = false;
              vartype aux_last_type_read_for_XMFS = UNKNOWN;
              double var_XLFSS_0d_double_Scalar;
              bool aux_XLFSS_read = false;
              vartype aux_last_type_read_for_XLFSS = UNKNOWN;
              NestedVector<double> var_E_1d_double_NestedVector;
              vartype aux_last_type_read_for_E = UNKNOWN;
              NestedVector<double> var_WE_1d_double_NestedVector;
              vartype aux_last_type_read_for_WE = UNKNOWN;
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  // if statement evaluation with lookahead
                  {
                    std::streampos cpp_old_streampos = cont.tellg();
                    {
                      // variable declarations
                      int& glob_var_LTY_0d_int_Scalar = var_LTY_0d_int_Scalar;
                      int var_LTY_0d_int_Scalar = glob_var_LTY_0d_int_Scalar;
                      bool& glob_aux_LTY_read = aux_LTY_read;
                      bool aux_LTY_read = glob_aux_LTY_read;
                      vartype aux_last_type_read_for_LTY = UNKNOWN;
                      cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                      cpp_line = cpp_read_raw_line(cont);
                      // read CONT record
                      // assign expression to variable LTY
                      var_LTY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                      aux_LTY_read = true;
                      validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                      aux_last_type_read_for_LTY = SCALAR_INT;
                      if ((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(0)))))))) {
                        cpp_found_match = true;
                      }
                      cont.seekg(cpp_old_streampos);
                    }
                    if (cpp_found_match) {
                      cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read CONT record
                      cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable LTY
                      var_LTY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                      aux_LTY_read = true;
                      validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                      aux_last_type_read_for_LTY = SCALAR_INT;
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_template = "[ MAT , 40 , MT / E1 , E2 , 0 , 0 , (2*NCI) , NCI / \n { C , XMT } { i = 1 to NCI } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      // assign expression to variable E1
                      var_E1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                      aux_E1_read = true;
                      validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                      aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                      // assign expression to variable E2
                      var_E2_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                      aux_E2_read = true;
                      validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                      aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts),  false, false, false, "0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NCI
                      var_NCI_0d_int_Scalar = (cpp_int_val/2);
                      aux_NCI_read = true;
                      validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                      aux_last_type_read_for_NCI = SCALAR_INT;
                      if ((! (aux_NCI_read == true))) {
                        // assign expression to variable NCI
                        var_NCI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NCI_read = true;
                        validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                        aux_last_type_read_for_NCI = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NCI_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NCI",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_i_0d_int_Scalar = 1;
                           var_i_0d_int_Scalar <= var_NCI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                          bool aux_i_read = true;
                          // read LIST body
                          // assign expression to variable C
                          var_C_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
                          aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable XMT
                          var_XMT_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("XMT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_XMT);
                          aux_last_type_read_for_XMT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LTY_0d_int_Scalar = var_LTY_0d_int_Scalar;
                        int var_LTY_0d_int_Scalar = glob_var_LTY_0d_int_Scalar;
                        bool& glob_aux_LTY_read = aux_LTY_read;
                        bool aux_LTY_read = glob_aux_LTY_read;
                        vartype aux_last_type_read_for_LTY = UNKNOWN;
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                        cpp_line = cpp_read_raw_line(cont);
                        // read CONT record
                        // assign expression to variable LTY
                        var_LTY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LTY_read = true;
                        validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                        aux_last_type_read_for_LTY = SCALAR_INT;
                        if ((((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(1))))))||(((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(2))))))||(((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(3)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read CONT record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LTY
                        var_LTY_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LTY_read = true;
                        validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                        aux_last_type_read_for_LTY = SCALAR_INT;
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_template = "[ MAT , 40 , MT / E1 , E2 , MATS , MTS , ((2*NEI)+2) , NEI / \n XMFS , XLFSS , { E , WE } { i = 1 to NEI } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        // assign expression to variable E1
                        var_E1_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts);
                        aux_E1_read = true;
                        validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                        aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                        // assign expression to variable E2
                        var_E2_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts);
                        aux_E2_read = true;
                        validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                        aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                        // assign expression to variable MATS
                        var_MATS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_MATS_read = true;
                        validate_vartype_consistency("MATS", SCALAR_INT, aux_last_type_read_for_MATS);
                        aux_last_type_read_for_MATS = SCALAR_INT;
                        // assign expression to variable MTS
                        var_MTS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_MTS_read = true;
                        validate_vartype_consistency("MTS", SCALAR_INT, aux_last_type_read_for_MTS);
                        aux_last_type_read_for_MTS = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NEI
                        var_NEI_0d_int_Scalar = ((cpp_int_val+(-2))/2);
                        aux_NEI_read = true;
                        validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                        aux_last_type_read_for_NEI = SCALAR_INT;
                        if ((! (aux_NEI_read == true))) {
                          // assign expression to variable NEI
                          var_NEI_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NEI_read = true;
                          validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                          aux_last_type_read_for_NEI = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NEI_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NEI",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body
                          // assign expression to variable XMFS
                          var_XMFS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                          aux_XMFS_read = true;
                          validate_vartype_consistency("XMFS", SCALAR_DOUBLE, aux_last_type_read_for_XMFS);
                          aux_last_type_read_for_XMFS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable XLFSS
                          var_XLFSS_0d_double_Scalar = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                          aux_XLFSS_read = true;
                          validate_vartype_consistency("XLFSS", SCALAR_DOUBLE, aux_last_type_read_for_XLFSS);
                          aux_last_type_read_for_XLFSS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }

                          for (int var_i_0d_int_Scalar = 1;
                             var_i_0d_int_Scalar <= var_NEI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                            bool aux_i_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable WE
                            var_WE_1d_double_NestedVector.set(var_i_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("WE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_WE);
                            aux_last_type_read_for_WE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
              }
              // store data in Python dictionary
              if (((aux_last_type_read_for_LTY == SCALAR_INT) && (aux_LTY_read == true))) {
                cpp_current_dict["LTY"] = var_LTY_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_E1 == SCALAR_DOUBLE) && (aux_E1_read == true))) {
                cpp_current_dict["E1"] = var_E1_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_E2 == SCALAR_DOUBLE) && (aux_E2_read == true))) {
                cpp_current_dict["E2"] = var_E2_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_NCI == SCALAR_INT) && (aux_NCI_read == true))) {
                cpp_current_dict["NCI"] = var_NCI_0d_int_Scalar;
              }
              if ((var_C_1d_double_NestedVector.get_last_index() != -1)) {
                auto& cpp_curvar0 = var_C_1d_double_NestedVector;
                cpp_current_dict["C"] = py::dict();
                py::dict cpp_curdict0 = cpp_current_dict["C"];
                for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                  cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                }
              }
              if ((var_XMT_1d_double_NestedVector.get_last_index() != -1)) {
                auto& cpp_curvar0 = var_XMT_1d_double_NestedVector;
                cpp_current_dict["XMT"] = py::dict();
                py::dict cpp_curdict0 = cpp_current_dict["XMT"];
                for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                  cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                }
              }
              if (((aux_last_type_read_for_MATS == SCALAR_INT) && (aux_MATS_read == true))) {
                cpp_current_dict["MATS"] = var_MATS_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_MTS == SCALAR_INT) && (aux_MTS_read == true))) {
                cpp_current_dict["MTS"] = var_MTS_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_NEI == SCALAR_INT) && (aux_NEI_read == true))) {
                cpp_current_dict["NEI"] = var_NEI_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_XMFS == SCALAR_DOUBLE) && (aux_XMFS_read == true))) {
                cpp_current_dict["XMFS"] = var_XMFS_0d_double_Scalar;
              }
              if (((aux_last_type_read_for_XLFSS == SCALAR_DOUBLE) && (aux_XLFSS_read == true))) {
                cpp_current_dict["XLFSS"] = var_XLFSS_0d_double_Scalar;
              }
              if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                auto& cpp_curvar0 = var_E_1d_double_NestedVector;
                cpp_current_dict["E"] = py::dict();
                py::dict cpp_curdict0 = cpp_current_dict["E"];
                for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                  cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                }
              }
              if ((var_WE_1d_double_NestedVector.get_last_index() != -1)) {
                auto& cpp_curvar0 = var_WE_1d_double_NestedVector;
                cpp_current_dict["WE"] = py::dict();
                py::dict cpp_curdict0 = cpp_current_dict["WE"];
                for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                  cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                }
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }

          for (int var_j_0d_int_Scalar = 1;
             var_j_0d_int_Scalar <= var_NI_0d_int_Scalar; var_j_0d_int_Scalar++) {
            bool aux_j_read = true;
            // open section ni_subsubsubsec
            {
              py::dict cpp_parent_dict = cpp_current_dict;
              if ((! cpp_parent_dict.contains("ni_subsubsubsec"))) {
                cpp_parent_dict["ni_subsubsubsec"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict["ni_subsubsubsec"];
              if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
              // variable declarations
              int var_LT_0d_int_Scalar;
              bool aux_LT_read = false;
              vartype aux_last_type_read_for_LT = UNKNOWN;
              int var_LB_0d_int_Scalar;
              bool aux_LB_read = false;
              vartype aux_last_type_read_for_LB = UNKNOWN;
              int cpp_int_val;
              bool aux_cpp_int_val_read = false;
              vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
              int var_NP_0d_int_Scalar;
              bool aux_NP_read = false;
              vartype aux_last_type_read_for_NP = UNKNOWN;
              NestedVector<double> var_Ek_1d_double_NestedVector;
              vartype aux_last_type_read_for_Ek = UNKNOWN;
              NestedVector<double> var_Fk_1d_double_NestedVector;
              vartype aux_last_type_read_for_Fk = UNKNOWN;
              NestedVector<double> var_El_1d_double_NestedVector;
              vartype aux_last_type_read_for_El = UNKNOWN;
              NestedVector<double> var_Fl_1d_double_NestedVector;
              vartype aux_last_type_read_for_Fl = UNKNOWN;
              int var_LS_0d_int_Scalar;
              bool aux_LS_read = false;
              vartype aux_last_type_read_for_LS = UNKNOWN;
              int var_NT_0d_int_Scalar;
              bool aux_NT_read = false;
              vartype aux_last_type_read_for_NT = UNKNOWN;
              int var_NE_0d_int_Scalar;
              bool aux_NE_read = false;
              vartype aux_last_type_read_for_NE = UNKNOWN;
              NestedVector<double> var_E_1d_double_NestedVector;
              vartype aux_last_type_read_for_E = UNKNOWN;
              Matrix2d<double> var_F_2d_double_Matrix2d;
              vartype aux_last_type_read_for_F = UNKNOWN;
              int var_NER_0d_int_Scalar;
              bool aux_NER_read = false;
              vartype aux_last_type_read_for_NER = UNKNOWN;
              NestedVector<double> var_ER_1d_double_NestedVector;
              vartype aux_last_type_read_for_ER = UNKNOWN;
              NestedVector<double> var_EC_1d_double_NestedVector;
              vartype aux_last_type_read_for_EC = UNKNOWN;
              NestedVector<double> var_F_1d_double_NestedVector;
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  // if statement evaluation with lookahead
                  {
                    std::streampos cpp_old_streampos = cont.tellg();
                    {
                      // variable declarations
                      int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                      int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                      bool& glob_aux_LT_read = aux_LT_read;
                      bool aux_LT_read = glob_aux_LT_read;
                      vartype aux_last_type_read_for_LT = UNKNOWN;
                      int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                      int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                      bool& glob_aux_LB_read = aux_LB_read;
                      bool aux_LB_read = glob_aux_LB_read;
                      vartype aux_last_type_read_for_LB = UNKNOWN;
                      int& glob_cpp_int_val = cpp_int_val;
                      int cpp_int_val = glob_cpp_int_val;
                      bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                      bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                      int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                      bool& glob_aux_NP_read = aux_NP_read;
                      bool aux_NP_read = glob_aux_NP_read;
                      vartype aux_last_type_read_for_NP = UNKNOWN;
                      cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { q = 1 to (NP-LT) } \n { El , Fl } { q = 1 to LT } ] LIST";
                      cpp_line = cpp_read_raw_line(cont);
                      // read LIST record
                      // assign expression to variable LT
                      var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                      aux_LT_read = true;
                      validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                      aux_last_type_read_for_LT = SCALAR_INT;
                      // assign expression to variable LB
                      var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                      aux_LB_read = true;
                      validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                      aux_last_type_read_for_LB = SCALAR_INT;
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NP
                      var_NP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NP_read = true;
                      validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                      aux_last_type_read_for_NP = SCALAR_INT;
                      if ((! (aux_NP_read == true))) {
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                      } else {
                      }
                      if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)>=(0)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)<=(4)))))))) {
                        cpp_found_match = true;
                      }
                      cont.seekg(cpp_old_streampos);
                    }
                    if (cpp_found_match) {
                      cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { q = 1 to (NP-LT) } \n { El , Fl } { q = 1 to LT } ] LIST";
                      cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                      // read LIST record
                      cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                        cpp_template, cpp_line, parse_opts);
                      // assign expression to variable LT
                      var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                      aux_LT_read = true;
                      validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                      aux_last_type_read_for_LT = SCALAR_INT;
                      // assign expression to variable LB
                      var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                      aux_LB_read = true;
                      validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                      aux_last_type_read_for_LB = SCALAR_INT;
                      // assign expression to variable cpp_int_val
                      cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NP
                      var_NP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NP_read = true;
                      validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                      aux_last_type_read_for_NP = SCALAR_INT;
                      if ((! (aux_NP_read == true))) {
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                      } else {
                        cpp_validate_field(var_NP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NP",
                          cpp_template, cpp_line, parse_opts);
                      }
                      {
                        int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST body

                        for (int var_q_0d_int_Scalar = 1;
                           var_q_0d_int_Scalar <= (var_NP_0d_int_Scalar-var_LT_0d_int_Scalar); var_q_0d_int_Scalar++) {
                          bool aux_q_read = true;
                          // read LIST body
                          // assign expression to variable Ek
                          var_Ek_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("Ek", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ek);
                          aux_last_type_read_for_Ek = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable Fk
                          var_Fk_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("Fk", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fk);
                          aux_last_type_read_for_Fk = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }

                        for (int var_q_0d_int_Scalar = 1;
                           var_q_0d_int_Scalar <= var_LT_0d_int_Scalar; var_q_0d_int_Scalar++) {
                          bool aux_q_read = true;
                          // read LIST body
                          // assign expression to variable El
                          var_El_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("El", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_El);
                          aux_last_type_read_for_El = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                          // assign expression to variable Fl
                          var_Fl_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                          validate_vartype_consistency("Fl", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fl);
                          aux_last_type_read_for_Fl = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                        int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                        bool& glob_aux_LS_read = aux_LS_read;
                        bool aux_LS_read = glob_aux_LS_read;
                        vartype aux_last_type_read_for_LS = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                        int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                        bool& glob_aux_NT_read = aux_NT_read;
                        bool aux_NT_read = glob_aux_NT_read;
                        vartype aux_last_type_read_for_NT = UNKNOWN;
                        int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                        int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                        bool& glob_aux_NE_read = aux_NE_read;
                        bool aux_NE_read = glob_aux_NE_read;
                        vartype aux_last_type_read_for_NE = UNKNOWN;
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = 1 to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                        cpp_line = cpp_read_raw_line(cont);
                        // read LIST record
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(0)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = 1 to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NE_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), false, false);

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body

                            for (int var_qp_0d_int_Scalar = 1;
                               var_qp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_qp_0d_int_Scalar++) {
                              bool aux_qp_read = true;
                              // read LIST body
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_q_0d_int_Scalar, var_qp_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                        int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                        bool& glob_aux_LS_read = aux_LS_read;
                        bool aux_LS_read = glob_aux_LS_read;
                        vartype aux_last_type_read_for_LS = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                        int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                        bool& glob_aux_NT_read = aux_NT_read;
                        bool aux_NT_read = glob_aux_NT_read;
                        vartype aux_last_type_read_for_NT = UNKNOWN;
                        int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                        int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                        bool& glob_aux_NE_read = aux_NE_read;
                        bool aux_NE_read = glob_aux_NE_read;
                        vartype aux_last_type_read_for_NE = UNKNOWN;
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = q to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                        cpp_line = cpp_read_raw_line(cont);
                        // read LIST record
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = q to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NE_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body

                            for (int var_qp_0d_int_Scalar = var_q_0d_int_Scalar;
                               var_qp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_qp_0d_int_Scalar++) {
                              bool aux_qp_read = true;
                              // read LIST body
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_q_0d_int_Scalar, var_qp_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                        int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                        bool& glob_aux_NT_read = aux_NT_read;
                        bool aux_NT_read = glob_aux_NT_read;
                        vartype aux_last_type_read_for_NT = UNKNOWN;
                        int& glob_var_NER_0d_int_Scalar = var_NER_0d_int_Scalar;
                        int var_NER_0d_int_Scalar = glob_var_NER_0d_int_Scalar;
                        bool& glob_aux_NER_read = aux_NER_read;
                        bool aux_NER_read = glob_aux_NER_read;
                        vartype aux_last_type_read_for_NER = UNKNOWN;
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { q = 1 to NER } { EC } { q = 1 to ((NT-1)/NER) } \n { { F } { l = 1 to (((NT-1)/NER)-1) } } { q = 1 to (NER-1) } ] LIST";
                        cpp_line = cpp_read_raw_line(cont);
                        // read LIST record
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        // assign expression to variable NER
                        var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NER_read = true;
                        validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                        aux_last_type_read_for_NER = SCALAR_INT;
                        if ((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(6)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { q = 1 to NER } { EC } { q = 1 to ((NT-1)/NER) } \n { { F } { l = 1 to (((NT-1)/NER)-1) } } { q = 1 to (NER-1) } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0, cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts),  false, false, false, "0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        // assign expression to variable NER
                        var_NER_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                        aux_NER_read = true;
                        validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                        aux_last_type_read_for_NER = SCALAR_INT;
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NER_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= ((var_NT_0d_int_Scalar-1)/var_NER_0d_int_Scalar); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            // assign expression to variable EC
                            var_EC_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("EC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EC);
                            aux_last_type_read_for_EC = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NER_0d_int_Scalar-1), 1, (((var_NT_0d_int_Scalar-1)/var_NER_0d_int_Scalar)-1), false, false);

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= (var_NER_0d_int_Scalar-1); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body

                            for (int var_l_0d_int_Scalar = 1;
                               var_l_0d_int_Scalar <= (((var_NT_0d_int_Scalar-1)/var_NER_0d_int_Scalar)-1); var_l_0d_int_Scalar++) {
                              bool aux_l_read = true;
                              // read LIST body
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_q_0d_int_Scalar, var_l_0d_int_Scalar) = cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts);
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      std::streampos cpp_old_streampos = cont.tellg();
                      {
                        // variable declarations
                        int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                        int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                        bool& glob_aux_LT_read = aux_LT_read;
                        bool aux_LT_read = glob_aux_LT_read;
                        vartype aux_last_type_read_for_LT = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_cpp_int_val = cpp_int_val;
                        int cpp_int_val = glob_cpp_int_val;
                        bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                        bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                        int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                        bool& glob_aux_NP_read = aux_NP_read;
                        bool aux_NP_read = glob_aux_NP_read;
                        vartype aux_last_type_read_for_NP = UNKNOWN;
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { q = 1 to NP } ] LIST";
                        cpp_line = cpp_read_raw_line(cont);
                        // read LIST record
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                        if ((((((((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(8))))))||(((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(9)))))))))&&((((aux_LT_read == true)) && ((var_LT_0d_int_Scalar)==(0)))))))) {
                          cpp_found_match = true;
                        }
                        cont.seekg(cpp_old_streampos);
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { q = 1 to NP } ] LIST";
                        cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                        // read LIST record
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 0, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        cpp_validate_field(0.0, cpp_read_field<double>(cpp_line.c_str(), 1, parse_opts),  false, false, false, "0.0",
                          cpp_template, cpp_line, parse_opts);
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 2, parse_opts);
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 3, parse_opts);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                          cpp_validate_field(var_NP_0d_int_Scalar, cpp_read_field<int>(cpp_line.c_str(), 5, parse_opts),  true, false, false, "NP",
                            cpp_template, cpp_line, parse_opts);
                        }
                        {
                          int cpp_npl = cpp_read_field<int>(cpp_line.c_str(), 4, parse_opts);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                            // assign expression to variable F
                            var_F_1d_double_NestedVector.set(var_q_0d_int_Scalar, cpp_read_field<double>(cpp_line.c_str(), cpp_j, parse_opts));
                            validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                            aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cpp_line = cpp_read_line(cont, mat, mf, mt, parse_opts);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                      }
                    }
                  }
                }
              }
              // store data in Python dictionary
              if (((aux_last_type_read_for_LT == SCALAR_INT) && (aux_LT_read == true))) {
                cpp_current_dict["LT"] = var_LT_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_LB == SCALAR_INT) && (aux_LB_read == true))) {
                cpp_current_dict["LB"] = var_LB_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_NP == SCALAR_INT) && (aux_NP_read == true))) {
                cpp_current_dict["NP"] = var_NP_0d_int_Scalar;
              }
              if ((var_Ek_1d_double_NestedVector.get_last_index() != -1)) {
                auto& cpp_curvar0 = var_Ek_1d_double_NestedVector;
                cpp_current_dict["Ek"] = py::dict();
                py::dict cpp_curdict0 = cpp_current_dict["Ek"];
                for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                  cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                }
              }
              if ((var_Fk_1d_double_NestedVector.get_last_index() != -1)) {
                auto& cpp_curvar0 = var_Fk_1d_double_NestedVector;
                cpp_current_dict["Fk"] = py::dict();
                py::dict cpp_curdict0 = cpp_current_dict["Fk"];
                for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                  cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                }
              }
              if ((var_El_1d_double_NestedVector.get_last_index() != -1)) {
                auto& cpp_curvar0 = var_El_1d_double_NestedVector;
                cpp_current_dict["El"] = py::dict();
                py::dict cpp_curdict0 = cpp_current_dict["El"];
                for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                  cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                }
              }
              if ((var_Fl_1d_double_NestedVector.get_last_index() != -1)) {
                auto& cpp_curvar0 = var_Fl_1d_double_NestedVector;
                cpp_current_dict["Fl"] = py::dict();
                py::dict cpp_curdict0 = cpp_current_dict["Fl"];
                for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                  cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                }
              }
              if (((aux_last_type_read_for_LS == SCALAR_INT) && (aux_LS_read == true))) {
                cpp_current_dict["LS"] = var_LS_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_NT == SCALAR_INT) && (aux_NT_read == true))) {
                cpp_current_dict["NT"] = var_NT_0d_int_Scalar;
              }
              if (((aux_last_type_read_for_NE == SCALAR_INT) && (aux_NE_read == true))) {
                cpp_current_dict["NE"] = var_NE_0d_int_Scalar;
              }
              if ((var_E_1d_double_NestedVector.get_last_index() != -1)) {
                auto& cpp_curvar0 = var_E_1d_double_NestedVector;
                cpp_current_dict["E"] = py::dict();
                py::dict cpp_curdict0 = cpp_current_dict["E"];
                for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                  cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                }
              }
              if (var_F_2d_double_Matrix2d.did_read()) {
                  cpp_current_dict["F"] = py::dict();
                  py::dict cpp_curdict0 = cpp_current_dict["F"];
                  for (int cpp_i1 = var_F_2d_double_Matrix2d.get_row_start_index(); cpp_i1 <= var_F_2d_double_Matrix2d.get_row_last_index(); cpp_i1++) {
                    cpp_curdict0[py::cast(cpp_i1)] = py::dict();
                    py::dict cpp_curdict1 = cpp_curdict0[py::cast(cpp_i1)];
                    for (int cpp_i2 = var_F_2d_double_Matrix2d.get_col_start_index(cpp_i1); cpp_i2 <= var_F_2d_double_Matrix2d.get_col_last_index(cpp_i1); cpp_i2++) {
                      cpp_curdict1[py::cast(cpp_i2)] = var_F_2d_double_Matrix2d(cpp_i1, cpp_i2);
                    }
                  }
              }
              if (((aux_last_type_read_for_NER == SCALAR_INT) && (aux_NER_read == true))) {
                cpp_current_dict["NER"] = var_NER_0d_int_Scalar;
              }
              if ((var_ER_1d_double_NestedVector.get_last_index() != -1)) {
                auto& cpp_curvar0 = var_ER_1d_double_NestedVector;
                cpp_current_dict["ER"] = py::dict();
                py::dict cpp_curdict0 = cpp_current_dict["ER"];
                for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                  cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                }
              }
              if ((var_EC_1d_double_NestedVector.get_last_index() != -1)) {
                auto& cpp_curvar0 = var_EC_1d_double_NestedVector;
                cpp_current_dict["EC"] = py::dict();
                py::dict cpp_curdict0 = cpp_current_dict["EC"];
                for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                  cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                }
              }
              if ((var_F_1d_double_NestedVector.get_last_index() != -1)) {
                auto& cpp_curvar0 = var_F_1d_double_NestedVector;
                cpp_current_dict["F"] = py::dict();
                py::dict cpp_curdict0 = cpp_current_dict["F"];
                for (int cpp_i1 = cpp_curvar0.get_start_index(); cpp_i1 <= cpp_curvar0.get_last_index(); cpp_i1++) {
                  cpp_curdict0[py::cast(cpp_i1)] = cpp_curvar0[cpp_i1];
                }
              }
              cpp_current_dict = cpp_parent_dict;
            }
          }
          // store data in Python dictionary
          if (((aux_last_type_read_for_XMF1 == SCALAR_DOUBLE) && (aux_XMF1_read == true))) {
            cpp_current_dict["XMF1"] = var_XMF1_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_XLFS1 == SCALAR_DOUBLE) && (aux_XLFS1_read == true))) {
            cpp_current_dict["XLFS1"] = var_XLFS1_0d_double_Scalar;
          }
          if (((aux_last_type_read_for_MAT1 == SCALAR_INT) && (aux_MAT1_read == true))) {
            cpp_current_dict["MAT1"] = var_MAT1_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_MT1 == SCALAR_INT) && (aux_MT1_read == true))) {
            cpp_current_dict["MT1"] = var_MT1_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NC == SCALAR_INT) && (aux_NC_read == true))) {
            cpp_current_dict["NC"] = var_NC_0d_int_Scalar;
          }
          if (((aux_last_type_read_for_NI == SCALAR_INT) && (aux_NI_read == true))) {
            cpp_current_dict["NI"] = var_NI_0d_int_Scalar;
          }
          cpp_current_dict = cpp_parent_dict;
        }
      }
      // store data in Python dictionary
      if (((aux_last_type_read_for_QM == SCALAR_DOUBLE) && (aux_QM_read == true))) {
        cpp_current_dict["QM"] = var_QM_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_QI == SCALAR_DOUBLE) && (aux_QI_read == true))) {
        cpp_current_dict["QI"] = var_QI_0d_double_Scalar;
      }
      if (((aux_last_type_read_for_IZAP == SCALAR_INT) && (aux_IZAP_read == true))) {
        cpp_current_dict["IZAP"] = var_IZAP_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_LFS == SCALAR_INT) && (aux_LFS_read == true))) {
        cpp_current_dict["LFS"] = var_LFS_0d_int_Scalar;
      }
      if (((aux_last_type_read_for_NL == SCALAR_INT) && (aux_NL_read == true))) {
        cpp_current_dict["NL"] = var_NL_0d_int_Scalar;
      }
      cpp_current_dict = cpp_parent_dict;
    }
  }
  cpp_read_send(cont, mat, mf, parse_opts);
  // store data in Python dictionary
  if (((aux_last_type_read_for_MAT == SCALAR_INT) && (aux_MAT_read == true))) {
    cpp_current_dict["MAT"] = var_MAT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MF == SCALAR_INT) && (aux_MF_read == true))) {
    cpp_current_dict["MF"] = var_MF_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_MT == SCALAR_INT) && (aux_MT_read == true))) {
    cpp_current_dict["MT"] = var_MT_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_ZA == SCALAR_DOUBLE) && (aux_ZA_read == true))) {
    cpp_current_dict["ZA"] = var_ZA_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_AWR == SCALAR_DOUBLE) && (aux_AWR_read == true))) {
    cpp_current_dict["AWR"] = var_AWR_0d_double_Scalar;
  }
  if (((aux_last_type_read_for_LIS == SCALAR_INT) && (aux_LIS_read == true))) {
    cpp_current_dict["LIS"] = var_LIS_0d_int_Scalar;
  }
  if (((aux_last_type_read_for_NS == SCALAR_INT) && (aux_NS_read == true))) {
    cpp_current_dict["NS"] = var_NS_0d_int_Scalar;
  }
  return cpp_current_dict;
}

void _check_end_records(bool after_fend, bool after_mend, bool after_tend, bool mat, bool mf, bool mt, bool last_mat, bool last_mf, bool last_mt, bool section_encountered, bool found_tpid, ParsingOptions parse_opts) {
  if (parse_opts.ignore_send_records == false) {
    if ((after_mend == true || after_tend == true)) {
      throw std::runtime_error("No MF/MT section allowed after MEND/TEND record");
    }
    if ((after_fend == true && section_encountered == false)) {
      throw std::runtime_error("FEND record without preceding MF/MT section encountered");
    }
    if ((after_fend == true && last_mf >= mf)) {
      throw std::runtime_error("MF sections must be in ascending order");
    }
  }
  if ((found_tpid == false && parse_opts.ignore_missing_tpid == false)) {
    throw std::runtime_error("Tape ID (TPID) record missing in first line");
  }
}

py::dict parse_endf_istream(std::istream& cont, py::object exclude, py::object include, ParsingOptions parse_opts=default_parsing_options()) {
  bool is_firstline = true;
  std::streampos curpos;
  py::dict mfmt_dict;
  py::dict curdict;
  int mat;
  int mf;
  int mt;
  bool section_encountered = false;
  int last_mat;
  int last_mf;
  int last_mt;
  std::string cpp_line;
  std::vector<std::string> verbatim_section;
  bool found_tpid = false;
  bool after_fend = false;
  bool after_mend = false;
  bool after_tend = false;
  curpos = cont.tellg();
  while (std::getline(cont, cpp_line)) {
    mat = cpp_read_custom_int_field(cpp_line.c_str(), 66, 4);
    mf = cpp_read_custom_int_field(cpp_line.c_str(), 70, 2);
    mt = cpp_read_custom_int_field(cpp_line.c_str(), 72, 3);
    if ((mf == 0 && mt == 0 && is_firstline)) {
      found_tpid = true;
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf0mt0_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 1 && mt == 460) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf1mt460_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 1 && mt == 458) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf1mt458_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 1 && mt == 456) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf1mt456_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 1 && mt == 455) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf1mt455_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 1 && mt == 452) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf1mt452_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 1 && mt == 451) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf1mt451_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 2 && mt == 151) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf2mt151_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 3) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf3_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 4) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf4_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 5) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf5_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 6) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf6_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 7 && mt == 451) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf7mt451_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 7 && mt == 4) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf7mt4_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 7 && mt == 2) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf7mt2_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 8 && mt == 459) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf8mt459_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 8 && mt == 457) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf8mt457_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 8 && mt == 454) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf8mt454_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 8) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf8_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 9) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf9_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 10) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf10_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 12) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf12_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 13) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf13_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 14) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf14_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 15) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf15_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 23) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf23_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 26) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf26_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 27) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf27_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 28) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf28_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 31) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf31_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 32) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf32_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 33) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf33_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 34) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf34_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 35) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf35_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if (mf == 40) {
      _check_end_records(after_fend, after_mend, after_tend, mat, mf, mt, last_mat, last_mf, last_mt, section_encountered, found_tpid, parse_opts);
      after_fend = false;
      section_encountered = true;
      cont.seekg(curpos);
      if (should_parse_section(mf, mt, exclude, include)) {
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = parse_mf40_istream(cont, parse_opts);
        }
      } else {
        verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
        {
          py::dict curdict = mfmt_dict;
          if (! curdict.contains(py::cast(mf))) {
            curdict[py::cast(mf)] = py::dict();
          }
          curdict = curdict[py::cast(mf)];
          curdict[py::cast(mt)] = verbatim_section;
        }
      }
    } else if ((mf != 0 && mt != 0)) {
      verbatim_section = read_section_verbatim(mat, mf, mt, cont, is_firstline, parse_opts);
      {
        py::dict curdict = mfmt_dict;
        if (! curdict.contains(py::cast(mf))) {
          curdict[py::cast(mf)] = py::dict();
        }
        curdict = curdict[py::cast(mf)];
        curdict[py::cast(mt)] = verbatim_section;
      }
    } else if (cpp_is_blank_line(cpp_line)) {
      if ((! parse_opts.ignore_blank_lines)) {
        throw std::runtime_error("Blank line detected");
      }
    } else if ((after_mend == true && cpp_is_tend_record(cpp_line, parse_opts))) {
      after_mend = false;
      after_tend = true;
    } else if ((after_fend == true && cpp_is_mend_record(cpp_line, parse_opts))) {
      after_mend = true;
    } else if (cpp_is_fend_record(cpp_line, mat, parse_opts)) {
      after_fend = true;
    } else {
      throw std::runtime_error(
        std::string("Invalid line encountered! This line is outside any MF/MT section.\n")
        + "Line: " + cpp_line
      );
    }
    last_mat = mat;
    last_mf = mf;
    last_mt = mt;
    curpos = cont.tellg();
    is_firstline = false;
  }
  return mfmt_dict;
}

py::dict parse_mf0mt0(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf0mt0_istream(iss, parse_opts);
}

py::dict parse_mf1mt451(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf1mt451_istream(iss, parse_opts);
}

py::dict parse_mf1mt452(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf1mt452_istream(iss, parse_opts);
}

py::dict parse_mf1mt455(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf1mt455_istream(iss, parse_opts);
}

py::dict parse_mf1mt456(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf1mt456_istream(iss, parse_opts);
}

py::dict parse_mf1mt458(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf1mt458_istream(iss, parse_opts);
}

py::dict parse_mf1mt460(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf1mt460_istream(iss, parse_opts);
}

py::dict parse_mf2mt151(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf2mt151_istream(iss, parse_opts);
}

py::dict parse_mf3(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf3_istream(iss, parse_opts);
}

py::dict parse_mf4(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf4_istream(iss, parse_opts);
}

py::dict parse_mf5(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf5_istream(iss, parse_opts);
}

py::dict parse_mf6(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf6_istream(iss, parse_opts);
}

py::dict parse_mf7mt2(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf7mt2_istream(iss, parse_opts);
}

py::dict parse_mf7mt4(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf7mt4_istream(iss, parse_opts);
}

py::dict parse_mf7mt451(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf7mt451_istream(iss, parse_opts);
}

py::dict parse_mf8(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf8_istream(iss, parse_opts);
}

py::dict parse_mf8mt454(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf8mt454_istream(iss, parse_opts);
}

py::dict parse_mf8mt457(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf8mt457_istream(iss, parse_opts);
}

py::dict parse_mf8mt459(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf8mt459_istream(iss, parse_opts);
}

py::dict parse_mf9(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf9_istream(iss, parse_opts);
}

py::dict parse_mf10(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf10_istream(iss, parse_opts);
}

py::dict parse_mf12(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf12_istream(iss, parse_opts);
}

py::dict parse_mf13(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf13_istream(iss, parse_opts);
}

py::dict parse_mf14(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf14_istream(iss, parse_opts);
}

py::dict parse_mf15(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf15_istream(iss, parse_opts);
}

py::dict parse_mf23(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf23_istream(iss, parse_opts);
}

py::dict parse_mf26(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf26_istream(iss, parse_opts);
}

py::dict parse_mf27(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf27_istream(iss, parse_opts);
}

py::dict parse_mf28(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf28_istream(iss, parse_opts);
}

py::dict parse_mf31(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf31_istream(iss, parse_opts);
}

py::dict parse_mf32(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf32_istream(iss, parse_opts);
}

py::dict parse_mf33(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf33_istream(iss, parse_opts);
}

py::dict parse_mf34(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf34_istream(iss, parse_opts);
}

py::dict parse_mf35(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf35_istream(iss, parse_opts);
}

py::dict parse_mf40(std::string& strcont, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_mf40_istream(iss, parse_opts);
}

py::dict parse_endf(std::string& strcont, py::object exclude, py::object include, ParsingOptions parse_opts) {
  std::istringstream iss(strcont);
  return parse_endf_istream(iss, exclude, include, parse_opts);
}

py::dict parse_mf0mt0_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf0mt0_istream(inpfile, parse_opts);
}

py::dict parse_mf1mt451_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf1mt451_istream(inpfile, parse_opts);
}

py::dict parse_mf1mt452_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf1mt452_istream(inpfile, parse_opts);
}

py::dict parse_mf1mt455_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf1mt455_istream(inpfile, parse_opts);
}

py::dict parse_mf1mt456_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf1mt456_istream(inpfile, parse_opts);
}

py::dict parse_mf1mt458_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf1mt458_istream(inpfile, parse_opts);
}

py::dict parse_mf1mt460_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf1mt460_istream(inpfile, parse_opts);
}

py::dict parse_mf2mt151_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf2mt151_istream(inpfile, parse_opts);
}

py::dict parse_mf3_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf3_istream(inpfile, parse_opts);
}

py::dict parse_mf4_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf4_istream(inpfile, parse_opts);
}

py::dict parse_mf5_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf5_istream(inpfile, parse_opts);
}

py::dict parse_mf6_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf6_istream(inpfile, parse_opts);
}

py::dict parse_mf7mt2_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf7mt2_istream(inpfile, parse_opts);
}

py::dict parse_mf7mt4_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf7mt4_istream(inpfile, parse_opts);
}

py::dict parse_mf7mt451_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf7mt451_istream(inpfile, parse_opts);
}

py::dict parse_mf8_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf8_istream(inpfile, parse_opts);
}

py::dict parse_mf8mt454_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf8mt454_istream(inpfile, parse_opts);
}

py::dict parse_mf8mt457_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf8mt457_istream(inpfile, parse_opts);
}

py::dict parse_mf8mt459_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf8mt459_istream(inpfile, parse_opts);
}

py::dict parse_mf9_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf9_istream(inpfile, parse_opts);
}

py::dict parse_mf10_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf10_istream(inpfile, parse_opts);
}

py::dict parse_mf12_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf12_istream(inpfile, parse_opts);
}

py::dict parse_mf13_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf13_istream(inpfile, parse_opts);
}

py::dict parse_mf14_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf14_istream(inpfile, parse_opts);
}

py::dict parse_mf15_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf15_istream(inpfile, parse_opts);
}

py::dict parse_mf23_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf23_istream(inpfile, parse_opts);
}

py::dict parse_mf26_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf26_istream(inpfile, parse_opts);
}

py::dict parse_mf27_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf27_istream(inpfile, parse_opts);
}

py::dict parse_mf28_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf28_istream(inpfile, parse_opts);
}

py::dict parse_mf31_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf31_istream(inpfile, parse_opts);
}

py::dict parse_mf32_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf32_istream(inpfile, parse_opts);
}

py::dict parse_mf33_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf33_istream(inpfile, parse_opts);
}

py::dict parse_mf34_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf34_istream(inpfile, parse_opts);
}

py::dict parse_mf35_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf35_istream(inpfile, parse_opts);
}

py::dict parse_mf40_file(std::string& filename, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_mf40_istream(inpfile, parse_opts);
}

py::dict parse_endf_file(std::string& filename, py::object exclude, py::object include, ParsingOptions parse_opts) {
  std::ifstream inpfile(filename);
if ((! inpfile.is_open())) {
  throw std::ifstream::failure("failed to open file " + filename);
}
  return parse_endf_istream(inpfile, exclude, include, parse_opts);
}



// MD5 hash of ENDF recipe underlying the following function: a38e6e76968fb4463ab67282d5c7f80d
// MD5 hash of the following function definition: b923f9c098701d8833220bebb08d1f20
void write_mf0mt0_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  std::string var_TAPEDESCR_0d_string_Scalar;
  bool aux_TAPEDESCR_read = false;
  vartype aux_last_type_read_for_TAPEDESCR = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 0;
  int mt = 0;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 0;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 0;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 0 , 0 / TAPEDESCR ] TEXT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  cpp_draft_line.replace(0, 66, py::cast<std::string>(cpp_current_dict["TAPEDESCR"]));
  // assign expression to variable TAPEDESCR
  var_TAPEDESCR_0d_string_Scalar = py::cast<std::string>(cpp_current_dict["TAPEDESCR"]);
  aux_TAPEDESCR_read = true;
  validate_vartype_consistency("TAPEDESCR", SCALAR_STRING, aux_last_type_read_for_TAPEDESCR);
  aux_last_type_read_for_TAPEDESCR = SCALAR_STRING;
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 58de2de2b82537497333c5e7a5bc310c
// MD5 hash of the following function definition: 58116e5e3ab931de865786d9a1e3b725
void write_mf1mt451_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LRP_0d_int_Scalar;
  bool aux_LRP_read = false;
  vartype aux_last_type_read_for_LRP = UNKNOWN;
  int var_LFI_0d_int_Scalar;
  bool aux_LFI_read = false;
  vartype aux_last_type_read_for_LFI = UNKNOWN;
  int var_NLIB_0d_int_Scalar;
  bool aux_NLIB_read = false;
  vartype aux_last_type_read_for_NLIB = UNKNOWN;
  int var_NMOD_0d_int_Scalar;
  bool aux_NMOD_read = false;
  vartype aux_last_type_read_for_NMOD = UNKNOWN;
  double var_ELIS_0d_double_Scalar;
  bool aux_ELIS_read = false;
  vartype aux_last_type_read_for_ELIS = UNKNOWN;
  double var_STA_0d_double_Scalar;
  bool aux_STA_read = false;
  vartype aux_last_type_read_for_STA = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_LISO_0d_int_Scalar;
  bool aux_LISO_read = false;
  vartype aux_last_type_read_for_LISO = UNKNOWN;
  int var_NFOR_0d_int_Scalar;
  bool aux_NFOR_read = false;
  vartype aux_last_type_read_for_NFOR = UNKNOWN;
  double var_AWI_0d_double_Scalar;
  bool aux_AWI_read = false;
  vartype aux_last_type_read_for_AWI = UNKNOWN;
  double var_EMAX_0d_double_Scalar;
  bool aux_EMAX_read = false;
  vartype aux_last_type_read_for_EMAX = UNKNOWN;
  int var_LREL_0d_int_Scalar;
  bool aux_LREL_read = false;
  vartype aux_last_type_read_for_LREL = UNKNOWN;
  int var_NSUB_0d_int_Scalar;
  bool aux_NSUB_read = false;
  vartype aux_last_type_read_for_NSUB = UNKNOWN;
  int var_NVER_0d_int_Scalar;
  bool aux_NVER_read = false;
  vartype aux_last_type_read_for_NVER = UNKNOWN;
  double var_TEMP_0d_double_Scalar;
  bool aux_TEMP_read = false;
  vartype aux_last_type_read_for_TEMP = UNKNOWN;
  int var_LDRV_0d_int_Scalar;
  bool aux_LDRV_read = false;
  vartype aux_last_type_read_for_LDRV = UNKNOWN;
  int var_NWD_0d_int_Scalar;
  bool aux_NWD_read = false;
  vartype aux_last_type_read_for_NWD = UNKNOWN;
  int var_NXC_0d_int_Scalar;
  bool aux_NXC_read = false;
  vartype aux_last_type_read_for_NXC = UNKNOWN;
  std::string var_ZSYMAM_0d_string_Scalar;
  bool aux_ZSYMAM_read = false;
  vartype aux_last_type_read_for_ZSYMAM = UNKNOWN;
  std::string var_ALAB_0d_string_Scalar;
  bool aux_ALAB_read = false;
  vartype aux_last_type_read_for_ALAB = UNKNOWN;
  std::string var_EDATE_0d_string_Scalar;
  bool aux_EDATE_read = false;
  vartype aux_last_type_read_for_EDATE = UNKNOWN;
  std::string var_AUTH_0d_string_Scalar;
  bool aux_AUTH_read = false;
  vartype aux_last_type_read_for_AUTH = UNKNOWN;
  std::string var_REF_0d_string_Scalar;
  bool aux_REF_read = false;
  vartype aux_last_type_read_for_REF = UNKNOWN;
  std::string var_DDATE_0d_string_Scalar;
  bool aux_DDATE_read = false;
  vartype aux_last_type_read_for_DDATE = UNKNOWN;
  std::string var_RDATE_0d_string_Scalar;
  bool aux_RDATE_read = false;
  vartype aux_last_type_read_for_RDATE = UNKNOWN;
  std::string var_ENDATE_0d_string_Scalar;
  bool aux_ENDATE_read = false;
  vartype aux_last_type_read_for_ENDATE = UNKNOWN;
  NestedVector<std::string> var_HSUB_1d_string_NestedVector;
  vartype aux_last_type_read_for_HSUB = UNKNOWN;
  NestedVector<std::string> var_DESCRIPTION_1d_string_NestedVector;
  vartype aux_last_type_read_for_DESCRIPTION = UNKNOWN;
  NestedVector<int> var_MFx_1d_int_NestedVector;
  vartype aux_last_type_read_for_MFx = UNKNOWN;
  NestedVector<int> var_MTx_1d_int_NestedVector;
  vartype aux_last_type_read_for_MTx = UNKNOWN;
  NestedVector<int> var_NCx_1d_int_NestedVector;
  vartype aux_last_type_read_for_NCx = UNKNOWN;
  NestedVector<int> var_MOD_1d_int_NestedVector;
  vartype aux_last_type_read_for_MOD = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 1;
  int mt = 451;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 451;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 1 , 451 / ZA , AWR , LRP , LFI , NLIB , NMOD ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LRP"]), write_opts);
  // assign expression to variable LRP
  var_LRP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LRP"]);
  aux_LRP_read = true;
  validate_vartype_consistency("LRP", SCALAR_INT, aux_last_type_read_for_LRP);
  aux_last_type_read_for_LRP = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LFI"]), write_opts);
  // assign expression to variable LFI
  var_LFI_0d_int_Scalar = py::cast<int>(cpp_current_dict["LFI"]);
  aux_LFI_read = true;
  validate_vartype_consistency("LFI", SCALAR_INT, aux_last_type_read_for_LFI);
  aux_last_type_read_for_LFI = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLIB"]), write_opts);
  // assign expression to variable NLIB
  var_NLIB_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLIB"]);
  aux_NLIB_read = true;
  validate_vartype_consistency("NLIB", SCALAR_INT, aux_last_type_read_for_NLIB);
  aux_last_type_read_for_NLIB = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NMOD"]), write_opts);
  // assign expression to variable NMOD
  var_NMOD_0d_int_Scalar = py::cast<int>(cpp_current_dict["NMOD"]);
  aux_NMOD_read = true;
  validate_vartype_consistency("NMOD", SCALAR_INT, aux_last_type_read_for_NMOD);
  aux_last_type_read_for_NMOD = SCALAR_INT;
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 1 , 451 / ELIS , STA , LIS , LISO , 0 , NFOR ] CONT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ELIS"]), write_opts);
  // assign expression to variable ELIS
  var_ELIS_0d_double_Scalar = py::cast<double>(cpp_current_dict["ELIS"]);
  aux_ELIS_read = true;
  validate_vartype_consistency("ELIS", SCALAR_DOUBLE, aux_last_type_read_for_ELIS);
  aux_last_type_read_for_ELIS = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["STA"]), write_opts);
  // assign expression to variable STA
  var_STA_0d_double_Scalar = py::cast<double>(cpp_current_dict["STA"]);
  aux_STA_read = true;
  validate_vartype_consistency("STA", SCALAR_DOUBLE, aux_last_type_read_for_STA);
  aux_last_type_read_for_STA = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LIS"]), write_opts);
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LIS"]);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LISO"]), write_opts);
  // assign expression to variable LISO
  var_LISO_0d_int_Scalar = py::cast<int>(cpp_current_dict["LISO"]);
  aux_LISO_read = true;
  validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
  aux_last_type_read_for_LISO = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NFOR"]), write_opts);
  // assign expression to variable NFOR
  var_NFOR_0d_int_Scalar = py::cast<int>(cpp_current_dict["NFOR"]);
  aux_NFOR_read = true;
  validate_vartype_consistency("NFOR", SCALAR_INT, aux_last_type_read_for_NFOR);
  aux_last_type_read_for_NFOR = SCALAR_INT;
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 1 , 451 / AWI , EMAX , LREL , 0 , NSUB , NVER ] CONT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AWI"]), write_opts);
  // assign expression to variable AWI
  var_AWI_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWI"]);
  aux_AWI_read = true;
  validate_vartype_consistency("AWI", SCALAR_DOUBLE, aux_last_type_read_for_AWI);
  aux_last_type_read_for_AWI = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["EMAX"]), write_opts);
  // assign expression to variable EMAX
  var_EMAX_0d_double_Scalar = py::cast<double>(cpp_current_dict["EMAX"]);
  aux_EMAX_read = true;
  validate_vartype_consistency("EMAX", SCALAR_DOUBLE, aux_last_type_read_for_EMAX);
  aux_last_type_read_for_EMAX = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LREL"]), write_opts);
  // assign expression to variable LREL
  var_LREL_0d_int_Scalar = py::cast<int>(cpp_current_dict["LREL"]);
  aux_LREL_read = true;
  validate_vartype_consistency("LREL", SCALAR_INT, aux_last_type_read_for_LREL);
  aux_last_type_read_for_LREL = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NSUB"]), write_opts);
  // assign expression to variable NSUB
  var_NSUB_0d_int_Scalar = py::cast<int>(cpp_current_dict["NSUB"]);
  aux_NSUB_read = true;
  validate_vartype_consistency("NSUB", SCALAR_INT, aux_last_type_read_for_NSUB);
  aux_last_type_read_for_NSUB = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NVER"]), write_opts);
  // assign expression to variable NVER
  var_NVER_0d_int_Scalar = py::cast<int>(cpp_current_dict["NVER"]);
  aux_NVER_read = true;
  validate_vartype_consistency("NVER", SCALAR_INT, aux_last_type_read_for_NVER);
  aux_last_type_read_for_NVER = SCALAR_INT;
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 1 , 451 / TEMP , 0.0 , LDRV , 0 , NWD , NXC ] CONT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["TEMP"]), write_opts);
  // assign expression to variable TEMP
  var_TEMP_0d_double_Scalar = py::cast<double>(cpp_current_dict["TEMP"]);
  aux_TEMP_read = true;
  validate_vartype_consistency("TEMP", SCALAR_DOUBLE, aux_last_type_read_for_TEMP);
  aux_last_type_read_for_TEMP = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LDRV"]), write_opts);
  // assign expression to variable LDRV
  var_LDRV_0d_int_Scalar = py::cast<int>(cpp_current_dict["LDRV"]);
  aux_LDRV_read = true;
  validate_vartype_consistency("LDRV", SCALAR_INT, aux_last_type_read_for_LDRV);
  aux_last_type_read_for_LDRV = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NWD"]), write_opts);
  // assign expression to variable NWD
  var_NWD_0d_int_Scalar = py::cast<int>(cpp_current_dict["NWD"]);
  aux_NWD_read = true;
  validate_vartype_consistency("NWD", SCALAR_INT, aux_last_type_read_for_NWD);
  aux_last_type_read_for_NWD = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NXC"]), write_opts);
  // assign expression to variable NXC
  var_NXC_0d_int_Scalar = py::cast<int>(cpp_current_dict["NXC"]);
  aux_NXC_read = true;
  validate_vartype_consistency("NXC", SCALAR_INT, aux_last_type_read_for_NXC);
  aux_last_type_read_for_NXC = SCALAR_INT;
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 1 , 451 / ZSYMAM { 11 } , ALAB { 11 } , EDATE { 10 } , { 1 } , AUTH { 33 } ] TEXT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  cpp_draft_line.replace(0, 11, py::cast<std::string>(cpp_current_dict["ZSYMAM"]));
  // assign expression to variable ZSYMAM
  var_ZSYMAM_0d_string_Scalar = py::cast<std::string>(cpp_current_dict["ZSYMAM"]);
  aux_ZSYMAM_read = true;
  validate_vartype_consistency("ZSYMAM", SCALAR_STRING, aux_last_type_read_for_ZSYMAM);
  aux_last_type_read_for_ZSYMAM = SCALAR_STRING;
  cpp_draft_line.replace(11, 11, py::cast<std::string>(cpp_current_dict["ALAB"]));
  // assign expression to variable ALAB
  var_ALAB_0d_string_Scalar = py::cast<std::string>(cpp_current_dict["ALAB"]);
  aux_ALAB_read = true;
  validate_vartype_consistency("ALAB", SCALAR_STRING, aux_last_type_read_for_ALAB);
  aux_last_type_read_for_ALAB = SCALAR_STRING;
  cpp_draft_line.replace(22, 10, py::cast<std::string>(cpp_current_dict["EDATE"]));
  // assign expression to variable EDATE
  var_EDATE_0d_string_Scalar = py::cast<std::string>(cpp_current_dict["EDATE"]);
  aux_EDATE_read = true;
  validate_vartype_consistency("EDATE", SCALAR_STRING, aux_last_type_read_for_EDATE);
  aux_last_type_read_for_EDATE = SCALAR_STRING;
  cpp_draft_line.replace(33, 33, py::cast<std::string>(cpp_current_dict["AUTH"]));
  // assign expression to variable AUTH
  var_AUTH_0d_string_Scalar = py::cast<std::string>(cpp_current_dict["AUTH"]);
  aux_AUTH_read = true;
  validate_vartype_consistency("AUTH", SCALAR_STRING, aux_last_type_read_for_AUTH);
  aux_last_type_read_for_AUTH = SCALAR_STRING;
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 1 , 451 / { 1 } , REF { 21 } , DDATE { 10 } , { 1 } , \n RDATE { 10 } , { 12 } , ENDATE { 8 } , { 3 } ] TEXT";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  cpp_draft_line.replace(1, 21, py::cast<std::string>(cpp_current_dict["REF"]));
  // assign expression to variable REF
  var_REF_0d_string_Scalar = py::cast<std::string>(cpp_current_dict["REF"]);
  aux_REF_read = true;
  validate_vartype_consistency("REF", SCALAR_STRING, aux_last_type_read_for_REF);
  aux_last_type_read_for_REF = SCALAR_STRING;
  cpp_draft_line.replace(22, 10, py::cast<std::string>(cpp_current_dict["DDATE"]));
  // assign expression to variable DDATE
  var_DDATE_0d_string_Scalar = py::cast<std::string>(cpp_current_dict["DDATE"]);
  aux_DDATE_read = true;
  validate_vartype_consistency("DDATE", SCALAR_STRING, aux_last_type_read_for_DDATE);
  aux_last_type_read_for_DDATE = SCALAR_STRING;
  cpp_draft_line.replace(33, 10, py::cast<std::string>(cpp_current_dict["RDATE"]));
  // assign expression to variable RDATE
  var_RDATE_0d_string_Scalar = py::cast<std::string>(cpp_current_dict["RDATE"]);
  aux_RDATE_read = true;
  validate_vartype_consistency("RDATE", SCALAR_STRING, aux_last_type_read_for_RDATE);
  aux_last_type_read_for_RDATE = SCALAR_STRING;
  cpp_draft_line.replace(55, 8, py::cast<std::string>(cpp_current_dict["ENDATE"]));
  // assign expression to variable ENDATE
  var_ENDATE_0d_string_Scalar = py::cast<std::string>(cpp_current_dict["ENDATE"]);
  aux_ENDATE_read = true;
  validate_vartype_consistency("ENDATE", SCALAR_STRING, aux_last_type_read_for_ENDATE);
  aux_last_type_read_for_ENDATE = SCALAR_STRING;
  cont << cpp_draft_line;

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= 3; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 1 , 451 / HSUB [ i ] ] TEXT";
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
    cpp_draft_line.replace(0, 66, py::cast<std::string>(cpp_current_dict["HSUB"][py::cast(var_i_0d_int_Scalar)]));
    // assign expression to variable HSUB
    var_HSUB_1d_string_NestedVector.set(var_i_0d_int_Scalar, py::cast<std::string>(cpp_current_dict["HSUB"][py::cast(var_i_0d_int_Scalar)]));
    validate_vartype_consistency("HSUB", NESTEDVECTOR_STRING, aux_last_type_read_for_HSUB);
    aux_last_type_read_for_HSUB = NESTEDVECTOR_STRING;
    cont << cpp_draft_line;
  }

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= (var_NWD_0d_int_Scalar-5); var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 1 , 451 / DESCRIPTION [ i ] ] TEXT";
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
    cpp_draft_line.replace(0, 66, py::cast<std::string>(cpp_current_dict["DESCRIPTION"][py::cast(var_i_0d_int_Scalar)]));
    // assign expression to variable DESCRIPTION
    var_DESCRIPTION_1d_string_NestedVector.set(var_i_0d_int_Scalar, py::cast<std::string>(cpp_current_dict["DESCRIPTION"][py::cast(var_i_0d_int_Scalar)]));
    validate_vartype_consistency("DESCRIPTION", NESTEDVECTOR_STRING, aux_last_type_read_for_DESCRIPTION);
    aux_last_type_read_for_DESCRIPTION = NESTEDVECTOR_STRING;
    cont << cpp_draft_line;
  }

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NXC_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 1 , 451 / blank , blank , MFx , MTx , NCx , MOD ] DIR";
    // read TEXT record
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["MFx"][py::cast(var_i_0d_int_Scalar)]), write_opts);
    // assign expression to variable MFx
    var_MFx_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_current_dict["MFx"][py::cast(var_i_0d_int_Scalar)]));
    validate_vartype_consistency("MFx", NESTEDVECTOR_INT, aux_last_type_read_for_MFx);
    aux_last_type_read_for_MFx = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["MTx"][py::cast(var_i_0d_int_Scalar)]), write_opts);
    // assign expression to variable MTx
    var_MTx_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_current_dict["MTx"][py::cast(var_i_0d_int_Scalar)]));
    validate_vartype_consistency("MTx", NESTEDVECTOR_INT, aux_last_type_read_for_MTx);
    aux_last_type_read_for_MTx = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NCx"][py::cast(var_i_0d_int_Scalar)]), write_opts);
    // assign expression to variable NCx
    var_NCx_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_current_dict["NCx"][py::cast(var_i_0d_int_Scalar)]));
    validate_vartype_consistency("NCx", NESTEDVECTOR_INT, aux_last_type_read_for_NCx);
    aux_last_type_read_for_NCx = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["MOD"][py::cast(var_i_0d_int_Scalar)]), write_opts);
    // assign expression to variable MOD
    var_MOD_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_current_dict["MOD"][py::cast(var_i_0d_int_Scalar)]));
    validate_vartype_consistency("MOD", NESTEDVECTOR_INT, aux_last_type_read_for_MOD);
    aux_last_type_read_for_MOD = NESTEDVECTOR_INT;
    cont << cpp_draft_line;
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 714e5d90ebe6fa41e07bef414c2ac8f4
// MD5 hash of the following function definition: ae3275b93ff4802f6d0b622e6a74575e
void write_mf1mt452_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LNU_0d_int_Scalar;
  bool aux_LNU_read = false;
  vartype aux_last_type_read_for_LNU = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  NestedVector<double> var_C_1d_double_NestedVector;
  vartype aux_last_type_read_for_C = UNKNOWN;
  std::vector<double> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<double> var_nu_0d_floatvec_Scalar;
  bool aux_nu_read = false;
  vartype aux_last_type_read_for_nu = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 1;
  int mt = 452;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 452;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 1 , 452 / ZA , AWR , 0 , LNU , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LNU"]), write_opts);
  // assign expression to variable LNU
  var_LNU_0d_int_Scalar = py::cast<int>(cpp_current_dict["LNU"]);
  aux_LNU_read = true;
  validate_vartype_consistency("LNU", SCALAR_INT, aux_last_type_read_for_LNU);
  aux_last_type_read_for_LNU = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 1 , 452 / 0.0 , 0.0 , 0 , 0 , NC , 0 / { C } { k = 1 to NC } ] LIST";
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        // read LIST record
        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NC"]), write_opts);
        // assign expression to variable NC
        var_NC_0d_int_Scalar = py::cast<int>(cpp_current_dict["NC"]);
        aux_NC_read = true;
        validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
        aux_last_type_read_for_NC = SCALAR_INT;
        cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NC"]), write_opts);
        cont << cpp_draft_line;
        {
          int cpp_npl = py::cast<int>(cpp_current_dict["NC"]);
          int cpp_i = 0;
          int cpp_j = 0;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read LIST body

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NC_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // read LIST body
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["C"][py::cast(var_k_0d_int_Scalar)]), write_opts);
            // assign expression to variable C
            var_C_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["C"][py::cast(var_k_0d_int_Scalar)]));
            validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
            aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
          }
          if (cpp_i != cpp_npl) {
            throw std::runtime_error("not exactly NPL elements consumed");
          }
        }
        cont << cpp_draft_line;
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 452 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nu ] TAB1";
          // read TAB1 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
          cpp_nr_val = py::len(cpp_current_dict["INT"]);
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
          cpp_np_val = py::len(cpp_current_dict["Eint"]);
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
          tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["nu"]);
          tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Eint
            var_Eint_0d_floatvec_Scalar = tab_body.X;
            aux_Eint_read = true;
            validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
            aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
            // assign expression to variable nu
            var_nu_0d_floatvec_Scalar = tab_body.Y;
            aux_nu_read = true;
            validate_vartype_consistency("nu", SCALAR_FLOATVEC, aux_last_type_read_for_nu);
            aux_last_type_read_for_nu = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 6372082f09eb7576770b456ddd80b3fb
// MD5 hash of the following function definition: cb27a8cdbc1a23e6510b804eab29f30e
void write_mf1mt455_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LDG_0d_int_Scalar;
  bool aux_LDG_read = false;
  vartype aux_last_type_read_for_LDG = UNKNOWN;
  int var_LNU_0d_int_Scalar;
  bool aux_LNU_read = false;
  vartype aux_last_type_read_for_LNU = UNKNOWN;
  int var_NNF_0d_int_Scalar;
  bool aux_NNF_read = false;
  vartype aux_last_type_read_for_NNF = UNKNOWN;
  NestedVector<double> var_lambda_1d_double_NestedVector;
  vartype aux_last_type_read_for_lambda = UNKNOWN;
  std::vector<double> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<double> var_nubar_d_0d_floatvec_Scalar;
  double var_nubar_d_0d_double_Scalar;
  bool aux_nubar_d_read = false;
  vartype aux_last_type_read_for_nubar_d = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int var_NE_0d_int_Scalar;
  bool aux_NE_read = false;
  vartype aux_last_type_read_for_NE = UNKNOWN;
  NestedVector<double> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<NestedVector<double>> var_lambda_2d_double_NestedVector;
  NestedVector<double>* ptr_lambda_2d_idx0;
  NestedVector<NestedVector<double>> var_alpha_2d_double_NestedVector;
  NestedVector<double>* ptr_alpha_2d_idx0;
  vartype aux_last_type_read_for_alpha = UNKNOWN;
  double var_E1_0d_double_Scalar;
  bool aux_E1_read = false;
  vartype aux_last_type_read_for_E1 = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  NestedVector<double> var_nubar_d_1d_double_NestedVector;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 1;
  int mt = 455;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 455;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 1 , 455 / ZA , AWR , LDG , LNU , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LDG"]), write_opts);
  // assign expression to variable LDG
  var_LDG_0d_int_Scalar = py::cast<int>(cpp_current_dict["LDG"]);
  aux_LDG_read = true;
  validate_vartype_consistency("LDG", SCALAR_INT, aux_last_type_read_for_LDG);
  aux_last_type_read_for_LDG = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LNU"]), write_opts);
  // assign expression to variable LNU
  var_LNU_0d_int_Scalar = py::cast<int>(cpp_current_dict["LNU"]);
  aux_LNU_read = true;
  validate_vartype_consistency("LNU", SCALAR_INT, aux_last_type_read_for_LNU);
  aux_last_type_read_for_LNU = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(0)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NNF , 0 / \n { lambda } { k = 1 to NNF } ] LIST";
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        // read LIST record
        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NNF"]), write_opts);
        // assign expression to variable NNF
        var_NNF_0d_int_Scalar = py::cast<int>(cpp_current_dict["NNF"]);
        aux_NNF_read = true;
        validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
        aux_last_type_read_for_NNF = SCALAR_INT;
        cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NNF"]), write_opts);
        cont << cpp_draft_line;
        {
          int cpp_npl = py::cast<int>(cpp_current_dict["NNF"]);
          int cpp_i = 0;
          int cpp_j = 0;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read LIST body

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // read LIST body
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["lambda"][py::cast(var_k_0d_int_Scalar)]), write_opts);
            // assign expression to variable lambda
            var_lambda_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["lambda"][py::cast(var_k_0d_int_Scalar)]));
            validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
            aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
          }
          if (cpp_i != cpp_npl) {
            throw std::runtime_error("not exactly NPL elements consumed");
          }
        }
        cont << cpp_draft_line;
        cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nubar_d ] TAB1";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
        cpp_nr_val = py::len(cpp_current_dict["INT"]);
        cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
        cpp_np_val = py::len(cpp_current_dict["Eint"]);
        cont << cpp_draft_line;
        tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
        tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["nubar_d"]);
        tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
        tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
        write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
        {
          Tab1Body tab_body = tab1_body;
          // assign expression to variable Eint
          var_Eint_0d_floatvec_Scalar = tab_body.X;
          aux_Eint_read = true;
          validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
          aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
          // assign expression to variable nubar_d
          var_nubar_d_0d_floatvec_Scalar = tab_body.Y;
          aux_nubar_d_read = true;
          validate_vartype_consistency("nubar_d", SCALAR_FLOATVEC, aux_last_type_read_for_nubar_d);
          aux_last_type_read_for_nubar_d = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
        cont << cpp_draft_line;
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(1)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
          // read TAB2 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
          // assign expression to variable NE
          var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
          aux_NE_read = true;
          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
          aux_last_type_read_for_NE = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
          cpp_nr_val = py::len(cpp_current_dict["INT"]);
          cont << cpp_draft_line;
          tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
          tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
          write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
          {
            Tab2Body tab_body = tab2_body;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            cpp_template = "[ MAT , 1 , 455 / 0.0 , E , 0 , 0 , (NNF*2) , 0 / \n { lambda , alpha } { l = 1 to NNF } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST record
            cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]), write_opts);
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_current_dict["NNF"])*2), write_opts);
            // assign expression to variable cpp_int_val
            cpp_int_val = (py::cast<int>(cpp_current_dict["NNF"])*2);
            aux_cpp_int_val_read = true;
            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
            // assign expression to variable NNF
            var_NNF_0d_int_Scalar = (cpp_int_val/2);
            aux_NNF_read = true;
            validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
            aux_last_type_read_for_NNF = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_current_dict["NNF"])*2), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = (py::cast<int>(cpp_current_dict["NNF"])*2);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read LIST body
              ptr_lambda_2d_idx0 = var_lambda_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
              ptr_alpha_2d_idx0 = var_alpha_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                // read LIST body
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["lambda"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]), write_opts);
                // assign expression to variable lambda
                ptr_lambda_2d_idx0->set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["lambda"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]));
                validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
                aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["alpha"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]), write_opts);
                // assign expression to variable alpha
                ptr_alpha_2d_idx0->set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["alpha"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]));
                validate_vartype_consistency("alpha", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_alpha);
                aux_last_type_read_for_alpha = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
          }
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nubar_d ] TAB1";
          // read TAB1 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
          cpp_nr_val = py::len(cpp_current_dict["INT"]);
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
          cpp_np_val = py::len(cpp_current_dict["Eint"]);
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
          tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["nubar_d"]);
          tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Eint
            var_Eint_0d_floatvec_Scalar = tab_body.X;
            aux_Eint_read = true;
            validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
            aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
            // assign expression to variable nubar_d
            var_nubar_d_0d_floatvec_Scalar = tab_body.Y;
            aux_nubar_d_read = true;
            validate_vartype_consistency("nubar_d", SCALAR_FLOATVEC, aux_last_type_read_for_nubar_d);
            aux_last_type_read_for_nubar_d = SCALAR_FLOATVEC;
            if ((! (aux_INT_read == true))) {
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
            } else {
            }
            if ((! (aux_NBT_read == true))) {
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            } else {
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(0)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NNF , 0 / { lambda } { k = 1 to NNF } ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read LIST record
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NNF"]), write_opts);
          // assign expression to variable NNF
          var_NNF_0d_int_Scalar = py::cast<int>(cpp_current_dict["NNF"]);
          aux_NNF_read = true;
          validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
          aux_last_type_read_for_NNF = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NNF"]), write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = py::cast<int>(cpp_current_dict["NNF"]);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["lambda"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable lambda
              var_lambda_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["lambda"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
              aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , 1 , 0 / nubar_d ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read LIST record
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, 1, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, 1, write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = 1;
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST body
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["nubar_d"]), write_opts);
            // assign expression to variable nubar_d
            var_nubar_d_0d_double_Scalar = py::cast<double>(cpp_current_dict["nubar_d"]);
            aux_nubar_d_read = true;
            validate_vartype_consistency("nubar_d", SCALAR_DOUBLE, aux_last_type_read_for_nubar_d);
            aux_last_type_read_for_nubar_d = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LDG_read == true)) && ((var_LDG_0d_int_Scalar)==(1)))))&&((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
          // read TAB2 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
          // assign expression to variable NE
          var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
          aux_NE_read = true;
          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
          aux_last_type_read_for_NE = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
          cpp_nr_val = py::len(cpp_current_dict["INT"]);
          cont << cpp_draft_line;
          tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
          tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
          write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
          {
            Tab2Body tab_body = tab2_body;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            cpp_template = "[ MAT , 1 , 455 / 0.0 , E1 , 0 , 0 , (NNF*2) , 0 / \n { lambda , alpha } { l = 1 to NNF } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST record
            cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E1"]), write_opts);
            // assign expression to variable E1
            var_E1_0d_double_Scalar = py::cast<double>(cpp_current_dict["E1"]);
            aux_E1_read = true;
            validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
            aux_last_type_read_for_E1 = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_current_dict["NNF"])*2), write_opts);
            // assign expression to variable cpp_int_val
            cpp_int_val = (py::cast<int>(cpp_current_dict["NNF"])*2);
            aux_cpp_int_val_read = true;
            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
            // assign expression to variable NNF
            var_NNF_0d_int_Scalar = (cpp_int_val/2);
            aux_NNF_read = true;
            validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
            aux_last_type_read_for_NNF = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_current_dict["NNF"])*2), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = (py::cast<int>(cpp_current_dict["NNF"])*2);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read LIST body
              ptr_lambda_2d_idx0 = var_lambda_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
              ptr_alpha_2d_idx0 = var_alpha_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                // read LIST body
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["lambda"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]), write_opts);
                // assign expression to variable lambda
                ptr_lambda_2d_idx0->set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["lambda"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]));
                validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
                aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["alpha"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]), write_opts);
                // assign expression to variable alpha
                ptr_alpha_2d_idx0->set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["alpha"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]));
                validate_vartype_consistency("alpha", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_alpha);
                aux_last_type_read_for_alpha = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
          }
          cpp_template = "[ MAT , 1 , 455 / 0.0 , 0.0 , 0 , 0 , NC , 0 / { nubar_d } { k = 1 to NC } ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read LIST record
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NC"]), write_opts);
          // assign expression to variable NC
          var_NC_0d_int_Scalar = py::cast<int>(cpp_current_dict["NC"]);
          aux_NC_read = true;
          validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
          aux_last_type_read_for_NC = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NC"]), write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = py::cast<int>(cpp_current_dict["NC"]);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NC_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["nubar_d"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable nubar_d
              var_nubar_d_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["nubar_d"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("nubar_d", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_nubar_d);
              aux_last_type_read_for_nubar_d = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: dc95e75784d9f676b28daf84959ecfb2
// MD5 hash of the following function definition: 162986d6d271b56fc2e68fd6a5b92506
void write_mf1mt456_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LNU_0d_int_Scalar;
  bool aux_LNU_read = false;
  vartype aux_last_type_read_for_LNU = UNKNOWN;
  std::vector<double> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<double> var_nubar_p_0d_floatvec_Scalar;
  double var_nubar_p_0d_double_Scalar;
  bool aux_nubar_p_read = false;
  vartype aux_last_type_read_for_nubar_p = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 1;
  int mt = 456;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 456;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 1 , 456 / ZA , AWR , 0 , LNU , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LNU"]), write_opts);
  // assign expression to variable LNU
  var_LNU_0d_int_Scalar = py::cast<int>(cpp_current_dict["LNU"]);
  aux_LNU_read = true;
  validate_vartype_consistency("LNU", SCALAR_INT, aux_last_type_read_for_LNU);
  aux_last_type_read_for_LNU = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(2)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 1 , 456 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / nubar_p ] TAB1";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
        cpp_nr_val = py::len(cpp_current_dict["INT"]);
        cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
        cpp_np_val = py::len(cpp_current_dict["Eint"]);
        cont << cpp_draft_line;
        tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
        tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["nubar_p"]);
        tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
        tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
        write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
        {
          Tab1Body tab_body = tab1_body;
          // assign expression to variable Eint
          var_Eint_0d_floatvec_Scalar = tab_body.X;
          aux_Eint_read = true;
          validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
          aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
          // assign expression to variable nubar_p
          var_nubar_p_0d_floatvec_Scalar = tab_body.Y;
          aux_nubar_p_read = true;
          validate_vartype_consistency("nubar_p", SCALAR_FLOATVEC, aux_last_type_read_for_nubar_p);
          aux_last_type_read_for_nubar_p = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
        cont << cpp_draft_line;
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LNU_read == true)) && ((var_LNU_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 1 , 456 / 0.0 , 0.0 , 0 , 0 , 1 , 0 / nubar_p ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read LIST record
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, 1, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, 1, write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = 1;
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST body
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["nubar_p"]), write_opts);
            // assign expression to variable nubar_p
            var_nubar_p_0d_double_Scalar = py::cast<double>(cpp_current_dict["nubar_p"]);
            aux_nubar_p_read = true;
            validate_vartype_consistency("nubar_p", SCALAR_DOUBLE, aux_last_type_read_for_nubar_p);
            aux_last_type_read_for_nubar_p = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 5b7d22a0815ff99a2cbd6db8a6ad59a3
// MD5 hash of the following function definition: 6545695b425fbf0e1f28ab66f5e40c65
void write_mf1mt458_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LFC_0d_int_Scalar;
  bool aux_LFC_read = false;
  vartype aux_last_type_read_for_LFC = UNKNOWN;
  int var_NPLY_0d_int_Scalar;
  bool aux_NPLY_read = false;
  vartype aux_last_type_read_for_NPLY = UNKNOWN;
  double var_EFR_0d_double_Scalar;
  bool aux_EFR_read = false;
  vartype aux_last_type_read_for_EFR = UNKNOWN;
  double var_dEFR_0d_double_Scalar;
  bool aux_dEFR_read = false;
  vartype aux_last_type_read_for_dEFR = UNKNOWN;
  double var_ENP_0d_double_Scalar;
  bool aux_ENP_read = false;
  vartype aux_last_type_read_for_ENP = UNKNOWN;
  double var_dENP_0d_double_Scalar;
  bool aux_dENP_read = false;
  vartype aux_last_type_read_for_dENP = UNKNOWN;
  double var_END_0d_double_Scalar;
  bool aux_END_read = false;
  vartype aux_last_type_read_for_END = UNKNOWN;
  double var_dEND_0d_double_Scalar;
  bool aux_dEND_read = false;
  vartype aux_last_type_read_for_dEND = UNKNOWN;
  double var_EGP_0d_double_Scalar;
  bool aux_EGP_read = false;
  vartype aux_last_type_read_for_EGP = UNKNOWN;
  double var_dEGP_0d_double_Scalar;
  bool aux_dEGP_read = false;
  vartype aux_last_type_read_for_dEGP = UNKNOWN;
  double var_EGD_0d_double_Scalar;
  bool aux_EGD_read = false;
  vartype aux_last_type_read_for_EGD = UNKNOWN;
  double var_dEGD_0d_double_Scalar;
  bool aux_dEGD_read = false;
  vartype aux_last_type_read_for_dEGD = UNKNOWN;
  double var_EB_0d_double_Scalar;
  bool aux_EB_read = false;
  vartype aux_last_type_read_for_EB = UNKNOWN;
  double var_dEB_0d_double_Scalar;
  bool aux_dEB_read = false;
  vartype aux_last_type_read_for_dEB = UNKNOWN;
  double var_ENU_0d_double_Scalar;
  bool aux_ENU_read = false;
  vartype aux_last_type_read_for_ENU = UNKNOWN;
  double var_dENU_0d_double_Scalar;
  bool aux_dENU_read = false;
  vartype aux_last_type_read_for_dENU = UNKNOWN;
  double var_ER_0d_double_Scalar;
  bool aux_ER_read = false;
  vartype aux_last_type_read_for_ER = UNKNOWN;
  double var_dER_0d_double_Scalar;
  bool aux_dER_read = false;
  vartype aux_last_type_read_for_dER = UNKNOWN;
  double var_ET_0d_double_Scalar;
  bool aux_ET_read = false;
  vartype aux_last_type_read_for_ET = UNKNOWN;
  double var_dET_0d_double_Scalar;
  bool aux_dET_read = false;
  vartype aux_last_type_read_for_dET = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<double> var_c_EFR_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EFR = UNKNOWN;
  NestedVector<double> var_dc_EFR_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EFR = UNKNOWN;
  NestedVector<double> var_c_ENP_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ENP = UNKNOWN;
  NestedVector<double> var_dc_ENP_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ENP = UNKNOWN;
  NestedVector<double> var_c_END_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_END = UNKNOWN;
  NestedVector<double> var_dc_END_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_END = UNKNOWN;
  NestedVector<double> var_c_EGP_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EGP = UNKNOWN;
  NestedVector<double> var_dc_EGP_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EGP = UNKNOWN;
  NestedVector<double> var_c_EGD_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EGD = UNKNOWN;
  NestedVector<double> var_dc_EGD_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EGD = UNKNOWN;
  NestedVector<double> var_c_EB_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_EB = UNKNOWN;
  NestedVector<double> var_dc_EB_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_EB = UNKNOWN;
  NestedVector<double> var_c_ENU_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ENU = UNKNOWN;
  NestedVector<double> var_dc_ENU_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ENU = UNKNOWN;
  NestedVector<double> var_c_ER_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ER = UNKNOWN;
  NestedVector<double> var_dc_ER_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ER = UNKNOWN;
  NestedVector<double> var_c_ET_1d_double_NestedVector;
  vartype aux_last_type_read_for_c_ET = UNKNOWN;
  NestedVector<double> var_dc_ET_1d_double_NestedVector;
  vartype aux_last_type_read_for_dc_ET = UNKNOWN;
  int var_NFC_0d_int_Scalar;
  bool aux_NFC_read = false;
  vartype aux_last_type_read_for_NFC = UNKNOWN;
  NestedVector<int> var_LDRV_1d_int_NestedVector;
  vartype aux_last_type_read_for_LDRV = UNKNOWN;
  NestedVector<int> var_IFC_1d_int_NestedVector;
  vartype aux_last_type_read_for_IFC = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 1;
  int mt = 458;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 458;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LFC_0d_int_Scalar = var_LFC_0d_int_Scalar;
          int var_LFC_0d_int_Scalar = glob_var_LFC_0d_int_Scalar;
          bool& glob_aux_LFC_read = aux_LFC_read;
          bool aux_LFC_read = glob_aux_LFC_read;
          vartype aux_last_type_read_for_LFC = UNKNOWN;
          int& glob_var_NPLY_0d_int_Scalar = var_NPLY_0d_int_Scalar;
          int var_NPLY_0d_int_Scalar = glob_var_NPLY_0d_int_Scalar;
          bool& glob_aux_NPLY_read = aux_NPLY_read;
          bool aux_NPLY_read = glob_aux_NPLY_read;
          vartype aux_last_type_read_for_NPLY = UNKNOWN;
          cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ZA", -99999.9));
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AWR", -99999.9));
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LFC
          var_LFC_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LFC", -99999));
          aux_LFC_read = true;
          validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
          aux_last_type_read_for_LFC = SCALAR_INT;
          cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
          // read LIST record
          // assign expression to variable NPLY
          var_NPLY_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NPLY", -99999));
          aux_NPLY_read = true;
          validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
          aux_last_type_read_for_NPLY = SCALAR_INT;
          if (((((((((aux_LFC_read == true)) && ((var_LFC_0d_int_Scalar)==(0)))))&&((((aux_NPLY_read == true)) && ((var_NPLY_0d_int_Scalar)==(0)))))))) {
            cpp_found_match = true;
          }
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read CONT record
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LFC"]), write_opts);
          // assign expression to variable LFC
          var_LFC_0d_int_Scalar = py::cast<int>(cpp_current_dict["LFC"]);
          aux_LFC_read = true;
          validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
          aux_last_type_read_for_LFC = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cont << cpp_draft_line;
          cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read LIST record
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["NPLY"]), write_opts);
          // assign expression to variable NPLY
          var_NPLY_0d_int_Scalar = py::cast<int>(cpp_current_dict["NPLY"]);
          aux_NPLY_read = true;
          validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
          aux_last_type_read_for_NPLY = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, 18, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, 9, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, 18, write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = 18;
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST body
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["EFR"]), write_opts);
            // assign expression to variable EFR
            var_EFR_0d_double_Scalar = py::cast<double>(cpp_current_dict["EFR"]);
            aux_EFR_read = true;
            validate_vartype_consistency("EFR", SCALAR_DOUBLE, aux_last_type_read_for_EFR);
            aux_last_type_read_for_EFR = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dEFR"]), write_opts);
            // assign expression to variable dEFR
            var_dEFR_0d_double_Scalar = py::cast<double>(cpp_current_dict["dEFR"]);
            aux_dEFR_read = true;
            validate_vartype_consistency("dEFR", SCALAR_DOUBLE, aux_last_type_read_for_dEFR);
            aux_last_type_read_for_dEFR = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ENP"]), write_opts);
            // assign expression to variable ENP
            var_ENP_0d_double_Scalar = py::cast<double>(cpp_current_dict["ENP"]);
            aux_ENP_read = true;
            validate_vartype_consistency("ENP", SCALAR_DOUBLE, aux_last_type_read_for_ENP);
            aux_last_type_read_for_ENP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dENP"]), write_opts);
            // assign expression to variable dENP
            var_dENP_0d_double_Scalar = py::cast<double>(cpp_current_dict["dENP"]);
            aux_dENP_read = true;
            validate_vartype_consistency("dENP", SCALAR_DOUBLE, aux_last_type_read_for_dENP);
            aux_last_type_read_for_dENP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["END"]), write_opts);
            // assign expression to variable END
            var_END_0d_double_Scalar = py::cast<double>(cpp_current_dict["END"]);
            aux_END_read = true;
            validate_vartype_consistency("END", SCALAR_DOUBLE, aux_last_type_read_for_END);
            aux_last_type_read_for_END = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dEND"]), write_opts);
            // assign expression to variable dEND
            var_dEND_0d_double_Scalar = py::cast<double>(cpp_current_dict["dEND"]);
            aux_dEND_read = true;
            validate_vartype_consistency("dEND", SCALAR_DOUBLE, aux_last_type_read_for_dEND);
            aux_last_type_read_for_dEND = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["EGP"]), write_opts);
            // assign expression to variable EGP
            var_EGP_0d_double_Scalar = py::cast<double>(cpp_current_dict["EGP"]);
            aux_EGP_read = true;
            validate_vartype_consistency("EGP", SCALAR_DOUBLE, aux_last_type_read_for_EGP);
            aux_last_type_read_for_EGP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dEGP"]), write_opts);
            // assign expression to variable dEGP
            var_dEGP_0d_double_Scalar = py::cast<double>(cpp_current_dict["dEGP"]);
            aux_dEGP_read = true;
            validate_vartype_consistency("dEGP", SCALAR_DOUBLE, aux_last_type_read_for_dEGP);
            aux_last_type_read_for_dEGP = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["EGD"]), write_opts);
            // assign expression to variable EGD
            var_EGD_0d_double_Scalar = py::cast<double>(cpp_current_dict["EGD"]);
            aux_EGD_read = true;
            validate_vartype_consistency("EGD", SCALAR_DOUBLE, aux_last_type_read_for_EGD);
            aux_last_type_read_for_EGD = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dEGD"]), write_opts);
            // assign expression to variable dEGD
            var_dEGD_0d_double_Scalar = py::cast<double>(cpp_current_dict["dEGD"]);
            aux_dEGD_read = true;
            validate_vartype_consistency("dEGD", SCALAR_DOUBLE, aux_last_type_read_for_dEGD);
            aux_last_type_read_for_dEGD = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["EB"]), write_opts);
            // assign expression to variable EB
            var_EB_0d_double_Scalar = py::cast<double>(cpp_current_dict["EB"]);
            aux_EB_read = true;
            validate_vartype_consistency("EB", SCALAR_DOUBLE, aux_last_type_read_for_EB);
            aux_last_type_read_for_EB = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dEB"]), write_opts);
            // assign expression to variable dEB
            var_dEB_0d_double_Scalar = py::cast<double>(cpp_current_dict["dEB"]);
            aux_dEB_read = true;
            validate_vartype_consistency("dEB", SCALAR_DOUBLE, aux_last_type_read_for_dEB);
            aux_last_type_read_for_dEB = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ENU"]), write_opts);
            // assign expression to variable ENU
            var_ENU_0d_double_Scalar = py::cast<double>(cpp_current_dict["ENU"]);
            aux_ENU_read = true;
            validate_vartype_consistency("ENU", SCALAR_DOUBLE, aux_last_type_read_for_ENU);
            aux_last_type_read_for_ENU = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dENU"]), write_opts);
            // assign expression to variable dENU
            var_dENU_0d_double_Scalar = py::cast<double>(cpp_current_dict["dENU"]);
            aux_dENU_read = true;
            validate_vartype_consistency("dENU", SCALAR_DOUBLE, aux_last_type_read_for_dENU);
            aux_last_type_read_for_dENU = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"]), write_opts);
            // assign expression to variable ER
            var_ER_0d_double_Scalar = py::cast<double>(cpp_current_dict["ER"]);
            aux_ER_read = true;
            validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
            aux_last_type_read_for_ER = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dER"]), write_opts);
            // assign expression to variable dER
            var_dER_0d_double_Scalar = py::cast<double>(cpp_current_dict["dER"]);
            aux_dER_read = true;
            validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
            aux_last_type_read_for_dER = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ET"]), write_opts);
            // assign expression to variable ET
            var_ET_0d_double_Scalar = py::cast<double>(cpp_current_dict["ET"]);
            aux_ET_read = true;
            validate_vartype_consistency("ET", SCALAR_DOUBLE, aux_last_type_read_for_ET);
            aux_last_type_read_for_ET = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dET"]), write_opts);
            // assign expression to variable dET
            var_dET_0d_double_Scalar = py::cast<double>(cpp_current_dict["dET"]);
            aux_dET_read = true;
            validate_vartype_consistency("dET", SCALAR_DOUBLE, aux_last_type_read_for_dET);
            aux_last_type_read_for_dET = SCALAR_DOUBLE;
            cpp_i++;
            cpp_j++;
            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
              cont << cpp_draft_line;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_j = 0;
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LFC_0d_int_Scalar = var_LFC_0d_int_Scalar;
            int var_LFC_0d_int_Scalar = glob_var_LFC_0d_int_Scalar;
            bool& glob_aux_LFC_read = aux_LFC_read;
            bool aux_LFC_read = glob_aux_LFC_read;
            vartype aux_last_type_read_for_LFC = UNKNOWN;
            int& glob_var_NPLY_0d_int_Scalar = var_NPLY_0d_int_Scalar;
            int var_NPLY_0d_int_Scalar = glob_var_NPLY_0d_int_Scalar;
            bool& glob_aux_NPLY_read = aux_NPLY_read;
            bool aux_NPLY_read = glob_aux_NPLY_read;
            vartype aux_last_type_read_for_NPLY = UNKNOWN;
            int& glob_cpp_int_val = cpp_int_val;
            int cpp_int_val = glob_cpp_int_val;
            bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
            bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ZA", -99999.9));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AWR", -99999.9));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LFC", -99999));
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , (18*(NPLY+1)) , (9*(NPLY+1)) / \n { c_EFR , dc_EFR , c_ENP , dc_ENP , c_END , dc_END , \n c_EGP , dc_EGP , c_EGD , dc_EGD , c_EB , dc_EB , \n c_ENU , dc_ENU , c_ER , dc_ER , c_ET , dc_ET } { k = 0 to NPLY } ] LIST";
            // read LIST record
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NPLY", -99999));
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
            if ((! (aux_NPLY_read == true))) {
              // assign expression to variable cpp_int_val
              cpp_int_val = (18*(py::cast<int>(cpp_current_dict.attr("get")("NPLY", -99999))+1));
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = ((cpp_int_val+(-18))/18);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } else {
            }
            if ((! (aux_NPLY_read == true))) {
              // assign expression to variable cpp_int_val
              cpp_int_val = (9*(py::cast<int>(cpp_current_dict.attr("get")("NPLY", -99999))+1));
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = ((cpp_int_val+(-9))/9);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } else {
            }
            if (((((((((aux_LFC_read == true)) && ((var_LFC_0d_int_Scalar)==(0)))))&&((((aux_NPLY_read == true)) && ((var_NPLY_0d_int_Scalar)>(0)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , 0 ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read CONT record
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LFC"]), write_opts);
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = py::cast<int>(cpp_current_dict["LFC"]);
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cont << cpp_draft_line;
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , (18*(NPLY+1)) , (9*(NPLY+1)) / \n { c_EFR , dc_EFR , c_ENP , dc_ENP , c_END , dc_END , \n c_EGP , dc_EGP , c_EGD , dc_EGD , c_EB , dc_EB , \n c_ENU , dc_ENU , c_ER , dc_ER , c_ET , dc_ET } { k = 0 to NPLY } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST record
            cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["NPLY"]), write_opts);
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = py::cast<int>(cpp_current_dict["NPLY"]);
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, (18*(py::cast<int>(cpp_current_dict["NPLY"])+1)), write_opts);
            if ((! (aux_NPLY_read == true))) {
              // assign expression to variable cpp_int_val
              cpp_int_val = (18*(py::cast<int>(cpp_current_dict["NPLY"])+1));
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = ((cpp_int_val+(-18))/18);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } else {
            }
            cpp_write_field<int>(cpp_draft_line, 5, (9*(py::cast<int>(cpp_current_dict["NPLY"])+1)), write_opts);
            if ((! (aux_NPLY_read == true))) {
              // assign expression to variable cpp_int_val
              cpp_int_val = (9*(py::cast<int>(cpp_current_dict["NPLY"])+1));
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NPLY
              var_NPLY_0d_int_Scalar = ((cpp_int_val+(-9))/9);
              aux_NPLY_read = true;
              validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
              aux_last_type_read_for_NPLY = SCALAR_INT;
            } else {
            }
            cpp_write_field<int>(cpp_draft_line, 4, (18*(py::cast<int>(cpp_current_dict["NPLY"])+1)), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = (18*(py::cast<int>(cpp_current_dict["NPLY"])+1));
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read LIST body

              for (int var_k_0d_int_Scalar = 0;
                 var_k_0d_int_Scalar <= var_NPLY_0d_int_Scalar; var_k_0d_int_Scalar++) {
                bool aux_k_read = true;
                // read LIST body
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["c_EFR"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable c_EFR
                var_c_EFR_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["c_EFR"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("c_EFR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EFR);
                aux_last_type_read_for_c_EFR = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dc_EFR"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable dc_EFR
                var_dc_EFR_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["dc_EFR"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("dc_EFR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EFR);
                aux_last_type_read_for_dc_EFR = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["c_ENP"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable c_ENP
                var_c_ENP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["c_ENP"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("c_ENP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ENP);
                aux_last_type_read_for_c_ENP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dc_ENP"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable dc_ENP
                var_dc_ENP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["dc_ENP"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("dc_ENP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ENP);
                aux_last_type_read_for_dc_ENP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["c_END"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable c_END
                var_c_END_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["c_END"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("c_END", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_END);
                aux_last_type_read_for_c_END = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dc_END"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable dc_END
                var_dc_END_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["dc_END"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("dc_END", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_END);
                aux_last_type_read_for_dc_END = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["c_EGP"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable c_EGP
                var_c_EGP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["c_EGP"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("c_EGP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EGP);
                aux_last_type_read_for_c_EGP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dc_EGP"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable dc_EGP
                var_dc_EGP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["dc_EGP"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("dc_EGP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EGP);
                aux_last_type_read_for_dc_EGP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["c_EGD"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable c_EGD
                var_c_EGD_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["c_EGD"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("c_EGD", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EGD);
                aux_last_type_read_for_c_EGD = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dc_EGD"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable dc_EGD
                var_dc_EGD_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["dc_EGD"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("dc_EGD", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EGD);
                aux_last_type_read_for_dc_EGD = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["c_EB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable c_EB
                var_c_EB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["c_EB"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("c_EB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_EB);
                aux_last_type_read_for_c_EB = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dc_EB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable dc_EB
                var_dc_EB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["dc_EB"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("dc_EB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_EB);
                aux_last_type_read_for_dc_EB = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["c_ENU"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable c_ENU
                var_c_ENU_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["c_ENU"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("c_ENU", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ENU);
                aux_last_type_read_for_c_ENU = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dc_ENU"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable dc_ENU
                var_dc_ENU_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["dc_ENU"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("dc_ENU", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ENU);
                aux_last_type_read_for_dc_ENU = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["c_ER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable c_ER
                var_c_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["c_ER"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("c_ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ER);
                aux_last_type_read_for_c_ER = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dc_ER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable dc_ER
                var_dc_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["dc_ER"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("dc_ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ER);
                aux_last_type_read_for_dc_ER = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["c_ET"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable c_ET
                var_c_ET_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["c_ET"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("c_ET", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_c_ET);
                aux_last_type_read_for_c_ET = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dc_ET"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable dc_ET
                var_dc_ET_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["dc_ET"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("dc_ET", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dc_ET);
                aux_last_type_read_for_dc_ET = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LFC_0d_int_Scalar = var_LFC_0d_int_Scalar;
            int var_LFC_0d_int_Scalar = glob_var_LFC_0d_int_Scalar;
            bool& glob_aux_LFC_read = aux_LFC_read;
            bool aux_LFC_read = glob_aux_LFC_read;
            vartype aux_last_type_read_for_LFC = UNKNOWN;
            int& glob_var_NFC_0d_int_Scalar = var_NFC_0d_int_Scalar;
            int var_NFC_0d_int_Scalar = glob_var_NFC_0d_int_Scalar;
            bool& glob_aux_NFC_read = aux_NFC_read;
            bool aux_NFC_read = glob_aux_NFC_read;
            vartype aux_last_type_read_for_NFC = UNKNOWN;
            int& glob_var_NPLY_0d_int_Scalar = var_NPLY_0d_int_Scalar;
            int var_NPLY_0d_int_Scalar = glob_var_NPLY_0d_int_Scalar;
            bool& glob_aux_NPLY_read = aux_NPLY_read;
            bool aux_NPLY_read = glob_aux_NPLY_read;
            vartype aux_last_type_read_for_NPLY = UNKNOWN;
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , NFC ] HEAD";
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ZA", -99999.9));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AWR", -99999.9));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LFC", -99999));
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            // assign expression to variable NFC
            var_NFC_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NFC", -99999));
            aux_NFC_read = true;
            validate_vartype_consistency("NFC", SCALAR_INT, aux_last_type_read_for_NFC);
            aux_last_type_read_for_NFC = SCALAR_INT;
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
            // read LIST record
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NPLY", -99999));
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
            if (((((((((aux_LFC_read == true)) && ((var_LFC_0d_int_Scalar)==(1)))))&&((((aux_NPLY_read == true)) && ((var_NPLY_0d_int_Scalar)==(0)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 1 , 458 / ZA , AWR , 0 , LFC , 0 , NFC ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read CONT record
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LFC"]), write_opts);
            // assign expression to variable LFC
            var_LFC_0d_int_Scalar = py::cast<int>(cpp_current_dict["LFC"]);
            aux_LFC_read = true;
            validate_vartype_consistency("LFC", SCALAR_INT, aux_last_type_read_for_LFC);
            aux_last_type_read_for_LFC = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NFC"]), write_opts);
            // assign expression to variable NFC
            var_NFC_0d_int_Scalar = py::cast<int>(cpp_current_dict["NFC"]);
            aux_NFC_read = true;
            validate_vartype_consistency("NFC", SCALAR_INT, aux_last_type_read_for_NFC);
            aux_last_type_read_for_NFC = SCALAR_INT;
            cont << cpp_draft_line;
            cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , 0 , NPLY , 18 , 9 / \n EFR , dEFR , ENP , dENP , END , dEND , \n EGP , dEGP , EGD , dEGD , EB , dEB , \n ENU , dENU , ER , dER , ET , dET ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST record
            cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["NPLY"]), write_opts);
            // assign expression to variable NPLY
            var_NPLY_0d_int_Scalar = py::cast<int>(cpp_current_dict["NPLY"]);
            aux_NPLY_read = true;
            validate_vartype_consistency("NPLY", SCALAR_INT, aux_last_type_read_for_NPLY);
            aux_last_type_read_for_NPLY = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, 18, write_opts);
            cpp_write_field<int>(cpp_draft_line, 5, 9, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, 18, write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = 18;
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read LIST body
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["EFR"]), write_opts);
              // assign expression to variable EFR
              var_EFR_0d_double_Scalar = py::cast<double>(cpp_current_dict["EFR"]);
              aux_EFR_read = true;
              validate_vartype_consistency("EFR", SCALAR_DOUBLE, aux_last_type_read_for_EFR);
              aux_last_type_read_for_EFR = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dEFR"]), write_opts);
              // assign expression to variable dEFR
              var_dEFR_0d_double_Scalar = py::cast<double>(cpp_current_dict["dEFR"]);
              aux_dEFR_read = true;
              validate_vartype_consistency("dEFR", SCALAR_DOUBLE, aux_last_type_read_for_dEFR);
              aux_last_type_read_for_dEFR = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ENP"]), write_opts);
              // assign expression to variable ENP
              var_ENP_0d_double_Scalar = py::cast<double>(cpp_current_dict["ENP"]);
              aux_ENP_read = true;
              validate_vartype_consistency("ENP", SCALAR_DOUBLE, aux_last_type_read_for_ENP);
              aux_last_type_read_for_ENP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dENP"]), write_opts);
              // assign expression to variable dENP
              var_dENP_0d_double_Scalar = py::cast<double>(cpp_current_dict["dENP"]);
              aux_dENP_read = true;
              validate_vartype_consistency("dENP", SCALAR_DOUBLE, aux_last_type_read_for_dENP);
              aux_last_type_read_for_dENP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["END"]), write_opts);
              // assign expression to variable END
              var_END_0d_double_Scalar = py::cast<double>(cpp_current_dict["END"]);
              aux_END_read = true;
              validate_vartype_consistency("END", SCALAR_DOUBLE, aux_last_type_read_for_END);
              aux_last_type_read_for_END = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dEND"]), write_opts);
              // assign expression to variable dEND
              var_dEND_0d_double_Scalar = py::cast<double>(cpp_current_dict["dEND"]);
              aux_dEND_read = true;
              validate_vartype_consistency("dEND", SCALAR_DOUBLE, aux_last_type_read_for_dEND);
              aux_last_type_read_for_dEND = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["EGP"]), write_opts);
              // assign expression to variable EGP
              var_EGP_0d_double_Scalar = py::cast<double>(cpp_current_dict["EGP"]);
              aux_EGP_read = true;
              validate_vartype_consistency("EGP", SCALAR_DOUBLE, aux_last_type_read_for_EGP);
              aux_last_type_read_for_EGP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dEGP"]), write_opts);
              // assign expression to variable dEGP
              var_dEGP_0d_double_Scalar = py::cast<double>(cpp_current_dict["dEGP"]);
              aux_dEGP_read = true;
              validate_vartype_consistency("dEGP", SCALAR_DOUBLE, aux_last_type_read_for_dEGP);
              aux_last_type_read_for_dEGP = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["EGD"]), write_opts);
              // assign expression to variable EGD
              var_EGD_0d_double_Scalar = py::cast<double>(cpp_current_dict["EGD"]);
              aux_EGD_read = true;
              validate_vartype_consistency("EGD", SCALAR_DOUBLE, aux_last_type_read_for_EGD);
              aux_last_type_read_for_EGD = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dEGD"]), write_opts);
              // assign expression to variable dEGD
              var_dEGD_0d_double_Scalar = py::cast<double>(cpp_current_dict["dEGD"]);
              aux_dEGD_read = true;
              validate_vartype_consistency("dEGD", SCALAR_DOUBLE, aux_last_type_read_for_dEGD);
              aux_last_type_read_for_dEGD = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["EB"]), write_opts);
              // assign expression to variable EB
              var_EB_0d_double_Scalar = py::cast<double>(cpp_current_dict["EB"]);
              aux_EB_read = true;
              validate_vartype_consistency("EB", SCALAR_DOUBLE, aux_last_type_read_for_EB);
              aux_last_type_read_for_EB = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dEB"]), write_opts);
              // assign expression to variable dEB
              var_dEB_0d_double_Scalar = py::cast<double>(cpp_current_dict["dEB"]);
              aux_dEB_read = true;
              validate_vartype_consistency("dEB", SCALAR_DOUBLE, aux_last_type_read_for_dEB);
              aux_last_type_read_for_dEB = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ENU"]), write_opts);
              // assign expression to variable ENU
              var_ENU_0d_double_Scalar = py::cast<double>(cpp_current_dict["ENU"]);
              aux_ENU_read = true;
              validate_vartype_consistency("ENU", SCALAR_DOUBLE, aux_last_type_read_for_ENU);
              aux_last_type_read_for_ENU = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dENU"]), write_opts);
              // assign expression to variable dENU
              var_dENU_0d_double_Scalar = py::cast<double>(cpp_current_dict["dENU"]);
              aux_dENU_read = true;
              validate_vartype_consistency("dENU", SCALAR_DOUBLE, aux_last_type_read_for_dENU);
              aux_last_type_read_for_dENU = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"]), write_opts);
              // assign expression to variable ER
              var_ER_0d_double_Scalar = py::cast<double>(cpp_current_dict["ER"]);
              aux_ER_read = true;
              validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
              aux_last_type_read_for_ER = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dER"]), write_opts);
              // assign expression to variable dER
              var_dER_0d_double_Scalar = py::cast<double>(cpp_current_dict["dER"]);
              aux_dER_read = true;
              validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
              aux_last_type_read_for_dER = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ET"]), write_opts);
              // assign expression to variable ET
              var_ET_0d_double_Scalar = py::cast<double>(cpp_current_dict["ET"]);
              aux_ET_read = true;
              validate_vartype_consistency("ET", SCALAR_DOUBLE, aux_last_type_read_for_ET);
              aux_last_type_read_for_ET = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dET"]), write_opts);
              // assign expression to variable dET
              var_dET_0d_double_Scalar = py::cast<double>(cpp_current_dict["dET"]);
              aux_dET_read = true;
              validate_vartype_consistency("dET", SCALAR_DOUBLE, aux_last_type_read_for_dET);
              aux_last_type_read_for_dET = SCALAR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NFC_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              cpp_template = "[ MAT , 1 , 458 / 0.0 , 0.0 , LDRV , IFC , NR , NP / Eint / EIFC ] TAB1 ( fiscomp [ k ] )";
              // read TAB1 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LDRV"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable LDRV
              var_LDRV_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["LDRV"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("LDRV", NESTEDVECTOR_INT, aux_last_type_read_for_LDRV);
              aux_last_type_read_for_LDRV = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["IFC"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable IFC
              var_IFC_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["IFC"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("IFC", NESTEDVECTOR_INT, aux_last_type_read_for_IFC);
              aux_last_type_read_for_IFC = NESTEDVECTOR_INT;
              {
                py::dict cpp_parent_dict_tmp = cpp_current_dict;
                if ((! cpp_parent_dict_tmp.contains("fiscomp"))) {
                  cpp_parent_dict_tmp["fiscomp"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict_tmp["fiscomp"];
                if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                  cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                }
                cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                cpp_nr_val = py::len(cpp_current_dict["INT"]);
                cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
                cpp_np_val = py::len(cpp_current_dict["Eint"]);
                cont << cpp_draft_line;
                tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
                tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["EIFC"]);
                tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                // variable declarations
                std::vector<double> var_Eint_0d_floatvec_Scalar;
                bool aux_Eint_read = false;
                vartype aux_last_type_read_for_Eint = UNKNOWN;
                std::vector<double> var_EIFC_0d_floatvec_Scalar;
                bool aux_EIFC_read = false;
                vartype aux_last_type_read_for_EIFC = UNKNOWN;
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab1Body tab_body = tab1_body;
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                  // assign expression to variable EIFC
                  var_EIFC_0d_floatvec_Scalar = tab_body.Y;
                  aux_EIFC_read = true;
                  validate_vartype_consistency("EIFC", SCALAR_FLOATVEC, aux_last_type_read_for_EIFC);
                  aux_last_type_read_for_EIFC = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
                cpp_current_dict = cpp_parent_dict_tmp;
              }
            }
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 446edfca967a9a8a84a4dade6f54784f
// MD5 hash of the following function definition: b845e034a9f459ad5067e6acccb063e2
void write_mf1mt460_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LO_0d_int_Scalar;
  bool aux_LO_read = false;
  vartype aux_last_type_read_for_LO = UNKNOWN;
  int var_NG_0d_int_Scalar;
  bool aux_NG_read = false;
  vartype aux_last_type_read_for_NG = UNKNOWN;
  NestedVector<double> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<std::vector<double>> var_tint_1d_floatvec_NestedVector;
  vartype aux_last_type_read_for_tint = UNKNOWN;
  NestedVector<std::vector<double>> var_T_1d_floatvec_NestedVector;
  vartype aux_last_type_read_for_T = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int var_NNF_0d_int_Scalar;
  bool aux_NNF_read = false;
  vartype aux_last_type_read_for_NNF = UNKNOWN;
  NestedVector<double> var_lambda_1d_double_NestedVector;
  vartype aux_last_type_read_for_lambda = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 1;
  int mt = 460;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 1;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 460;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
          int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
          bool& glob_aux_LO_read = aux_LO_read;
          bool aux_LO_read = glob_aux_LO_read;
          vartype aux_last_type_read_for_LO = UNKNOWN;
          int& glob_var_NG_0d_int_Scalar = var_NG_0d_int_Scalar;
          int var_NG_0d_int_Scalar = glob_var_NG_0d_int_Scalar;
          bool& glob_aux_NG_read = aux_NG_read;
          bool aux_NG_read = glob_aux_NG_read;
          vartype aux_last_type_read_for_NG = UNKNOWN;
          cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , NG , 0 ] HEAD";
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ZA", -99999.9));
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AWR", -99999.9));
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LO
          var_LO_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LO", -99999));
          aux_LO_read = true;
          validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
          aux_last_type_read_for_LO = SCALAR_INT;
          // assign expression to variable NG
          var_NG_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NG", -99999));
          aux_NG_read = true;
          validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
          aux_last_type_read_for_NG = SCALAR_INT;
          if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(1)))))))) {
            cpp_found_match = true;
          }
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , NG , 0 ] HEAD";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read CONT record
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LO"]), write_opts);
          // assign expression to variable LO
          var_LO_0d_int_Scalar = py::cast<int>(cpp_current_dict["LO"]);
          aux_LO_read = true;
          validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
          aux_last_type_read_for_LO = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NG"]), write_opts);
          // assign expression to variable NG
          var_NG_0d_int_Scalar = py::cast<int>(cpp_current_dict["NG"]);
          aux_NG_read = true;
          validate_vartype_consistency("NG", SCALAR_INT, aux_last_type_read_for_NG);
          aux_last_type_read_for_NG = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cont << cpp_draft_line;

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_NG_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 1 , 460 / E , 0.0 , i , 0 , NR , NP / tint [ i ] / T [ i ] ] TAB1";
            // read TAB1 record
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]), write_opts);
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["i"]), write_opts);
            if ((! (aux_i_read == true))) {
              // assign expression to variable i
            } else {
            }
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
            cpp_nr_val = py::len(cpp_current_dict["INT"]);
            cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["tint"][py::cast(var_i_0d_int_Scalar)]), write_opts);
            cpp_np_val = py::len(cpp_current_dict["tint"][py::cast(var_i_0d_int_Scalar)]);
            cont << cpp_draft_line;
            tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["tint"][py::cast(var_i_0d_int_Scalar)]);
            tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["T"][py::cast(var_i_0d_int_Scalar)]);
            tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
            tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
            write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
            {
              Tab1Body tab_body = tab1_body;
              // assign expression to variable tint
              var_tint_1d_floatvec_NestedVector.set(var_i_0d_int_Scalar, tab_body.X);
              validate_vartype_consistency("tint", NESTEDVECTOR_FLOATVEC, aux_last_type_read_for_tint);
              aux_last_type_read_for_tint = NESTEDVECTOR_FLOATVEC;
              // assign expression to variable T
              var_T_1d_floatvec_NestedVector.set(var_i_0d_int_Scalar, tab_body.Y);
              validate_vartype_consistency("T", NESTEDVECTOR_FLOATVEC, aux_last_type_read_for_T);
              aux_last_type_read_for_T = NESTEDVECTOR_FLOATVEC;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            cont << cpp_draft_line;
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
            int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
            bool& glob_aux_LO_read = aux_LO_read;
            bool aux_LO_read = glob_aux_LO_read;
            vartype aux_last_type_read_for_LO = UNKNOWN;
            cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , 0 , 0 ] HEAD";
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ZA", -99999.9));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AWR", -99999.9));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LO
            var_LO_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LO", -99999));
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(2)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 1 , 460 / ZA , AWR , LO , 0 , 0 , 0 ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read CONT record
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LO"]), write_opts);
            // assign expression to variable LO
            var_LO_0d_int_Scalar = py::cast<int>(cpp_current_dict["LO"]);
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cont << cpp_draft_line;
            cpp_template = "[ MAT , 1 , 460 / 0.0 , 0.0 , 0 , 0 , NNF , 0 / \n { lambda } { i = 1 to NNF } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST record
            cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NNF"]), write_opts);
            // assign expression to variable NNF
            var_NNF_0d_int_Scalar = py::cast<int>(cpp_current_dict["NNF"]);
            aux_NNF_read = true;
            validate_vartype_consistency("NNF", SCALAR_INT, aux_last_type_read_for_NNF);
            aux_last_type_read_for_NNF = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NNF"]), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = py::cast<int>(cpp_current_dict["NNF"]);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read LIST body

              for (int var_i_0d_int_Scalar = 1;
                 var_i_0d_int_Scalar <= var_NNF_0d_int_Scalar; var_i_0d_int_Scalar++) {
                bool aux_i_read = true;
                // read LIST body
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["lambda"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                // assign expression to variable lambda
                var_lambda_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["lambda"][py::cast(var_i_0d_int_Scalar)]));
                validate_vartype_consistency("lambda", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_lambda);
                aux_last_type_read_for_lambda = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 2248296c1207eae0ffc6859b0c2eec26
// MD5 hash of the following function definition: 552ea4ed73d8b35d2e9c456ce5b59ec9
void write_mf2mt151_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NIS_0d_int_Scalar;
  bool aux_NIS_read = false;
  vartype aux_last_type_read_for_NIS = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 2;
  int mt = 151;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 2;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 151;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 2 , 151 / ZA , AWR , 0 , 0 , NIS , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NIS"]), write_opts);
  // assign expression to variable NIS
  var_NIS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NIS"]);
  aux_NIS_read = true;
  validate_vartype_consistency("NIS", SCALAR_INT, aux_last_type_read_for_NIS);
  aux_last_type_read_for_NIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NIS_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    // open section isotope
    {
      py::dict cpp_parent_dict_tmp = cpp_current_dict;
      if ((! cpp_parent_dict_tmp.contains("isotope"))) {
        cpp_parent_dict_tmp["isotope"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict_tmp["isotope"];
      if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
      // variable declarations
      double var_ZAI_0d_double_Scalar;
      bool aux_ZAI_read = false;
      vartype aux_last_type_read_for_ZAI = UNKNOWN;
      double var_ABN_0d_double_Scalar;
      bool aux_ABN_read = false;
      vartype aux_last_type_read_for_ABN = UNKNOWN;
      int var_LFW_0d_int_Scalar;
      bool aux_LFW_read = false;
      vartype aux_last_type_read_for_LFW = UNKNOWN;
      int var_NER_0d_int_Scalar;
      bool aux_NER_read = false;
      vartype aux_last_type_read_for_NER = UNKNOWN;
      cpp_template = "[ MAT , 2 , 151 / ZAI , ABN , 0 , LFW , NER , 0 ] CONT";
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
      // read CONT record
      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZAI"]), write_opts);
      // assign expression to variable ZAI
      var_ZAI_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZAI"]);
      aux_ZAI_read = true;
      validate_vartype_consistency("ZAI", SCALAR_DOUBLE, aux_last_type_read_for_ZAI);
      aux_last_type_read_for_ZAI = SCALAR_DOUBLE;
      cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["ABN"]), write_opts);
      // assign expression to variable ABN
      var_ABN_0d_double_Scalar = py::cast<double>(cpp_current_dict["ABN"]);
      aux_ABN_read = true;
      validate_vartype_consistency("ABN", SCALAR_DOUBLE, aux_last_type_read_for_ABN);
      aux_last_type_read_for_ABN = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LFW"]), write_opts);
      // assign expression to variable LFW
      var_LFW_0d_int_Scalar = py::cast<int>(cpp_current_dict["LFW"]);
      aux_LFW_read = true;
      validate_vartype_consistency("LFW", SCALAR_INT, aux_last_type_read_for_LFW);
      aux_last_type_read_for_LFW = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NER"]), write_opts);
      // assign expression to variable NER
      var_NER_0d_int_Scalar = py::cast<int>(cpp_current_dict["NER"]);
      aux_NER_read = true;
      validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
      aux_last_type_read_for_NER = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
      cont << cpp_draft_line;

      for (int var_j_0d_int_Scalar = 1;
         var_j_0d_int_Scalar <= var_NER_0d_int_Scalar; var_j_0d_int_Scalar++) {
        bool aux_j_read = true;
        // open section range
        {
          py::dict cpp_parent_dict_tmp = cpp_current_dict;
          if ((! cpp_parent_dict_tmp.contains("range"))) {
            cpp_parent_dict_tmp["range"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict_tmp["range"];
          if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
            cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
          }
          cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
          // variable declarations
          double var_EL_0d_double_Scalar;
          bool aux_EL_read = false;
          vartype aux_last_type_read_for_EL = UNKNOWN;
          double var_EH_0d_double_Scalar;
          bool aux_EH_read = false;
          vartype aux_last_type_read_for_EH = UNKNOWN;
          int var_LRU_0d_int_Scalar;
          bool aux_LRU_read = false;
          vartype aux_last_type_read_for_LRU = UNKNOWN;
          int var_LRF_0d_int_Scalar;
          bool aux_LRF_read = false;
          vartype aux_last_type_read_for_LRF = UNKNOWN;
          int var_NRO_0d_int_Scalar;
          bool aux_NRO_read = false;
          vartype aux_last_type_read_for_NRO = UNKNOWN;
          int var_NAPS_0d_int_Scalar;
          bool aux_NAPS_read = false;
          vartype aux_last_type_read_for_NAPS = UNKNOWN;
          double var_SPI_0d_double_Scalar;
          bool aux_SPI_read = false;
          vartype aux_last_type_read_for_SPI = UNKNOWN;
          double var_AP_0d_double_Scalar;
          std::vector<double> var_AP_0d_floatvec_Scalar;
          bool aux_AP_read = false;
          vartype aux_last_type_read_for_AP = UNKNOWN;
          int var_NLS_0d_int_Scalar;
          bool aux_NLS_read = false;
          vartype aux_last_type_read_for_NLS = UNKNOWN;
          std::vector<double> var_Eint_0d_floatvec_Scalar;
          bool aux_Eint_read = false;
          vartype aux_last_type_read_for_Eint = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          int var_LAD_0d_int_Scalar;
          bool aux_LAD_read = false;
          vartype aux_last_type_read_for_LAD = UNKNOWN;
          int var_NLSC_0d_int_Scalar;
          bool aux_NLSC_read = false;
          vartype aux_last_type_read_for_NLSC = UNKNOWN;
          int var_IFG_0d_int_Scalar;
          bool aux_IFG_read = false;
          vartype aux_last_type_read_for_IFG = UNKNOWN;
          int var_KRM_0d_int_Scalar;
          bool aux_KRM_read = false;
          vartype aux_last_type_read_for_KRM = UNKNOWN;
          int var_NJS_0d_int_Scalar;
          bool aux_NJS_read = false;
          vartype aux_last_type_read_for_NJS = UNKNOWN;
          int var_KRL_0d_int_Scalar;
          bool aux_KRL_read = false;
          vartype aux_last_type_read_for_KRL = UNKNOWN;
          int var_NPP_0d_int_Scalar;
          bool aux_NPP_read = false;
          vartype aux_last_type_read_for_NPP = UNKNOWN;
          int cpp_int_val;
          bool aux_cpp_int_val_read = false;
          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
          NestedVector<double> var_MA_1d_double_NestedVector;
          vartype aux_last_type_read_for_MA = UNKNOWN;
          NestedVector<double> var_MB_1d_double_NestedVector;
          vartype aux_last_type_read_for_MB = UNKNOWN;
          NestedVector<double> var_ZA_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          NestedVector<double> var_ZB_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZB = UNKNOWN;
          NestedVector<double> var_IA_1d_double_NestedVector;
          vartype aux_last_type_read_for_IA = UNKNOWN;
          NestedVector<double> var_IB_1d_double_NestedVector;
          vartype aux_last_type_read_for_IB = UNKNOWN;
          NestedVector<double> var_Q_1d_double_NestedVector;
          vartype aux_last_type_read_for_Q = UNKNOWN;
          NestedVector<double> var_PNT_1d_double_NestedVector;
          vartype aux_last_type_read_for_PNT = UNKNOWN;
          NestedVector<double> var_SHF_1d_double_NestedVector;
          vartype aux_last_type_read_for_SHF = UNKNOWN;
          NestedVector<double> var_MT_1d_double_NestedVector;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          NestedVector<double> var_PA_1d_double_NestedVector;
          vartype aux_last_type_read_for_PA = UNKNOWN;
          NestedVector<double> var_PB_1d_double_NestedVector;
          vartype aux_last_type_read_for_PB = UNKNOWN;
          int var_LSSF_0d_int_Scalar;
          bool aux_LSSF_read = false;
          vartype aux_last_type_read_for_LSSF = UNKNOWN;
          int var_NE_0d_int_Scalar;
          bool aux_NE_read = false;
          vartype aux_last_type_read_for_NE = UNKNOWN;
          NestedVector<double> var_ES_1d_double_NestedVector;
          vartype aux_last_type_read_for_ES = UNKNOWN;
          cpp_template = "[ MAT , 2 , 151 / EL , EH , LRU , LRF , NRO , NAPS ] CONT";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read CONT record
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["EL"]), write_opts);
          // assign expression to variable EL
          var_EL_0d_double_Scalar = py::cast<double>(cpp_current_dict["EL"]);
          aux_EL_read = true;
          validate_vartype_consistency("EL", SCALAR_DOUBLE, aux_last_type_read_for_EL);
          aux_last_type_read_for_EL = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["EH"]), write_opts);
          // assign expression to variable EH
          var_EH_0d_double_Scalar = py::cast<double>(cpp_current_dict["EH"]);
          aux_EH_read = true;
          validate_vartype_consistency("EH", SCALAR_DOUBLE, aux_last_type_read_for_EH);
          aux_last_type_read_for_EH = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LRU"]), write_opts);
          // assign expression to variable LRU
          var_LRU_0d_int_Scalar = py::cast<int>(cpp_current_dict["LRU"]);
          aux_LRU_read = true;
          validate_vartype_consistency("LRU", SCALAR_INT, aux_last_type_read_for_LRU);
          aux_last_type_read_for_LRU = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LRF"]), write_opts);
          // assign expression to variable LRF
          var_LRF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LRF"]);
          aux_LRF_read = true;
          validate_vartype_consistency("LRF", SCALAR_INT, aux_last_type_read_for_LRF);
          aux_last_type_read_for_LRF = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NRO"]), write_opts);
          // assign expression to variable NRO
          var_NRO_0d_int_Scalar = py::cast<int>(cpp_current_dict["NRO"]);
          aux_NRO_read = true;
          validate_vartype_consistency("NRO", SCALAR_INT, aux_last_type_read_for_NRO);
          aux_last_type_read_for_NRO = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NAPS"]), write_opts);
          // assign expression to variable NAPS
          var_NAPS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NAPS"]);
          aux_NAPS_read = true;
          validate_vartype_consistency("NAPS", SCALAR_INT, aux_last_type_read_for_NAPS);
          aux_last_type_read_for_NAPS = SCALAR_INT;
          cont << cpp_draft_line;
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((((((aux_NIS_read == true)) && ((var_NIS_0d_int_Scalar)==(1)))))&&((((aux_ZAI_read == true)) && ((var_ZAI_0d_double_Scalar)==(var_ZA_0d_double_Scalar)))))&&((((aux_ABN_read == true)) && ((var_ABN_0d_double_Scalar)==(1)))))&&((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(0)))))&&((((aux_NER_read == true)) && ((var_NER_0d_int_Scalar)==(1)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if (((((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(0)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(0)))))&&((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)==(0)))))&&((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      // evaluate if-elif-else clause
                      {
                        bool cpp_found_match = false;
                        if (! cpp_found_match) {
                          // if statement evaluation with lookahead
                          {
                            {
                              // variable declarations
                              double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                              double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                              bool& glob_aux_EL_read = aux_EL_read;
                              bool aux_EL_read = glob_aux_EL_read;
                              vartype aux_last_type_read_for_EL = UNKNOWN;
                              double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                              double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                              bool& glob_aux_EH_read = aux_EH_read;
                              bool aux_EH_read = glob_aux_EH_read;
                              vartype aux_last_type_read_for_EH = UNKNOWN;
                              int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                              int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                              bool& glob_aux_LRU_read = aux_LRU_read;
                              bool aux_LRU_read = glob_aux_LRU_read;
                              vartype aux_last_type_read_for_LRU = UNKNOWN;
                              int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                              int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                              bool& glob_aux_LRF_read = aux_LRF_read;
                              bool aux_LRF_read = glob_aux_LRF_read;
                              vartype aux_last_type_read_for_LRF = UNKNOWN;
                              int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                              int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                              bool& glob_aux_NRO_read = aux_NRO_read;
                              bool aux_NRO_read = glob_aux_NRO_read;
                              vartype aux_last_type_read_for_NRO = UNKNOWN;
                              int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                              int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                              bool& glob_aux_NAPS_read = aux_NAPS_read;
                              bool aux_NAPS_read = glob_aux_NAPS_read;
                              vartype aux_last_type_read_for_NAPS = UNKNOWN;
                              double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                              double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                              bool& glob_aux_SPI_read = aux_SPI_read;
                              bool aux_SPI_read = glob_aux_SPI_read;
                              vartype aux_last_type_read_for_SPI = UNKNOWN;
                              double& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                              double var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                              bool& glob_aux_AP_read = aux_AP_read;
                              bool aux_AP_read = glob_aux_AP_read;
                              vartype aux_last_type_read_for_AP = UNKNOWN;
                              int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                              int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                              bool& glob_aux_NLS_read = aux_NLS_read;
                              bool aux_NLS_read = glob_aux_NLS_read;
                              vartype aux_last_type_read_for_NLS = UNKNOWN;
                              cpp_template = "[ MAT , 2 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                              // read CONT record
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("SPI", -99999.9));
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AP", -99999.9));
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NLS", -99999));
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                              if ((((((((aux_NLS_read == true)) && ((var_NLS_0d_int_Scalar)==(0)))))))) {
                                cpp_found_match = true;
                              }
                            }
                            if (cpp_found_match) {
                              cpp_template = "[ MAT , 2 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              // read CONT record
                              cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AP"]), write_opts);
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict["AP"]);
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                              cont << cpp_draft_line;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if (((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      // evaluate if-elif-else clause
                      {
                        bool cpp_found_match = false;
                        if (! cpp_found_match) {
                          if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                            // if statement evaluation
                            cpp_found_match = true;
                            cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                            // read TAB1 record
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                            cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                            cpp_nr_val = py::len(cpp_current_dict["INT"]);
                            cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
                            cpp_np_val = py::len(cpp_current_dict["Eint"]);
                            cont << cpp_draft_line;
                            tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
                            tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["AP"]);
                            tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                            tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                            write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                            {
                              Tab1Body tab_body = tab1_body;
                              // assign expression to variable Eint
                              var_Eint_0d_floatvec_Scalar = tab_body.X;
                              aux_Eint_read = true;
                              validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                              aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                              if ((! (aux_AP_read == true))) {
                                // assign expression to variable AP
                                var_AP_0d_floatvec_Scalar = tab_body.Y;
                                aux_AP_read = true;
                                validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                              } else {
                              }
                              // assign expression to variable INT
                              var_INT_0d_intvec_Scalar = tab_body.INT;
                              aux_INT_read = true;
                              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                              aux_last_type_read_for_INT = SCALAR_INTVEC;
                              // assign expression to variable NBT
                              var_NBT_0d_intvec_Scalar = tab_body.NBT;
                              aux_NBT_read = true;
                              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                              aux_last_type_read_for_NBT = SCALAR_INTVEC;
                            }
                            cont << cpp_draft_line;
                          }
                        }
                      }
                      // evaluate if-elif-else clause
                      {
                        bool cpp_found_match = false;
                        if (! cpp_found_match) {
                          if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                            // if statement evaluation
                            cpp_found_match = true;
                            cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , 0 , 0 , NLS , 0 ] CONT";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read CONT record
                            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                            if ((! (aux_SPI_read == true))) {
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                            } else {
                            }
                            cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                            if ((! (aux_NLS_read == true))) {
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                            cont << cpp_draft_line;
                          }
                        }
                        if (! cpp_found_match) {
                          cpp_template = "[ MAT , 2 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read CONT record
                          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                          if ((! (aux_SPI_read == true))) {
                            // assign expression to variable SPI
                            var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                            aux_SPI_read = true;
                            validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                            aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                          } else {
                          }
                          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AP"]), write_opts);
                          if ((! (aux_AP_read == true))) {
                            // assign expression to variable AP
                            var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict["AP"]);
                            aux_AP_read = true;
                            validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                            aux_last_type_read_for_AP = SCALAR_DOUBLE;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                          if ((! (aux_NLS_read == true))) {
                            // assign expression to variable NLS
                            var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                            aux_NLS_read = true;
                            validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                            aux_last_type_read_for_NLS = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                          cont << cpp_draft_line;
                        }
                      }

                      for (int var_m_0d_int_Scalar = 1;
                         var_m_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                        bool aux_m_read = true;
                        // open section spingroup
                        {
                          py::dict cpp_parent_dict_tmp = cpp_current_dict;
                          if ((! cpp_parent_dict_tmp.contains("spingroup"))) {
                            cpp_parent_dict_tmp["spingroup"] = py::dict();
                          }
                          py::dict cpp_current_dict = cpp_parent_dict_tmp["spingroup"];
                          if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                            cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                          }
                          cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                          // variable declarations
                          double var_AWRI_0d_double_Scalar;
                          bool aux_AWRI_read = false;
                          vartype aux_last_type_read_for_AWRI = UNKNOWN;
                          double var_QX_0d_double_Scalar;
                          bool aux_QX_read = false;
                          vartype aux_last_type_read_for_QX = UNKNOWN;
                          int var_L_0d_int_Scalar;
                          bool aux_L_read = false;
                          vartype aux_last_type_read_for_L = UNKNOWN;
                          int var_LRX_0d_int_Scalar;
                          bool aux_LRX_read = false;
                          vartype aux_last_type_read_for_LRX = UNKNOWN;
                          int cpp_int_val;
                          bool aux_cpp_int_val_read = false;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int var_NRS_0d_int_Scalar;
                          bool aux_NRS_read = false;
                          vartype aux_last_type_read_for_NRS = UNKNOWN;
                          NestedVector<double> var_ER_1d_double_NestedVector;
                          vartype aux_last_type_read_for_ER = UNKNOWN;
                          NestedVector<double> var_AJ_1d_double_NestedVector;
                          vartype aux_last_type_read_for_AJ = UNKNOWN;
                          NestedVector<double> var_GT_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GT = UNKNOWN;
                          NestedVector<double> var_GN_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GN = UNKNOWN;
                          NestedVector<double> var_GG_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GG = UNKNOWN;
                          NestedVector<double> var_GF_1d_double_NestedVector;
                          vartype aux_last_type_read_for_GF = UNKNOWN;
                          cpp_template = "[ MAT , 2 , 151 / AWRI , QX , L , LRX , (6*NRS) , NRS / \n { ER , AJ , GT , GN , GG , GF } { k = 1 to NRS } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AWRI"]), write_opts);
                          // assign expression to variable AWRI
                          var_AWRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWRI"]);
                          aux_AWRI_read = true;
                          validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                          aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["QX"]), write_opts);
                          // assign expression to variable QX
                          var_QX_0d_double_Scalar = py::cast<double>(cpp_current_dict["QX"]);
                          aux_QX_read = true;
                          validate_vartype_consistency("QX", SCALAR_DOUBLE, aux_last_type_read_for_QX);
                          aux_last_type_read_for_QX = SCALAR_DOUBLE;
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["L"]), write_opts);
                          // assign expression to variable L
                          var_L_0d_int_Scalar = py::cast<int>(cpp_current_dict["L"]);
                          aux_L_read = true;
                          validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                          aux_last_type_read_for_L = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LRX"]), write_opts);
                          // assign expression to variable LRX
                          var_LRX_0d_int_Scalar = py::cast<int>(cpp_current_dict["LRX"]);
                          aux_LRX_read = true;
                          validate_vartype_consistency("LRX", SCALAR_INT, aux_last_type_read_for_LRX);
                          aux_last_type_read_for_LRX = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NRS"])), write_opts);
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (6*py::cast<int>(cpp_current_dict["NRS"]));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NRS
                          var_NRS_0d_int_Scalar = (cpp_int_val/6);
                          aux_NRS_read = true;
                          validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                          aux_last_type_read_for_NRS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NRS"]), write_opts);
                          if ((! (aux_NRS_read == true))) {
                            // assign expression to variable NRS
                            var_NRS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NRS"]);
                            aux_NRS_read = true;
                            validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                            aux_last_type_read_for_NRS = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NRS"])), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = (6*py::cast<int>(cpp_current_dict["NRS"]));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable ER
                              var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                              aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable AJ
                              var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                              aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GT"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable GT
                              var_GT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GT"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                              aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GN"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable GN
                              var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GN"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                              aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable GG
                              var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                              aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GF"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable GF
                              var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GF"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                              aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                          cpp_current_dict = cpp_parent_dict_tmp;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if ((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(3)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                              // read TAB1 record
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                              cpp_nr_val = py::len(cpp_current_dict["INT"]);
                              cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
                              cpp_np_val = py::len(cpp_current_dict["Eint"]);
                              cont << cpp_draft_line;
                              tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
                              tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["AP"]);
                              tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                              tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                              write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                              {
                                Tab1Body tab_body = tab1_body;
                                // assign expression to variable Eint
                                var_Eint_0d_floatvec_Scalar = tab_body.X;
                                aux_Eint_read = true;
                                validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                                aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                                if ((! (aux_AP_read == true))) {
                                  // assign expression to variable AP
                                  var_AP_0d_floatvec_Scalar = tab_body.Y;
                                  aux_AP_read = true;
                                  validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                  aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                                } else {
                                }
                                // assign expression to variable INT
                                var_INT_0d_intvec_Scalar = tab_body.INT;
                                aux_INT_read = true;
                                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                aux_last_type_read_for_INT = SCALAR_INTVEC;
                                // assign expression to variable NBT
                                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                aux_NBT_read = true;
                                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                aux_last_type_read_for_NBT = SCALAR_INTVEC;
                              }
                              cont << cpp_draft_line;
                            }
                          }
                        }
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , LAD , 0 , NLS , NLSC ] CONT";
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              // read CONT record
                              cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                              if ((! (aux_SPI_read == true))) {
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              } else {
                              }
                              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LAD"]), write_opts);
                              // assign expression to variable LAD
                              var_LAD_0d_int_Scalar = py::cast<int>(cpp_current_dict["LAD"]);
                              aux_LAD_read = true;
                              validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                              aux_last_type_read_for_LAD = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                              if ((! (aux_NLS_read == true))) {
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } else {
                              }
                              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NLSC"]), write_opts);
                              // assign expression to variable NLSC
                              var_NLSC_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLSC"]);
                              aux_NLSC_read = true;
                              validate_vartype_consistency("NLSC", SCALAR_INT, aux_last_type_read_for_NLSC);
                              aux_last_type_read_for_NLSC = SCALAR_INT;
                              cont << cpp_draft_line;
                            }
                          }
                          if (! cpp_found_match) {
                            cpp_template = "[ MAT , 2 , 151 / SPI , AP , LAD , 0 , NLS , NLSC ] CONT";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read CONT record
                            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                            if ((! (aux_SPI_read == true))) {
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                            } else {
                            }
                            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AP"]), write_opts);
                            if ((! (aux_AP_read == true))) {
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict["AP"]);
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LAD"]), write_opts);
                            // assign expression to variable LAD
                            var_LAD_0d_int_Scalar = py::cast<int>(cpp_current_dict["LAD"]);
                            aux_LAD_read = true;
                            validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                            aux_last_type_read_for_LAD = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                            if ((! (aux_NLS_read == true))) {
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NLSC"]), write_opts);
                            // assign expression to variable NLSC
                            var_NLSC_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLSC"]);
                            aux_NLSC_read = true;
                            validate_vartype_consistency("NLSC", SCALAR_INT, aux_last_type_read_for_NLSC);
                            aux_last_type_read_for_NLSC = SCALAR_INT;
                            cont << cpp_draft_line;
                          }
                        }

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // open section spingroup
                          {
                            py::dict cpp_parent_dict_tmp = cpp_current_dict;
                            if ((! cpp_parent_dict_tmp.contains("spingroup"))) {
                              cpp_parent_dict_tmp["spingroup"] = py::dict();
                            }
                            py::dict cpp_current_dict = cpp_parent_dict_tmp["spingroup"];
                            if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                              cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                            }
                            cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                            // variable declarations
                            double var_AWRI_0d_double_Scalar;
                            bool aux_AWRI_read = false;
                            vartype aux_last_type_read_for_AWRI = UNKNOWN;
                            double var_APL_0d_double_Scalar;
                            bool aux_APL_read = false;
                            vartype aux_last_type_read_for_APL = UNKNOWN;
                            int var_L_0d_int_Scalar;
                            bool aux_L_read = false;
                            vartype aux_last_type_read_for_L = UNKNOWN;
                            int cpp_int_val;
                            bool aux_cpp_int_val_read = false;
                            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                            int var_NRS_0d_int_Scalar;
                            bool aux_NRS_read = false;
                            vartype aux_last_type_read_for_NRS = UNKNOWN;
                            NestedVector<double> var_ER_1d_double_NestedVector;
                            vartype aux_last_type_read_for_ER = UNKNOWN;
                            NestedVector<double> var_AJ_1d_double_NestedVector;
                            vartype aux_last_type_read_for_AJ = UNKNOWN;
                            NestedVector<double> var_GN_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GN = UNKNOWN;
                            NestedVector<double> var_GG_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GG = UNKNOWN;
                            NestedVector<double> var_GFA_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GFA = UNKNOWN;
                            NestedVector<double> var_GFB_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GFB = UNKNOWN;
                            cpp_template = "[ MAT , 2 , 151 / AWRI , APL , L , 0 , (6*NRS) , NRS / \n { ER , AJ , GN , GG , GFA , GFB } { k = 1 to NRS } ] LIST";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST record
                            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AWRI"]), write_opts);
                            // assign expression to variable AWRI
                            var_AWRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWRI"]);
                            aux_AWRI_read = true;
                            validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                            aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["APL"]), write_opts);
                            // assign expression to variable APL
                            var_APL_0d_double_Scalar = py::cast<double>(cpp_current_dict["APL"]);
                            aux_APL_read = true;
                            validate_vartype_consistency("APL", SCALAR_DOUBLE, aux_last_type_read_for_APL);
                            aux_last_type_read_for_APL = SCALAR_DOUBLE;
                            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["L"]), write_opts);
                            // assign expression to variable L
                            var_L_0d_int_Scalar = py::cast<int>(cpp_current_dict["L"]);
                            aux_L_read = true;
                            validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                            aux_last_type_read_for_L = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NRS"])), write_opts);
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (6*py::cast<int>(cpp_current_dict["NRS"]));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NRS
                            var_NRS_0d_int_Scalar = (cpp_int_val/6);
                            aux_NRS_read = true;
                            validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                            aux_last_type_read_for_NRS = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NRS"]), write_opts);
                            if ((! (aux_NRS_read == true))) {
                              // assign expression to variable NRS
                              var_NRS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NRS"]);
                              aux_NRS_read = true;
                              validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                              aux_last_type_read_for_NRS = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NRS"])), write_opts);
                            cont << cpp_draft_line;
                            {
                              int cpp_npl = (6*py::cast<int>(cpp_current_dict["NRS"]));
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              // read LIST body

                              for (int var_k_0d_int_Scalar = 1;
                                 var_k_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                                bool aux_k_read = true;
                                // read LIST body
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                                // assign expression to variable ER
                                var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]));
                                validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                                aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                                // assign expression to variable AJ
                                var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]));
                                validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                                aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GN"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                                // assign expression to variable GN
                                var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GN"][py::cast(var_k_0d_int_Scalar)]));
                                validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                                aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                                // assign expression to variable GG
                                var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]));
                                validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                                aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GFA"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                                // assign expression to variable GFA
                                var_GFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GFA"][py::cast(var_k_0d_int_Scalar)]));
                                validate_vartype_consistency("GFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFA);
                                aux_last_type_read_for_GFA = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GFB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                                // assign expression to variable GFB
                                var_GFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GFB"][py::cast(var_k_0d_int_Scalar)]));
                                validate_vartype_consistency("GFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFB);
                                aux_last_type_read_for_GFB = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            cont << cpp_draft_line;
                            cpp_current_dict = cpp_parent_dict_tmp;
                          }
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if ((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(7)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , IFG , KRM , NJS , KRL ] CONT";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read CONT record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["IFG"]), write_opts);
                        // assign expression to variable IFG
                        var_IFG_0d_int_Scalar = py::cast<int>(cpp_current_dict["IFG"]);
                        aux_IFG_read = true;
                        validate_vartype_consistency("IFG", SCALAR_INT, aux_last_type_read_for_IFG);
                        aux_last_type_read_for_IFG = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["KRM"]), write_opts);
                        // assign expression to variable KRM
                        var_KRM_0d_int_Scalar = py::cast<int>(cpp_current_dict["KRM"]);
                        aux_KRM_read = true;
                        validate_vartype_consistency("KRM", SCALAR_INT, aux_last_type_read_for_KRM);
                        aux_last_type_read_for_KRM = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NJS"]), write_opts);
                        // assign expression to variable NJS
                        var_NJS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NJS"]);
                        aux_NJS_read = true;
                        validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                        aux_last_type_read_for_NJS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["KRL"]), write_opts);
                        // assign expression to variable KRL
                        var_KRL_0d_int_Scalar = py::cast<int>(cpp_current_dict["KRL"]);
                        aux_KRL_read = true;
                        validate_vartype_consistency("KRL", SCALAR_INT, aux_last_type_read_for_KRL);
                        aux_last_type_read_for_KRL = SCALAR_INT;
                        cont << cpp_draft_line;
                        cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , NPP , 0 , (12*NPP) , (2*NPP) / \n { MA , MB , ZA , ZB , IA , IB , \n Q , PNT , SHF , MT , PA , PB } { k = 1 to NPP } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["NPP"]), write_opts);
                        // assign expression to variable NPP
                        var_NPP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NPP"]);
                        aux_NPP_read = true;
                        validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                        aux_last_type_read_for_NPP = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_current_dict["NPP"])), write_opts);
                        if ((! (aux_NPP_read == true))) {
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (12*py::cast<int>(cpp_current_dict["NPP"]));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NPP
                          var_NPP_0d_int_Scalar = (cpp_int_val/12);
                          aux_NPP_read = true;
                          validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                          aux_last_type_read_for_NPP = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 5, (2*py::cast<int>(cpp_current_dict["NPP"])), write_opts);
                        if ((! (aux_NPP_read == true))) {
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (2*py::cast<int>(cpp_current_dict["NPP"]));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NPP
                          var_NPP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NPP_read = true;
                          validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                          aux_last_type_read_for_NPP = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_current_dict["NPP"])), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = (12*py::cast<int>(cpp_current_dict["NPP"]));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NPP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["MA"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable MA
                            var_MA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["MA"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("MA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MA);
                            aux_last_type_read_for_MA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["MB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable MB
                            var_MB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["MB"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("MB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MB);
                            aux_last_type_read_for_MB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ZA"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable ZA
                            var_ZA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ZA"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("ZA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZA);
                            aux_last_type_read_for_ZA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ZB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable ZB
                            var_ZB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ZB"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("ZB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZB);
                            aux_last_type_read_for_ZB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["IA"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable IA
                            var_IA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["IA"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("IA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IA);
                            aux_last_type_read_for_IA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["IB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable IB
                            var_IB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["IB"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("IB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IB);
                            aux_last_type_read_for_IB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Q"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable Q
                            var_Q_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["Q"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("Q", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Q);
                            aux_last_type_read_for_Q = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["PNT"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable PNT
                            var_PNT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["PNT"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("PNT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PNT);
                            aux_last_type_read_for_PNT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["SHF"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable SHF
                            var_SHF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["SHF"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("SHF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SHF);
                            aux_last_type_read_for_SHF = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["MT"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable MT
                            var_MT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["MT"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("MT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MT);
                            aux_last_type_read_for_MT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["PA"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable PA
                            var_PA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["PA"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("PA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PA);
                            aux_last_type_read_for_PA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["PB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable PB
                            var_PB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["PB"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("PB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PB);
                            aux_last_type_read_for_PB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;

                        for (int var_k_0d_int_Scalar = 1;
                           var_k_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                          bool aux_k_read = true;
                          // open section spingroup
                          {
                            py::dict cpp_parent_dict_tmp = cpp_current_dict;
                            if ((! cpp_parent_dict_tmp.contains("spingroup"))) {
                              cpp_parent_dict_tmp["spingroup"] = py::dict();
                            }
                            py::dict cpp_current_dict = cpp_parent_dict_tmp["spingroup"];
                            if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                              cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                            }
                            cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                            // variable declarations
                            double var_AJ_0d_double_Scalar;
                            bool aux_AJ_read = false;
                            vartype aux_last_type_read_for_AJ = UNKNOWN;
                            double var_PJ_0d_double_Scalar;
                            bool aux_PJ_read = false;
                            vartype aux_last_type_read_for_PJ = UNKNOWN;
                            int var_KBK_0d_int_Scalar;
                            bool aux_KBK_read = false;
                            vartype aux_last_type_read_for_KBK = UNKNOWN;
                            int var_KPS_0d_int_Scalar;
                            bool aux_KPS_read = false;
                            vartype aux_last_type_read_for_KPS = UNKNOWN;
                            int cpp_int_val;
                            bool aux_cpp_int_val_read = false;
                            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                            int var_NCH_0d_int_Scalar;
                            bool aux_NCH_read = false;
                            vartype aux_last_type_read_for_NCH = UNKNOWN;
                            NestedVector<double> var_PPI_1d_double_NestedVector;
                            vartype aux_last_type_read_for_PPI = UNKNOWN;
                            NestedVector<double> var_L_1d_double_NestedVector;
                            vartype aux_last_type_read_for_L = UNKNOWN;
                            NestedVector<double> var_SCH_1d_double_NestedVector;
                            vartype aux_last_type_read_for_SCH = UNKNOWN;
                            NestedVector<double> var_BND_1d_double_NestedVector;
                            vartype aux_last_type_read_for_BND = UNKNOWN;
                            NestedVector<double> var_APE_1d_double_NestedVector;
                            vartype aux_last_type_read_for_APE = UNKNOWN;
                            NestedVector<double> var_APT_1d_double_NestedVector;
                            vartype aux_last_type_read_for_APT = UNKNOWN;
                            int var_NRS_0d_int_Scalar;
                            bool aux_NRS_read = false;
                            vartype aux_last_type_read_for_NRS = UNKNOWN;
                            NestedVector<double> var_ER_1d_double_NestedVector;
                            vartype aux_last_type_read_for_ER = UNKNOWN;
                            Matrix2d<double> var_GAM_2d_double_Matrix2d;
                            vartype aux_last_type_read_for_GAM = UNKNOWN;
                            int var_NX_0d_int_Scalar;
                            bool aux_NX_read = false;
                            vartype aux_last_type_read_for_NX = UNKNOWN;
                            cpp_template = "[ MAT , 2 , 151 / AJ , PJ , KBK , KPS , (6*NCH) , NCH / \n { PPI , L , SCH , BND , APE , APT } { l = 1 to NCH } ] LIST";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST record
                            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AJ"]), write_opts);
                            // assign expression to variable AJ
                            var_AJ_0d_double_Scalar = py::cast<double>(cpp_current_dict["AJ"]);
                            aux_AJ_read = true;
                            validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                            aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["PJ"]), write_opts);
                            // assign expression to variable PJ
                            var_PJ_0d_double_Scalar = py::cast<double>(cpp_current_dict["PJ"]);
                            aux_PJ_read = true;
                            validate_vartype_consistency("PJ", SCALAR_DOUBLE, aux_last_type_read_for_PJ);
                            aux_last_type_read_for_PJ = SCALAR_DOUBLE;
                            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["KBK"]), write_opts);
                            // assign expression to variable KBK
                            var_KBK_0d_int_Scalar = py::cast<int>(cpp_current_dict["KBK"]);
                            aux_KBK_read = true;
                            validate_vartype_consistency("KBK", SCALAR_INT, aux_last_type_read_for_KBK);
                            aux_last_type_read_for_KBK = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["KPS"]), write_opts);
                            // assign expression to variable KPS
                            var_KPS_0d_int_Scalar = py::cast<int>(cpp_current_dict["KPS"]);
                            aux_KPS_read = true;
                            validate_vartype_consistency("KPS", SCALAR_INT, aux_last_type_read_for_KPS);
                            aux_last_type_read_for_KPS = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NCH"])), write_opts);
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (6*py::cast<int>(cpp_current_dict["NCH"]));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NCH
                            var_NCH_0d_int_Scalar = (cpp_int_val/6);
                            aux_NCH_read = true;
                            validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                            aux_last_type_read_for_NCH = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NCH"]), write_opts);
                            if ((! (aux_NCH_read == true))) {
                              // assign expression to variable NCH
                              var_NCH_0d_int_Scalar = py::cast<int>(cpp_current_dict["NCH"]);
                              aux_NCH_read = true;
                              validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                              aux_last_type_read_for_NCH = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NCH"])), write_opts);
                            cont << cpp_draft_line;
                            {
                              int cpp_npl = (6*py::cast<int>(cpp_current_dict["NCH"]));
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              // read LIST body

                              for (int var_l_0d_int_Scalar = 1;
                                 var_l_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_l_0d_int_Scalar++) {
                                bool aux_l_read = true;
                                // read LIST body
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["PPI"][py::cast(var_l_0d_int_Scalar)]), write_opts);
                                // assign expression to variable PPI
                                var_PPI_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["PPI"][py::cast(var_l_0d_int_Scalar)]));
                                validate_vartype_consistency("PPI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PPI);
                                aux_last_type_read_for_PPI = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["L"][py::cast(var_l_0d_int_Scalar)]), write_opts);
                                // assign expression to variable L
                                var_L_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["L"][py::cast(var_l_0d_int_Scalar)]));
                                validate_vartype_consistency("L", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_L);
                                aux_last_type_read_for_L = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["SCH"][py::cast(var_l_0d_int_Scalar)]), write_opts);
                                // assign expression to variable SCH
                                var_SCH_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["SCH"][py::cast(var_l_0d_int_Scalar)]));
                                validate_vartype_consistency("SCH", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SCH);
                                aux_last_type_read_for_SCH = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["BND"][py::cast(var_l_0d_int_Scalar)]), write_opts);
                                // assign expression to variable BND
                                var_BND_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["BND"][py::cast(var_l_0d_int_Scalar)]));
                                validate_vartype_consistency("BND", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BND);
                                aux_last_type_read_for_BND = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["APE"][py::cast(var_l_0d_int_Scalar)]), write_opts);
                                // assign expression to variable APE
                                var_APE_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["APE"][py::cast(var_l_0d_int_Scalar)]));
                                validate_vartype_consistency("APE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APE);
                                aux_last_type_read_for_APE = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["APT"][py::cast(var_l_0d_int_Scalar)]), write_opts);
                                // assign expression to variable APT
                                var_APT_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["APT"][py::cast(var_l_0d_int_Scalar)]));
                                validate_vartype_consistency("APT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APT);
                                aux_last_type_read_for_APT = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            cont << cpp_draft_line;
                            // evaluate if-elif-else clause
                            {
                              bool cpp_found_match = false;
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  {
                                    // variable declarations
                                    double& glob_var_AJ_0d_double_Scalar = var_AJ_0d_double_Scalar;
                                    double var_AJ_0d_double_Scalar = glob_var_AJ_0d_double_Scalar;
                                    bool& glob_aux_AJ_read = aux_AJ_read;
                                    bool aux_AJ_read = glob_aux_AJ_read;
                                    vartype aux_last_type_read_for_AJ = UNKNOWN;
                                    double& glob_var_PJ_0d_double_Scalar = var_PJ_0d_double_Scalar;
                                    double var_PJ_0d_double_Scalar = glob_var_PJ_0d_double_Scalar;
                                    bool& glob_aux_PJ_read = aux_PJ_read;
                                    bool aux_PJ_read = glob_aux_PJ_read;
                                    vartype aux_last_type_read_for_PJ = UNKNOWN;
                                    int& glob_var_KBK_0d_int_Scalar = var_KBK_0d_int_Scalar;
                                    int var_KBK_0d_int_Scalar = glob_var_KBK_0d_int_Scalar;
                                    bool& glob_aux_KBK_read = aux_KBK_read;
                                    bool aux_KBK_read = glob_aux_KBK_read;
                                    vartype aux_last_type_read_for_KBK = UNKNOWN;
                                    int& glob_var_KPS_0d_int_Scalar = var_KPS_0d_int_Scalar;
                                    int var_KPS_0d_int_Scalar = glob_var_KPS_0d_int_Scalar;
                                    bool& glob_aux_KPS_read = aux_KPS_read;
                                    bool aux_KPS_read = glob_aux_KPS_read;
                                    vartype aux_last_type_read_for_KPS = UNKNOWN;
                                    int& glob_cpp_int_val = cpp_int_val;
                                    int cpp_int_val = glob_cpp_int_val;
                                    bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                                    bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                                    vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                    int& glob_var_NCH_0d_int_Scalar = var_NCH_0d_int_Scalar;
                                    int var_NCH_0d_int_Scalar = glob_var_NCH_0d_int_Scalar;
                                    bool& glob_aux_NCH_read = aux_NCH_read;
                                    bool aux_NCH_read = glob_aux_NCH_read;
                                    vartype aux_last_type_read_for_NCH = UNKNOWN;
                                    NestedVector<double>& glob_var_PPI_1d_double_NestedVector = var_PPI_1d_double_NestedVector;
                                    NestedVector<double> var_PPI_1d_double_NestedVector = glob_var_PPI_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_PPI = UNKNOWN;
                                    NestedVector<double>& glob_var_L_1d_double_NestedVector = var_L_1d_double_NestedVector;
                                    NestedVector<double> var_L_1d_double_NestedVector = glob_var_L_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_L = UNKNOWN;
                                    NestedVector<double>& glob_var_SCH_1d_double_NestedVector = var_SCH_1d_double_NestedVector;
                                    NestedVector<double> var_SCH_1d_double_NestedVector = glob_var_SCH_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_SCH = UNKNOWN;
                                    NestedVector<double>& glob_var_BND_1d_double_NestedVector = var_BND_1d_double_NestedVector;
                                    NestedVector<double> var_BND_1d_double_NestedVector = glob_var_BND_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_BND = UNKNOWN;
                                    NestedVector<double>& glob_var_APE_1d_double_NestedVector = var_APE_1d_double_NestedVector;
                                    NestedVector<double> var_APE_1d_double_NestedVector = glob_var_APE_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_APE = UNKNOWN;
                                    NestedVector<double>& glob_var_APT_1d_double_NestedVector = var_APT_1d_double_NestedVector;
                                    NestedVector<double> var_APT_1d_double_NestedVector = glob_var_APT_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_APT = UNKNOWN;
                                    int& glob_var_NRS_0d_int_Scalar = var_NRS_0d_int_Scalar;
                                    int var_NRS_0d_int_Scalar = glob_var_NRS_0d_int_Scalar;
                                    bool& glob_aux_NRS_read = aux_NRS_read;
                                    bool aux_NRS_read = glob_aux_NRS_read;
                                    vartype aux_last_type_read_for_NRS = UNKNOWN;
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*NX) , NX / \n { ER , { GAM } { m = 1 to NCH } , \n { 0.0 } { p = 1 to num_zeros } } { n = 1 to NRS } ] LIST";
                                    // read LIST record
                                    // assign expression to variable NRS
                                    var_NRS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NRS", -99999));
                                    aux_NRS_read = true;
                                    validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                    aux_last_type_read_for_NRS = SCALAR_INT;
                                    if ((! (aux_NCH_read == true))) {
                                      throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NCH because the modulo operator is not supported.");
                                    } else {
                                    }
                                    if ((! (aux_NRS_read == true))) {
                                      throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NRS because the modulo operator is not supported.");
                                    } else {
                                    }
                                    if ((! (aux_NCH_read == true))) {
                                      throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NCH because the modulo operator is not supported.");
                                    } else {
                                    }
                                    if ((! (aux_NRS_read == true))) {
                                      throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NRS because the modulo operator is not supported.");
                                    } else {
                                    }
                                    if ((((((((aux_NRS_read == true)) && ((var_NRS_0d_int_Scalar)>(0)))))))) {
                                      cpp_found_match = true;
                                    }
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*((((1+NCH)+((5-NCH)%6))*NRS)/6)) , ((((1+NCH)+((5-NCH)%6))*NRS)/6) / \n { ER , { GAM } { m = 1 to NCH } , \n { 0.0 } { p = 1 to num_zeros } } { n = 1 to NRS } ] LIST";
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                    // read LIST record
                                    cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                                    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["NRS"]), write_opts);
                                    // assign expression to variable NRS
                                    var_NRS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NRS"]);
                                    aux_NRS_read = true;
                                    validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                    aux_last_type_read_for_NRS = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 4, (6*((((1+py::cast<int>(cpp_current_dict["NCH"]))+((5-py::cast<int>(cpp_current_dict["NCH"]))%6))*py::cast<int>(cpp_current_dict["NRS"]))/6)), write_opts);
                                    if ((! (aux_NCH_read == true))) {
                                      throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NCH because the modulo operator is not supported.");
                                    } else {
                                    }
                                    if ((! (aux_NRS_read == true))) {
                                      throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRS)/6))==value cannot be solved for NRS because the modulo operator is not supported.");
                                    } else {
                                    }
                                    cpp_write_field<int>(cpp_draft_line, 5, ((((1+py::cast<int>(cpp_current_dict["NCH"]))+((5-py::cast<int>(cpp_current_dict["NCH"]))%6))*py::cast<int>(cpp_current_dict["NRS"]))/6), write_opts);
                                    if ((! (aux_NCH_read == true))) {
                                      throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NCH because the modulo operator is not supported.");
                                    } else {
                                    }
                                    if ((! (aux_NRS_read == true))) {
                                      throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRS)/6)==value cannot be solved for NRS because the modulo operator is not supported.");
                                    } else {
                                    }
                                    cpp_write_field<int>(cpp_draft_line, 4, (6*((((1+py::cast<int>(cpp_current_dict["NCH"]))+((5-py::cast<int>(cpp_current_dict["NCH"]))%6))*py::cast<int>(cpp_current_dict["NRS"]))/6)), write_opts);
                                    cont << cpp_draft_line;
                                    {
                                      int cpp_npl = (6*((((1+py::cast<int>(cpp_current_dict["NCH"]))+((5-py::cast<int>(cpp_current_dict["NCH"]))%6))*py::cast<int>(cpp_current_dict["NRS"]))/6));
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      // read LIST body
                                      var_GAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRS_0d_int_Scalar, false, false);

                                      for (int var_n_0d_int_Scalar = 1;
                                         var_n_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                        bool aux_n_read = true;
                                        // read LIST body
                                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"][py::cast(var_n_0d_int_Scalar)]), write_opts);
                                        // assign expression to variable ER
                                        var_ER_1d_double_NestedVector.set(var_n_0d_int_Scalar, py::cast<double>(cpp_current_dict["ER"][py::cast(var_n_0d_int_Scalar)]));
                                        validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                                        aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                                        cpp_i++;
                                        cpp_j++;
                                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                          cont << cpp_draft_line;
                                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                          cpp_j = 0;
                                        }

                                        for (int var_m_0d_int_Scalar = 1;
                                           var_m_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                          bool aux_m_read = true;
                                          // read LIST body
                                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GAM"][py::cast(var_m_0d_int_Scalar)][py::cast(var_n_0d_int_Scalar)]), write_opts);
                                          // assign expression to variable GAM
                                          var_GAM_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = py::cast<double>(cpp_current_dict["GAM"][py::cast(var_m_0d_int_Scalar)][py::cast(var_n_0d_int_Scalar)]);
                                          validate_vartype_consistency("GAM", MATRIX2D_DOUBLE, aux_last_type_read_for_GAM);
                                          aux_last_type_read_for_GAM = MATRIX2D_DOUBLE;
                                          cpp_i++;
                                          cpp_j++;
                                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                            cont << cpp_draft_line;
                                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                            cpp_j = 0;
                                          }
                                        }

                                        for (int var_p_0d_int_Scalar = 1;
                                           var_p_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_p_0d_int_Scalar++) {
                                          bool aux_p_read = true;
                                          // read LIST body
                                          cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                          cpp_i++;
                                          cpp_j++;
                                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                            cont << cpp_draft_line;
                                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                            cpp_j = 0;
                                          }
                                        }
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                    cont << cpp_draft_line;
                                  }
                                }
                              }
                            }
                            // evaluate if-elif-else clause
                            {
                              bool cpp_found_match = false;
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  {
                                    // variable declarations
                                    double& glob_var_AJ_0d_double_Scalar = var_AJ_0d_double_Scalar;
                                    double var_AJ_0d_double_Scalar = glob_var_AJ_0d_double_Scalar;
                                    bool& glob_aux_AJ_read = aux_AJ_read;
                                    bool aux_AJ_read = glob_aux_AJ_read;
                                    vartype aux_last_type_read_for_AJ = UNKNOWN;
                                    double& glob_var_PJ_0d_double_Scalar = var_PJ_0d_double_Scalar;
                                    double var_PJ_0d_double_Scalar = glob_var_PJ_0d_double_Scalar;
                                    bool& glob_aux_PJ_read = aux_PJ_read;
                                    bool aux_PJ_read = glob_aux_PJ_read;
                                    vartype aux_last_type_read_for_PJ = UNKNOWN;
                                    int& glob_var_KBK_0d_int_Scalar = var_KBK_0d_int_Scalar;
                                    int var_KBK_0d_int_Scalar = glob_var_KBK_0d_int_Scalar;
                                    bool& glob_aux_KBK_read = aux_KBK_read;
                                    bool aux_KBK_read = glob_aux_KBK_read;
                                    vartype aux_last_type_read_for_KBK = UNKNOWN;
                                    int& glob_var_KPS_0d_int_Scalar = var_KPS_0d_int_Scalar;
                                    int var_KPS_0d_int_Scalar = glob_var_KPS_0d_int_Scalar;
                                    bool& glob_aux_KPS_read = aux_KPS_read;
                                    bool aux_KPS_read = glob_aux_KPS_read;
                                    vartype aux_last_type_read_for_KPS = UNKNOWN;
                                    int& glob_cpp_int_val = cpp_int_val;
                                    int cpp_int_val = glob_cpp_int_val;
                                    bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                                    bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                                    vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                    int& glob_var_NCH_0d_int_Scalar = var_NCH_0d_int_Scalar;
                                    int var_NCH_0d_int_Scalar = glob_var_NCH_0d_int_Scalar;
                                    bool& glob_aux_NCH_read = aux_NCH_read;
                                    bool aux_NCH_read = glob_aux_NCH_read;
                                    vartype aux_last_type_read_for_NCH = UNKNOWN;
                                    NestedVector<double>& glob_var_PPI_1d_double_NestedVector = var_PPI_1d_double_NestedVector;
                                    NestedVector<double> var_PPI_1d_double_NestedVector = glob_var_PPI_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_PPI = UNKNOWN;
                                    NestedVector<double>& glob_var_L_1d_double_NestedVector = var_L_1d_double_NestedVector;
                                    NestedVector<double> var_L_1d_double_NestedVector = glob_var_L_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_L = UNKNOWN;
                                    NestedVector<double>& glob_var_SCH_1d_double_NestedVector = var_SCH_1d_double_NestedVector;
                                    NestedVector<double> var_SCH_1d_double_NestedVector = glob_var_SCH_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_SCH = UNKNOWN;
                                    NestedVector<double>& glob_var_BND_1d_double_NestedVector = var_BND_1d_double_NestedVector;
                                    NestedVector<double> var_BND_1d_double_NestedVector = glob_var_BND_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_BND = UNKNOWN;
                                    NestedVector<double>& glob_var_APE_1d_double_NestedVector = var_APE_1d_double_NestedVector;
                                    NestedVector<double> var_APE_1d_double_NestedVector = glob_var_APE_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_APE = UNKNOWN;
                                    NestedVector<double>& glob_var_APT_1d_double_NestedVector = var_APT_1d_double_NestedVector;
                                    NestedVector<double> var_APT_1d_double_NestedVector = glob_var_APT_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_APT = UNKNOWN;
                                    int& glob_var_NRS_0d_int_Scalar = var_NRS_0d_int_Scalar;
                                    int var_NRS_0d_int_Scalar = glob_var_NRS_0d_int_Scalar;
                                    bool& glob_aux_NRS_read = aux_NRS_read;
                                    bool aux_NRS_read = glob_aux_NRS_read;
                                    vartype aux_last_type_read_for_NRS = UNKNOWN;
                                    NestedVector<double>& glob_var_ER_1d_double_NestedVector = var_ER_1d_double_NestedVector;
                                    NestedVector<double> var_ER_1d_double_NestedVector = glob_var_ER_1d_double_NestedVector;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    Matrix2d<double>& glob_var_GAM_2d_double_Matrix2d = var_GAM_2d_double_Matrix2d;
                                    Matrix2d<double> var_GAM_2d_double_Matrix2d = glob_var_GAM_2d_double_Matrix2d;
                                    vartype aux_last_type_read_for_GAM = UNKNOWN;
                                    int& glob_var_NX_0d_int_Scalar = var_NX_0d_int_Scalar;
                                    int var_NX_0d_int_Scalar = glob_var_NX_0d_int_Scalar;
                                    bool& glob_aux_NX_read = aux_NX_read;
                                    bool aux_NX_read = glob_aux_NX_read;
                                    vartype aux_last_type_read_for_NX = UNKNOWN;
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*NX) , NX / \n { 0.0 } { m = 1 to 6 } ] LIST";
                                    // read LIST record
                                    if ((! (aux_NRS_read == true))) {
                                      // assign expression to variable NRS
                                      var_NRS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NRS", -99999));
                                      aux_NRS_read = true;
                                      validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                      aux_last_type_read_for_NRS = SCALAR_INT;
                                    } else {
                                    }
                                    // assign expression to variable cpp_int_val
                                    cpp_int_val = (6*py::cast<int>(cpp_current_dict.attr("get")("NX", -99999)));
                                    aux_cpp_int_val_read = true;
                                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                    // assign expression to variable NX
                                    var_NX_0d_int_Scalar = (cpp_int_val/6);
                                    aux_NX_read = true;
                                    validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                    aux_last_type_read_for_NX = SCALAR_INT;
                                    if ((! (aux_NX_read == true))) {
                                      // assign expression to variable NX
                                      var_NX_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NX", -99999));
                                      aux_NX_read = true;
                                      validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                      aux_last_type_read_for_NX = SCALAR_INT;
                                    } else {
                                    }
                                    if (((((((((aux_NRS_read == true)) && ((var_NRS_0d_int_Scalar)==(0)))))&&((((aux_NX_read == true)) && ((var_NX_0d_int_Scalar)==(1)))))))) {
                                      cpp_found_match = true;
                                    }
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , NRS , (6*NX) , NX / \n { 0.0 } { m = 1 to 6 } ] LIST";
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                    // read LIST record
                                    cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                                    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["NRS"]), write_opts);
                                    if ((! (aux_NRS_read == true))) {
                                      // assign expression to variable NRS
                                      var_NRS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NRS"]);
                                      aux_NRS_read = true;
                                      validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                                      aux_last_type_read_for_NRS = SCALAR_INT;
                                    } else {
                                    }
                                    cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NX"])), write_opts);
                                    // assign expression to variable cpp_int_val
                                    cpp_int_val = (6*py::cast<int>(cpp_current_dict["NX"]));
                                    aux_cpp_int_val_read = true;
                                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                    // assign expression to variable NX
                                    var_NX_0d_int_Scalar = (cpp_int_val/6);
                                    aux_NX_read = true;
                                    validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                    aux_last_type_read_for_NX = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NX"]), write_opts);
                                    if ((! (aux_NX_read == true))) {
                                      // assign expression to variable NX
                                      var_NX_0d_int_Scalar = py::cast<int>(cpp_current_dict["NX"]);
                                      aux_NX_read = true;
                                      validate_vartype_consistency("NX", SCALAR_INT, aux_last_type_read_for_NX);
                                      aux_last_type_read_for_NX = SCALAR_INT;
                                    } else {
                                    }
                                    cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NX"])), write_opts);
                                    cont << cpp_draft_line;
                                    {
                                      int cpp_npl = (6*py::cast<int>(cpp_current_dict["NX"]));
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      // read LIST body

                                      for (int var_m_0d_int_Scalar = 1;
                                         var_m_0d_int_Scalar <= 6; var_m_0d_int_Scalar++) {
                                        bool aux_m_read = true;
                                        // read LIST body
                                        cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                        cpp_i++;
                                        cpp_j++;
                                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                          cont << cpp_draft_line;
                                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                          cpp_j = 0;
                                        }
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                    cont << cpp_draft_line;
                                  }
                                }
                              }
                            }
                            cpp_current_dict = cpp_parent_dict_tmp;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                if ((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(2)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  // evaluate if-elif-else clause
                  {
                    bool cpp_found_match = false;
                    if (! cpp_found_match) {
                      if (((((((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(0)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                              // read TAB1 record
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                              cpp_nr_val = py::len(cpp_current_dict["INT"]);
                              cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
                              cpp_np_val = py::len(cpp_current_dict["Eint"]);
                              cont << cpp_draft_line;
                              tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
                              tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["AP"]);
                              tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                              tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                              write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                              {
                                Tab1Body tab_body = tab1_body;
                                // assign expression to variable Eint
                                var_Eint_0d_floatvec_Scalar = tab_body.X;
                                aux_Eint_read = true;
                                validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                                aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                                if ((! (aux_AP_read == true))) {
                                  // assign expression to variable AP
                                  var_AP_0d_floatvec_Scalar = tab_body.Y;
                                  aux_AP_read = true;
                                  validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                  aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                                } else {
                                }
                                // assign expression to variable INT
                                var_INT_0d_intvec_Scalar = tab_body.INT;
                                aux_INT_read = true;
                                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                aux_last_type_read_for_INT = SCALAR_INTVEC;
                                // assign expression to variable NBT
                                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                aux_NBT_read = true;
                                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                aux_last_type_read_for_NBT = SCALAR_INTVEC;
                              }
                              cont << cpp_draft_line;
                            }
                          }
                        }
                        // evaluate if-elif-else clause
                        {
                          bool cpp_found_match = false;
                          if (! cpp_found_match) {
                            if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                              // if statement evaluation
                              cpp_found_match = true;
                              cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , LSSF , 0 , NLS , 0 ] CONT";
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              // read CONT record
                              cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                              if ((! (aux_SPI_read == true))) {
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              } else {
                              }
                              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LSSF"]), write_opts);
                              // assign expression to variable LSSF
                              var_LSSF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LSSF"]);
                              aux_LSSF_read = true;
                              validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                              aux_last_type_read_for_LSSF = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                              if ((! (aux_NLS_read == true))) {
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } else {
                              }
                              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                              cont << cpp_draft_line;
                            }
                          }
                          if (! cpp_found_match) {
                            cpp_template = "[ MAT , 2 , 151 / SPI , AP , LSSF , 0 , NLS , 0 ] CONT";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read CONT record
                            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                            if ((! (aux_SPI_read == true))) {
                              // assign expression to variable SPI
                              var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                              aux_SPI_read = true;
                              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                            } else {
                            }
                            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AP"]), write_opts);
                            if ((! (aux_AP_read == true))) {
                              // assign expression to variable AP
                              var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict["AP"]);
                              aux_AP_read = true;
                              validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                              aux_last_type_read_for_AP = SCALAR_DOUBLE;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LSSF"]), write_opts);
                            // assign expression to variable LSSF
                            var_LSSF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LSSF"]);
                            aux_LSSF_read = true;
                            validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                            aux_last_type_read_for_LSSF = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                            if ((! (aux_NLS_read == true))) {
                              // assign expression to variable NLS
                              var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                              aux_NLS_read = true;
                              validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                              aux_last_type_read_for_NLS = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                            cont << cpp_draft_line;
                          }
                        }

                        for (int var_p_0d_int_Scalar = 1;
                           var_p_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                          bool aux_p_read = true;
                          // open section l_group
                          {
                            py::dict cpp_parent_dict_tmp = cpp_current_dict;
                            if ((! cpp_parent_dict_tmp.contains("l_group"))) {
                              cpp_parent_dict_tmp["l_group"] = py::dict();
                            }
                            py::dict cpp_current_dict = cpp_parent_dict_tmp["l_group"];
                            if ((! cpp_current_dict.contains(py::cast(var_p_0d_int_Scalar)))) {
                              cpp_current_dict[py::cast(var_p_0d_int_Scalar)] = py::dict();
                            }
                            cpp_current_dict = cpp_current_dict[py::cast(var_p_0d_int_Scalar)];
                            // variable declarations
                            double var_AWRI_0d_double_Scalar;
                            bool aux_AWRI_read = false;
                            vartype aux_last_type_read_for_AWRI = UNKNOWN;
                            int var_L_0d_int_Scalar;
                            bool aux_L_read = false;
                            vartype aux_last_type_read_for_L = UNKNOWN;
                            int cpp_int_val;
                            bool aux_cpp_int_val_read = false;
                            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                            int var_NJS_0d_int_Scalar;
                            bool aux_NJS_read = false;
                            vartype aux_last_type_read_for_NJS = UNKNOWN;
                            NestedVector<double> var_D_1d_double_NestedVector;
                            vartype aux_last_type_read_for_D = UNKNOWN;
                            NestedVector<double> var_AJ_1d_double_NestedVector;
                            vartype aux_last_type_read_for_AJ = UNKNOWN;
                            NestedVector<double> var_AMUN_1d_double_NestedVector;
                            vartype aux_last_type_read_for_AMUN = UNKNOWN;
                            NestedVector<double> var_GN0_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GN0 = UNKNOWN;
                            NestedVector<double> var_GG_1d_double_NestedVector;
                            vartype aux_last_type_read_for_GG = UNKNOWN;
                            cpp_template = "[ MAT , 2 , 151 / AWRI , 0.0 , L , 0 , (6*NJS) , NJS / \n { D , AJ , AMUN , GN0 , GG , 0.0 } { m = 1 to NJS } ] LIST";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST record
                            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AWRI"]), write_opts);
                            // assign expression to variable AWRI
                            var_AWRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWRI"]);
                            aux_AWRI_read = true;
                            validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                            aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                            cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["L"]), write_opts);
                            // assign expression to variable L
                            var_L_0d_int_Scalar = py::cast<int>(cpp_current_dict["L"]);
                            aux_L_read = true;
                            validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                            aux_last_type_read_for_L = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NJS"])), write_opts);
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (6*py::cast<int>(cpp_current_dict["NJS"]));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NJS
                            var_NJS_0d_int_Scalar = (cpp_int_val/6);
                            aux_NJS_read = true;
                            validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                            aux_last_type_read_for_NJS = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NJS"]), write_opts);
                            if ((! (aux_NJS_read == true))) {
                              // assign expression to variable NJS
                              var_NJS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NJS"]);
                              aux_NJS_read = true;
                              validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                              aux_last_type_read_for_NJS = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NJS"])), write_opts);
                            cont << cpp_draft_line;
                            {
                              int cpp_npl = (6*py::cast<int>(cpp_current_dict["NJS"]));
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              // read LIST body

                              for (int var_m_0d_int_Scalar = 1;
                                 var_m_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                bool aux_m_read = true;
                                // read LIST body
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["D"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                                // assign expression to variable D
                                var_D_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["D"][py::cast(var_m_0d_int_Scalar)]));
                                validate_vartype_consistency("D", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_D);
                                aux_last_type_read_for_D = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                                // assign expression to variable AJ
                                var_AJ_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_m_0d_int_Scalar)]));
                                validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                                aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AMUN"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                                // assign expression to variable AMUN
                                var_AMUN_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["AMUN"][py::cast(var_m_0d_int_Scalar)]));
                                validate_vartype_consistency("AMUN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AMUN);
                                aux_last_type_read_for_AMUN = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GN0"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                                // assign expression to variable GN0
                                var_GN0_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["GN0"][py::cast(var_m_0d_int_Scalar)]));
                                validate_vartype_consistency("GN0", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN0);
                                aux_last_type_read_for_GN0 = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GG"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                                // assign expression to variable GG
                                var_GG_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["GG"][py::cast(var_m_0d_int_Scalar)]));
                                validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                                aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                                cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            cont << cpp_draft_line;
                            cpp_current_dict = cpp_parent_dict_tmp;
                          }
                        }
                      }
                    }
                    if (! cpp_found_match) {
                      if (! cpp_found_match) {
                        if (((((((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 2 , 151 / SPI , AP , LSSF , 0 , NE , NLS / \n { ES } { p = 1 to NE } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                          if ((! (aux_SPI_read == true))) {
                            // assign expression to variable SPI
                            var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                            aux_SPI_read = true;
                            validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                            aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                          } else {
                          }
                          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AP"]), write_opts);
                          if ((! (aux_AP_read == true))) {
                            // assign expression to variable AP
                            var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict["AP"]);
                            aux_AP_read = true;
                            validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                            aux_last_type_read_for_AP = SCALAR_DOUBLE;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LSSF"]), write_opts);
                          // assign expression to variable LSSF
                          var_LSSF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LSSF"]);
                          aux_LSSF_read = true;
                          validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                          aux_last_type_read_for_LSSF = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NE"]), write_opts);
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                          if ((! (aux_NLS_read == true))) {
                            // assign expression to variable NLS
                            var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                            aux_NLS_read = true;
                            validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                            aux_last_type_read_for_NLS = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NE"]), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = py::cast<int>(cpp_current_dict["NE"]);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body

                            for (int var_p_0d_int_Scalar = 1;
                               var_p_0d_int_Scalar <= var_NE_0d_int_Scalar; var_p_0d_int_Scalar++) {
                              bool aux_p_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ES"][py::cast(var_p_0d_int_Scalar)]), write_opts);
                              // assign expression to variable ES
                              var_ES_1d_double_NestedVector.set(var_p_0d_int_Scalar, py::cast<double>(cpp_current_dict["ES"][py::cast(var_p_0d_int_Scalar)]));
                              validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                              aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;

                          for (int var_p_0d_int_Scalar = 1;
                             var_p_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                            bool aux_p_read = true;
                            // open section j_group
                            {
                              py::dict cpp_parent_dict_tmp = cpp_current_dict;
                              if ((! cpp_parent_dict_tmp.contains("j_group"))) {
                                cpp_parent_dict_tmp["j_group"] = py::dict();
                              }
                              py::dict cpp_current_dict = cpp_parent_dict_tmp["j_group"];
                              if ((! cpp_current_dict.contains(py::cast(var_p_0d_int_Scalar)))) {
                                cpp_current_dict[py::cast(var_p_0d_int_Scalar)] = py::dict();
                              }
                              cpp_current_dict = cpp_current_dict[py::cast(var_p_0d_int_Scalar)];
                              // variable declarations
                              double var_AWRI_0d_double_Scalar;
                              bool aux_AWRI_read = false;
                              vartype aux_last_type_read_for_AWRI = UNKNOWN;
                              int var_L_0d_int_Scalar;
                              bool aux_L_read = false;
                              vartype aux_last_type_read_for_L = UNKNOWN;
                              int var_NJS_0d_int_Scalar;
                              bool aux_NJS_read = false;
                              vartype aux_last_type_read_for_NJS = UNKNOWN;
                              cpp_template = "[ MAT , 2 , 151 / AWRI , 0.0 , L , 0 , NJS , 0 ] CONT";
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              // read CONT record
                              cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AWRI"]), write_opts);
                              // assign expression to variable AWRI
                              var_AWRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWRI"]);
                              aux_AWRI_read = true;
                              validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                              aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["L"]), write_opts);
                              // assign expression to variable L
                              var_L_0d_int_Scalar = py::cast<int>(cpp_current_dict["L"]);
                              aux_L_read = true;
                              validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                              aux_last_type_read_for_L = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NJS"]), write_opts);
                              // assign expression to variable NJS
                              var_NJS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NJS"]);
                              aux_NJS_read = true;
                              validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                              aux_last_type_read_for_NJS = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                              cont << cpp_draft_line;

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // open section subsec
                                {
                                  py::dict cpp_parent_dict_tmp = cpp_current_dict;
                                  if ((! cpp_parent_dict_tmp.contains("subsec"))) {
                                    cpp_parent_dict_tmp["subsec"] = py::dict();
                                  }
                                  py::dict cpp_current_dict = cpp_parent_dict_tmp["subsec"];
                                  if ((! cpp_current_dict.contains(py::cast(var_n_0d_int_Scalar)))) {
                                    cpp_current_dict[py::cast(var_n_0d_int_Scalar)] = py::dict();
                                  }
                                  cpp_current_dict = cpp_current_dict[py::cast(var_n_0d_int_Scalar)];
                                  // variable declarations
                                  int var_L_0d_int_Scalar;
                                  bool aux_L_read = false;
                                  vartype aux_last_type_read_for_L = UNKNOWN;
                                  int var_MUF_0d_int_Scalar;
                                  bool aux_MUF_read = false;
                                  vartype aux_last_type_read_for_MUF = UNKNOWN;
                                  int cpp_int_val;
                                  bool aux_cpp_int_val_read = false;
                                  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                  int var_NE_0d_int_Scalar;
                                  bool aux_NE_read = false;
                                  vartype aux_last_type_read_for_NE = UNKNOWN;
                                  double var_D_0d_double_Scalar;
                                  bool aux_D_read = false;
                                  vartype aux_last_type_read_for_D = UNKNOWN;
                                  double var_AJ_0d_double_Scalar;
                                  bool aux_AJ_read = false;
                                  vartype aux_last_type_read_for_AJ = UNKNOWN;
                                  double var_AMUN_0d_double_Scalar;
                                  bool aux_AMUN_read = false;
                                  vartype aux_last_type_read_for_AMUN = UNKNOWN;
                                  double var_GN0_0d_double_Scalar;
                                  bool aux_GN0_read = false;
                                  vartype aux_last_type_read_for_GN0 = UNKNOWN;
                                  double var_GG_0d_double_Scalar;
                                  bool aux_GG_read = false;
                                  vartype aux_last_type_read_for_GG = UNKNOWN;
                                  NestedVector<double> var_GF_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GF = UNKNOWN;
                                  cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , L , MUF , (NE+6) , 0 / \n D , AJ , AMUN , GN0 , GG , 0.0 , \n { GF } { m = 1 to NE } ] LIST";
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  // read LIST record
                                  cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                                  cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["L"]), write_opts);
                                  if ((! (aux_L_read == true))) {
                                    // assign expression to variable L
                                    var_L_0d_int_Scalar = py::cast<int>(cpp_current_dict["L"]);
                                    aux_L_read = true;
                                    validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                                    aux_last_type_read_for_L = SCALAR_INT;
                                  } else {
                                  }
                                  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["MUF"]), write_opts);
                                  // assign expression to variable MUF
                                  var_MUF_0d_int_Scalar = py::cast<int>(cpp_current_dict["MUF"]);
                                  aux_MUF_read = true;
                                  validate_vartype_consistency("MUF", SCALAR_INT, aux_last_type_read_for_MUF);
                                  aux_last_type_read_for_MUF = SCALAR_INT;
                                  cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_current_dict["NE"])+6), write_opts);
                                  if ((! (aux_NE_read == true))) {
                                    // assign expression to variable cpp_int_val
                                    cpp_int_val = (py::cast<int>(cpp_current_dict["NE"])+6);
                                    aux_cpp_int_val_read = true;
                                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                    // assign expression to variable NE
                                    var_NE_0d_int_Scalar = (cpp_int_val+(-6));
                                    aux_NE_read = true;
                                    validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                                    aux_last_type_read_for_NE = SCALAR_INT;
                                  } else {
                                  }
                                  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_current_dict["NE"])+6), write_opts);
                                  cont << cpp_draft_line;
                                  {
                                    int cpp_npl = (py::cast<int>(cpp_current_dict["NE"])+6);
                                    int cpp_i = 0;
                                    int cpp_j = 0;
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                    // read LIST body
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["D"]), write_opts);
                                    // assign expression to variable D
                                    var_D_0d_double_Scalar = py::cast<double>(cpp_current_dict["D"]);
                                    aux_D_read = true;
                                    validate_vartype_consistency("D", SCALAR_DOUBLE, aux_last_type_read_for_D);
                                    aux_last_type_read_for_D = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AJ"]), write_opts);
                                    // assign expression to variable AJ
                                    var_AJ_0d_double_Scalar = py::cast<double>(cpp_current_dict["AJ"]);
                                    aux_AJ_read = true;
                                    validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                                    aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AMUN"]), write_opts);
                                    // assign expression to variable AMUN
                                    var_AMUN_0d_double_Scalar = py::cast<double>(cpp_current_dict["AMUN"]);
                                    aux_AMUN_read = true;
                                    validate_vartype_consistency("AMUN", SCALAR_DOUBLE, aux_last_type_read_for_AMUN);
                                    aux_last_type_read_for_AMUN = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GN0"]), write_opts);
                                    // assign expression to variable GN0
                                    var_GN0_0d_double_Scalar = py::cast<double>(cpp_current_dict["GN0"]);
                                    aux_GN0_read = true;
                                    validate_vartype_consistency("GN0", SCALAR_DOUBLE, aux_last_type_read_for_GN0);
                                    aux_last_type_read_for_GN0 = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GG"]), write_opts);
                                    // assign expression to variable GG
                                    var_GG_0d_double_Scalar = py::cast<double>(cpp_current_dict["GG"]);
                                    aux_GG_read = true;
                                    validate_vartype_consistency("GG", SCALAR_DOUBLE, aux_last_type_read_for_GG);
                                    aux_last_type_read_for_GG = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }

                                    for (int var_m_0d_int_Scalar = 1;
                                       var_m_0d_int_Scalar <= var_NE_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                      bool aux_m_read = true;
                                      // read LIST body
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GF"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                                      // assign expression to variable GF
                                      var_GF_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["GF"][py::cast(var_m_0d_int_Scalar)]));
                                      validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                                      aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                    }
                                    if (cpp_i != cpp_npl) {
                                      throw std::runtime_error("not exactly NPL elements consumed");
                                    }
                                  }
                                  cont << cpp_draft_line;
                                  cpp_current_dict = cpp_parent_dict_tmp;
                                }
                              }
                              cpp_current_dict = cpp_parent_dict_tmp;
                            }
                          }
                        }
                      }
                    }
                    if (! cpp_found_match) {
                      if (! cpp_found_match) {
                        if ((((((((((((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(0))))))||(((((aux_LFW_read == true)) && ((var_LFW_0d_int_Scalar)==(1)))))))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          // evaluate if-elif-else clause
                          {
                            bool cpp_found_match = false;
                            if (! cpp_found_match) {
                              if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                                // if statement evaluation
                                cpp_found_match = true;
                                cpp_template = "[ MAT , 2 , 151 / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / AP ] TAB1";
                                // read TAB1 record
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                                cpp_nr_val = py::len(cpp_current_dict["INT"]);
                                cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
                                cpp_np_val = py::len(cpp_current_dict["Eint"]);
                                cont << cpp_draft_line;
                                tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
                                tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["AP"]);
                                tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                                tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                                write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                                {
                                  Tab1Body tab_body = tab1_body;
                                  // assign expression to variable Eint
                                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                                  aux_Eint_read = true;
                                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                                  if ((! (aux_AP_read == true))) {
                                    // assign expression to variable AP
                                    var_AP_0d_floatvec_Scalar = tab_body.Y;
                                    aux_AP_read = true;
                                    validate_vartype_consistency("AP", SCALAR_FLOATVEC, aux_last_type_read_for_AP);
                                    aux_last_type_read_for_AP = SCALAR_FLOATVEC;
                                  } else {
                                  }
                                  // assign expression to variable INT
                                  var_INT_0d_intvec_Scalar = tab_body.INT;
                                  aux_INT_read = true;
                                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                                  // assign expression to variable NBT
                                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                                  aux_NBT_read = true;
                                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                                }
                                cont << cpp_draft_line;
                              }
                            }
                          }
                          // evaluate if-elif-else clause
                          {
                            bool cpp_found_match = false;
                            if (! cpp_found_match) {
                              if (((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))&&(((((((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(0))))))||(((((aux_NAPS_read == true)) && ((var_NAPS_0d_int_Scalar)==(1)))))))))))) {
                                // if statement evaluation
                                cpp_found_match = true;
                                cpp_template = "[ MAT , 2 , 151 / SPI , 0.0 , LSSF , 0 , NLS , 0 ] CONT";
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                // read CONT record
                                cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                                if ((! (aux_SPI_read == true))) {
                                  // assign expression to variable SPI
                                  var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                                  aux_SPI_read = true;
                                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                                } else {
                                }
                                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                                cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LSSF"]), write_opts);
                                // assign expression to variable LSSF
                                var_LSSF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LSSF"]);
                                aux_LSSF_read = true;
                                validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                                aux_last_type_read_for_LSSF = SCALAR_INT;
                                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                                if ((! (aux_NLS_read == true))) {
                                  // assign expression to variable NLS
                                  var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                                  aux_NLS_read = true;
                                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                  aux_last_type_read_for_NLS = SCALAR_INT;
                                } else {
                                }
                                cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                cont << cpp_draft_line;
                              }
                            }
                            if (! cpp_found_match) {
                              cpp_template = "[ MAT , 2 , 151 / SPI , AP , LSSF , 0 , NLS , 0 ] CONT";
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              // read CONT record
                              cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                              if ((! (aux_SPI_read == true))) {
                                // assign expression to variable SPI
                                var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                                aux_SPI_read = true;
                                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                              } else {
                              }
                              cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AP"]), write_opts);
                              if ((! (aux_AP_read == true))) {
                                // assign expression to variable AP
                                var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict["AP"]);
                                aux_AP_read = true;
                                validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                                aux_last_type_read_for_AP = SCALAR_DOUBLE;
                              } else {
                              }
                              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LSSF"]), write_opts);
                              // assign expression to variable LSSF
                              var_LSSF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LSSF"]);
                              aux_LSSF_read = true;
                              validate_vartype_consistency("LSSF", SCALAR_INT, aux_last_type_read_for_LSSF);
                              aux_last_type_read_for_LSSF = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                              if ((! (aux_NLS_read == true))) {
                                // assign expression to variable NLS
                                var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                                aux_NLS_read = true;
                                validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                                aux_last_type_read_for_NLS = SCALAR_INT;
                              } else {
                              }
                              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                              cont << cpp_draft_line;
                            }
                          }

                          for (int var_p_0d_int_Scalar = 1;
                             var_p_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                            bool aux_p_read = true;
                            // open section l_group
                            {
                              py::dict cpp_parent_dict_tmp = cpp_current_dict;
                              if ((! cpp_parent_dict_tmp.contains("l_group"))) {
                                cpp_parent_dict_tmp["l_group"] = py::dict();
                              }
                              py::dict cpp_current_dict = cpp_parent_dict_tmp["l_group"];
                              if ((! cpp_current_dict.contains(py::cast(var_p_0d_int_Scalar)))) {
                                cpp_current_dict[py::cast(var_p_0d_int_Scalar)] = py::dict();
                              }
                              cpp_current_dict = cpp_current_dict[py::cast(var_p_0d_int_Scalar)];
                              // variable declarations
                              double var_AWRI_0d_double_Scalar;
                              bool aux_AWRI_read = false;
                              vartype aux_last_type_read_for_AWRI = UNKNOWN;
                              int var_L_0d_int_Scalar;
                              bool aux_L_read = false;
                              vartype aux_last_type_read_for_L = UNKNOWN;
                              int var_NJS_0d_int_Scalar;
                              bool aux_NJS_read = false;
                              vartype aux_last_type_read_for_NJS = UNKNOWN;
                              cpp_template = "[ MAT , 2 , 151 / AWRI , 0.0 , L , 0 , NJS , 0 ] CONT";
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              // read CONT record
                              cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AWRI"]), write_opts);
                              // assign expression to variable AWRI
                              var_AWRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWRI"]);
                              aux_AWRI_read = true;
                              validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                              aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["L"]), write_opts);
                              // assign expression to variable L
                              var_L_0d_int_Scalar = py::cast<int>(cpp_current_dict["L"]);
                              aux_L_read = true;
                              validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                              aux_last_type_read_for_L = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NJS"]), write_opts);
                              // assign expression to variable NJS
                              var_NJS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NJS"]);
                              aux_NJS_read = true;
                              validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                              aux_last_type_read_for_NJS = SCALAR_INT;
                              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                              cont << cpp_draft_line;

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // open section subsec
                                {
                                  py::dict cpp_parent_dict_tmp = cpp_current_dict;
                                  if ((! cpp_parent_dict_tmp.contains("subsec"))) {
                                    cpp_parent_dict_tmp["subsec"] = py::dict();
                                  }
                                  py::dict cpp_current_dict = cpp_parent_dict_tmp["subsec"];
                                  if ((! cpp_current_dict.contains(py::cast(var_n_0d_int_Scalar)))) {
                                    cpp_current_dict[py::cast(var_n_0d_int_Scalar)] = py::dict();
                                  }
                                  cpp_current_dict = cpp_current_dict[py::cast(var_n_0d_int_Scalar)];
                                  // variable declarations
                                  double var_AJ_0d_double_Scalar;
                                  bool aux_AJ_read = false;
                                  vartype aux_last_type_read_for_AJ = UNKNOWN;
                                  int var_INT_0d_int_Scalar;
                                  bool aux_INT_read = false;
                                  vartype aux_last_type_read_for_INT = UNKNOWN;
                                  int cpp_int_val;
                                  bool aux_cpp_int_val_read = false;
                                  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                                  int var_NE_0d_int_Scalar;
                                  bool aux_NE_read = false;
                                  vartype aux_last_type_read_for_NE = UNKNOWN;
                                  double var_AMUX_0d_double_Scalar;
                                  bool aux_AMUX_read = false;
                                  vartype aux_last_type_read_for_AMUX = UNKNOWN;
                                  double var_AMUN_0d_double_Scalar;
                                  bool aux_AMUN_read = false;
                                  vartype aux_last_type_read_for_AMUN = UNKNOWN;
                                  double var_AMUG_0d_double_Scalar;
                                  bool aux_AMUG_read = false;
                                  vartype aux_last_type_read_for_AMUG = UNKNOWN;
                                  double var_AMUF_0d_double_Scalar;
                                  bool aux_AMUF_read = false;
                                  vartype aux_last_type_read_for_AMUF = UNKNOWN;
                                  NestedVector<double> var_ES_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_ES = UNKNOWN;
                                  NestedVector<double> var_D_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_D = UNKNOWN;
                                  NestedVector<double> var_GX_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GX = UNKNOWN;
                                  NestedVector<double> var_GN0_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GN0 = UNKNOWN;
                                  NestedVector<double> var_GG_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GG = UNKNOWN;
                                  NestedVector<double> var_GF_1d_double_NestedVector;
                                  vartype aux_last_type_read_for_GF = UNKNOWN;
                                  cpp_template = "[ MAT , 2 , 151 / AJ , 0.0 , INT , 0 , ((6*NE)+6) , NE / \n 0.0 , 0.0 , AMUX , AMUN , AMUG , AMUF , \n { ES , D , GX , GN0 , GG , GF } { m = 1 to NE } ] LIST";
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  // read LIST record
                                  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AJ"]), write_opts);
                                  // assign expression to variable AJ
                                  var_AJ_0d_double_Scalar = py::cast<double>(cpp_current_dict["AJ"]);
                                  aux_AJ_read = true;
                                  validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                                  aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                                  cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["INT"]), write_opts);
                                  if ((! (aux_INT_read == true))) {
                                    // assign expression to variable INT
                                    var_INT_0d_int_Scalar = py::cast<int>(cpp_current_dict["INT"]);
                                    aux_INT_read = true;
                                    validate_vartype_consistency("INT", SCALAR_INT, aux_last_type_read_for_INT);
                                    aux_last_type_read_for_INT = SCALAR_INT;
                                  } else {
                                  }
                                  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 4, ((6*py::cast<int>(cpp_current_dict["NE"]))+6), write_opts);
                                  // assign expression to variable cpp_int_val
                                  cpp_int_val = ((6*py::cast<int>(cpp_current_dict["NE"]))+6);
                                  aux_cpp_int_val_read = true;
                                  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                                  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                                  // assign expression to variable NE
                                  var_NE_0d_int_Scalar = ((cpp_int_val+(-6))/6);
                                  aux_NE_read = true;
                                  validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                                  aux_last_type_read_for_NE = SCALAR_INT;
                                  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
                                  if ((! (aux_NE_read == true))) {
                                    // assign expression to variable NE
                                    var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
                                    aux_NE_read = true;
                                    validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                                    aux_last_type_read_for_NE = SCALAR_INT;
                                  } else {
                                  }
                                  cpp_write_field<int>(cpp_draft_line, 4, ((6*py::cast<int>(cpp_current_dict["NE"]))+6), write_opts);
                                  cont << cpp_draft_line;
                                  {
                                    int cpp_npl = ((6*py::cast<int>(cpp_current_dict["NE"]))+6);
                                    int cpp_i = 0;
                                    int cpp_j = 0;
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                    // read LIST body
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AMUX"]), write_opts);
                                    // assign expression to variable AMUX
                                    var_AMUX_0d_double_Scalar = py::cast<double>(cpp_current_dict["AMUX"]);
                                    aux_AMUX_read = true;
                                    validate_vartype_consistency("AMUX", SCALAR_DOUBLE, aux_last_type_read_for_AMUX);
                                    aux_last_type_read_for_AMUX = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AMUN"]), write_opts);
                                    // assign expression to variable AMUN
                                    var_AMUN_0d_double_Scalar = py::cast<double>(cpp_current_dict["AMUN"]);
                                    aux_AMUN_read = true;
                                    validate_vartype_consistency("AMUN", SCALAR_DOUBLE, aux_last_type_read_for_AMUN);
                                    aux_last_type_read_for_AMUN = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AMUG"]), write_opts);
                                    // assign expression to variable AMUG
                                    var_AMUG_0d_double_Scalar = py::cast<double>(cpp_current_dict["AMUG"]);
                                    aux_AMUG_read = true;
                                    validate_vartype_consistency("AMUG", SCALAR_DOUBLE, aux_last_type_read_for_AMUG);
                                    aux_last_type_read_for_AMUG = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AMUF"]), write_opts);
                                    // assign expression to variable AMUF
                                    var_AMUF_0d_double_Scalar = py::cast<double>(cpp_current_dict["AMUF"]);
                                    aux_AMUF_read = true;
                                    validate_vartype_consistency("AMUF", SCALAR_DOUBLE, aux_last_type_read_for_AMUF);
                                    aux_last_type_read_for_AMUF = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }

                                    for (int var_m_0d_int_Scalar = 1;
                                       var_m_0d_int_Scalar <= var_NE_0d_int_Scalar; var_m_0d_int_Scalar++) {
                                      bool aux_m_read = true;
                                      // read LIST body
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ES"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                                      // assign expression to variable ES
                                      var_ES_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["ES"][py::cast(var_m_0d_int_Scalar)]));
                                      validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                                      aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["D"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                                      // assign expression to variable D
                                      var_D_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["D"][py::cast(var_m_0d_int_Scalar)]));
                                      validate_vartype_consistency("D", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_D);
                                      aux_last_type_read_for_D = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GX"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                                      // assign expression to variable GX
                                      var_GX_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["GX"][py::cast(var_m_0d_int_Scalar)]));
                                      validate_vartype_consistency("GX", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GX);
                                      aux_last_type_read_for_GX = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GN0"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                                      // assign expression to variable GN0
                                      var_GN0_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["GN0"][py::cast(var_m_0d_int_Scalar)]));
                                      validate_vartype_consistency("GN0", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN0);
                                      aux_last_type_read_for_GN0 = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GG"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                                      // assign expression to variable GG
                                      var_GG_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["GG"][py::cast(var_m_0d_int_Scalar)]));
                                      validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                                      aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GF"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                                      // assign expression to variable GF
                                      var_GF_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["GF"][py::cast(var_m_0d_int_Scalar)]));
                                      validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                                      aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                    }
                                    if (cpp_i != cpp_npl) {
                                      throw std::runtime_error("not exactly NPL elements consumed");
                                    }
                                  }
                                  cont << cpp_draft_line;
                                  cpp_current_dict = cpp_parent_dict_tmp;
                                }
                              }
                              cpp_current_dict = cpp_parent_dict_tmp;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          cpp_current_dict = cpp_parent_dict_tmp;
        }
      }
      cpp_current_dict = cpp_parent_dict_tmp;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: b060c9a10c5a2def7c0e13f02c35f9ae
// MD5 hash of the following function definition: 49d41fa184b495c44845d3ac8dac6538
void write_mf3_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  double var_QM_0d_double_Scalar;
  bool aux_QM_read = false;
  vartype aux_last_type_read_for_QM = UNKNOWN;
  double var_QI_0d_double_Scalar;
  bool aux_QI_read = false;
  vartype aux_last_type_read_for_QI = UNKNOWN;
  int var_LR_0d_int_Scalar;
  bool aux_LR_read = false;
  vartype aux_last_type_read_for_LR = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 3;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 3;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 3 , MT / ZA , AWR , 0 , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 3 , MT / QM , QI , 0 , LR , NR , NP / E / xs ] TAB1 ( xstable )";
  // read TAB1 record
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["QM"]), write_opts);
  // assign expression to variable QM
  var_QM_0d_double_Scalar = py::cast<double>(cpp_current_dict["QM"]);
  aux_QM_read = true;
  validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
  aux_last_type_read_for_QM = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["QI"]), write_opts);
  // assign expression to variable QI
  var_QI_0d_double_Scalar = py::cast<double>(cpp_current_dict["QI"]);
  aux_QI_read = true;
  validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
  aux_last_type_read_for_QI = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LR"]), write_opts);
  // assign expression to variable LR
  var_LR_0d_int_Scalar = py::cast<int>(cpp_current_dict["LR"]);
  aux_LR_read = true;
  validate_vartype_consistency("LR", SCALAR_INT, aux_last_type_read_for_LR);
  aux_last_type_read_for_LR = SCALAR_INT;
  {
    py::dict cpp_parent_dict_tmp = cpp_current_dict;
    if ((! cpp_parent_dict_tmp.contains("xstable"))) {
      cpp_parent_dict_tmp["xstable"] = py::dict();
    }
    py::dict cpp_current_dict = cpp_parent_dict_tmp["xstable"];
    cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
    cpp_nr_val = py::len(cpp_current_dict["INT"]);
    cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
    cpp_np_val = py::len(cpp_current_dict["E"]);
    cont << cpp_draft_line;
    tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
    tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["xs"]);
    tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
    tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
    write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
    // variable declarations
    std::vector<double> var_E_0d_floatvec_Scalar;
    bool aux_E_read = false;
    vartype aux_last_type_read_for_E = UNKNOWN;
    std::vector<double> var_xs_0d_floatvec_Scalar;
    bool aux_xs_read = false;
    vartype aux_last_type_read_for_xs = UNKNOWN;
    std::vector<int> var_INT_0d_intvec_Scalar;
    bool aux_INT_read = false;
    vartype aux_last_type_read_for_INT = UNKNOWN;
    std::vector<int> var_NBT_0d_intvec_Scalar;
    bool aux_NBT_read = false;
    vartype aux_last_type_read_for_NBT = UNKNOWN;
    {
      Tab1Body tab_body = tab1_body;
      // assign expression to variable E
      var_E_0d_floatvec_Scalar = tab_body.X;
      aux_E_read = true;
      validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
      aux_last_type_read_for_E = SCALAR_FLOATVEC;
      // assign expression to variable xs
      var_xs_0d_floatvec_Scalar = tab_body.Y;
      aux_xs_read = true;
      validate_vartype_consistency("xs", SCALAR_FLOATVEC, aux_last_type_read_for_xs);
      aux_last_type_read_for_xs = SCALAR_FLOATVEC;
      // assign expression to variable INT
      var_INT_0d_intvec_Scalar = tab_body.INT;
      aux_INT_read = true;
      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
      aux_last_type_read_for_INT = SCALAR_INTVEC;
      // assign expression to variable NBT
      var_NBT_0d_intvec_Scalar = tab_body.NBT;
      aux_NBT_read = true;
      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
      aux_last_type_read_for_NBT = SCALAR_INTVEC;
    }
    cont << cpp_draft_line;
    cpp_current_dict = cpp_parent_dict_tmp;
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: c4d60855b8643a410283ef0c47845391
// MD5 hash of the following function definition: e195e77b592aa183f3e88dbdbfdfe449
void write_mf4_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LTT_0d_int_Scalar;
  bool aux_LTT_read = false;
  vartype aux_last_type_read_for_LTT = UNKNOWN;
  int var_LI_0d_int_Scalar;
  bool aux_LI_read = false;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_LCT_0d_int_Scalar;
  bool aux_LCT_read = false;
  vartype aux_last_type_read_for_LCT = UNKNOWN;
  int var_NM_0d_int_Scalar;
  bool aux_NM_read = false;
  vartype aux_last_type_read_for_NM = UNKNOWN;
  int var_NE_0d_int_Scalar;
  bool aux_NE_read = false;
  vartype aux_last_type_read_for_NE = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  double var_T_0d_double_Scalar;
  bool aux_T_read = false;
  vartype aux_last_type_read_for_T = UNKNOWN;
  NestedVector<double> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  int var_LT_0d_int_Scalar;
  bool aux_LT_read = false;
  vartype aux_last_type_read_for_LT = UNKNOWN;
  NestedVector<int> var_NL_1d_int_NestedVector;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  NestedVector<NestedVector<double>> var_a_2d_double_NestedVector;
  NestedVector<double>* ptr_a_2d_idx0;
  vartype aux_last_type_read_for_a = UNKNOWN;
  int var_NE1_0d_int_Scalar;
  bool aux_NE1_read = false;
  vartype aux_last_type_read_for_NE1 = UNKNOWN;
  NestedVector<NestedVector<double>> var_al_2d_double_NestedVector;
  NestedVector<double>* ptr_al_2d_idx0;
  vartype aux_last_type_read_for_al = UNKNOWN;
  int var_NE2_0d_int_Scalar;
  bool aux_NE2_read = false;
  vartype aux_last_type_read_for_NE2 = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 4;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 4;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 4 , MT / ZA , AWR , 0 , LTT , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LTT"]), write_opts);
  // assign expression to variable LTT
  var_LTT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LTT"]);
  aux_LTT_read = true;
  validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
  aux_last_type_read_for_LTT = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LTT_0d_int_Scalar = var_LTT_0d_int_Scalar;
          int var_LTT_0d_int_Scalar = glob_var_LTT_0d_int_Scalar;
          bool& glob_aux_LTT_read = aux_LTT_read;
          bool aux_LTT_read = glob_aux_LTT_read;
          vartype aux_last_type_read_for_LTT = UNKNOWN;
          int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
          int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
          bool& glob_aux_LI_read = aux_LI_read;
          bool aux_LI_read = glob_aux_LI_read;
          vartype aux_last_type_read_for_LI = UNKNOWN;
          int& glob_var_LCT_0d_int_Scalar = var_LCT_0d_int_Scalar;
          int var_LCT_0d_int_Scalar = glob_var_LCT_0d_int_Scalar;
          bool& glob_aux_LCT_read = aux_LCT_read;
          bool aux_LCT_read = glob_aux_LCT_read;
          vartype aux_last_type_read_for_LCT = UNKNOWN;
          int& glob_var_NM_0d_int_Scalar = var_NM_0d_int_Scalar;
          int var_NM_0d_int_Scalar = glob_var_NM_0d_int_Scalar;
          bool& glob_aux_NM_read = aux_NM_read;
          bool aux_NM_read = glob_aux_NM_read;
          vartype aux_last_type_read_for_NM = UNKNOWN;
          cpp_template = "[ MAT , 4 , MT / 0.0 , AWR , LI , LCT , 0 , NM ] CONT";
          // read CONT record
          if ((! (aux_AWR_read == true))) {
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AWR", -99999.9));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          } else {
          }
          // assign expression to variable LI
          var_LI_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LI", -99999));
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          // assign expression to variable LCT
          var_LCT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LCT", -99999));
          aux_LCT_read = true;
          validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
          aux_last_type_read_for_LCT = SCALAR_INT;
          // assign expression to variable NM
          var_NM_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NM", -99999));
          aux_NM_read = true;
          validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
          aux_last_type_read_for_NM = SCALAR_INT;
          if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(3)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
            cpp_found_match = true;
          }
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 4 , MT / 0.0 , AWR , LI , LCT , 0 , NM ] CONT";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read CONT record
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
          if ((! (aux_AWR_read == true))) {
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          } else {
          }
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LI"]), write_opts);
          // assign expression to variable LI
          var_LI_0d_int_Scalar = py::cast<int>(cpp_current_dict["LI"]);
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LCT"]), write_opts);
          // assign expression to variable LCT
          var_LCT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCT"]);
          aux_LCT_read = true;
          validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
          aux_last_type_read_for_LCT = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NM"]), write_opts);
          // assign expression to variable NM
          var_NM_0d_int_Scalar = py::cast<int>(cpp_current_dict["NM"]);
          aux_NM_read = true;
          validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
          aux_last_type_read_for_NM = SCALAR_INT;
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      cpp_template = "[ MAT , 4 , MT / 0.0 , AWR , LI , LCT , 0 , 0 ] CONT";
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
      // read CONT record
      cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
      cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
      if ((! (aux_AWR_read == true))) {
        // assign expression to variable AWR
        var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
        aux_AWR_read = true;
        validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
        aux_last_type_read_for_AWR = SCALAR_DOUBLE;
      } else {
      }
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LI"]), write_opts);
      // assign expression to variable LI
      var_LI_0d_int_Scalar = py::cast<int>(cpp_current_dict["LI"]);
      aux_LI_read = true;
      validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
      aux_last_type_read_for_LI = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LCT"]), write_opts);
      // assign expression to variable LCT
      var_LCT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCT"]);
      aux_LCT_read = true;
      validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
      aux_last_type_read_for_LCT = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
      cont << cpp_draft_line;
    }
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(1)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
        // read TAB2 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
        // assign expression to variable NE
        var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
        aux_NE_read = true;
        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
        aux_last_type_read_for_NE = SCALAR_INT;
        cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
        cpp_nr_val = py::len(cpp_current_dict["INT"]);
        cont << cpp_draft_line;
        tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
        tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
        write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
        {
          Tab2Body tab_body = tab2_body;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
        cont << cpp_draft_line;

        for (int var_i_0d_int_Scalar = 1;
           var_i_0d_int_Scalar <= var_NE_0d_int_Scalar; var_i_0d_int_Scalar++) {
          bool aux_i_read = true;
          cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NL , 0 / { a } { l = 1 to NL } ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read LIST record
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["T"]), write_opts);
          // assign expression to variable T
          var_T_0d_double_Scalar = py::cast<double>(cpp_current_dict["T"]);
          aux_T_read = true;
          validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
          aux_last_type_read_for_T = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]), write_opts);
          // assign expression to variable E
          var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]));
          validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
          aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LT"]), write_opts);
          // assign expression to variable LT
          var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LT"]);
          aux_LT_read = true;
          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
          aux_last_type_read_for_LT = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NL"][py::cast(var_i_0d_int_Scalar)]), write_opts);
          // assign expression to variable NL
          var_NL_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_current_dict["NL"][py::cast(var_i_0d_int_Scalar)]));
          validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
          aux_last_type_read_for_NL = NESTEDVECTOR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NL"][py::cast(var_i_0d_int_Scalar)]), write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = py::cast<int>(cpp_current_dict["NL"][py::cast(var_i_0d_int_Scalar)]);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST body
            ptr_a_2d_idx0 = var_a_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

            for (int var_l_0d_int_Scalar = 1;
               var_l_0d_int_Scalar <= var_NL_1d_int_NestedVector[var_i_0d_int_Scalar]; var_l_0d_int_Scalar++) {
              bool aux_l_read = true;
              // read LIST body
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["a"][py::cast(var_i_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]), write_opts);
              // assign expression to variable a
              ptr_a_2d_idx0->set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["a"][py::cast(var_i_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]));
              validate_vartype_consistency("a", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_a);
              aux_last_type_read_for_a = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(2)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2 ( energy_table )";
          // read TAB2 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
          // assign expression to variable NE
          var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
          aux_NE_read = true;
          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
          aux_last_type_read_for_NE = SCALAR_INT;
          {
            py::dict cpp_parent_dict_tmp = cpp_current_dict;
            if ((! cpp_parent_dict_tmp.contains("energy_table"))) {
              cpp_parent_dict_tmp["energy_table"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict_tmp["energy_table"];
            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
            cpp_nr_val = py::len(cpp_current_dict["INT"]);
            cont << cpp_draft_line;
            tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
            tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
            write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
            // variable declarations
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab2Body tab_body = tab2_body;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            cont << cpp_draft_line;
            cpp_current_dict = cpp_parent_dict_tmp;
          }

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_NE_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NR , NP / mu / f ] TAB1 ( angtable [ i ] )";
            // read TAB1 record
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["T"]), write_opts);
            // assign expression to variable T
            var_T_0d_double_Scalar = py::cast<double>(cpp_current_dict["T"]);
            aux_T_read = true;
            validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
            aux_last_type_read_for_T = SCALAR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]), write_opts);
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LT"]), write_opts);
            // assign expression to variable LT
            var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LT"]);
            aux_LT_read = true;
            validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
            aux_last_type_read_for_LT = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            {
              py::dict cpp_parent_dict_tmp = cpp_current_dict;
              if ((! cpp_parent_dict_tmp.contains("angtable"))) {
                cpp_parent_dict_tmp["angtable"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict_tmp["angtable"];
              if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
              cpp_nr_val = py::len(cpp_current_dict["INT"]);
              cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["mu"]), write_opts);
              cpp_np_val = py::len(cpp_current_dict["mu"]);
              cont << cpp_draft_line;
              tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["mu"]);
              tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["f"]);
              tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
              tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
              write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
              // variable declarations
              std::vector<double> var_mu_0d_floatvec_Scalar;
              bool aux_mu_read = false;
              vartype aux_last_type_read_for_mu = UNKNOWN;
              std::vector<double> var_f_0d_floatvec_Scalar;
              bool aux_f_read = false;
              vartype aux_last_type_read_for_f = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = tab1_body;
                // assign expression to variable mu
                var_mu_0d_floatvec_Scalar = tab_body.X;
                aux_mu_read = true;
                validate_vartype_consistency("mu", SCALAR_FLOATVEC, aux_last_type_read_for_mu);
                aux_last_type_read_for_mu = SCALAR_FLOATVEC;
                // assign expression to variable f
                var_f_0d_floatvec_Scalar = tab_body.Y;
                aux_f_read = true;
                validate_vartype_consistency("f", SCALAR_FLOATVEC, aux_last_type_read_for_f);
                aux_last_type_read_for_f = SCALAR_FLOATVEC;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              cont << cpp_draft_line;
              cpp_current_dict = cpp_parent_dict_tmp;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if (((((((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(3)))))&&((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE1 / Eint ] TAB2 ( leg_int )";
          // read TAB2 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE1"]), write_opts);
          // assign expression to variable NE1
          var_NE1_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE1"]);
          aux_NE1_read = true;
          validate_vartype_consistency("NE1", SCALAR_INT, aux_last_type_read_for_NE1);
          aux_last_type_read_for_NE1 = SCALAR_INT;
          {
            py::dict cpp_parent_dict_tmp = cpp_current_dict;
            if ((! cpp_parent_dict_tmp.contains("leg_int"))) {
              cpp_parent_dict_tmp["leg_int"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict_tmp["leg_int"];
            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
            cpp_nr_val = py::len(cpp_current_dict["INT"]);
            cont << cpp_draft_line;
            tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
            tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
            write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
            // variable declarations
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab2Body tab_body = tab2_body;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            cont << cpp_draft_line;
            cpp_current_dict = cpp_parent_dict_tmp;
          }

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_NE1_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NL , 0 / \n { al } { j = 1 to NL } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST record
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["T"]), write_opts);
            // assign expression to variable T
            var_T_0d_double_Scalar = py::cast<double>(cpp_current_dict["T"]);
            aux_T_read = true;
            validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
            aux_last_type_read_for_T = SCALAR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]), write_opts);
            // assign expression to variable E
            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]));
            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LT"]), write_opts);
            // assign expression to variable LT
            var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LT"]);
            aux_LT_read = true;
            validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
            aux_last_type_read_for_LT = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NL"][py::cast(var_i_0d_int_Scalar)]), write_opts);
            // assign expression to variable NL
            var_NL_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_current_dict["NL"][py::cast(var_i_0d_int_Scalar)]));
            validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
            aux_last_type_read_for_NL = NESTEDVECTOR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NL"][py::cast(var_i_0d_int_Scalar)]), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = py::cast<int>(cpp_current_dict["NL"][py::cast(var_i_0d_int_Scalar)]);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read LIST body
              ptr_al_2d_idx0 = var_al_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NL_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                // read LIST body
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["al"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]), write_opts);
                // assign expression to variable al
                ptr_al_2d_idx0->set(var_j_0d_int_Scalar, py::cast<double>(cpp_current_dict["al"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]));
                validate_vartype_consistency("al", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_al);
                aux_last_type_read_for_al = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
          }
          cpp_template = "[ MAT , 4 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE2 / Eint ] TAB2 ( ang_int )";
          // read TAB2 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE2"]), write_opts);
          // assign expression to variable NE2
          var_NE2_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE2"]);
          aux_NE2_read = true;
          validate_vartype_consistency("NE2", SCALAR_INT, aux_last_type_read_for_NE2);
          aux_last_type_read_for_NE2 = SCALAR_INT;
          {
            py::dict cpp_parent_dict_tmp = cpp_current_dict;
            if ((! cpp_parent_dict_tmp.contains("ang_int"))) {
              cpp_parent_dict_tmp["ang_int"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict_tmp["ang_int"];
            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
            cpp_nr_val = py::len(cpp_current_dict["INT"]);
            cont << cpp_draft_line;
            tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
            tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
            write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
            // variable declarations
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab2Body tab_body = tab2_body;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            cont << cpp_draft_line;
            cpp_current_dict = cpp_parent_dict_tmp;
          }

          for (int var_i_0d_int_Scalar = var_NE1_0d_int_Scalar;
             var_i_0d_int_Scalar <= ((var_NE1_0d_int_Scalar+var_NE2_0d_int_Scalar)-1); var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 4 , MT / T , E , LT , 0 , NR , NP / mu / f ] TAB1 ( angtable [ i ] )";
            // read TAB1 record
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["T"]), write_opts);
            if ((! (aux_T_read == true))) {
              // assign expression to variable T
              var_T_0d_double_Scalar = py::cast<double>(cpp_current_dict["T"]);
              aux_T_read = true;
              validate_vartype_consistency("T", SCALAR_DOUBLE, aux_last_type_read_for_T);
              aux_last_type_read_for_T = SCALAR_DOUBLE;
            } else {
            }
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]), write_opts);
            if ((! var_E_1d_double_NestedVector.contains(var_i_0d_int_Scalar))) {
              // assign expression to variable E
              var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]));
              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
            } else {
            }
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LT"]), write_opts);
            if ((! (aux_LT_read == true))) {
              // assign expression to variable LT
              var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LT"]);
              aux_LT_read = true;
              validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
              aux_last_type_read_for_LT = SCALAR_INT;
            } else {
            }
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            {
              py::dict cpp_parent_dict_tmp = cpp_current_dict;
              if ((! cpp_parent_dict_tmp.contains("angtable"))) {
                cpp_parent_dict_tmp["angtable"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict_tmp["angtable"];
              if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
              cpp_nr_val = py::len(cpp_current_dict["INT"]);
              cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["mu"]), write_opts);
              cpp_np_val = py::len(cpp_current_dict["mu"]);
              cont << cpp_draft_line;
              tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["mu"]);
              tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["f"]);
              tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
              tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
              write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
              // variable declarations
              std::vector<double> var_mu_0d_floatvec_Scalar;
              bool aux_mu_read = false;
              vartype aux_last_type_read_for_mu = UNKNOWN;
              std::vector<double> var_f_0d_floatvec_Scalar;
              bool aux_f_read = false;
              vartype aux_last_type_read_for_f = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = tab1_body;
                // assign expression to variable mu
                var_mu_0d_floatvec_Scalar = tab_body.X;
                aux_mu_read = true;
                validate_vartype_consistency("mu", SCALAR_FLOATVEC, aux_last_type_read_for_mu);
                aux_last_type_read_for_mu = SCALAR_FLOATVEC;
                // assign expression to variable f
                var_f_0d_floatvec_Scalar = tab_body.Y;
                aux_f_read = true;
                validate_vartype_consistency("f", SCALAR_FLOATVEC, aux_last_type_read_for_f);
                aux_last_type_read_for_f = SCALAR_FLOATVEC;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              cont << cpp_draft_line;
              cpp_current_dict = cpp_parent_dict_tmp;
            }
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 63861c67fded34c8e694d0399677c11f
// MD5 hash of the following function definition: 815ba2bdeaa792aa296ae9a67e87f4f2
void write_mf5_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 5;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 5;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 5 , MT / ZA , AWR , 0 , 0 , NK , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NK"]), write_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = py::cast<int>(cpp_current_dict["NK"]);
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section contribution
    {
      py::dict cpp_parent_dict_tmp = cpp_current_dict;
      if ((! cpp_parent_dict_tmp.contains("contribution"))) {
        cpp_parent_dict_tmp["contribution"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict_tmp["contribution"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      int var_LF_0d_int_Scalar;
      bool aux_LF_read = false;
      vartype aux_last_type_read_for_LF = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      NestedVector<double> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      double var_U_0d_double_Scalar;
      bool aux_U_read = false;
      vartype aux_last_type_read_for_U = UNKNOWN;
      std::vector<double> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      std::vector<double> var_p_0d_floatvec_Scalar;
      bool aux_p_read = false;
      vartype aux_last_type_read_for_p = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            {
              // variable declarations
              int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
              int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
              bool& glob_aux_LF_read = aux_LF_read;
              bool aux_LF_read = glob_aux_LF_read;
              vartype aux_last_type_read_for_LF = UNKNOWN;
              cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
              // read TAB1 record
              // assign expression to variable LF
              var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LF", -99999));
              aux_LF_read = true;
              validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
              aux_last_type_read_for_LF = SCALAR_INT;
              if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(1)))))))) {
                cpp_found_match = true;
              }
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
              // read TAB1 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LF"]), write_opts);
              // assign expression to variable LF
              var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LF"]);
              aux_LF_read = true;
              validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
              aux_last_type_read_for_LF = SCALAR_INT;
              {
                py::dict cpp_parent_dict_tmp = cpp_current_dict;
                if ((! cpp_parent_dict_tmp.contains("p_table"))) {
                  cpp_parent_dict_tmp["p_table"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict_tmp["p_table"];
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                cpp_nr_val = py::len(cpp_current_dict["INT"]);
                cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
                cpp_np_val = py::len(cpp_current_dict["E"]);
                cont << cpp_draft_line;
                tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
                tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["p"]);
                tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                // variable declarations
                std::vector<double> var_E_0d_floatvec_Scalar;
                bool aux_E_read = false;
                vartype aux_last_type_read_for_E = UNKNOWN;
                std::vector<double> var_p_0d_floatvec_Scalar;
                bool aux_p_read = false;
                vartype aux_last_type_read_for_p = UNKNOWN;
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab1Body tab_body = tab1_body;
                  // assign expression to variable E
                  var_E_0d_floatvec_Scalar = tab_body.X;
                  aux_E_read = true;
                  validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
                cpp_current_dict = cpp_parent_dict_tmp;
              }
              cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E ] TAB2 ( E_interp )";
              // read TAB2 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              {
                py::dict cpp_parent_dict_tmp = cpp_current_dict;
                if ((! cpp_parent_dict_tmp.contains("E_interp"))) {
                  cpp_parent_dict_tmp["E_interp"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict_tmp["E_interp"];
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                cpp_nr_val = py::len(cpp_current_dict["INT"]);
                cont << cpp_draft_line;
                tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
                // variable declarations
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab2Body tab_body = tab2_body;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
                cpp_current_dict = cpp_parent_dict_tmp;
              }

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NE_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                cpp_template = "[ MAT , 5 , MT / 0.0 , E , 0 , 0 , NR , NF / Eout / g ] TAB1 ( spectrum [ l ] )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E"][py::cast(var_l_0d_int_Scalar)]), write_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_l_0d_int_Scalar)]));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                {
                  py::dict cpp_parent_dict_tmp = cpp_current_dict;
                  if ((! cpp_parent_dict_tmp.contains("spectrum"))) {
                    cpp_parent_dict_tmp["spectrum"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict_tmp["spectrum"];
                  if ((! cpp_current_dict.contains(py::cast(var_l_0d_int_Scalar)))) {
                    cpp_current_dict[py::cast(var_l_0d_int_Scalar)] = py::dict();
                  }
                  cpp_current_dict = cpp_current_dict[py::cast(var_l_0d_int_Scalar)];
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                  cpp_nr_val = py::len(cpp_current_dict["INT"]);
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eout"]), write_opts);
                  cpp_np_val = py::len(cpp_current_dict["Eout"]);
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eout"]);
                  tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["g"]);
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<double> var_Eout_0d_floatvec_Scalar;
                  bool aux_Eout_read = false;
                  vartype aux_last_type_read_for_Eout = UNKNOWN;
                  std::vector<double> var_g_0d_floatvec_Scalar;
                  bool aux_g_read = false;
                  vartype aux_last_type_read_for_g = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable Eout
                    var_Eout_0d_floatvec_Scalar = tab_body.X;
                    aux_Eout_read = true;
                    validate_vartype_consistency("Eout", SCALAR_FLOATVEC, aux_last_type_read_for_Eout);
                    aux_last_type_read_for_Eout = SCALAR_FLOATVEC;
                    // assign expression to variable g
                    var_g_0d_floatvec_Scalar = tab_body.Y;
                    aux_g_read = true;
                    validate_vartype_consistency("g", SCALAR_FLOATVEC, aux_last_type_read_for_g);
                    aux_last_type_read_for_g = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict_tmp;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              {
                // variable declarations
                double& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                double var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                // assign expression to variable U
                var_U_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("U", -99999.9));
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LF", -99999));
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(5)))))))) {
                  cpp_found_match = true;
                }
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["U"]), write_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = py::cast<double>(cpp_current_dict["U"]);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LF"]), write_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LF"]);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict_tmp = cpp_current_dict;
                  if ((! cpp_parent_dict_tmp.contains("p_table"))) {
                    cpp_parent_dict_tmp["p_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict_tmp["p_table"];
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                  cpp_nr_val = py::len(cpp_current_dict["INT"]);
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
                  cpp_np_val = py::len(cpp_current_dict["E"]);
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
                  tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["p"]);
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<double> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<double> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict_tmp;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E / theta ] TAB1 ( theta_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                {
                  py::dict cpp_parent_dict_tmp = cpp_current_dict;
                  if ((! cpp_parent_dict_tmp.contains("theta_table"))) {
                    cpp_parent_dict_tmp["theta_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict_tmp["theta_table"];
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                  cpp_nr_val = py::len(cpp_current_dict["INT"]);
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
                  cpp_np_val = py::len(cpp_current_dict["E"]);
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
                  tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["theta"]);
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<double> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<double> var_theta_0d_floatvec_Scalar;
                  bool aux_theta_read = false;
                  vartype aux_last_type_read_for_theta = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable theta
                    var_theta_0d_floatvec_Scalar = tab_body.Y;
                    aux_theta_read = true;
                    validate_vartype_consistency("theta", SCALAR_FLOATVEC, aux_last_type_read_for_theta);
                    aux_last_type_read_for_theta = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict_tmp;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NF / x / g ] TAB1 ( g_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                {
                  py::dict cpp_parent_dict_tmp = cpp_current_dict;
                  if ((! cpp_parent_dict_tmp.contains("g_table"))) {
                    cpp_parent_dict_tmp["g_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict_tmp["g_table"];
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                  cpp_nr_val = py::len(cpp_current_dict["INT"]);
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["x"]), write_opts);
                  cpp_np_val = py::len(cpp_current_dict["x"]);
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["x"]);
                  tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["g"]);
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<double> var_x_0d_floatvec_Scalar;
                  bool aux_x_read = false;
                  vartype aux_last_type_read_for_x = UNKNOWN;
                  std::vector<double> var_g_0d_floatvec_Scalar;
                  bool aux_g_read = false;
                  vartype aux_last_type_read_for_g = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable x
                    var_x_0d_floatvec_Scalar = tab_body.X;
                    aux_x_read = true;
                    validate_vartype_consistency("x", SCALAR_FLOATVEC, aux_last_type_read_for_x);
                    aux_last_type_read_for_x = SCALAR_FLOATVEC;
                    // assign expression to variable g
                    var_g_0d_floatvec_Scalar = tab_body.Y;
                    aux_g_read = true;
                    validate_vartype_consistency("g", SCALAR_FLOATVEC, aux_last_type_read_for_g);
                    aux_last_type_read_for_g = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict_tmp;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              {
                // variable declarations
                double& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                double var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                // assign expression to variable U
                var_U_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("U", -99999.9));
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LF", -99999));
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(7)))))))) {
                  cpp_found_match = true;
                }
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["U"]), write_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = py::cast<double>(cpp_current_dict["U"]);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LF"]), write_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LF"]);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict_tmp = cpp_current_dict;
                  if ((! cpp_parent_dict_tmp.contains("p_table"))) {
                    cpp_parent_dict_tmp["p_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict_tmp["p_table"];
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                  cpp_nr_val = py::len(cpp_current_dict["INT"]);
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
                  cpp_np_val = py::len(cpp_current_dict["E"]);
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
                  tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["p"]);
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<double> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<double> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict_tmp;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E / theta ] TAB1 ( theta_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                {
                  py::dict cpp_parent_dict_tmp = cpp_current_dict;
                  if ((! cpp_parent_dict_tmp.contains("theta_table"))) {
                    cpp_parent_dict_tmp["theta_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict_tmp["theta_table"];
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                  cpp_nr_val = py::len(cpp_current_dict["INT"]);
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
                  cpp_np_val = py::len(cpp_current_dict["E"]);
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
                  tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["theta"]);
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<double> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<double> var_theta_0d_floatvec_Scalar;
                  bool aux_theta_read = false;
                  vartype aux_last_type_read_for_theta = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable theta
                    var_theta_0d_floatvec_Scalar = tab_body.Y;
                    aux_theta_read = true;
                    validate_vartype_consistency("theta", SCALAR_FLOATVEC, aux_last_type_read_for_theta);
                    aux_last_type_read_for_theta = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict_tmp;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              {
                // variable declarations
                double& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                double var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                // assign expression to variable U
                var_U_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("U", -99999.9));
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LF", -99999));
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(9)))))))) {
                  cpp_found_match = true;
                }
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1 ( p_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["U"]), write_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = py::cast<double>(cpp_current_dict["U"]);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LF"]), write_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LF"]);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                {
                  py::dict cpp_parent_dict_tmp = cpp_current_dict;
                  if ((! cpp_parent_dict_tmp.contains("p_table"))) {
                    cpp_parent_dict_tmp["p_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict_tmp["p_table"];
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                  cpp_nr_val = py::len(cpp_current_dict["INT"]);
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
                  cpp_np_val = py::len(cpp_current_dict["E"]);
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
                  tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["p"]);
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<double> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<double> var_p_0d_floatvec_Scalar;
                  bool aux_p_read = false;
                  vartype aux_last_type_read_for_p = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable p
                    var_p_0d_floatvec_Scalar = tab_body.Y;
                    aux_p_read = true;
                    validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                    aux_last_type_read_for_p = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict_tmp;
                }
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E / theta ] TAB1 ( theta_table )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                {
                  py::dict cpp_parent_dict_tmp = cpp_current_dict;
                  if ((! cpp_parent_dict_tmp.contains("theta_table"))) {
                    cpp_parent_dict_tmp["theta_table"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict_tmp["theta_table"];
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                  cpp_nr_val = py::len(cpp_current_dict["INT"]);
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
                  cpp_np_val = py::len(cpp_current_dict["E"]);
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
                  tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["theta"]);
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<double> var_E_0d_floatvec_Scalar;
                  bool aux_E_read = false;
                  vartype aux_last_type_read_for_E = UNKNOWN;
                  std::vector<double> var_theta_0d_floatvec_Scalar;
                  bool aux_theta_read = false;
                  vartype aux_last_type_read_for_theta = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable E
                    var_E_0d_floatvec_Scalar = tab_body.X;
                    aux_E_read = true;
                    validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                    aux_last_type_read_for_E = SCALAR_FLOATVEC;
                    // assign expression to variable theta
                    var_theta_0d_floatvec_Scalar = tab_body.Y;
                    aux_theta_read = true;
                    validate_vartype_consistency("theta", SCALAR_FLOATVEC, aux_last_type_read_for_theta);
                    aux_last_type_read_for_theta = SCALAR_FLOATVEC;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict_tmp;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              {
                // variable declarations
                double& glob_var_U_0d_double_Scalar = var_U_0d_double_Scalar;
                double var_U_0d_double_Scalar = glob_var_U_0d_double_Scalar;
                bool& glob_aux_U_read = aux_U_read;
                bool aux_U_read = glob_aux_U_read;
                vartype aux_last_type_read_for_U = UNKNOWN;
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1";
                // read TAB1 record
                // assign expression to variable U
                var_U_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("U", -99999.9));
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LF", -99999));
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(11)))))))) {
                  cpp_found_match = true;
                }
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / U , 0.0 , 0 , LF , NR , NP / E / p ] TAB1";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["U"]), write_opts);
                // assign expression to variable U
                var_U_0d_double_Scalar = py::cast<double>(cpp_current_dict["U"]);
                aux_U_read = true;
                validate_vartype_consistency("U", SCALAR_DOUBLE, aux_last_type_read_for_U);
                aux_last_type_read_for_U = SCALAR_DOUBLE;
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LF"]), write_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LF"]);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                cpp_nr_val = py::len(cpp_current_dict["INT"]);
                cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
                cpp_np_val = py::len(cpp_current_dict["E"]);
                cont << cpp_draft_line;
                tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
                tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["p"]);
                tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                {
                  Tab1Body tab_body = tab1_body;
                  // assign expression to variable E
                  var_E_0d_floatvec_Scalar = tab_body.X;
                  aux_E_read = true;
                  validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            // if statement evaluation with lookahead
            {
              {
                // variable declarations
                int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
                int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
                bool& glob_aux_LF_read = aux_LF_read;
                bool aux_LF_read = glob_aux_LF_read;
                vartype aux_last_type_read_for_LF = UNKNOWN;
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1";
                // read TAB1 record
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LF", -99999));
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(12)))))))) {
                  cpp_found_match = true;
                }
              }
              if (cpp_found_match) {
                cpp_template = "[ MAT , 5 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / E / p ] TAB1";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LF"]), write_opts);
                // assign expression to variable LF
                var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LF"]);
                aux_LF_read = true;
                validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
                aux_last_type_read_for_LF = SCALAR_INT;
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                cpp_nr_val = py::len(cpp_current_dict["INT"]);
                cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
                cpp_np_val = py::len(cpp_current_dict["E"]);
                cont << cpp_draft_line;
                tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
                tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["p"]);
                tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                {
                  Tab1Body tab_body = tab1_body;
                  // assign expression to variable E
                  var_E_0d_floatvec_Scalar = tab_body.X;
                  aux_E_read = true;
                  validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
              }
            }
          }
        }
      }
      cpp_current_dict = cpp_parent_dict_tmp;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: ca82cdd58bd8081afe9c01f911284492
// MD5 hash of the following function definition: c6d1b825635ef9ee7e241e23e1324819
void write_mf6_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_JP_0d_int_Scalar;
  bool aux_JP_read = false;
  vartype aux_last_type_read_for_JP = UNKNOWN;
  int var_LCT_0d_int_Scalar;
  bool aux_LCT_read = false;
  vartype aux_last_type_read_for_LCT = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 6;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 6;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 6 , MT / ZA , AWR , JP , LCT , NK , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["JP"]), write_opts);
  // assign expression to variable JP
  var_JP_0d_int_Scalar = py::cast<int>(cpp_current_dict["JP"]);
  aux_JP_read = true;
  validate_vartype_consistency("JP", SCALAR_INT, aux_last_type_read_for_JP);
  aux_last_type_read_for_JP = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LCT"]), write_opts);
  // assign expression to variable LCT
  var_LCT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCT"]);
  aux_LCT_read = true;
  validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
  aux_last_type_read_for_LCT = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NK"]), write_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = py::cast<int>(cpp_current_dict["NK"]);
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NK_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict_tmp = cpp_current_dict;
      if ((! cpp_parent_dict_tmp.contains("subsection"))) {
        cpp_parent_dict_tmp["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict_tmp["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
      // variable declarations
      double var_ZAP_0d_double_Scalar;
      bool aux_ZAP_read = false;
      vartype aux_last_type_read_for_ZAP = UNKNOWN;
      double var_AWP_0d_double_Scalar;
      bool aux_AWP_read = false;
      vartype aux_last_type_read_for_AWP = UNKNOWN;
      int var_LIP_0d_int_Scalar;
      bool aux_LIP_read = false;
      vartype aux_last_type_read_for_LIP = UNKNOWN;
      int var_LAW_0d_int_Scalar;
      bool aux_LAW_read = false;
      vartype aux_last_type_read_for_LAW = UNKNOWN;
      int var_LANG_0d_int_Scalar;
      bool aux_LANG_read = false;
      vartype aux_last_type_read_for_LANG = UNKNOWN;
      int var_LEP_0d_int_Scalar;
      bool aux_LEP_read = false;
      vartype aux_last_type_read_for_LEP = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      NestedVector<double> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      NestedVector<int> var_ND_1d_int_NestedVector;
      vartype aux_last_type_read_for_ND = UNKNOWN;
      NestedVector<int> var_NA_1d_int_NestedVector;
      vartype aux_last_type_read_for_NA = UNKNOWN;
      int cpp_int_val;
      bool aux_cpp_int_val_read = false;
      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
      NestedVector<int> var_NEP_1d_int_NestedVector;
      vartype aux_last_type_read_for_NEP = UNKNOWN;
      NestedVector<NestedVector<double>> var_Ep_2d_double_NestedVector;
      NestedVector<double>* ptr_Ep_2d_idx0;
      vartype aux_last_type_read_for_Ep = UNKNOWN;
      NestedVector<NestedVector<NestedVector<double>>> var_b_3d_double_NestedVector;
      NestedVector<double>* ptr_b_3d_idx1;
      NestedVector<NestedVector<double>>* ptr_b_3d_idx0;
      vartype aux_last_type_read_for_b = UNKNOWN;
      NestedVector<int> var_NLW_1d_int_NestedVector;
      vartype aux_last_type_read_for_NLW = UNKNOWN;
      NestedVector<int> var_NL_1d_int_NestedVector;
      vartype aux_last_type_read_for_NL = UNKNOWN;
      NestedVector<NestedVector<double>> var_A_2d_double_NestedVector;
      NestedVector<double>* ptr_A_2d_idx0;
      vartype aux_last_type_read_for_A = UNKNOWN;
      double var_SPI_0d_double_Scalar;
      bool aux_SPI_read = false;
      vartype aux_last_type_read_for_SPI = UNKNOWN;
      int var_LIDP_0d_int_Scalar;
      bool aux_LIDP_read = false;
      vartype aux_last_type_read_for_LIDP = UNKNOWN;
      NestedVector<int> var_LTP_1d_int_NestedVector;
      vartype aux_last_type_read_for_LTP = UNKNOWN;
      NestedVector<int> var_NW_1d_int_NestedVector;
      vartype aux_last_type_read_for_NW = UNKNOWN;
      double var_APSX_0d_double_Scalar;
      bool aux_APSX_read = false;
      vartype aux_last_type_read_for_APSX = UNKNOWN;
      int var_NPSX_0d_int_Scalar;
      bool aux_NPSX_read = false;
      vartype aux_last_type_read_for_NPSX = UNKNOWN;
      NestedVector<int> var_NMU_1d_int_NestedVector;
      vartype aux_last_type_read_for_NMU = UNKNOWN;
      NestedVector<NestedVector<double>> var_mu_2d_double_NestedVector;
      NestedVector<double>* ptr_mu_2d_idx0;
      vartype aux_last_type_read_for_mu = UNKNOWN;
      cpp_template = "[ MAT , 6 , MT / ZAP , AWP , LIP , LAW , NR , NP / Eint / yi ] TAB1 ( yields )";
      // read TAB1 record
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZAP"]), write_opts);
      // assign expression to variable ZAP
      var_ZAP_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZAP"]);
      aux_ZAP_read = true;
      validate_vartype_consistency("ZAP", SCALAR_DOUBLE, aux_last_type_read_for_ZAP);
      aux_last_type_read_for_ZAP = SCALAR_DOUBLE;
      cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWP"]), write_opts);
      // assign expression to variable AWP
      var_AWP_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWP"]);
      aux_AWP_read = true;
      validate_vartype_consistency("AWP", SCALAR_DOUBLE, aux_last_type_read_for_AWP);
      aux_last_type_read_for_AWP = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LIP"]), write_opts);
      // assign expression to variable LIP
      var_LIP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LIP"]);
      aux_LIP_read = true;
      validate_vartype_consistency("LIP", SCALAR_INT, aux_last_type_read_for_LIP);
      aux_last_type_read_for_LIP = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LAW"]), write_opts);
      // assign expression to variable LAW
      var_LAW_0d_int_Scalar = py::cast<int>(cpp_current_dict["LAW"]);
      aux_LAW_read = true;
      validate_vartype_consistency("LAW", SCALAR_INT, aux_last_type_read_for_LAW);
      aux_last_type_read_for_LAW = SCALAR_INT;
      {
        py::dict cpp_parent_dict_tmp = cpp_current_dict;
        if ((! cpp_parent_dict_tmp.contains("yields"))) {
          cpp_parent_dict_tmp["yields"] = py::dict();
        }
        py::dict cpp_current_dict = cpp_parent_dict_tmp["yields"];
        cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
        cpp_nr_val = py::len(cpp_current_dict["INT"]);
        cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
        cpp_np_val = py::len(cpp_current_dict["Eint"]);
        cont << cpp_draft_line;
        tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
        tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["yi"]);
        tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
        tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
        write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
        // variable declarations
        std::vector<double> var_Eint_0d_floatvec_Scalar;
        bool aux_Eint_read = false;
        vartype aux_last_type_read_for_Eint = UNKNOWN;
        std::vector<double> var_yi_0d_floatvec_Scalar;
        bool aux_yi_read = false;
        vartype aux_last_type_read_for_yi = UNKNOWN;
        std::vector<int> var_INT_0d_intvec_Scalar;
        bool aux_INT_read = false;
        vartype aux_last_type_read_for_INT = UNKNOWN;
        std::vector<int> var_NBT_0d_intvec_Scalar;
        bool aux_NBT_read = false;
        vartype aux_last_type_read_for_NBT = UNKNOWN;
        {
          Tab1Body tab_body = tab1_body;
          // assign expression to variable Eint
          var_Eint_0d_floatvec_Scalar = tab_body.X;
          aux_Eint_read = true;
          validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
          aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
          // assign expression to variable yi
          var_yi_0d_floatvec_Scalar = tab_body.Y;
          aux_yi_read = true;
          validate_vartype_consistency("yi", SCALAR_FLOATVEC, aux_last_type_read_for_yi);
          aux_last_type_read_for_yi = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
        cont << cpp_draft_line;
        cpp_current_dict = cpp_parent_dict_tmp;
      }
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(1)))))))) {
            // if statement evaluation
            cpp_found_match = true;
            cpp_template = "[ MAT , 6 , MT / 0.0 , 0.0 , LANG , LEP , NR , NE / Eint ] TAB2";
            // read TAB2 record
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LANG"]), write_opts);
            // assign expression to variable LANG
            var_LANG_0d_int_Scalar = py::cast<int>(cpp_current_dict["LANG"]);
            aux_LANG_read = true;
            validate_vartype_consistency("LANG", SCALAR_INT, aux_last_type_read_for_LANG);
            aux_last_type_read_for_LANG = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LEP"]), write_opts);
            // assign expression to variable LEP
            var_LEP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LEP"]);
            aux_LEP_read = true;
            validate_vartype_consistency("LEP", SCALAR_INT, aux_last_type_read_for_LEP);
            aux_last_type_read_for_LEP = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
            // assign expression to variable NE
            var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
            aux_NE_read = true;
            validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
            aux_last_type_read_for_NE = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
            cpp_nr_val = py::len(cpp_current_dict["INT"]);
            cont << cpp_draft_line;
            tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
            tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
            write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
            {
              Tab2Body tab_body = tab2_body;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            cont << cpp_draft_line;

            for (int var_j_0d_int_Scalar = 1;
               var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
              bool aux_j_read = true;
              cpp_template = "[ MAT , 6 , MT / 0.0 , E , ND , NA , NW , NEP / \n { Ep , { b } { m = 0 to NA } } { k = 1 to NEP } ] LIST";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read LIST record
              cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E"][py::cast(var_j_0d_int_Scalar)]), write_opts);
              // assign expression to variable E
              var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_j_0d_int_Scalar)]));
              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["ND"][py::cast(var_j_0d_int_Scalar)]), write_opts);
              // assign expression to variable ND
              var_ND_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_current_dict["ND"][py::cast(var_j_0d_int_Scalar)]));
              validate_vartype_consistency("ND", NESTEDVECTOR_INT, aux_last_type_read_for_ND);
              aux_last_type_read_for_ND = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["NA"][py::cast(var_j_0d_int_Scalar)]), write_opts);
              // assign expression to variable NA
              var_NA_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_current_dict["NA"][py::cast(var_j_0d_int_Scalar)]));
              validate_vartype_consistency("NA", NESTEDVECTOR_INT, aux_last_type_read_for_NA);
              aux_last_type_read_for_NA = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_current_dict["NEP"][py::cast(var_j_0d_int_Scalar)])*(py::cast<int>(cpp_current_dict["NA"][py::cast(var_j_0d_int_Scalar)])+2)), write_opts);
              // assign expression to variable cpp_int_val
              cpp_int_val = (py::cast<int>(cpp_current_dict["NEP"][py::cast(var_j_0d_int_Scalar)])*(py::cast<int>(cpp_current_dict["NA"][py::cast(var_j_0d_int_Scalar)])+2));
              aux_cpp_int_val_read = true;
              validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
              aux_last_type_read_for_cpp_int_val = SCALAR_INT;
              // assign expression to variable NEP
              var_NEP_1d_int_NestedVector.set(var_j_0d_int_Scalar, (cpp_int_val/(var_NA_1d_int_NestedVector[var_j_0d_int_Scalar]+2)));
              validate_vartype_consistency("NEP", NESTEDVECTOR_INT, aux_last_type_read_for_NEP);
              aux_last_type_read_for_NEP = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NEP"][py::cast(var_j_0d_int_Scalar)]), write_opts);
              if ((! var_NEP_1d_int_NestedVector.contains(var_j_0d_int_Scalar))) {
                // assign expression to variable NEP
                var_NEP_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_current_dict["NEP"][py::cast(var_j_0d_int_Scalar)]));
                validate_vartype_consistency("NEP", NESTEDVECTOR_INT, aux_last_type_read_for_NEP);
                aux_last_type_read_for_NEP = NESTEDVECTOR_INT;
              } else {
              }
              cpp_write_field<int>(cpp_draft_line, 4, (py::cast<int>(cpp_current_dict["NEP"][py::cast(var_j_0d_int_Scalar)])*(py::cast<int>(cpp_current_dict["NA"][py::cast(var_j_0d_int_Scalar)])+2)), write_opts);
              cont << cpp_draft_line;
              {
                int cpp_npl = (py::cast<int>(cpp_current_dict["NEP"][py::cast(var_j_0d_int_Scalar)])*(py::cast<int>(cpp_current_dict["NA"][py::cast(var_j_0d_int_Scalar)])+2));
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                // read LIST body
                ptr_Ep_2d_idx0 = var_Ep_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);
                ptr_b_3d_idx0 = var_b_3d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                for (int var_k_0d_int_Scalar = 1;
                   var_k_0d_int_Scalar <= var_NEP_1d_int_NestedVector[var_j_0d_int_Scalar]; var_k_0d_int_Scalar++) {
                  bool aux_k_read = true;
                  // read LIST body
                  cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Ep"][py::cast(var_j_0d_int_Scalar)][py::cast(var_k_0d_int_Scalar)]), write_opts);
                  // assign expression to variable Ep
                  ptr_Ep_2d_idx0->set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["Ep"][py::cast(var_j_0d_int_Scalar)][py::cast(var_k_0d_int_Scalar)]));
                  validate_vartype_consistency("Ep", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ep);
                  aux_last_type_read_for_Ep = NESTEDVECTOR_DOUBLE;
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    cpp_j = 0;
                  }
                  ptr_b_3d_idx1 = ptr_b_3d_idx0->prepare(var_k_0d_int_Scalar);

                  for (int var_m_0d_int_Scalar = 0;
                     var_m_0d_int_Scalar <= var_NA_1d_int_NestedVector[var_j_0d_int_Scalar]; var_m_0d_int_Scalar++) {
                    bool aux_m_read = true;
                    // read LIST body
                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["b"][py::cast(var_j_0d_int_Scalar)][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
                    // assign expression to variable b
                    ptr_b_3d_idx1->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["b"][py::cast(var_j_0d_int_Scalar)][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
                    validate_vartype_consistency("b", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_b);
                    aux_last_type_read_for_b = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cont << cpp_draft_line;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      cpp_j = 0;
                    }
                  }
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
              cont << cpp_draft_line;
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(2)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
              // read TAB2 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
              cpp_nr_val = py::len(cpp_current_dict["INT"]);
              cont << cpp_draft_line;
              tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
              tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
              write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
              {
                Tab2Body tab_body = tab2_body;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              cont << cpp_draft_line;

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                cpp_template = "[ MAT , 6 , MT / 0.0 , E , LANG , 0 , NLW , NL / { A } { l = 1 to NLW } ] LIST";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                // read LIST record
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E"][py::cast(var_j_0d_int_Scalar)]), write_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_j_0d_int_Scalar)]));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LANG"]), write_opts);
                // assign expression to variable LANG
                var_LANG_0d_int_Scalar = py::cast<int>(cpp_current_dict["LANG"]);
                aux_LANG_read = true;
                validate_vartype_consistency("LANG", SCALAR_INT, aux_last_type_read_for_LANG);
                aux_last_type_read_for_LANG = SCALAR_INT;
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLW"][py::cast(var_j_0d_int_Scalar)]), write_opts);
                // assign expression to variable NLW
                var_NLW_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_current_dict["NLW"][py::cast(var_j_0d_int_Scalar)]));
                validate_vartype_consistency("NLW", NESTEDVECTOR_INT, aux_last_type_read_for_NLW);
                aux_last_type_read_for_NLW = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NL"][py::cast(var_j_0d_int_Scalar)]), write_opts);
                // assign expression to variable NL
                var_NL_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_current_dict["NL"][py::cast(var_j_0d_int_Scalar)]));
                validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLW"][py::cast(var_j_0d_int_Scalar)]), write_opts);
                cont << cpp_draft_line;
                {
                  int cpp_npl = py::cast<int>(cpp_current_dict["NLW"][py::cast(var_j_0d_int_Scalar)]);
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  // read LIST body
                  ptr_A_2d_idx0 = var_A_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                  for (int var_l_0d_int_Scalar = 1;
                     var_l_0d_int_Scalar <= var_NLW_1d_int_NestedVector[var_j_0d_int_Scalar]; var_l_0d_int_Scalar++) {
                    bool aux_l_read = true;
                    // read LIST body
                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["A"][py::cast(var_j_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]), write_opts);
                    // assign expression to variable A
                    ptr_A_2d_idx0->set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["A"][py::cast(var_j_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]));
                    validate_vartype_consistency("A", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_A);
                    aux_last_type_read_for_A = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cont << cpp_draft_line;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      cpp_j = 0;
                    }
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
                cont << cpp_draft_line;
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(5)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / SPI , 0.0 , LIDP , 0 , NR , NE / Eint ] TAB2";
              // read TAB2 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
              // assign expression to variable SPI
              var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
              aux_SPI_read = true;
              validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
              aux_last_type_read_for_SPI = SCALAR_DOUBLE;
              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LIDP"]), write_opts);
              // assign expression to variable LIDP
              var_LIDP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LIDP"]);
              aux_LIDP_read = true;
              validate_vartype_consistency("LIDP", SCALAR_INT, aux_last_type_read_for_LIDP);
              aux_last_type_read_for_LIDP = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
              cpp_nr_val = py::len(cpp_current_dict["INT"]);
              cont << cpp_draft_line;
              tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
              tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
              write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
              {
                Tab2Body tab_body = tab2_body;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              cont << cpp_draft_line;

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                cpp_template = "[ MAT , 6 , MT / 0.0 , E , LTP , 0 , NW , NL / \n { A } { k = 1 to NW } ] LIST";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                // read LIST record
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E"][py::cast(var_j_0d_int_Scalar)]), write_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_j_0d_int_Scalar)]));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LTP"][py::cast(var_j_0d_int_Scalar)]), write_opts);
                // assign expression to variable LTP
                var_LTP_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_current_dict["LTP"][py::cast(var_j_0d_int_Scalar)]));
                validate_vartype_consistency("LTP", NESTEDVECTOR_INT, aux_last_type_read_for_LTP);
                aux_last_type_read_for_LTP = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NW"][py::cast(var_j_0d_int_Scalar)]), write_opts);
                // assign expression to variable NW
                var_NW_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_current_dict["NW"][py::cast(var_j_0d_int_Scalar)]));
                validate_vartype_consistency("NW", NESTEDVECTOR_INT, aux_last_type_read_for_NW);
                aux_last_type_read_for_NW = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NL"][py::cast(var_j_0d_int_Scalar)]), write_opts);
                // assign expression to variable NL
                var_NL_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_current_dict["NL"][py::cast(var_j_0d_int_Scalar)]));
                validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NW"][py::cast(var_j_0d_int_Scalar)]), write_opts);
                cont << cpp_draft_line;
                {
                  int cpp_npl = py::cast<int>(cpp_current_dict["NW"][py::cast(var_j_0d_int_Scalar)]);
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  // read LIST body
                  ptr_A_2d_idx0 = var_A_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                  for (int var_k_0d_int_Scalar = 1;
                     var_k_0d_int_Scalar <= var_NW_1d_int_NestedVector[var_j_0d_int_Scalar]; var_k_0d_int_Scalar++) {
                    bool aux_k_read = true;
                    // read LIST body
                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["A"][py::cast(var_j_0d_int_Scalar)][py::cast(var_k_0d_int_Scalar)]), write_opts);
                    // assign expression to variable A
                    ptr_A_2d_idx0->set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["A"][py::cast(var_j_0d_int_Scalar)][py::cast(var_k_0d_int_Scalar)]));
                    validate_vartype_consistency("A", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_A);
                    aux_last_type_read_for_A = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cont << cpp_draft_line;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      cpp_j = 0;
                    }
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
                cont << cpp_draft_line;
              }
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(6)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / APSX , 0.0 , 0 , 0 , 0 , NPSX ] CONT";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read CONT record
              cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["APSX"]), write_opts);
              // assign expression to variable APSX
              var_APSX_0d_double_Scalar = py::cast<double>(cpp_current_dict["APSX"]);
              aux_APSX_read = true;
              validate_vartype_consistency("APSX", SCALAR_DOUBLE, aux_last_type_read_for_APSX);
              aux_last_type_read_for_APSX = SCALAR_DOUBLE;
              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NPSX"]), write_opts);
              // assign expression to variable NPSX
              var_NPSX_0d_int_Scalar = py::cast<int>(cpp_current_dict["NPSX"]);
              aux_NPSX_read = true;
              validate_vartype_consistency("NPSX", SCALAR_INT, aux_last_type_read_for_NPSX);
              aux_last_type_read_for_NPSX = SCALAR_INT;
              cont << cpp_draft_line;
            }
          }
        }
        if (! cpp_found_match) {
          if (! cpp_found_match) {
            if ((((((((aux_LAW_read == true)) && ((var_LAW_0d_int_Scalar)==(7)))))))) {
              // if statement evaluation
              cpp_found_match = true;
              cpp_template = "[ MAT , 6 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / E ] TAB2 ( E_interpol )";
              // read TAB2 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              {
                py::dict cpp_parent_dict_tmp = cpp_current_dict;
                if ((! cpp_parent_dict_tmp.contains("E_interpol"))) {
                  cpp_parent_dict_tmp["E_interpol"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict_tmp["E_interpol"];
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                cpp_nr_val = py::len(cpp_current_dict["INT"]);
                cont << cpp_draft_line;
                tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
                // variable declarations
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab2Body tab_body = tab2_body;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
                cpp_current_dict = cpp_parent_dict_tmp;
              }

              for (int var_j_0d_int_Scalar = 1;
                 var_j_0d_int_Scalar <= var_NE_0d_int_Scalar; var_j_0d_int_Scalar++) {
                bool aux_j_read = true;
                cpp_template = "[ MAT , 6 , MT / 0.0 , E , 0 , 0 , NRM , NMU / mu ] TAB2 ( mu_interpol [ j ] )";
                // read TAB2 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E"][py::cast(var_j_0d_int_Scalar)]), write_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_j_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_j_0d_int_Scalar)]));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NMU"][py::cast(var_j_0d_int_Scalar)]), write_opts);
                // assign expression to variable NMU
                var_NMU_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_current_dict["NMU"][py::cast(var_j_0d_int_Scalar)]));
                validate_vartype_consistency("NMU", NESTEDVECTOR_INT, aux_last_type_read_for_NMU);
                aux_last_type_read_for_NMU = NESTEDVECTOR_INT;
                {
                  py::dict cpp_parent_dict_tmp = cpp_current_dict;
                  if ((! cpp_parent_dict_tmp.contains("mu_interpol"))) {
                    cpp_parent_dict_tmp["mu_interpol"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict_tmp["mu_interpol"];
                  if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
                    cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
                  }
                  cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                  cpp_nr_val = py::len(cpp_current_dict["INT"]);
                  cont << cpp_draft_line;
                  tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                  tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                  write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab2Body tab_body = tab2_body;
                    // assign expression to variable INT
                    var_INT_0d_intvec_Scalar = tab_body.INT;
                    aux_INT_read = true;
                    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                    aux_last_type_read_for_INT = SCALAR_INTVEC;
                    // assign expression to variable NBT
                    var_NBT_0d_intvec_Scalar = tab_body.NBT;
                    aux_NBT_read = true;
                    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                    aux_last_type_read_for_NBT = SCALAR_INTVEC;
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict_tmp;
                }
                ptr_mu_2d_idx0 = var_mu_2d_double_NestedVector.prepare(var_j_0d_int_Scalar);

                for (int var_k_0d_int_Scalar = 1;
                   var_k_0d_int_Scalar <= var_NMU_1d_int_NestedVector[var_j_0d_int_Scalar]; var_k_0d_int_Scalar++) {
                  bool aux_k_read = true;
                  cpp_template = "[ MAT , 6 , MT / 0.0 , mu , 0 , 0 , NRP , NEP / Ep / f ] TAB1 ( table [ j , k ] )";
                  // read TAB1 record
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["mu"][py::cast(var_j_0d_int_Scalar)][py::cast(var_k_0d_int_Scalar)]), write_opts);
                  // assign expression to variable mu
                  ptr_mu_2d_idx0->set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["mu"][py::cast(var_j_0d_int_Scalar)][py::cast(var_k_0d_int_Scalar)]));
                  validate_vartype_consistency("mu", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_mu);
                  aux_last_type_read_for_mu = NESTEDVECTOR_DOUBLE;
                  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                  {
                    py::dict cpp_parent_dict_tmp = cpp_current_dict;
                    if ((! cpp_parent_dict_tmp.contains("table"))) {
                      cpp_parent_dict_tmp["table"] = py::dict();
                    }
                    py::dict cpp_current_dict = cpp_parent_dict_tmp["table"];
                    if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
                      cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
                    }
                    cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
                    if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                      cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                    }
                    cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                    cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                    cpp_nr_val = py::len(cpp_current_dict["INT"]);
                    cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Ep"]), write_opts);
                    cpp_np_val = py::len(cpp_current_dict["Ep"]);
                    cont << cpp_draft_line;
                    tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Ep"]);
                    tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["f"]);
                    tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                    tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                    write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                    // variable declarations
                    std::vector<double> var_Ep_0d_floatvec_Scalar;
                    bool aux_Ep_read = false;
                    vartype aux_last_type_read_for_Ep = UNKNOWN;
                    std::vector<double> var_f_0d_floatvec_Scalar;
                    bool aux_f_read = false;
                    vartype aux_last_type_read_for_f = UNKNOWN;
                    std::vector<int> var_INT_0d_intvec_Scalar;
                    bool aux_INT_read = false;
                    vartype aux_last_type_read_for_INT = UNKNOWN;
                    std::vector<int> var_NBT_0d_intvec_Scalar;
                    bool aux_NBT_read = false;
                    vartype aux_last_type_read_for_NBT = UNKNOWN;
                    {
                      Tab1Body tab_body = tab1_body;
                      // assign expression to variable Ep
                      var_Ep_0d_floatvec_Scalar = tab_body.X;
                      aux_Ep_read = true;
                      validate_vartype_consistency("Ep", SCALAR_FLOATVEC, aux_last_type_read_for_Ep);
                      aux_last_type_read_for_Ep = SCALAR_FLOATVEC;
                      // assign expression to variable f
                      var_f_0d_floatvec_Scalar = tab_body.Y;
                      aux_f_read = true;
                      validate_vartype_consistency("f", SCALAR_FLOATVEC, aux_last_type_read_for_f);
                      aux_last_type_read_for_f = SCALAR_FLOATVEC;
                      // assign expression to variable INT
                      var_INT_0d_intvec_Scalar = tab_body.INT;
                      aux_INT_read = true;
                      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                      aux_last_type_read_for_INT = SCALAR_INTVEC;
                      // assign expression to variable NBT
                      var_NBT_0d_intvec_Scalar = tab_body.NBT;
                      aux_NBT_read = true;
                      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                      aux_last_type_read_for_NBT = SCALAR_INTVEC;
                    }
                    cont << cpp_draft_line;
                    cpp_current_dict = cpp_parent_dict_tmp;
                  }
                }
              }
            }
          }
        }
      }
      cpp_current_dict = cpp_parent_dict_tmp;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: bd9c9da4de018928918c4acb82f32a0a
// MD5 hash of the following function definition: 65ce6b76801a2a15755e235398bd12b1
void write_mf7mt2_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LTHR_0d_int_Scalar;
  bool aux_LTHR_read = false;
  vartype aux_last_type_read_for_LTHR = UNKNOWN;
  double var_T0_0d_double_Scalar;
  bool aux_T0_read = false;
  vartype aux_last_type_read_for_T0 = UNKNOWN;
  int var_LT_0d_int_Scalar;
  bool aux_LT_read = false;
  vartype aux_last_type_read_for_LT = UNKNOWN;
  NestedVector<double> var_T_1d_double_NestedVector;
  vartype aux_last_type_read_for_T = UNKNOWN;
  int var_LI_0d_int_Scalar;
  bool aux_LI_read = false;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_NP_0d_int_Scalar;
  bool aux_NP_read = false;
  vartype aux_last_type_read_for_NP = UNKNOWN;
  NestedVector<NestedVector<double>> var_S_2d_double_NestedVector;
  NestedVector<double>* ptr_S_2d_idx0;
  vartype aux_last_type_read_for_S = UNKNOWN;
  double var_SB_0d_double_Scalar;
  bool aux_SB_read = false;
  vartype aux_last_type_read_for_SB = UNKNOWN;
  std::vector<double> var_Tint_0d_floatvec_Scalar;
  bool aux_Tint_read = false;
  vartype aux_last_type_read_for_Tint = UNKNOWN;
  std::vector<double> var_Wp_0d_floatvec_Scalar;
  bool aux_Wp_read = false;
  vartype aux_last_type_read_for_Wp = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 7;
  int mt = 2;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 7;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 2;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 7 , 2 / ZA , AWR , LTHR , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LTHR"]), write_opts);
  // assign expression to variable LTHR
  var_LTHR_0d_int_Scalar = py::cast<int>(cpp_current_dict["LTHR"]);
  aux_LTHR_read = true;
  validate_vartype_consistency("LTHR", SCALAR_INT, aux_last_type_read_for_LTHR);
  aux_last_type_read_for_LTHR = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_LTHR_read == true)) && ((var_LTHR_0d_int_Scalar)==(1)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 2 / T0 , 0.0 , LT , 0 , NR , NP / Eint / S ] TAB1 ( S_T0_table )";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["T0"]), write_opts);
        // assign expression to variable T0
        var_T0_0d_double_Scalar = py::cast<double>(cpp_current_dict["T0"]);
        aux_T0_read = true;
        validate_vartype_consistency("T0", SCALAR_DOUBLE, aux_last_type_read_for_T0);
        aux_last_type_read_for_T0 = SCALAR_DOUBLE;
        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LT"]), write_opts);
        // assign expression to variable LT
        var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LT"]);
        aux_LT_read = true;
        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
        aux_last_type_read_for_LT = SCALAR_INT;
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        {
          py::dict cpp_parent_dict_tmp = cpp_current_dict;
          if ((! cpp_parent_dict_tmp.contains("S_T0_table"))) {
            cpp_parent_dict_tmp["S_T0_table"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict_tmp["S_T0_table"];
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
          cpp_nr_val = py::len(cpp_current_dict["INT"]);
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
          cpp_np_val = py::len(cpp_current_dict["Eint"]);
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
          tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["S"]);
          tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          // variable declarations
          std::vector<double> var_Eint_0d_floatvec_Scalar;
          bool aux_Eint_read = false;
          vartype aux_last_type_read_for_Eint = UNKNOWN;
          std::vector<double> var_S_0d_floatvec_Scalar;
          bool aux_S_read = false;
          vartype aux_last_type_read_for_S = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Eint
            var_Eint_0d_floatvec_Scalar = tab_body.X;
            aux_Eint_read = true;
            validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
            aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
            // assign expression to variable S
            var_S_0d_floatvec_Scalar = tab_body.Y;
            aux_S_read = true;
            validate_vartype_consistency("S", SCALAR_FLOATVEC, aux_last_type_read_for_S);
            aux_last_type_read_for_S = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
          cpp_current_dict = cpp_parent_dict_tmp;
        }

        for (int var_i_0d_int_Scalar = 1;
           var_i_0d_int_Scalar <= var_LT_0d_int_Scalar; var_i_0d_int_Scalar++) {
          bool aux_i_read = true;
          cpp_template = "[ MAT , 7 , 2 / T , 0.0 , LI , 0 , NP , 0 / \n { S } { q = 1 to NP } ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read LIST record
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["T"][py::cast(var_i_0d_int_Scalar)]), write_opts);
          // assign expression to variable T
          var_T_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["T"][py::cast(var_i_0d_int_Scalar)]));
          validate_vartype_consistency("T", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_T);
          aux_last_type_read_for_T = NESTEDVECTOR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LI"]), write_opts);
          // assign expression to variable LI
          var_LI_0d_int_Scalar = py::cast<int>(cpp_current_dict["LI"]);
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NP"]), write_opts);
          // assign expression to variable NP
          var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NP"]);
          aux_NP_read = true;
          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
          aux_last_type_read_for_NP = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NP"]), write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = py::cast<int>(cpp_current_dict["NP"]);
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST body

            for (int var_q_0d_int_Scalar = 1;
               var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
              bool aux_q_read = true;
              // read LIST body
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["S"][py::cast(var_q_0d_int_Scalar)][py::cast(var_i_0d_int_Scalar)]), write_opts);
              // assign expression to variable S
              ptr_S_2d_idx0 = var_S_2d_double_NestedVector.prepare(var_q_0d_int_Scalar);
              ptr_S_2d_idx0->set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["S"][py::cast(var_q_0d_int_Scalar)][py::cast(var_i_0d_int_Scalar)]));
              validate_vartype_consistency("S", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_S);
              aux_last_type_read_for_S = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LTHR_read == true)) && ((var_LTHR_0d_int_Scalar)==(2)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 7 , 2 / SB , 0.0 , 0 , 0 , NR , NP / Tint / Wp ] TAB1";
          // read TAB1 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SB"]), write_opts);
          // assign expression to variable SB
          var_SB_0d_double_Scalar = py::cast<double>(cpp_current_dict["SB"]);
          aux_SB_read = true;
          validate_vartype_consistency("SB", SCALAR_DOUBLE, aux_last_type_read_for_SB);
          aux_last_type_read_for_SB = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
          cpp_nr_val = py::len(cpp_current_dict["INT"]);
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Tint"]), write_opts);
          cpp_np_val = py::len(cpp_current_dict["Tint"]);
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Tint"]);
          tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["Wp"]);
          tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Wp
            var_Wp_0d_floatvec_Scalar = tab_body.Y;
            aux_Wp_read = true;
            validate_vartype_consistency("Wp", SCALAR_FLOATVEC, aux_last_type_read_for_Wp);
            aux_last_type_read_for_Wp = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_LTHR_read == true)) && ((var_LTHR_0d_int_Scalar)==(3)))))))) {
          // if statement evaluation
          cpp_found_match = true;
          cpp_template = "[ MAT , 7 , 2 / T0 , 0.0 , LT , 0 , NR , NP / Eint / S ] TAB1 ( S_T0_table )";
          // read TAB1 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["T0"]), write_opts);
          // assign expression to variable T0
          var_T0_0d_double_Scalar = py::cast<double>(cpp_current_dict["T0"]);
          aux_T0_read = true;
          validate_vartype_consistency("T0", SCALAR_DOUBLE, aux_last_type_read_for_T0);
          aux_last_type_read_for_T0 = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LT"]), write_opts);
          // assign expression to variable LT
          var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LT"]);
          aux_LT_read = true;
          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
          aux_last_type_read_for_LT = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          {
            py::dict cpp_parent_dict_tmp = cpp_current_dict;
            if ((! cpp_parent_dict_tmp.contains("S_T0_table"))) {
              cpp_parent_dict_tmp["S_T0_table"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict_tmp["S_T0_table"];
            cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
            cpp_nr_val = py::len(cpp_current_dict["INT"]);
            cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
            cpp_np_val = py::len(cpp_current_dict["Eint"]);
            cont << cpp_draft_line;
            tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
            tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["S"]);
            tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
            tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
            write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
            // variable declarations
            std::vector<double> var_Eint_0d_floatvec_Scalar;
            bool aux_Eint_read = false;
            vartype aux_last_type_read_for_Eint = UNKNOWN;
            std::vector<double> var_S_0d_floatvec_Scalar;
            bool aux_S_read = false;
            vartype aux_last_type_read_for_S = UNKNOWN;
            std::vector<int> var_INT_0d_intvec_Scalar;
            bool aux_INT_read = false;
            vartype aux_last_type_read_for_INT = UNKNOWN;
            std::vector<int> var_NBT_0d_intvec_Scalar;
            bool aux_NBT_read = false;
            vartype aux_last_type_read_for_NBT = UNKNOWN;
            {
              Tab1Body tab_body = tab1_body;
              // assign expression to variable Eint
              var_Eint_0d_floatvec_Scalar = tab_body.X;
              aux_Eint_read = true;
              validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
              aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
              // assign expression to variable S
              var_S_0d_floatvec_Scalar = tab_body.Y;
              aux_S_read = true;
              validate_vartype_consistency("S", SCALAR_FLOATVEC, aux_last_type_read_for_S);
              aux_last_type_read_for_S = SCALAR_FLOATVEC;
              // assign expression to variable INT
              var_INT_0d_intvec_Scalar = tab_body.INT;
              aux_INT_read = true;
              validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
              aux_last_type_read_for_INT = SCALAR_INTVEC;
              // assign expression to variable NBT
              var_NBT_0d_intvec_Scalar = tab_body.NBT;
              aux_NBT_read = true;
              validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
              aux_last_type_read_for_NBT = SCALAR_INTVEC;
            }
            cont << cpp_draft_line;
            cpp_current_dict = cpp_parent_dict_tmp;
          }

          for (int var_i_0d_int_Scalar = 1;
             var_i_0d_int_Scalar <= var_LT_0d_int_Scalar; var_i_0d_int_Scalar++) {
            bool aux_i_read = true;
            cpp_template = "[ MAT , 7 , 2 / T , 0.0 , LI , 0 , NP , 0 / \n { S } { q = 1 to NP } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST record
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["T"][py::cast(var_i_0d_int_Scalar)]), write_opts);
            // assign expression to variable T
            var_T_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["T"][py::cast(var_i_0d_int_Scalar)]));
            validate_vartype_consistency("T", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_T);
            aux_last_type_read_for_T = NESTEDVECTOR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LI"]), write_opts);
            // assign expression to variable LI
            var_LI_0d_int_Scalar = py::cast<int>(cpp_current_dict["LI"]);
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NP"]), write_opts);
            // assign expression to variable NP
            var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NP"]);
            aux_NP_read = true;
            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
            aux_last_type_read_for_NP = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NP"]), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = py::cast<int>(cpp_current_dict["NP"]);
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read LIST body

              for (int var_q_0d_int_Scalar = 1;
                 var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
                bool aux_q_read = true;
                // read LIST body
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["S"][py::cast(var_q_0d_int_Scalar)][py::cast(var_i_0d_int_Scalar)]), write_opts);
                // assign expression to variable S
                ptr_S_2d_idx0 = var_S_2d_double_NestedVector.prepare(var_q_0d_int_Scalar);
                ptr_S_2d_idx0->set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["S"][py::cast(var_q_0d_int_Scalar)][py::cast(var_i_0d_int_Scalar)]));
                validate_vartype_consistency("S", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_S);
                aux_last_type_read_for_S = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
          }
          cpp_template = "[ MAT , 7 , 2 / SB , 0.0 , 0 , 0 , NR , NP / Tint / Wp ] TAB1";
          // read TAB1 record
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SB"]), write_opts);
          // assign expression to variable SB
          var_SB_0d_double_Scalar = py::cast<double>(cpp_current_dict["SB"]);
          aux_SB_read = true;
          validate_vartype_consistency("SB", SCALAR_DOUBLE, aux_last_type_read_for_SB);
          aux_last_type_read_for_SB = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
          cpp_nr_val = py::len(cpp_current_dict["INT"]);
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Tint"]), write_opts);
          cpp_np_val = py::len(cpp_current_dict["Tint"]);
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Tint"]);
          tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["Wp"]);
          tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Wp
            var_Wp_0d_floatvec_Scalar = tab_body.Y;
            aux_Wp_read = true;
            validate_vartype_consistency("Wp", SCALAR_FLOATVEC, aux_last_type_read_for_Wp);
            aux_last_type_read_for_Wp = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: a3934a161c54e232c57d90823e77ee29
// MD5 hash of the following function definition: 0dc850fe65533a1e74adbf1f9ea7f9cc
void write_mf7mt4_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LAT_0d_int_Scalar;
  bool aux_LAT_read = false;
  vartype aux_last_type_read_for_LAT = UNKNOWN;
  int var_LASYM_0d_int_Scalar;
  bool aux_LASYM_read = false;
  vartype aux_last_type_read_for_LASYM = UNKNOWN;
  int var_LLN_0d_int_Scalar;
  bool aux_LLN_read = false;
  vartype aux_last_type_read_for_LLN = UNKNOWN;
  int var_NI_0d_int_Scalar;
  bool aux_NI_read = false;
  vartype aux_last_type_read_for_NI = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  NestedVector<double> var_B_1d_double_NestedVector;
  vartype aux_last_type_read_for_B = UNKNOWN;
  int var_NB_0d_int_Scalar;
  bool aux_NB_read = false;
  vartype aux_last_type_read_for_NB = UNKNOWN;
  double var_T0_0d_double_Scalar;
  bool aux_T0_read = false;
  vartype aux_last_type_read_for_T0 = UNKNOWN;
  NestedVector<double> var_beta_1d_double_NestedVector;
  vartype aux_last_type_read_for_beta = UNKNOWN;
  NestedVector<int> var_LT_1d_int_NestedVector;
  vartype aux_last_type_read_for_LT = UNKNOWN;
  NestedVector<double> var_T_1d_double_NestedVector;
  vartype aux_last_type_read_for_T = UNKNOWN;
  NestedVector<int> var_LI_1d_int_NestedVector;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_NP_0d_int_Scalar;
  bool aux_NP_read = false;
  vartype aux_last_type_read_for_NP = UNKNOWN;
  NestedVector<NestedVector<NestedVector<double>>> var_S_3d_double_NestedVector;
  NestedVector<double>* ptr_S_3d_idx1;
  NestedVector<NestedVector<double>>* ptr_S_3d_idx0;
  vartype aux_last_type_read_for_S = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 7;
  int mt = 4;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 7;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 4;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 7 , 4 / ZA , AWR , 0 , LAT , LASYM , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LAT"]), write_opts);
  // assign expression to variable LAT
  var_LAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LAT"]);
  aux_LAT_read = true;
  validate_vartype_consistency("LAT", SCALAR_INT, aux_last_type_read_for_LAT);
  aux_last_type_read_for_LAT = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["LASYM"]), write_opts);
  // assign expression to variable LASYM
  var_LASYM_0d_int_Scalar = py::cast<int>(cpp_current_dict["LASYM"]);
  aux_LASYM_read = true;
  validate_vartype_consistency("LASYM", SCALAR_INT, aux_last_type_read_for_LASYM);
  aux_last_type_read_for_LASYM = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , LLN , 0 , NI , NS / { B } { n = 1 to NI } ] LIST";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read LIST record
  cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
  cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LLN"]), write_opts);
  // assign expression to variable LLN
  var_LLN_0d_int_Scalar = py::cast<int>(cpp_current_dict["LLN"]);
  aux_LLN_read = true;
  validate_vartype_consistency("LLN", SCALAR_INT, aux_last_type_read_for_LLN);
  aux_last_type_read_for_LLN = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NI"]), write_opts);
  // assign expression to variable NI
  var_NI_0d_int_Scalar = py::cast<int>(cpp_current_dict["NI"]);
  aux_NI_read = true;
  validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
  aux_last_type_read_for_NI = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NS"]), write_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NS"]);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NI"]), write_opts);
  cont << cpp_draft_line;
  {
    int cpp_npl = py::cast<int>(cpp_current_dict["NI"]);
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
    // read LIST body

    for (int var_n_0d_int_Scalar = 1;
       var_n_0d_int_Scalar <= var_NI_0d_int_Scalar; var_n_0d_int_Scalar++) {
      bool aux_n_read = true;
      // read LIST body
      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["B"][py::cast(var_n_0d_int_Scalar)]), write_opts);
      // assign expression to variable B
      var_B_1d_double_NestedVector.set(var_n_0d_int_Scalar, py::cast<double>(cpp_current_dict["B"][py::cast(var_n_0d_int_Scalar)]));
      validate_vartype_consistency("B", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_B);
      aux_last_type_read_for_B = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NB / beta_int ] TAB2 ( beta_interp )";
  // read TAB2 record
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
  cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NB"]), write_opts);
  // assign expression to variable NB
  var_NB_0d_int_Scalar = py::cast<int>(cpp_current_dict["NB"]);
  aux_NB_read = true;
  validate_vartype_consistency("NB", SCALAR_INT, aux_last_type_read_for_NB);
  aux_last_type_read_for_NB = SCALAR_INT;
  {
    py::dict cpp_parent_dict_tmp = cpp_current_dict;
    if ((! cpp_parent_dict_tmp.contains("beta_interp"))) {
      cpp_parent_dict_tmp["beta_interp"] = py::dict();
    }
    py::dict cpp_current_dict = cpp_parent_dict_tmp["beta_interp"];
    cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
    cpp_nr_val = py::len(cpp_current_dict["INT"]);
    cont << cpp_draft_line;
    tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
    tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
    write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
    // variable declarations
    std::vector<int> var_INT_0d_intvec_Scalar;
    bool aux_INT_read = false;
    vartype aux_last_type_read_for_INT = UNKNOWN;
    std::vector<int> var_NBT_0d_intvec_Scalar;
    bool aux_NBT_read = false;
    vartype aux_last_type_read_for_NBT = UNKNOWN;
    {
      Tab2Body tab_body = tab2_body;
      // assign expression to variable INT
      var_INT_0d_intvec_Scalar = tab_body.INT;
      aux_INT_read = true;
      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
      aux_last_type_read_for_INT = SCALAR_INTVEC;
      // assign expression to variable NBT
      var_NBT_0d_intvec_Scalar = tab_body.NBT;
      aux_NBT_read = true;
      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
      aux_last_type_read_for_NBT = SCALAR_INTVEC;
    }
    cont << cpp_draft_line;
    cpp_current_dict = cpp_parent_dict_tmp;
  }

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NB_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 7 , 4 / T0 , beta , LT , 0 , NR , NP / alpha / S ] TAB1 ( S_table [ i ] )";
    // read TAB1 record
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["T0"]), write_opts);
    // assign expression to variable T0
    var_T0_0d_double_Scalar = py::cast<double>(cpp_current_dict["T0"]);
    aux_T0_read = true;
    validate_vartype_consistency("T0", SCALAR_DOUBLE, aux_last_type_read_for_T0);
    aux_last_type_read_for_T0 = SCALAR_DOUBLE;
    cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["beta"][py::cast(var_i_0d_int_Scalar)]), write_opts);
    // assign expression to variable beta
    var_beta_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["beta"][py::cast(var_i_0d_int_Scalar)]));
    validate_vartype_consistency("beta", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_beta);
    aux_last_type_read_for_beta = NESTEDVECTOR_DOUBLE;
    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LT"][py::cast(var_i_0d_int_Scalar)]), write_opts);
    // assign expression to variable LT
    var_LT_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_current_dict["LT"][py::cast(var_i_0d_int_Scalar)]));
    validate_vartype_consistency("LT", NESTEDVECTOR_INT, aux_last_type_read_for_LT);
    aux_last_type_read_for_LT = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
    {
      py::dict cpp_parent_dict_tmp = cpp_current_dict;
      if ((! cpp_parent_dict_tmp.contains("S_table"))) {
        cpp_parent_dict_tmp["S_table"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict_tmp["S_table"];
      if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
      cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
      cpp_nr_val = py::len(cpp_current_dict["INT"]);
      cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["alpha"]), write_opts);
      cpp_np_val = py::len(cpp_current_dict["alpha"]);
      cont << cpp_draft_line;
      tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["alpha"]);
      tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["S"]);
      tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
      tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
      write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
      // variable declarations
      std::vector<double> var_alpha_0d_floatvec_Scalar;
      bool aux_alpha_read = false;
      vartype aux_last_type_read_for_alpha = UNKNOWN;
      std::vector<double> var_S_0d_floatvec_Scalar;
      bool aux_S_read = false;
      vartype aux_last_type_read_for_S = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      {
        Tab1Body tab_body = tab1_body;
        // assign expression to variable alpha
        var_alpha_0d_floatvec_Scalar = tab_body.X;
        aux_alpha_read = true;
        validate_vartype_consistency("alpha", SCALAR_FLOATVEC, aux_last_type_read_for_alpha);
        aux_last_type_read_for_alpha = SCALAR_FLOATVEC;
        // assign expression to variable S
        var_S_0d_floatvec_Scalar = tab_body.Y;
        aux_S_read = true;
        validate_vartype_consistency("S", SCALAR_FLOATVEC, aux_last_type_read_for_S);
        aux_last_type_read_for_S = SCALAR_FLOATVEC;
        // assign expression to variable INT
        var_INT_0d_intvec_Scalar = tab_body.INT;
        aux_INT_read = true;
        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
        aux_last_type_read_for_INT = SCALAR_INTVEC;
        // assign expression to variable NBT
        var_NBT_0d_intvec_Scalar = tab_body.NBT;
        aux_NBT_read = true;
        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
        aux_last_type_read_for_NBT = SCALAR_INTVEC;
      }
      cont << cpp_draft_line;
      cpp_current_dict = cpp_parent_dict_tmp;
    }

    for (int var_j_0d_int_Scalar = 1;
       var_j_0d_int_Scalar <= var_LT_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
      bool aux_j_read = true;
      cpp_template = "[ MAT , 7 , 4 / T , beta , LI , 0 , NP , 0 / { S } { q = 1 to NP } ] LIST";
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
      // read LIST record
      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["T"][py::cast(var_j_0d_int_Scalar)]), write_opts);
      // assign expression to variable T
      var_T_1d_double_NestedVector.set(var_j_0d_int_Scalar, py::cast<double>(cpp_current_dict["T"][py::cast(var_j_0d_int_Scalar)]));
      validate_vartype_consistency("T", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_T);
      aux_last_type_read_for_T = NESTEDVECTOR_DOUBLE;
      cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["beta"][py::cast(var_i_0d_int_Scalar)]), write_opts);
      if ((! var_beta_1d_double_NestedVector.contains(var_i_0d_int_Scalar))) {
        // assign expression to variable beta
        var_beta_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["beta"][py::cast(var_i_0d_int_Scalar)]));
        validate_vartype_consistency("beta", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_beta);
        aux_last_type_read_for_beta = NESTEDVECTOR_DOUBLE;
      } else {
      }
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LI"][py::cast(var_j_0d_int_Scalar)]), write_opts);
      // assign expression to variable LI
      var_LI_1d_int_NestedVector.set(var_j_0d_int_Scalar, py::cast<int>(cpp_current_dict["LI"][py::cast(var_j_0d_int_Scalar)]));
      validate_vartype_consistency("LI", NESTEDVECTOR_INT, aux_last_type_read_for_LI);
      aux_last_type_read_for_LI = NESTEDVECTOR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NP"]), write_opts);
      // assign expression to variable NP
      var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NP"]);
      aux_NP_read = true;
      validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
      aux_last_type_read_for_NP = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NP"]), write_opts);
      cont << cpp_draft_line;
      {
        int cpp_npl = py::cast<int>(cpp_current_dict["NP"]);
        int cpp_i = 0;
        int cpp_j = 0;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        // read LIST body

        for (int var_q_0d_int_Scalar = 1;
           var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
          bool aux_q_read = true;
          // read LIST body
          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["S"][py::cast(var_q_0d_int_Scalar)][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]), write_opts);
          // assign expression to variable S
          ptr_S_3d_idx0 = var_S_3d_double_NestedVector.prepare(var_q_0d_int_Scalar);
          ptr_S_3d_idx1 = ptr_S_3d_idx0->prepare(var_i_0d_int_Scalar);
          ptr_S_3d_idx1->set(var_j_0d_int_Scalar, py::cast<double>(cpp_current_dict["S"][py::cast(var_q_0d_int_Scalar)][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]));
          validate_vartype_consistency("S", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_S);
          aux_last_type_read_for_S = NESTEDVECTOR_DOUBLE;
          cpp_i++;
          cpp_j++;
          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
            cont << cpp_draft_line;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            cpp_j = 0;
          }
        }
        if (cpp_i != cpp_npl) {
          throw std::runtime_error("not exactly NPL elements consumed");
        }
      }
      cont << cpp_draft_line;
    }
  }
  cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff0 ] TAB1 ( teff0_table )";
  // read TAB1 record
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
  cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  {
    py::dict cpp_parent_dict_tmp = cpp_current_dict;
    if ((! cpp_parent_dict_tmp.contains("teff0_table"))) {
      cpp_parent_dict_tmp["teff0_table"] = py::dict();
    }
    py::dict cpp_current_dict = cpp_parent_dict_tmp["teff0_table"];
    cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
    cpp_nr_val = py::len(cpp_current_dict["INT"]);
    cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Tint"]), write_opts);
    cpp_np_val = py::len(cpp_current_dict["Tint"]);
    cont << cpp_draft_line;
    tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Tint"]);
    tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["Teff0"]);
    tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
    tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
    write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
    // variable declarations
    std::vector<double> var_Tint_0d_floatvec_Scalar;
    bool aux_Tint_read = false;
    vartype aux_last_type_read_for_Tint = UNKNOWN;
    std::vector<double> var_Teff0_0d_floatvec_Scalar;
    bool aux_Teff0_read = false;
    vartype aux_last_type_read_for_Teff0 = UNKNOWN;
    std::vector<int> var_INT_0d_intvec_Scalar;
    bool aux_INT_read = false;
    vartype aux_last_type_read_for_INT = UNKNOWN;
    std::vector<int> var_NBT_0d_intvec_Scalar;
    bool aux_NBT_read = false;
    vartype aux_last_type_read_for_NBT = UNKNOWN;
    {
      Tab1Body tab_body = tab1_body;
      // assign expression to variable Tint
      var_Tint_0d_floatvec_Scalar = tab_body.X;
      aux_Tint_read = true;
      validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
      aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
      // assign expression to variable Teff0
      var_Teff0_0d_floatvec_Scalar = tab_body.Y;
      aux_Teff0_read = true;
      validate_vartype_consistency("Teff0", SCALAR_FLOATVEC, aux_last_type_read_for_Teff0);
      aux_last_type_read_for_Teff0 = SCALAR_FLOATVEC;
      // assign expression to variable INT
      var_INT_0d_intvec_Scalar = tab_body.INT;
      aux_INT_read = true;
      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
      aux_last_type_read_for_INT = SCALAR_INTVEC;
      // assign expression to variable NBT
      var_NBT_0d_intvec_Scalar = tab_body.NBT;
      aux_NBT_read = true;
      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
      aux_last_type_read_for_NBT = SCALAR_INTVEC;
    }
    cont << cpp_draft_line;
    cpp_current_dict = cpp_parent_dict_tmp;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_NI_read == true)) && ((var_NI_0d_int_Scalar)>=(7)))))&&(((var_B_1d_double_NestedVector.contains(7)) && ((var_B_1d_double_NestedVector[7])==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff1 ] TAB1 ( teff1_table )";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        {
          py::dict cpp_parent_dict_tmp = cpp_current_dict;
          if ((! cpp_parent_dict_tmp.contains("teff1_table"))) {
            cpp_parent_dict_tmp["teff1_table"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict_tmp["teff1_table"];
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
          cpp_nr_val = py::len(cpp_current_dict["INT"]);
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Tint"]), write_opts);
          cpp_np_val = py::len(cpp_current_dict["Tint"]);
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Tint"]);
          tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["Teff1"]);
          tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          // variable declarations
          std::vector<double> var_Tint_0d_floatvec_Scalar;
          bool aux_Tint_read = false;
          vartype aux_last_type_read_for_Tint = UNKNOWN;
          std::vector<double> var_Teff1_0d_floatvec_Scalar;
          bool aux_Teff1_read = false;
          vartype aux_last_type_read_for_Teff1 = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Teff1
            var_Teff1_0d_floatvec_Scalar = tab_body.Y;
            aux_Teff1_read = true;
            validate_vartype_consistency("Teff1", SCALAR_FLOATVEC, aux_last_type_read_for_Teff1);
            aux_last_type_read_for_Teff1 = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
          cpp_current_dict = cpp_parent_dict_tmp;
        }
      }
    }
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_NI_read == true)) && ((var_NI_0d_int_Scalar)>=(13)))))&&(((var_B_1d_double_NestedVector.contains(13)) && ((var_B_1d_double_NestedVector[13])==(0.0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff2 ] TAB1 ( teff2_table )";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        {
          py::dict cpp_parent_dict_tmp = cpp_current_dict;
          if ((! cpp_parent_dict_tmp.contains("teff2_table"))) {
            cpp_parent_dict_tmp["teff2_table"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict_tmp["teff2_table"];
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
          cpp_nr_val = py::len(cpp_current_dict["INT"]);
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Tint"]), write_opts);
          cpp_np_val = py::len(cpp_current_dict["Tint"]);
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Tint"]);
          tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["Teff2"]);
          tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          // variable declarations
          std::vector<double> var_Tint_0d_floatvec_Scalar;
          bool aux_Tint_read = false;
          vartype aux_last_type_read_for_Tint = UNKNOWN;
          std::vector<double> var_Teff2_0d_floatvec_Scalar;
          bool aux_Teff2_read = false;
          vartype aux_last_type_read_for_Teff2 = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Teff2
            var_Teff2_0d_floatvec_Scalar = tab_body.Y;
            aux_Teff2_read = true;
            validate_vartype_consistency("Teff2", SCALAR_FLOATVEC, aux_last_type_read_for_Teff2);
            aux_last_type_read_for_Teff2 = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
          cpp_current_dict = cpp_parent_dict_tmp;
        }
      }
    }
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if (((((((((aux_NI_read == true)) && ((var_NI_0d_int_Scalar)>=(19)))))&&(((var_B_1d_double_NestedVector.contains(19)) && ((var_B_1d_double_NestedVector[19])==(0.0)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 7 , 4 / 0.0 , 0.0 , 0 , 0 , NR , NT / Tint / Teff3 ] TAB1 ( teff3_table )";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        {
          py::dict cpp_parent_dict_tmp = cpp_current_dict;
          if ((! cpp_parent_dict_tmp.contains("teff3_table"))) {
            cpp_parent_dict_tmp["teff3_table"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict_tmp["teff3_table"];
          cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
          cpp_nr_val = py::len(cpp_current_dict["INT"]);
          cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Tint"]), write_opts);
          cpp_np_val = py::len(cpp_current_dict["Tint"]);
          cont << cpp_draft_line;
          tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Tint"]);
          tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["Teff3"]);
          tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
          tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
          write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
          // variable declarations
          std::vector<double> var_Tint_0d_floatvec_Scalar;
          bool aux_Tint_read = false;
          vartype aux_last_type_read_for_Tint = UNKNOWN;
          std::vector<double> var_Teff3_0d_floatvec_Scalar;
          bool aux_Teff3_read = false;
          vartype aux_last_type_read_for_Teff3 = UNKNOWN;
          std::vector<int> var_INT_0d_intvec_Scalar;
          bool aux_INT_read = false;
          vartype aux_last_type_read_for_INT = UNKNOWN;
          std::vector<int> var_NBT_0d_intvec_Scalar;
          bool aux_NBT_read = false;
          vartype aux_last_type_read_for_NBT = UNKNOWN;
          {
            Tab1Body tab_body = tab1_body;
            // assign expression to variable Tint
            var_Tint_0d_floatvec_Scalar = tab_body.X;
            aux_Tint_read = true;
            validate_vartype_consistency("Tint", SCALAR_FLOATVEC, aux_last_type_read_for_Tint);
            aux_last_type_read_for_Tint = SCALAR_FLOATVEC;
            // assign expression to variable Teff3
            var_Teff3_0d_floatvec_Scalar = tab_body.Y;
            aux_Teff3_read = true;
            validate_vartype_consistency("Teff3", SCALAR_FLOATVEC, aux_last_type_read_for_Teff3);
            aux_last_type_read_for_Teff3 = SCALAR_FLOATVEC;
            // assign expression to variable INT
            var_INT_0d_intvec_Scalar = tab_body.INT;
            aux_INT_read = true;
            validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
            aux_last_type_read_for_INT = SCALAR_INTVEC;
            // assign expression to variable NBT
            var_NBT_0d_intvec_Scalar = tab_body.NBT;
            aux_NBT_read = true;
            validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
            aux_last_type_read_for_NBT = SCALAR_INTVEC;
          }
          cont << cpp_draft_line;
          cpp_current_dict = cpp_parent_dict_tmp;
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 0468c7052e96f983d6f680ae2b54c677
// MD5 hash of the following function definition: 90d9d6f0801882edfe6e31a874fb5188
void write_mf7mt451_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NA_0d_int_Scalar;
  bool aux_NA_read = false;
  vartype aux_last_type_read_for_NA = UNKNOWN;
  int var_NAS_0d_int_Scalar;
  bool aux_NAS_read = false;
  vartype aux_last_type_read_for_NAS = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  NestedVector<int> var_NI_1d_int_NestedVector;
  vartype aux_last_type_read_for_NI = UNKNOWN;
  NestedVector<NestedVector<double>> var_ZAI_2d_double_NestedVector;
  NestedVector<double>* ptr_ZAI_2d_idx0;
  vartype aux_last_type_read_for_ZAI = UNKNOWN;
  NestedVector<NestedVector<double>> var_LISI_2d_double_NestedVector;
  NestedVector<double>* ptr_LISI_2d_idx0;
  vartype aux_last_type_read_for_LISI = UNKNOWN;
  NestedVector<NestedVector<double>> var_AFI_2d_double_NestedVector;
  NestedVector<double>* ptr_AFI_2d_idx0;
  vartype aux_last_type_read_for_AFI = UNKNOWN;
  NestedVector<NestedVector<double>> var_AWRI_2d_double_NestedVector;
  NestedVector<double>* ptr_AWRI_2d_idx0;
  vartype aux_last_type_read_for_AWRI = UNKNOWN;
  NestedVector<NestedVector<double>> var_SFI_2d_double_NestedVector;
  NestedVector<double>* ptr_SFI_2d_idx0;
  vartype aux_last_type_read_for_SFI = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 7;
  int mt = 451;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 7;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 451;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 7 , 451 / ZA , AWR , NA , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["NA"]), write_opts);
  // assign expression to variable NA
  var_NA_0d_int_Scalar = py::cast<int>(cpp_current_dict["NA"]);
  aux_NA_read = true;
  validate_vartype_consistency("NA", SCALAR_INT, aux_last_type_read_for_NA);
  aux_last_type_read_for_NA = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NA_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    cpp_template = "[ MAT , 7 , 451 / 0 , 0 , NAS , 0 , (6*NI) , NI / \n { ZAI , LISI , AFI , AWRI , SFI , 0 } { j = 1 to NI } ] LIST";
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
    // read LIST record
    cpp_write_field<double>(cpp_draft_line, 0, 0, write_opts);
    cpp_write_field<double>(cpp_draft_line, 1, 0, write_opts);
    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["NAS"]), write_opts);
    // assign expression to variable NAS
    var_NAS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NAS"]);
    aux_NAS_read = true;
    validate_vartype_consistency("NAS", SCALAR_INT, aux_last_type_read_for_NAS);
    aux_last_type_read_for_NAS = SCALAR_INT;
    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
    cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NI"][py::cast(var_i_0d_int_Scalar)])), write_opts);
    // assign expression to variable cpp_int_val
    cpp_int_val = (6*py::cast<int>(cpp_current_dict["NI"][py::cast(var_i_0d_int_Scalar)]));
    aux_cpp_int_val_read = true;
    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
    // assign expression to variable NI
    var_NI_1d_int_NestedVector.set(var_i_0d_int_Scalar, (cpp_int_val/6));
    validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
    aux_last_type_read_for_NI = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NI"][py::cast(var_i_0d_int_Scalar)]), write_opts);
    if ((! var_NI_1d_int_NestedVector.contains(var_i_0d_int_Scalar))) {
      // assign expression to variable NI
      var_NI_1d_int_NestedVector.set(var_i_0d_int_Scalar, py::cast<int>(cpp_current_dict["NI"][py::cast(var_i_0d_int_Scalar)]));
      validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
      aux_last_type_read_for_NI = NESTEDVECTOR_INT;
    } else {
    }
    cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NI"][py::cast(var_i_0d_int_Scalar)])), write_opts);
    cont << cpp_draft_line;
    {
      int cpp_npl = (6*py::cast<int>(cpp_current_dict["NI"][py::cast(var_i_0d_int_Scalar)]));
      int cpp_i = 0;
      int cpp_j = 0;
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
      // read LIST body
      ptr_ZAI_2d_idx0 = var_ZAI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_LISI_2d_idx0 = var_LISI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_AFI_2d_idx0 = var_AFI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_AWRI_2d_idx0 = var_AWRI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);
      ptr_SFI_2d_idx0 = var_SFI_2d_double_NestedVector.prepare(var_i_0d_int_Scalar);

      for (int var_j_0d_int_Scalar = 1;
         var_j_0d_int_Scalar <= var_NI_1d_int_NestedVector[var_i_0d_int_Scalar]; var_j_0d_int_Scalar++) {
        bool aux_j_read = true;
        // read LIST body
        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ZAI"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]), write_opts);
        // assign expression to variable ZAI
        ptr_ZAI_2d_idx0->set(var_j_0d_int_Scalar, py::cast<double>(cpp_current_dict["ZAI"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]));
        validate_vartype_consistency("ZAI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAI);
        aux_last_type_read_for_ZAI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["LISI"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]), write_opts);
        // assign expression to variable LISI
        ptr_LISI_2d_idx0->set(var_j_0d_int_Scalar, py::cast<double>(cpp_current_dict["LISI"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]));
        validate_vartype_consistency("LISI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_LISI);
        aux_last_type_read_for_LISI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AFI"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]), write_opts);
        // assign expression to variable AFI
        ptr_AFI_2d_idx0->set(var_j_0d_int_Scalar, py::cast<double>(cpp_current_dict["AFI"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]));
        validate_vartype_consistency("AFI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AFI);
        aux_last_type_read_for_AFI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AWRI"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]), write_opts);
        // assign expression to variable AWRI
        ptr_AWRI_2d_idx0->set(var_j_0d_int_Scalar, py::cast<double>(cpp_current_dict["AWRI"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]));
        validate_vartype_consistency("AWRI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AWRI);
        aux_last_type_read_for_AWRI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["SFI"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]), write_opts);
        // assign expression to variable SFI
        ptr_SFI_2d_idx0->set(var_j_0d_int_Scalar, py::cast<double>(cpp_current_dict["SFI"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]));
        validate_vartype_consistency("SFI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SFI);
        aux_last_type_read_for_SFI = NESTEDVECTOR_DOUBLE;
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
        cpp_write_field<double>(cpp_draft_line, cpp_j, 0, write_opts);
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
      }
      if (cpp_i != cpp_npl) {
        throw std::runtime_error("not exactly NPL elements consumed");
      }
    }
    cont << cpp_draft_line;
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: e0fff507053b212e2ece7181a9f7fb15
// MD5 hash of the following function definition: 998c41d9dd6941bfd9e617b4440ae7ee
void write_mf8_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_LISO_0d_int_Scalar;
  bool aux_LISO_read = false;
  vartype aux_last_type_read_for_LISO = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  int var_NO_0d_int_Scalar;
  bool aux_NO_read = false;
  vartype aux_last_type_read_for_NO = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 8;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 8 , MT / ZA , AWR , LIS , LISO , NS , NO ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LIS"]), write_opts);
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LIS"]);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LISO"]), write_opts);
  // assign expression to variable LISO
  var_LISO_0d_int_Scalar = py::cast<int>(cpp_current_dict["LISO"]);
  aux_LISO_read = true;
  validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
  aux_last_type_read_for_LISO = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NS"]), write_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NS"]);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NO"]), write_opts);
  // assign expression to variable NO
  var_NO_0d_int_Scalar = py::cast<int>(cpp_current_dict["NO"]);
  aux_NO_read = true;
  validate_vartype_consistency("NO", SCALAR_INT, aux_last_type_read_for_NO);
  aux_last_type_read_for_NO = SCALAR_INT;
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_NO_read == true)) && ((var_NO_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;

        for (int var_k_0d_int_Scalar = 1;
           var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
          bool aux_k_read = true;
          // open section subsection
          {
            py::dict cpp_parent_dict_tmp = cpp_current_dict;
            if ((! cpp_parent_dict_tmp.contains("subsection"))) {
              cpp_parent_dict_tmp["subsection"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict_tmp["subsection"];
            if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
              cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
            }
            cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
            // variable declarations
            double var_ZAP_0d_double_Scalar;
            bool aux_ZAP_read = false;
            vartype aux_last_type_read_for_ZAP = UNKNOWN;
            double var_ELFS_0d_double_Scalar;
            bool aux_ELFS_read = false;
            vartype aux_last_type_read_for_ELFS = UNKNOWN;
            int var_LMF_0d_int_Scalar;
            bool aux_LMF_read = false;
            vartype aux_last_type_read_for_LMF = UNKNOWN;
            int var_LFS_0d_int_Scalar;
            bool aux_LFS_read = false;
            vartype aux_last_type_read_for_LFS = UNKNOWN;
            int cpp_int_val;
            bool aux_cpp_int_val_read = false;
            vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
            int var_ND_0d_int_Scalar;
            bool aux_ND_read = false;
            vartype aux_last_type_read_for_ND = UNKNOWN;
            NestedVector<double> var_HL_1d_double_NestedVector;
            vartype aux_last_type_read_for_HL = UNKNOWN;
            NestedVector<double> var_RTYP_1d_double_NestedVector;
            vartype aux_last_type_read_for_RTYP = UNKNOWN;
            NestedVector<double> var_ZAN_1d_double_NestedVector;
            vartype aux_last_type_read_for_ZAN = UNKNOWN;
            NestedVector<double> var_BR_1d_double_NestedVector;
            vartype aux_last_type_read_for_BR = UNKNOWN;
            NestedVector<double> var_END_1d_double_NestedVector;
            vartype aux_last_type_read_for_END = UNKNOWN;
            NestedVector<double> var_CT_1d_double_NestedVector;
            vartype aux_last_type_read_for_CT = UNKNOWN;
            cpp_template = "[ MAT , 8 , MT / ZAP , ELFS , LMF , LFS , (6*ND) , 0 / \n { HL , RTYP , ZAN , BR , END , CT } { l = 1 to ND } ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST record
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZAP"]), write_opts);
            // assign expression to variable ZAP
            var_ZAP_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZAP"]);
            aux_ZAP_read = true;
            validate_vartype_consistency("ZAP", SCALAR_DOUBLE, aux_last_type_read_for_ZAP);
            aux_last_type_read_for_ZAP = SCALAR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["ELFS"]), write_opts);
            // assign expression to variable ELFS
            var_ELFS_0d_double_Scalar = py::cast<double>(cpp_current_dict["ELFS"]);
            aux_ELFS_read = true;
            validate_vartype_consistency("ELFS", SCALAR_DOUBLE, aux_last_type_read_for_ELFS);
            aux_last_type_read_for_ELFS = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LMF"]), write_opts);
            // assign expression to variable LMF
            var_LMF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LMF"]);
            aux_LMF_read = true;
            validate_vartype_consistency("LMF", SCALAR_INT, aux_last_type_read_for_LMF);
            aux_last_type_read_for_LMF = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LFS"]), write_opts);
            // assign expression to variable LFS
            var_LFS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LFS"]);
            aux_LFS_read = true;
            validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
            aux_last_type_read_for_LFS = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["ND"])), write_opts);
            // assign expression to variable cpp_int_val
            cpp_int_val = (6*py::cast<int>(cpp_current_dict["ND"]));
            aux_cpp_int_val_read = true;
            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
            // assign expression to variable ND
            var_ND_0d_int_Scalar = (cpp_int_val/6);
            aux_ND_read = true;
            validate_vartype_consistency("ND", SCALAR_INT, aux_last_type_read_for_ND);
            aux_last_type_read_for_ND = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["ND"])), write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = (6*py::cast<int>(cpp_current_dict["ND"]));
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read LIST body

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_ND_0d_int_Scalar; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                // read LIST body
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["HL"][py::cast(var_l_0d_int_Scalar)]), write_opts);
                // assign expression to variable HL
                var_HL_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["HL"][py::cast(var_l_0d_int_Scalar)]));
                validate_vartype_consistency("HL", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_HL);
                aux_last_type_read_for_HL = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RTYP"][py::cast(var_l_0d_int_Scalar)]), write_opts);
                // assign expression to variable RTYP
                var_RTYP_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["RTYP"][py::cast(var_l_0d_int_Scalar)]));
                validate_vartype_consistency("RTYP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_RTYP);
                aux_last_type_read_for_RTYP = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ZAN"][py::cast(var_l_0d_int_Scalar)]), write_opts);
                // assign expression to variable ZAN
                var_ZAN_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["ZAN"][py::cast(var_l_0d_int_Scalar)]));
                validate_vartype_consistency("ZAN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAN);
                aux_last_type_read_for_ZAN = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["BR"][py::cast(var_l_0d_int_Scalar)]), write_opts);
                // assign expression to variable BR
                var_BR_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["BR"][py::cast(var_l_0d_int_Scalar)]));
                validate_vartype_consistency("BR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BR);
                aux_last_type_read_for_BR = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["END"][py::cast(var_l_0d_int_Scalar)]), write_opts);
                // assign expression to variable END
                var_END_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["END"][py::cast(var_l_0d_int_Scalar)]));
                validate_vartype_consistency("END", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_END);
                aux_last_type_read_for_END = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["CT"][py::cast(var_l_0d_int_Scalar)]), write_opts);
                // assign expression to variable CT
                var_CT_1d_double_NestedVector.set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["CT"][py::cast(var_l_0d_int_Scalar)]));
                validate_vartype_consistency("CT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_CT);
                aux_last_type_read_for_CT = NESTEDVECTOR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
            cpp_current_dict = cpp_parent_dict_tmp;
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        if ((((((((aux_NO_read == true)) && ((var_NO_0d_int_Scalar)==(1)))))))) {
          // if statement evaluation
          cpp_found_match = true;

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // open section subsection
            {
              py::dict cpp_parent_dict_tmp = cpp_current_dict;
              if ((! cpp_parent_dict_tmp.contains("subsection"))) {
                cpp_parent_dict_tmp["subsection"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict_tmp["subsection"];
              if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
              // variable declarations
              double var_ZAP_0d_double_Scalar;
              bool aux_ZAP_read = false;
              vartype aux_last_type_read_for_ZAP = UNKNOWN;
              double var_ELFS_0d_double_Scalar;
              bool aux_ELFS_read = false;
              vartype aux_last_type_read_for_ELFS = UNKNOWN;
              int var_LMF_0d_int_Scalar;
              bool aux_LMF_read = false;
              vartype aux_last_type_read_for_LMF = UNKNOWN;
              int var_LFS_0d_int_Scalar;
              bool aux_LFS_read = false;
              vartype aux_last_type_read_for_LFS = UNKNOWN;
              cpp_template = "[ MAT , 8 , MT / ZAP , ELFS , LMF , LFS , 0 , 0 ] CONT";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read CONT record
              cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZAP"]), write_opts);
              // assign expression to variable ZAP
              var_ZAP_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZAP"]);
              aux_ZAP_read = true;
              validate_vartype_consistency("ZAP", SCALAR_DOUBLE, aux_last_type_read_for_ZAP);
              aux_last_type_read_for_ZAP = SCALAR_DOUBLE;
              cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["ELFS"]), write_opts);
              // assign expression to variable ELFS
              var_ELFS_0d_double_Scalar = py::cast<double>(cpp_current_dict["ELFS"]);
              aux_ELFS_read = true;
              validate_vartype_consistency("ELFS", SCALAR_DOUBLE, aux_last_type_read_for_ELFS);
              aux_last_type_read_for_ELFS = SCALAR_DOUBLE;
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LMF"]), write_opts);
              // assign expression to variable LMF
              var_LMF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LMF"]);
              aux_LMF_read = true;
              validate_vartype_consistency("LMF", SCALAR_INT, aux_last_type_read_for_LMF);
              aux_last_type_read_for_LMF = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LFS"]), write_opts);
              // assign expression to variable LFS
              var_LFS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LFS"]);
              aux_LFS_read = true;
              validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
              aux_last_type_read_for_LFS = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
              cont << cpp_draft_line;
              cpp_current_dict = cpp_parent_dict_tmp;
            }
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 2c946085e67d919e399440582cef277e
// MD5 hash of the following function definition: 22e58ca222954b76ef7c48e00fe2aad4
void write_mf8mt454_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_LE_0d_int_Scalar;
  bool aux_LE_read = false;
  vartype aux_last_type_read_for_LE = UNKNOWN;
  NestedVector<double> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<int> var_NN_1d_int_NestedVector;
  vartype aux_last_type_read_for_NN = UNKNOWN;
  NestedVector<int> var_NFP_1d_int_NestedVector;
  vartype aux_last_type_read_for_NFP = UNKNOWN;
  NestedVector<NestedVector<double>> var_ZAFP_2d_double_NestedVector;
  NestedVector<double>* ptr_ZAFP_2d_idx0;
  vartype aux_last_type_read_for_ZAFP = UNKNOWN;
  NestedVector<NestedVector<double>> var_FPS_2d_double_NestedVector;
  NestedVector<double>* ptr_FPS_2d_idx0;
  vartype aux_last_type_read_for_FPS = UNKNOWN;
  NestedVector<NestedVector<double>> var_YI_2d_double_NestedVector;
  NestedVector<double>* ptr_YI_2d_idx0;
  vartype aux_last_type_read_for_YI = UNKNOWN;
  NestedVector<NestedVector<double>> var_DYI_2d_double_NestedVector;
  NestedVector<double>* ptr_DYI_2d_idx0;
  vartype aux_last_type_read_for_DYI = UNKNOWN;
  NestedVector<int> var_I_1d_int_NestedVector;
  vartype aux_last_type_read_for_I = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 8;
  int mt = 454;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 454;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 8 , MT / ZA , AWR , (LE+1) , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, (py::cast<int>(cpp_current_dict["LE"])+1), write_opts);
  // assign expression to variable cpp_int_val
  cpp_int_val = (py::cast<int>(cpp_current_dict["LE"])+1);
  aux_cpp_int_val_read = true;
  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
  // assign expression to variable LE
  var_LE_0d_int_Scalar = (cpp_int_val+(-1));
  aux_LE_read = true;
  validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
  aux_last_type_read_for_LE = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 8 , MT / E , 0.0 , LE , 0 , NN , NFP / \n { ZAFP , FPS , YI , DYI } { m = 1 to NFP } ] LIST";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read LIST record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["E"][py::cast(0)]), write_opts);
  // assign expression to variable E
  var_E_1d_double_NestedVector.set(0, py::cast<double>(cpp_current_dict["E"][py::cast(0)]));
  validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
  aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LE"]), write_opts);
  if ((! (aux_LE_read == true))) {
    // assign expression to variable LE
    var_LE_0d_int_Scalar = py::cast<int>(cpp_current_dict["LE"]);
    aux_LE_read = true;
    validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
    aux_last_type_read_for_LE = SCALAR_INT;
  } else {
  }
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NN"][py::cast(0)]), write_opts);
  // assign expression to variable NN
  var_NN_1d_int_NestedVector.set(0, py::cast<int>(cpp_current_dict["NN"][py::cast(0)]));
  validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
  aux_last_type_read_for_NN = NESTEDVECTOR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NFP"][py::cast(0)]), write_opts);
  // assign expression to variable NFP
  var_NFP_1d_int_NestedVector.set(0, py::cast<int>(cpp_current_dict["NFP"][py::cast(0)]));
  validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
  aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NN"][py::cast(0)]), write_opts);
  cont << cpp_draft_line;
  {
    int cpp_npl = py::cast<int>(cpp_current_dict["NN"][py::cast(0)]);
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
    // read LIST body
    ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(0);
    ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(0);
    ptr_YI_2d_idx0 = var_YI_2d_double_NestedVector.prepare(0);
    ptr_DYI_2d_idx0 = var_DYI_2d_double_NestedVector.prepare(0);

    for (int var_m_0d_int_Scalar = 1;
       var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[0]; var_m_0d_int_Scalar++) {
      bool aux_m_read = true;
      // read LIST body
      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ZAFP"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]), write_opts);
      // assign expression to variable ZAFP
      ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["ZAFP"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]));
      validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
      aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_j = 0;
      }
      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["FPS"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]), write_opts);
      // assign expression to variable FPS
      ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["FPS"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]));
      validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
      aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_j = 0;
      }
      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["YI"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]), write_opts);
      // assign expression to variable YI
      ptr_YI_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["YI"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]));
      validate_vartype_consistency("YI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YI);
      aux_last_type_read_for_YI = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_j = 0;
      }
      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DYI"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]), write_opts);
      // assign expression to variable DYI
      ptr_DYI_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DYI"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]));
      validate_vartype_consistency("DYI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYI);
      aux_last_type_read_for_DYI = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_LE_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    cpp_template = "[ MAT , 8 , MT / E , 0.0 , I , 0 , NN , NFP / \n { ZAFP , FPS , YI , DYI } { m = 1 to NFP } ] LIST";
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
    // read LIST record
    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]), write_opts);
    if ((! var_E_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable E
      var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]));
      validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
      aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
    } else {
    }
    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["I"][py::cast(var_k_0d_int_Scalar)]), write_opts);
    // assign expression to variable I
    var_I_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["I"][py::cast(var_k_0d_int_Scalar)]));
    validate_vartype_consistency("I", NESTEDVECTOR_INT, aux_last_type_read_for_I);
    aux_last_type_read_for_I = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NN"][py::cast(var_k_0d_int_Scalar)]), write_opts);
    if ((! var_NN_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NN
      var_NN_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["NN"][py::cast(var_k_0d_int_Scalar)]));
      validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
      aux_last_type_read_for_NN = NESTEDVECTOR_INT;
    } else {
    }
    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NFP"][py::cast(var_k_0d_int_Scalar)]), write_opts);
    if ((! var_NFP_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NFP
      var_NFP_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["NFP"][py::cast(var_k_0d_int_Scalar)]));
      validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
      aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
    } else {
    }
    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NN"][py::cast(var_k_0d_int_Scalar)]), write_opts);
    cont << cpp_draft_line;
    {
      int cpp_npl = py::cast<int>(cpp_current_dict["NN"][py::cast(var_k_0d_int_Scalar)]);
      int cpp_i = 0;
      int cpp_j = 0;
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
      // read LIST body
      ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_YI_2d_idx0 = var_YI_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_DYI_2d_idx0 = var_DYI_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

      for (int var_m_0d_int_Scalar = 1;
         var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[var_k_0d_int_Scalar]; var_m_0d_int_Scalar++) {
        bool aux_m_read = true;
        // read LIST body
        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ZAFP"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
        if ((! (var_ZAFP_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_ZAFP_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable ZAFP
          ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["ZAFP"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
          validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
          aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["FPS"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
        if ((! (var_FPS_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_FPS_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable FPS
          ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["FPS"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
          validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
          aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["YI"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
        if ((! (var_YI_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_YI_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable YI
          ptr_YI_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["YI"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
          validate_vartype_consistency("YI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YI);
          aux_last_type_read_for_YI = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DYI"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
        if ((! (var_DYI_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_DYI_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable DYI
          ptr_DYI_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DYI"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
          validate_vartype_consistency("DYI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYI);
          aux_last_type_read_for_DYI = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
      }
      if (cpp_i != cpp_npl) {
        throw std::runtime_error("not exactly NPL elements consumed");
      }
    }
    cont << cpp_draft_line;
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 938fd3d870f297fe0f3b2ca86b863542
// MD5 hash of the following function definition: b1f987fb0ea34b4e3bfc2f34d372af90
void write_mf8mt457_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_LISO_0d_int_Scalar;
  bool aux_LISO_read = false;
  vartype aux_last_type_read_for_LISO = UNKNOWN;
  int var_NST_0d_int_Scalar;
  bool aux_NST_read = false;
  vartype aux_last_type_read_for_NST = UNKNOWN;
  int var_NSP_0d_int_Scalar;
  bool aux_NSP_read = false;
  vartype aux_last_type_read_for_NSP = UNKNOWN;
  double var_Thalf_0d_double_Scalar;
  bool aux_Thalf_read = false;
  vartype aux_last_type_read_for_Thalf = UNKNOWN;
  double var_dThalf_0d_double_Scalar;
  bool aux_dThalf_read = false;
  vartype aux_last_type_read_for_dThalf = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  NestedVector<double> var_Ebar_x_1d_double_NestedVector;
  vartype aux_last_type_read_for_Ebar_x = UNKNOWN;
  NestedVector<double> var_dEbar_x_1d_double_NestedVector;
  vartype aux_last_type_read_for_dEbar_x = UNKNOWN;
  double var_SPI_0d_double_Scalar;
  bool aux_SPI_read = false;
  vartype aux_last_type_read_for_SPI = UNKNOWN;
  double var_PAR_0d_double_Scalar;
  bool aux_PAR_read = false;
  vartype aux_last_type_read_for_PAR = UNKNOWN;
  int var_NDK_0d_int_Scalar;
  bool aux_NDK_read = false;
  vartype aux_last_type_read_for_NDK = UNKNOWN;
  NestedVector<double> var_RTYP_1d_double_NestedVector;
  vartype aux_last_type_read_for_RTYP = UNKNOWN;
  NestedVector<double> var_RFS_1d_double_NestedVector;
  vartype aux_last_type_read_for_RFS = UNKNOWN;
  NestedVector<double> var_Q_1d_double_NestedVector;
  vartype aux_last_type_read_for_Q = UNKNOWN;
  NestedVector<double> var_dQ_1d_double_NestedVector;
  vartype aux_last_type_read_for_dQ = UNKNOWN;
  NestedVector<double> var_BR_1d_double_NestedVector;
  vartype aux_last_type_read_for_BR = UNKNOWN;
  NestedVector<double> var_dBR_1d_double_NestedVector;
  vartype aux_last_type_read_for_dBR = UNKNOWN;
  int var_JENDL_LIST_NPL_0d_int_Scalar;
  bool aux_JENDL_LIST_NPL_read = false;
  vartype aux_last_type_read_for_JENDL_LIST_NPL = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 8;
  int mt = 457;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 457;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LIS_0d_int_Scalar = var_LIS_0d_int_Scalar;
          int var_LIS_0d_int_Scalar = glob_var_LIS_0d_int_Scalar;
          bool& glob_aux_LIS_read = aux_LIS_read;
          bool aux_LIS_read = glob_aux_LIS_read;
          vartype aux_last_type_read_for_LIS = UNKNOWN;
          int& glob_var_LISO_0d_int_Scalar = var_LISO_0d_int_Scalar;
          int var_LISO_0d_int_Scalar = glob_var_LISO_0d_int_Scalar;
          bool& glob_aux_LISO_read = aux_LISO_read;
          bool aux_LISO_read = glob_aux_LISO_read;
          vartype aux_last_type_read_for_LISO = UNKNOWN;
          int& glob_var_NST_0d_int_Scalar = var_NST_0d_int_Scalar;
          int var_NST_0d_int_Scalar = glob_var_NST_0d_int_Scalar;
          bool& glob_aux_NST_read = aux_NST_read;
          bool aux_NST_read = glob_aux_NST_read;
          vartype aux_last_type_read_for_NST = UNKNOWN;
          int& glob_var_NSP_0d_int_Scalar = var_NSP_0d_int_Scalar;
          int var_NSP_0d_int_Scalar = glob_var_NSP_0d_int_Scalar;
          bool& glob_aux_NSP_read = aux_NSP_read;
          bool aux_NSP_read = glob_aux_NSP_read;
          vartype aux_last_type_read_for_NSP = UNKNOWN;
          cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , NSP ] HEAD";
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ZA", -99999.9));
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AWR", -99999.9));
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LIS
          var_LIS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LIS", -99999));
          aux_LIS_read = true;
          validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
          aux_last_type_read_for_LIS = SCALAR_INT;
          // assign expression to variable LISO
          var_LISO_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LISO", -99999));
          aux_LISO_read = true;
          validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
          aux_last_type_read_for_LISO = SCALAR_INT;
          // assign expression to variable NST
          var_NST_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NST", -99999));
          aux_NST_read = true;
          validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
          aux_last_type_read_for_NST = SCALAR_INT;
          // assign expression to variable NSP
          var_NSP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NSP", -99999));
          aux_NSP_read = true;
          validate_vartype_consistency("NSP", SCALAR_INT, aux_last_type_read_for_NSP);
          aux_last_type_read_for_NSP = SCALAR_INT;
          if ((((((((aux_NST_read == true)) && ((var_NST_0d_int_Scalar)==(0)))))))) {
            cpp_found_match = true;
          }
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , NSP ] HEAD";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read CONT record
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LIS"]), write_opts);
          // assign expression to variable LIS
          var_LIS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LIS"]);
          aux_LIS_read = true;
          validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
          aux_last_type_read_for_LIS = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LISO"]), write_opts);
          // assign expression to variable LISO
          var_LISO_0d_int_Scalar = py::cast<int>(cpp_current_dict["LISO"]);
          aux_LISO_read = true;
          validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
          aux_last_type_read_for_LISO = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NST"]), write_opts);
          // assign expression to variable NST
          var_NST_0d_int_Scalar = py::cast<int>(cpp_current_dict["NST"]);
          aux_NST_read = true;
          validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
          aux_last_type_read_for_NST = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NSP"]), write_opts);
          // assign expression to variable NSP
          var_NSP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NSP"]);
          aux_NSP_read = true;
          validate_vartype_consistency("NSP", SCALAR_INT, aux_last_type_read_for_NSP);
          aux_last_type_read_for_NSP = SCALAR_INT;
          cont << cpp_draft_line;
          cpp_template = "[ MAT , 8 , 457 / Thalf , dThalf , 0 , 0 , (2*NC) , 0 / \n { Ebar_x , dEbar_x } { k = 1 to NC } ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read LIST record
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["Thalf"]), write_opts);
          // assign expression to variable Thalf
          var_Thalf_0d_double_Scalar = py::cast<double>(cpp_current_dict["Thalf"]);
          aux_Thalf_read = true;
          validate_vartype_consistency("Thalf", SCALAR_DOUBLE, aux_last_type_read_for_Thalf);
          aux_last_type_read_for_Thalf = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["dThalf"]), write_opts);
          // assign expression to variable dThalf
          var_dThalf_0d_double_Scalar = py::cast<double>(cpp_current_dict["dThalf"]);
          aux_dThalf_read = true;
          validate_vartype_consistency("dThalf", SCALAR_DOUBLE, aux_last_type_read_for_dThalf);
          aux_last_type_read_for_dThalf = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NC"])), write_opts);
          // assign expression to variable cpp_int_val
          cpp_int_val = (2*py::cast<int>(cpp_current_dict["NC"]));
          aux_cpp_int_val_read = true;
          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
          // assign expression to variable NC
          var_NC_0d_int_Scalar = (cpp_int_val/2);
          aux_NC_read = true;
          validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
          aux_last_type_read_for_NC = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NC"])), write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = (2*py::cast<int>(cpp_current_dict["NC"]));
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NC_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Ebar_x"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable Ebar_x
              var_Ebar_x_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["Ebar_x"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("Ebar_x", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ebar_x);
              aux_last_type_read_for_Ebar_x = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dEbar_x"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable dEbar_x
              var_dEbar_x_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["dEbar_x"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("dEbar_x", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dEbar_x);
              aux_last_type_read_for_dEbar_x = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;
          cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , (6*NDK) , NDK / \n { RTYP , RFS , Q , dQ , BR , dBR } { k = 1 to NDK } ] LIST";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read LIST record
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
          // assign expression to variable SPI
          var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
          aux_SPI_read = true;
          validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
          aux_last_type_read_for_SPI = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["PAR"]), write_opts);
          // assign expression to variable PAR
          var_PAR_0d_double_Scalar = py::cast<double>(cpp_current_dict["PAR"]);
          aux_PAR_read = true;
          validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
          aux_last_type_read_for_PAR = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NDK"])), write_opts);
          // assign expression to variable cpp_int_val
          cpp_int_val = (6*py::cast<int>(cpp_current_dict["NDK"]));
          aux_cpp_int_val_read = true;
          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
          // assign expression to variable NDK
          var_NDK_0d_int_Scalar = (cpp_int_val/6);
          aux_NDK_read = true;
          validate_vartype_consistency("NDK", SCALAR_INT, aux_last_type_read_for_NDK);
          aux_last_type_read_for_NDK = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NDK"]), write_opts);
          if ((! (aux_NDK_read == true))) {
            // assign expression to variable NDK
            var_NDK_0d_int_Scalar = py::cast<int>(cpp_current_dict["NDK"]);
            aux_NDK_read = true;
            validate_vartype_consistency("NDK", SCALAR_INT, aux_last_type_read_for_NDK);
            aux_last_type_read_for_NDK = SCALAR_INT;
          } else {
          }
          cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NDK"])), write_opts);
          cont << cpp_draft_line;
          {
            int cpp_npl = (6*py::cast<int>(cpp_current_dict["NDK"]));
            int cpp_i = 0;
            int cpp_j = 0;
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST body

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NDK_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              // read LIST body
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RTYP"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable RTYP
              var_RTYP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["RTYP"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("RTYP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_RTYP);
              aux_last_type_read_for_RTYP = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RFS"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable RFS
              var_RFS_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["RFS"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("RFS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_RFS);
              aux_last_type_read_for_RFS = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Q"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable Q
              var_Q_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["Q"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("Q", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Q);
              aux_last_type_read_for_Q = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dQ"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable dQ
              var_dQ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["dQ"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("dQ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dQ);
              aux_last_type_read_for_dQ = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["BR"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable BR
              var_BR_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["BR"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("BR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BR);
              aux_last_type_read_for_BR = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dBR"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable dBR
              var_dBR_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["dBR"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("dBR", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_dBR);
              aux_last_type_read_for_dBR = NESTEDVECTOR_DOUBLE;
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
            }
            if (cpp_i != cpp_npl) {
              throw std::runtime_error("not exactly NPL elements consumed");
            }
          }
          cont << cpp_draft_line;

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NSP_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            // open section spectrum
            {
              py::dict cpp_parent_dict_tmp = cpp_current_dict;
              if ((! cpp_parent_dict_tmp.contains("spectrum"))) {
                cpp_parent_dict_tmp["spectrum"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict_tmp["spectrum"];
              if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
              // variable declarations
              double var_STYP_0d_double_Scalar;
              bool aux_STYP_read = false;
              vartype aux_last_type_read_for_STYP = UNKNOWN;
              int var_LCON_0d_int_Scalar;
              bool aux_LCON_read = false;
              vartype aux_last_type_read_for_LCON = UNKNOWN;
              int var_LCOV_0d_int_Scalar;
              bool aux_LCOV_read = false;
              vartype aux_last_type_read_for_LCOV = UNKNOWN;
              int var_NER_0d_int_Scalar;
              bool aux_NER_read = false;
              vartype aux_last_type_read_for_NER = UNKNOWN;
              double var_FD_0d_double_Scalar;
              bool aux_FD_read = false;
              vartype aux_last_type_read_for_FD = UNKNOWN;
              double var_dFD_0d_double_Scalar;
              bool aux_dFD_read = false;
              vartype aux_last_type_read_for_dFD = UNKNOWN;
              double var_ERAV_0d_double_Scalar;
              bool aux_ERAV_read = false;
              vartype aux_last_type_read_for_ERAV = UNKNOWN;
              double var_dERAV_0d_double_Scalar;
              bool aux_dERAV_read = false;
              vartype aux_last_type_read_for_dERAV = UNKNOWN;
              double var_FC_0d_double_Scalar;
              bool aux_FC_read = false;
              vartype aux_last_type_read_for_FC = UNKNOWN;
              double var_dFC_0d_double_Scalar;
              bool aux_dFC_read = false;
              vartype aux_last_type_read_for_dFC = UNKNOWN;
              cpp_template = "[ MAT , 8 , 457 / 0.0 , STYP , LCON , LCOV , 6 , NER / \n FD , dFD , ERAV , dERAV , FC , dFC ] LIST";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read LIST record
              cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["STYP"]), write_opts);
              // assign expression to variable STYP
              var_STYP_0d_double_Scalar = py::cast<double>(cpp_current_dict["STYP"]);
              aux_STYP_read = true;
              validate_vartype_consistency("STYP", SCALAR_DOUBLE, aux_last_type_read_for_STYP);
              aux_last_type_read_for_STYP = SCALAR_DOUBLE;
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LCON"]), write_opts);
              // assign expression to variable LCON
              var_LCON_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCON"]);
              aux_LCON_read = true;
              validate_vartype_consistency("LCON", SCALAR_INT, aux_last_type_read_for_LCON);
              aux_last_type_read_for_LCON = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LCOV"]), write_opts);
              // assign expression to variable LCOV
              var_LCOV_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCOV"]);
              aux_LCOV_read = true;
              validate_vartype_consistency("LCOV", SCALAR_INT, aux_last_type_read_for_LCOV);
              aux_last_type_read_for_LCOV = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, 6, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NER"]), write_opts);
              // assign expression to variable NER
              var_NER_0d_int_Scalar = py::cast<int>(cpp_current_dict["NER"]);
              aux_NER_read = true;
              validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
              aux_last_type_read_for_NER = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, 6, write_opts);
              cont << cpp_draft_line;
              {
                int cpp_npl = 6;
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                // read LIST body
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["FD"]), write_opts);
                // assign expression to variable FD
                var_FD_0d_double_Scalar = py::cast<double>(cpp_current_dict["FD"]);
                aux_FD_read = true;
                validate_vartype_consistency("FD", SCALAR_DOUBLE, aux_last_type_read_for_FD);
                aux_last_type_read_for_FD = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dFD"]), write_opts);
                // assign expression to variable dFD
                var_dFD_0d_double_Scalar = py::cast<double>(cpp_current_dict["dFD"]);
                aux_dFD_read = true;
                validate_vartype_consistency("dFD", SCALAR_DOUBLE, aux_last_type_read_for_dFD);
                aux_last_type_read_for_dFD = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ERAV"]), write_opts);
                // assign expression to variable ERAV
                var_ERAV_0d_double_Scalar = py::cast<double>(cpp_current_dict["ERAV"]);
                aux_ERAV_read = true;
                validate_vartype_consistency("ERAV", SCALAR_DOUBLE, aux_last_type_read_for_ERAV);
                aux_last_type_read_for_ERAV = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dERAV"]), write_opts);
                // assign expression to variable dERAV
                var_dERAV_0d_double_Scalar = py::cast<double>(cpp_current_dict["dERAV"]);
                aux_dERAV_read = true;
                validate_vartype_consistency("dERAV", SCALAR_DOUBLE, aux_last_type_read_for_dERAV);
                aux_last_type_read_for_dERAV = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["FC"]), write_opts);
                // assign expression to variable FC
                var_FC_0d_double_Scalar = py::cast<double>(cpp_current_dict["FC"]);
                aux_FC_read = true;
                validate_vartype_consistency("FC", SCALAR_DOUBLE, aux_last_type_read_for_FC);
                aux_last_type_read_for_FC = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dFC"]), write_opts);
                // assign expression to variable dFC
                var_dFC_0d_double_Scalar = py::cast<double>(cpp_current_dict["dFC"]);
                aux_dFC_read = true;
                validate_vartype_consistency("dFC", SCALAR_DOUBLE, aux_last_type_read_for_dFC);
                aux_last_type_read_for_dFC = SCALAR_DOUBLE;
                cpp_i++;
                cpp_j++;
                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                  cont << cpp_draft_line;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  cpp_j = 0;
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
              cont << cpp_draft_line;
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if ((((((((aux_LCON_read == true)) && ((var_LCON_0d_int_Scalar)!=(1)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section discrete
                    {
                      py::dict cpp_parent_dict_tmp = cpp_current_dict;
                      if ((! cpp_parent_dict_tmp.contains("discrete"))) {
                        cpp_parent_dict_tmp["discrete"] = py::dict();
                      }
                      py::dict cpp_current_dict = cpp_parent_dict_tmp["discrete"];
                      // variable declarations

                      for (int var_i_0d_int_Scalar = 1;
                         var_i_0d_int_Scalar <= var_NER_0d_int_Scalar; var_i_0d_int_Scalar++) {
                        bool aux_i_read = true;
                        // open section energysec
                        {
                          py::dict cpp_parent_dict_tmp = cpp_current_dict;
                          if ((! cpp_parent_dict_tmp.contains("energysec"))) {
                            cpp_parent_dict_tmp["energysec"] = py::dict();
                          }
                          py::dict cpp_current_dict = cpp_parent_dict_tmp["energysec"];
                          if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
                            cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
                          }
                          cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
                          // variable declarations
                          double var_ER_0d_double_Scalar;
                          bool aux_ER_read = false;
                          vartype aux_last_type_read_for_ER = UNKNOWN;
                          double var_dER_0d_double_Scalar;
                          bool aux_dER_read = false;
                          vartype aux_last_type_read_for_dER = UNKNOWN;
                          int var_NT_0d_int_Scalar;
                          bool aux_NT_read = false;
                          vartype aux_last_type_read_for_NT = UNKNOWN;
                          double var_RTYP_0d_double_Scalar;
                          bool aux_RTYP_read = false;
                          vartype aux_last_type_read_for_RTYP = UNKNOWN;
                          double var_TYPE_0d_double_Scalar;
                          bool aux_TYPE_read = false;
                          vartype aux_last_type_read_for_TYPE = UNKNOWN;
                          double var_RI_0d_double_Scalar;
                          bool aux_RI_read = false;
                          vartype aux_last_type_read_for_RI = UNKNOWN;
                          double var_dRI_0d_double_Scalar;
                          bool aux_dRI_read = false;
                          vartype aux_last_type_read_for_dRI = UNKNOWN;
                          double var_RIS_0d_double_Scalar;
                          bool aux_RIS_read = false;
                          vartype aux_last_type_read_for_RIS = UNKNOWN;
                          double var_dRIS_0d_double_Scalar;
                          bool aux_dRIS_read = false;
                          vartype aux_last_type_read_for_dRIS = UNKNOWN;
                          double var_RICC_0d_double_Scalar;
                          bool aux_RICC_read = false;
                          vartype aux_last_type_read_for_RICC = UNKNOWN;
                          double var_dRICC_0d_double_Scalar;
                          bool aux_dRICC_read = false;
                          vartype aux_last_type_read_for_dRICC = UNKNOWN;
                          double var_RICK_0d_double_Scalar;
                          bool aux_RICK_read = false;
                          vartype aux_last_type_read_for_RICK = UNKNOWN;
                          double var_dRICK_0d_double_Scalar;
                          bool aux_dRICK_read = false;
                          vartype aux_last_type_read_for_dRICK = UNKNOWN;
                          double var_RICL_0d_double_Scalar;
                          bool aux_RICL_read = false;
                          vartype aux_last_type_read_for_RICL = UNKNOWN;
                          double var_dRICL_0d_double_Scalar;
                          bool aux_dRICL_read = false;
                          vartype aux_last_type_read_for_dRICL = UNKNOWN;
                          // evaluate if-elif-else clause
                          {
                            bool cpp_found_match = false;
                            if (! cpp_found_match) {
                              // if statement evaluation with lookahead
                              {
                                {
                                  // variable declarations
                                  double& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                  double var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                  bool& glob_aux_ER_read = aux_ER_read;
                                  bool aux_ER_read = glob_aux_ER_read;
                                  vartype aux_last_type_read_for_ER = UNKNOWN;
                                  double& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                  double var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                  bool& glob_aux_dER_read = aux_dER_read;
                                  bool aux_dER_read = glob_aux_dER_read;
                                  vartype aux_last_type_read_for_dER = UNKNOWN;
                                  int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                  int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                  bool& glob_aux_NT_read = aux_NT_read;
                                  bool aux_NT_read = glob_aux_NT_read;
                                  vartype aux_last_type_read_for_NT = UNKNOWN;
                                  cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI ] LIST";
                                  // read LIST record
                                  // assign expression to variable ER
                                  var_ER_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ER", -99999.9));
                                  aux_ER_read = true;
                                  validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                  aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                  // assign expression to variable dER
                                  var_dER_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("dER", -99999.9));
                                  aux_dER_read = true;
                                  validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                  aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                  // assign expression to variable NT
                                  var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NT", -99999));
                                  aux_NT_read = true;
                                  validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                  aux_last_type_read_for_NT = SCALAR_INT;
                                  if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(4)))))))) {
                                    cpp_found_match = true;
                                  }
                                }
                                if (cpp_found_match) {
                                  cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI ] LIST";
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  // read LIST record
                                  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ER"]), write_opts);
                                  // assign expression to variable ER
                                  var_ER_0d_double_Scalar = py::cast<double>(cpp_current_dict["ER"]);
                                  aux_ER_read = true;
                                  validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                  aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["dER"]), write_opts);
                                  // assign expression to variable dER
                                  var_dER_0d_double_Scalar = py::cast<double>(cpp_current_dict["dER"]);
                                  aux_dER_read = true;
                                  validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                  aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                                  // assign expression to variable NT
                                  var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NT"]);
                                  aux_NT_read = true;
                                  validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                  aux_last_type_read_for_NT = SCALAR_INT;
                                  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                                  cont << cpp_draft_line;
                                  {
                                    int cpp_npl = py::cast<int>(cpp_current_dict["NT"]);
                                    int cpp_i = 0;
                                    int cpp_j = 0;
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                    // read LIST body
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RTYP"]), write_opts);
                                    // assign expression to variable RTYP
                                    var_RTYP_0d_double_Scalar = py::cast<double>(cpp_current_dict["RTYP"]);
                                    aux_RTYP_read = true;
                                    validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                    aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["TYPE"]), write_opts);
                                    // assign expression to variable TYPE
                                    var_TYPE_0d_double_Scalar = py::cast<double>(cpp_current_dict["TYPE"]);
                                    aux_TYPE_read = true;
                                    validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                    aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RI"]), write_opts);
                                    // assign expression to variable RI
                                    var_RI_0d_double_Scalar = py::cast<double>(cpp_current_dict["RI"]);
                                    aux_RI_read = true;
                                    validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                    aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRI"]), write_opts);
                                    // assign expression to variable dRI
                                    var_dRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRI"]);
                                    aux_dRI_read = true;
                                    validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                    aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                    cpp_i++;
                                    cpp_j++;
                                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                      cont << cpp_draft_line;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      cpp_j = 0;
                                    }
                                    if (cpp_i != cpp_npl) {
                                      throw std::runtime_error("not exactly NPL elements consumed");
                                    }
                                  }
                                  cont << cpp_draft_line;
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  {
                                    // variable declarations
                                    double& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    double var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    double& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    double var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS ] LIST";
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ER", -99999.9));
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("dER", -99999.9));
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NT", -99999));
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(6)))))))) {
                                      cpp_found_match = true;
                                    }
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS ] LIST";
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                    // read LIST record
                                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ER"]), write_opts);
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = py::cast<double>(cpp_current_dict["ER"]);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["dER"]), write_opts);
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = py::cast<double>(cpp_current_dict["dER"]);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NT"]);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                                    cont << cpp_draft_line;
                                    {
                                      int cpp_npl = py::cast<int>(cpp_current_dict["NT"]);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      // read LIST body
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RTYP"]), write_opts);
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = py::cast<double>(cpp_current_dict["RTYP"]);
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["TYPE"]), write_opts);
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = py::cast<double>(cpp_current_dict["TYPE"]);
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RI"]), write_opts);
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = py::cast<double>(cpp_current_dict["RI"]);
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRI"]), write_opts);
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRI"]);
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RIS"]), write_opts);
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = py::cast<double>(cpp_current_dict["RIS"]);
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRIS"]), write_opts);
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRIS"]);
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                    cont << cpp_draft_line;
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  {
                                    // variable declarations
                                    double& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    double var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    double& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    double var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC ] LIST";
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ER", -99999.9));
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("dER", -99999.9));
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NT", -99999));
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(8)))))))) {
                                      cpp_found_match = true;
                                    }
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC ] LIST";
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                    // read LIST record
                                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ER"]), write_opts);
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = py::cast<double>(cpp_current_dict["ER"]);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["dER"]), write_opts);
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = py::cast<double>(cpp_current_dict["dER"]);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NT"]);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                                    cont << cpp_draft_line;
                                    {
                                      int cpp_npl = py::cast<int>(cpp_current_dict["NT"]);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      // read LIST body
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RTYP"]), write_opts);
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = py::cast<double>(cpp_current_dict["RTYP"]);
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["TYPE"]), write_opts);
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = py::cast<double>(cpp_current_dict["TYPE"]);
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RI"]), write_opts);
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = py::cast<double>(cpp_current_dict["RI"]);
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRI"]), write_opts);
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRI"]);
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RIS"]), write_opts);
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = py::cast<double>(cpp_current_dict["RIS"]);
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRIS"]), write_opts);
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRIS"]);
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RICC"]), write_opts);
                                      // assign expression to variable RICC
                                      var_RICC_0d_double_Scalar = py::cast<double>(cpp_current_dict["RICC"]);
                                      aux_RICC_read = true;
                                      validate_vartype_consistency("RICC", SCALAR_DOUBLE, aux_last_type_read_for_RICC);
                                      aux_last_type_read_for_RICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRICC"]), write_opts);
                                      // assign expression to variable dRICC
                                      var_dRICC_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRICC"]);
                                      aux_dRICC_read = true;
                                      validate_vartype_consistency("dRICC", SCALAR_DOUBLE, aux_last_type_read_for_dRICC);
                                      aux_last_type_read_for_dRICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                    cont << cpp_draft_line;
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  {
                                    // variable declarations
                                    double& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    double var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    double& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    double var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK ] LIST";
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ER", -99999.9));
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("dER", -99999.9));
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NT", -99999));
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(10)))))))) {
                                      cpp_found_match = true;
                                    }
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK ] LIST";
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                    // read LIST record
                                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ER"]), write_opts);
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = py::cast<double>(cpp_current_dict["ER"]);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["dER"]), write_opts);
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = py::cast<double>(cpp_current_dict["dER"]);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NT"]);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                                    cont << cpp_draft_line;
                                    {
                                      int cpp_npl = py::cast<int>(cpp_current_dict["NT"]);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      // read LIST body
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RTYP"]), write_opts);
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = py::cast<double>(cpp_current_dict["RTYP"]);
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["TYPE"]), write_opts);
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = py::cast<double>(cpp_current_dict["TYPE"]);
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RI"]), write_opts);
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = py::cast<double>(cpp_current_dict["RI"]);
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRI"]), write_opts);
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRI"]);
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RIS"]), write_opts);
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = py::cast<double>(cpp_current_dict["RIS"]);
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRIS"]), write_opts);
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRIS"]);
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RICC"]), write_opts);
                                      // assign expression to variable RICC
                                      var_RICC_0d_double_Scalar = py::cast<double>(cpp_current_dict["RICC"]);
                                      aux_RICC_read = true;
                                      validate_vartype_consistency("RICC", SCALAR_DOUBLE, aux_last_type_read_for_RICC);
                                      aux_last_type_read_for_RICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRICC"]), write_opts);
                                      // assign expression to variable dRICC
                                      var_dRICC_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRICC"]);
                                      aux_dRICC_read = true;
                                      validate_vartype_consistency("dRICC", SCALAR_DOUBLE, aux_last_type_read_for_dRICC);
                                      aux_last_type_read_for_dRICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RICK"]), write_opts);
                                      // assign expression to variable RICK
                                      var_RICK_0d_double_Scalar = py::cast<double>(cpp_current_dict["RICK"]);
                                      aux_RICK_read = true;
                                      validate_vartype_consistency("RICK", SCALAR_DOUBLE, aux_last_type_read_for_RICK);
                                      aux_last_type_read_for_RICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRICK"]), write_opts);
                                      // assign expression to variable dRICK
                                      var_dRICK_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRICK"]);
                                      aux_dRICK_read = true;
                                      validate_vartype_consistency("dRICK", SCALAR_DOUBLE, aux_last_type_read_for_dRICK);
                                      aux_last_type_read_for_dRICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                    cont << cpp_draft_line;
                                  }
                                }
                              }
                            }
                            if (! cpp_found_match) {
                              if (! cpp_found_match) {
                                // if statement evaluation with lookahead
                                {
                                  {
                                    // variable declarations
                                    double& glob_var_ER_0d_double_Scalar = var_ER_0d_double_Scalar;
                                    double var_ER_0d_double_Scalar = glob_var_ER_0d_double_Scalar;
                                    bool& glob_aux_ER_read = aux_ER_read;
                                    bool aux_ER_read = glob_aux_ER_read;
                                    vartype aux_last_type_read_for_ER = UNKNOWN;
                                    double& glob_var_dER_0d_double_Scalar = var_dER_0d_double_Scalar;
                                    double var_dER_0d_double_Scalar = glob_var_dER_0d_double_Scalar;
                                    bool& glob_aux_dER_read = aux_dER_read;
                                    bool aux_dER_read = glob_aux_dER_read;
                                    vartype aux_last_type_read_for_dER = UNKNOWN;
                                    int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                                    int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                                    bool& glob_aux_NT_read = aux_NT_read;
                                    bool aux_NT_read = glob_aux_NT_read;
                                    vartype aux_last_type_read_for_NT = UNKNOWN;
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK , RICL , dRICL ] LIST";
                                    // read LIST record
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ER", -99999.9));
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("dER", -99999.9));
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NT", -99999));
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    if ((((((((aux_NT_read == true)) && ((var_NT_0d_int_Scalar)==(12)))))))) {
                                      cpp_found_match = true;
                                    }
                                  }
                                  if (cpp_found_match) {
                                    cpp_template = "[ MAT , 8 , 457 / ER , dER , 0 , 0 , NT , 0 / \n RTYP , TYPE , RI , dRI , RIS , dRIS , \n RICC , dRICC , RICK , dRICK , RICL , dRICL ] LIST";
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                    // read LIST record
                                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ER"]), write_opts);
                                    // assign expression to variable ER
                                    var_ER_0d_double_Scalar = py::cast<double>(cpp_current_dict["ER"]);
                                    aux_ER_read = true;
                                    validate_vartype_consistency("ER", SCALAR_DOUBLE, aux_last_type_read_for_ER);
                                    aux_last_type_read_for_ER = SCALAR_DOUBLE;
                                    cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["dER"]), write_opts);
                                    // assign expression to variable dER
                                    var_dER_0d_double_Scalar = py::cast<double>(cpp_current_dict["dER"]);
                                    aux_dER_read = true;
                                    validate_vartype_consistency("dER", SCALAR_DOUBLE, aux_last_type_read_for_dER);
                                    aux_last_type_read_for_dER = SCALAR_DOUBLE;
                                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                                    // assign expression to variable NT
                                    var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NT"]);
                                    aux_NT_read = true;
                                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                                    aux_last_type_read_for_NT = SCALAR_INT;
                                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                                    cont << cpp_draft_line;
                                    {
                                      int cpp_npl = py::cast<int>(cpp_current_dict["NT"]);
                                      int cpp_i = 0;
                                      int cpp_j = 0;
                                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                      // read LIST body
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RTYP"]), write_opts);
                                      // assign expression to variable RTYP
                                      var_RTYP_0d_double_Scalar = py::cast<double>(cpp_current_dict["RTYP"]);
                                      aux_RTYP_read = true;
                                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["TYPE"]), write_opts);
                                      // assign expression to variable TYPE
                                      var_TYPE_0d_double_Scalar = py::cast<double>(cpp_current_dict["TYPE"]);
                                      aux_TYPE_read = true;
                                      validate_vartype_consistency("TYPE", SCALAR_DOUBLE, aux_last_type_read_for_TYPE);
                                      aux_last_type_read_for_TYPE = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RI"]), write_opts);
                                      // assign expression to variable RI
                                      var_RI_0d_double_Scalar = py::cast<double>(cpp_current_dict["RI"]);
                                      aux_RI_read = true;
                                      validate_vartype_consistency("RI", SCALAR_DOUBLE, aux_last_type_read_for_RI);
                                      aux_last_type_read_for_RI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRI"]), write_opts);
                                      // assign expression to variable dRI
                                      var_dRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRI"]);
                                      aux_dRI_read = true;
                                      validate_vartype_consistency("dRI", SCALAR_DOUBLE, aux_last_type_read_for_dRI);
                                      aux_last_type_read_for_dRI = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RIS"]), write_opts);
                                      // assign expression to variable RIS
                                      var_RIS_0d_double_Scalar = py::cast<double>(cpp_current_dict["RIS"]);
                                      aux_RIS_read = true;
                                      validate_vartype_consistency("RIS", SCALAR_DOUBLE, aux_last_type_read_for_RIS);
                                      aux_last_type_read_for_RIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRIS"]), write_opts);
                                      // assign expression to variable dRIS
                                      var_dRIS_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRIS"]);
                                      aux_dRIS_read = true;
                                      validate_vartype_consistency("dRIS", SCALAR_DOUBLE, aux_last_type_read_for_dRIS);
                                      aux_last_type_read_for_dRIS = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RICC"]), write_opts);
                                      // assign expression to variable RICC
                                      var_RICC_0d_double_Scalar = py::cast<double>(cpp_current_dict["RICC"]);
                                      aux_RICC_read = true;
                                      validate_vartype_consistency("RICC", SCALAR_DOUBLE, aux_last_type_read_for_RICC);
                                      aux_last_type_read_for_RICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRICC"]), write_opts);
                                      // assign expression to variable dRICC
                                      var_dRICC_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRICC"]);
                                      aux_dRICC_read = true;
                                      validate_vartype_consistency("dRICC", SCALAR_DOUBLE, aux_last_type_read_for_dRICC);
                                      aux_last_type_read_for_dRICC = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RICK"]), write_opts);
                                      // assign expression to variable RICK
                                      var_RICK_0d_double_Scalar = py::cast<double>(cpp_current_dict["RICK"]);
                                      aux_RICK_read = true;
                                      validate_vartype_consistency("RICK", SCALAR_DOUBLE, aux_last_type_read_for_RICK);
                                      aux_last_type_read_for_RICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRICK"]), write_opts);
                                      // assign expression to variable dRICK
                                      var_dRICK_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRICK"]);
                                      aux_dRICK_read = true;
                                      validate_vartype_consistency("dRICK", SCALAR_DOUBLE, aux_last_type_read_for_dRICK);
                                      aux_last_type_read_for_dRICK = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RICL"]), write_opts);
                                      // assign expression to variable RICL
                                      var_RICL_0d_double_Scalar = py::cast<double>(cpp_current_dict["RICL"]);
                                      aux_RICL_read = true;
                                      validate_vartype_consistency("RICL", SCALAR_DOUBLE, aux_last_type_read_for_RICL);
                                      aux_last_type_read_for_RICL = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["dRICL"]), write_opts);
                                      // assign expression to variable dRICL
                                      var_dRICL_0d_double_Scalar = py::cast<double>(cpp_current_dict["dRICL"]);
                                      aux_dRICL_read = true;
                                      validate_vartype_consistency("dRICL", SCALAR_DOUBLE, aux_last_type_read_for_dRICL);
                                      aux_last_type_read_for_dRICL = SCALAR_DOUBLE;
                                      cpp_i++;
                                      cpp_j++;
                                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                        cont << cpp_draft_line;
                                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                        cpp_j = 0;
                                      }
                                      if (cpp_i != cpp_npl) {
                                        throw std::runtime_error("not exactly NPL elements consumed");
                                      }
                                    }
                                    cont << cpp_draft_line;
                                  }
                                }
                              }
                            }
                          }
                          cpp_current_dict = cpp_parent_dict_tmp;
                        }
                      }
                      cpp_current_dict = cpp_parent_dict_tmp;
                    }
                  }
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if ((((((((aux_LCON_read == true)) && ((var_LCON_0d_int_Scalar)!=(0)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section continuous
                    {
                      py::dict cpp_parent_dict_tmp = cpp_current_dict;
                      if ((! cpp_parent_dict_tmp.contains("continuous"))) {
                        cpp_parent_dict_tmp["continuous"] = py::dict();
                      }
                      py::dict cpp_current_dict = cpp_parent_dict_tmp["continuous"];
                      // variable declarations
                      double var_RTYP_0d_double_Scalar;
                      bool aux_RTYP_read = false;
                      vartype aux_last_type_read_for_RTYP = UNKNOWN;
                      std::vector<double> var_Eint_0d_floatvec_Scalar;
                      bool aux_Eint_read = false;
                      vartype aux_last_type_read_for_Eint = UNKNOWN;
                      std::vector<double> var_RP_0d_floatvec_Scalar;
                      bool aux_RP_read = false;
                      vartype aux_last_type_read_for_RP = UNKNOWN;
                      std::vector<int> var_INT_0d_intvec_Scalar;
                      bool aux_INT_read = false;
                      vartype aux_last_type_read_for_INT = UNKNOWN;
                      std::vector<int> var_NBT_0d_intvec_Scalar;
                      bool aux_NBT_read = false;
                      vartype aux_last_type_read_for_NBT = UNKNOWN;
                      cpp_template = "[ MAT , 8 , 457 / RTYP , 0.0 , 0 , 0 , NR , NP / Eint / RP ] TAB1";
                      // read TAB1 record
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["RTYP"]), write_opts);
                      // assign expression to variable RTYP
                      var_RTYP_0d_double_Scalar = py::cast<double>(cpp_current_dict["RTYP"]);
                      aux_RTYP_read = true;
                      validate_vartype_consistency("RTYP", SCALAR_DOUBLE, aux_last_type_read_for_RTYP);
                      aux_last_type_read_for_RTYP = SCALAR_DOUBLE;
                      cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                      cpp_nr_val = py::len(cpp_current_dict["INT"]);
                      cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
                      cpp_np_val = py::len(cpp_current_dict["Eint"]);
                      cont << cpp_draft_line;
                      tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
                      tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["RP"]);
                      tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                      tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                      write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                      {
                        Tab1Body tab_body = tab1_body;
                        // assign expression to variable Eint
                        var_Eint_0d_floatvec_Scalar = tab_body.X;
                        aux_Eint_read = true;
                        validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                        aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                        // assign expression to variable RP
                        var_RP_0d_floatvec_Scalar = tab_body.Y;
                        aux_RP_read = true;
                        validate_vartype_consistency("RP", SCALAR_FLOATVEC, aux_last_type_read_for_RP);
                        aux_last_type_read_for_RP = SCALAR_FLOATVEC;
                        // assign expression to variable INT
                        var_INT_0d_intvec_Scalar = tab_body.INT;
                        aux_INT_read = true;
                        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                        aux_last_type_read_for_INT = SCALAR_INTVEC;
                        // assign expression to variable NBT
                        var_NBT_0d_intvec_Scalar = tab_body.NBT;
                        aux_NBT_read = true;
                        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                        aux_last_type_read_for_NBT = SCALAR_INTVEC;
                      }
                      cont << cpp_draft_line;
                      cpp_current_dict = cpp_parent_dict_tmp;
                    }
                  }
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if ((((((((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(0)))))&&((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(2)))))&&((((aux_LCON_read == true)) && ((var_LCON_0d_int_Scalar)!=(0)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section continuous
                    {
                      py::dict cpp_parent_dict_tmp = cpp_current_dict;
                      if ((! cpp_parent_dict_tmp.contains("continuous"))) {
                        cpp_parent_dict_tmp["continuous"] = py::dict();
                      }
                      py::dict cpp_current_dict = cpp_parent_dict_tmp["continuous"];
                      // variable declarations
                      int cpp_int_val;
                      bool aux_cpp_int_val_read = false;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int var_NPP_0d_int_Scalar;
                      bool aux_NPP_read = false;
                      vartype aux_last_type_read_for_NPP = UNKNOWN;
                      NestedVector<double> var_E_1d_double_NestedVector;
                      vartype aux_last_type_read_for_E = UNKNOWN;
                      NestedVector<double> var_F_1d_double_NestedVector;
                      vartype aux_last_type_read_for_F = UNKNOWN;
                      cpp_template = "[ MAT , 8 , 457 / 0.0 , 0.0 , 0 , 2 , (2*NPP) , NPP / { E , F } { m = 1 to NPP } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read LIST record
                      cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                      cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 3, 2, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NPP"])), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (2*py::cast<int>(cpp_current_dict["NPP"]));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NPP
                      var_NPP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NPP_read = true;
                      validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                      aux_last_type_read_for_NPP = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NPP"]), write_opts);
                      if ((! (aux_NPP_read == true))) {
                        // assign expression to variable NPP
                        var_NPP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NPP"]);
                        aux_NPP_read = true;
                        validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                        aux_last_type_read_for_NPP = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NPP"])), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (2*py::cast<int>(cpp_current_dict["NPP"]));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST body

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NPP_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // read LIST body
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable E
                          var_E_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                          aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable F
                          var_F_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["F"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                          aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                      cpp_current_dict = cpp_parent_dict_tmp;
                    }
                  }
                }
              }
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  if (((((((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(0)))))&&((((aux_LCOV_read == true)) && ((var_LCOV_0d_int_Scalar)!=(1)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    // open section discrete
                    {
                      py::dict cpp_parent_dict_tmp = cpp_current_dict;
                      if ((! cpp_parent_dict_tmp.contains("discrete"))) {
                        cpp_parent_dict_tmp["discrete"] = py::dict();
                      }
                      py::dict cpp_current_dict = cpp_parent_dict_tmp["discrete"];
                      // variable declarations
                      // open section cov
                      {
                        py::dict cpp_parent_dict_tmp = cpp_current_dict;
                        if ((! cpp_parent_dict_tmp.contains("cov"))) {
                          cpp_parent_dict_tmp["cov"] = py::dict();
                        }
                        py::dict cpp_current_dict = cpp_parent_dict_tmp["cov"];
                        // variable declarations
                        int var_LS_0d_int_Scalar;
                        bool aux_LS_read = false;
                        vartype aux_last_type_read_for_LS = UNKNOWN;
                        int var_NE_0d_int_Scalar;
                        bool aux_NE_read = false;
                        vartype aux_last_type_read_for_NE = UNKNOWN;
                        int var_NERP_0d_int_Scalar;
                        bool aux_NERP_read = false;
                        vartype aux_last_type_read_for_NERP = UNKNOWN;
                        NestedVector<double> var_E_1d_double_NestedVector;
                        vartype aux_last_type_read_for_E = UNKNOWN;
                        Matrix2d<double> var_F_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_F = UNKNOWN;
                        cpp_template = "[ MAT , 8 , 457 / 0.0 , 0.0 , LS , 5 , NE , NERP / \n { E } { m = 1 to NERP } , { { F } { n = m to (NERP-2) } } { m = 1 to (NERP-2) } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LS"]), write_opts);
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LS"]);
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, 5, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NE"]), write_opts);
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NERP"]), write_opts);
                        // assign expression to variable NERP
                        var_NERP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NERP"]);
                        aux_NERP_read = true;
                        validate_vartype_consistency("NERP", SCALAR_INT, aux_last_type_read_for_NERP);
                        aux_last_type_read_for_NERP = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NE"]), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = py::cast<int>(cpp_current_dict["NE"]);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= var_NERP_0d_int_Scalar; var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_m_0d_int_Scalar)]));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NERP_0d_int_Scalar-2), 1, (var_NERP_0d_int_Scalar-2), true, false);

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= (var_NERP_0d_int_Scalar-2); var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body

                            for (int var_n_0d_int_Scalar = var_m_0d_int_Scalar;
                               var_n_0d_int_Scalar <= (var_NERP_0d_int_Scalar-2); var_n_0d_int_Scalar++) {
                              bool aux_n_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_m_0d_int_Scalar)][py::cast(var_n_0d_int_Scalar)]), write_opts);
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = py::cast<double>(cpp_current_dict["F"][py::cast(var_m_0d_int_Scalar)][py::cast(var_n_0d_int_Scalar)]);
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                        cpp_current_dict = cpp_parent_dict_tmp;
                      }
                      cpp_current_dict = cpp_parent_dict_tmp;
                    }
                  }
                }
              }
              cpp_current_dict = cpp_parent_dict_tmp;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LIS_0d_int_Scalar = var_LIS_0d_int_Scalar;
            int var_LIS_0d_int_Scalar = glob_var_LIS_0d_int_Scalar;
            bool& glob_aux_LIS_read = aux_LIS_read;
            bool aux_LIS_read = glob_aux_LIS_read;
            vartype aux_last_type_read_for_LIS = UNKNOWN;
            int& glob_var_LISO_0d_int_Scalar = var_LISO_0d_int_Scalar;
            int var_LISO_0d_int_Scalar = glob_var_LISO_0d_int_Scalar;
            bool& glob_aux_LISO_read = aux_LISO_read;
            bool aux_LISO_read = glob_aux_LISO_read;
            vartype aux_last_type_read_for_LISO = UNKNOWN;
            int& glob_var_NST_0d_int_Scalar = var_NST_0d_int_Scalar;
            int var_NST_0d_int_Scalar = glob_var_NST_0d_int_Scalar;
            bool& glob_aux_NST_read = aux_NST_read;
            bool aux_NST_read = glob_aux_NST_read;
            vartype aux_last_type_read_for_NST = UNKNOWN;
            cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , 0 ] HEAD";
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ZA", -99999.9));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AWR", -99999.9));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LIS
            var_LIS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LIS", -99999));
            aux_LIS_read = true;
            validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
            aux_last_type_read_for_LIS = SCALAR_INT;
            // assign expression to variable LISO
            var_LISO_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LISO", -99999));
            aux_LISO_read = true;
            validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
            aux_last_type_read_for_LISO = SCALAR_INT;
            // assign expression to variable NST
            var_NST_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NST", -99999));
            aux_NST_read = true;
            validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
            aux_last_type_read_for_NST = SCALAR_INT;
            if ((((((((aux_NST_read == true)) && ((var_NST_0d_int_Scalar)==(1)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 8 , 457 / ZA , AWR , LIS , LISO , NST , 0 ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read CONT record
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LIS"]), write_opts);
            // assign expression to variable LIS
            var_LIS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LIS"]);
            aux_LIS_read = true;
            validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
            aux_last_type_read_for_LIS = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LISO"]), write_opts);
            // assign expression to variable LISO
            var_LISO_0d_int_Scalar = py::cast<int>(cpp_current_dict["LISO"]);
            aux_LISO_read = true;
            validate_vartype_consistency("LISO", SCALAR_INT, aux_last_type_read_for_LISO);
            aux_last_type_read_for_LISO = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NST"]), write_opts);
            // assign expression to variable NST
            var_NST_0d_int_Scalar = py::cast<int>(cpp_current_dict["NST"]);
            aux_NST_read = true;
            validate_vartype_consistency("NST", SCALAR_INT, aux_last_type_read_for_NST);
            aux_last_type_read_for_NST = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cont << cpp_draft_line;
            cpp_template = "[ MAT , 8 , 457 / 0.0 , 0.0 , 0 , 0 , 6 , 0 / \n 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ] LIST";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read LIST record
            cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
            cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, 6, write_opts);
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cpp_write_field<int>(cpp_draft_line, 4, 6, write_opts);
            cont << cpp_draft_line;
            {
              int cpp_npl = 6;
              int cpp_i = 0;
              int cpp_j = 0;
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read LIST body
              cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
              cpp_i++;
              cpp_j++;
              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                cont << cpp_draft_line;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_j = 0;
              }
              if (cpp_i != cpp_npl) {
                throw std::runtime_error("not exactly NPL elements consumed");
              }
            }
            cont << cpp_draft_line;
            // evaluate if-elif-else clause
            {
              bool cpp_found_match = false;
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
                    int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
                    bool& glob_aux_MAT_read = aux_MAT_read;
                    bool aux_MAT_read = glob_aux_MAT_read;
                    vartype aux_last_type_read_for_MAT = UNKNOWN;
                    int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
                    int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
                    bool& glob_aux_MF_read = aux_MF_read;
                    bool aux_MF_read = glob_aux_MF_read;
                    vartype aux_last_type_read_for_MF = UNKNOWN;
                    int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
                    int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
                    bool& glob_aux_MT_read = aux_MT_read;
                    bool aux_MT_read = glob_aux_MT_read;
                    vartype aux_last_type_read_for_MT = UNKNOWN;
                    double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
                    double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
                    bool& glob_aux_ZA_read = aux_ZA_read;
                    bool aux_ZA_read = glob_aux_ZA_read;
                    vartype aux_last_type_read_for_ZA = UNKNOWN;
                    double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
                    double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
                    bool& glob_aux_AWR_read = aux_AWR_read;
                    bool aux_AWR_read = glob_aux_AWR_read;
                    vartype aux_last_type_read_for_AWR = UNKNOWN;
                    int& glob_var_LIS_0d_int_Scalar = var_LIS_0d_int_Scalar;
                    int var_LIS_0d_int_Scalar = glob_var_LIS_0d_int_Scalar;
                    bool& glob_aux_LIS_read = aux_LIS_read;
                    bool aux_LIS_read = glob_aux_LIS_read;
                    vartype aux_last_type_read_for_LIS = UNKNOWN;
                    int& glob_var_LISO_0d_int_Scalar = var_LISO_0d_int_Scalar;
                    int var_LISO_0d_int_Scalar = glob_var_LISO_0d_int_Scalar;
                    bool& glob_aux_LISO_read = aux_LISO_read;
                    bool aux_LISO_read = glob_aux_LISO_read;
                    vartype aux_last_type_read_for_LISO = UNKNOWN;
                    int& glob_var_NST_0d_int_Scalar = var_NST_0d_int_Scalar;
                    int var_NST_0d_int_Scalar = glob_var_NST_0d_int_Scalar;
                    bool& glob_aux_NST_read = aux_NST_read;
                    bool aux_NST_read = glob_aux_NST_read;
                    vartype aux_last_type_read_for_NST = UNKNOWN;
                    double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    double& glob_var_PAR_0d_double_Scalar = var_PAR_0d_double_Scalar;
                    double var_PAR_0d_double_Scalar = glob_var_PAR_0d_double_Scalar;
                    bool& glob_aux_PAR_read = aux_PAR_read;
                    bool aux_PAR_read = glob_aux_PAR_read;
                    vartype aux_last_type_read_for_PAR = UNKNOWN;
                    int& glob_var_JENDL_LIST_NPL_0d_int_Scalar = var_JENDL_LIST_NPL_0d_int_Scalar;
                    int var_JENDL_LIST_NPL_0d_int_Scalar = glob_var_JENDL_LIST_NPL_0d_int_Scalar;
                    bool& glob_aux_JENDL_LIST_NPL_read = aux_JENDL_LIST_NPL_read;
                    bool aux_JENDL_LIST_NPL_read = glob_aux_JENDL_LIST_NPL_read;
                    vartype aux_last_type_read_for_JENDL_LIST_NPL = UNKNOWN;
                    cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , JENDL_LIST_NPL , 0 / \n { 0.0 } { k = 1 to JENDL_LIST_NPL } ] LIST";
                    // read LIST record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("SPI", -99999.9));
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable PAR
                    var_PAR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("PAR", -99999.9));
                    aux_PAR_read = true;
                    validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
                    aux_last_type_read_for_PAR = SCALAR_DOUBLE;
                    // assign expression to variable JENDL_LIST_NPL
                    var_JENDL_LIST_NPL_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("JENDL_LIST_NPL", -99999));
                    aux_JENDL_LIST_NPL_read = true;
                    validate_vartype_consistency("JENDL_LIST_NPL", SCALAR_INT, aux_last_type_read_for_JENDL_LIST_NPL);
                    aux_last_type_read_for_JENDL_LIST_NPL = SCALAR_INT;
                    if ((((((((aux_JENDL_LIST_NPL_read == true)) && ((var_JENDL_LIST_NPL_0d_int_Scalar)!=(6)))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , JENDL_LIST_NPL , 0 / \n { 0.0 } { k = 1 to JENDL_LIST_NPL } ] LIST";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read LIST record
                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["PAR"]), write_opts);
                    // assign expression to variable PAR
                    var_PAR_0d_double_Scalar = py::cast<double>(cpp_current_dict["PAR"]);
                    aux_PAR_read = true;
                    validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
                    aux_last_type_read_for_PAR = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["JENDL_LIST_NPL"]), write_opts);
                    // assign expression to variable JENDL_LIST_NPL
                    var_JENDL_LIST_NPL_0d_int_Scalar = py::cast<int>(cpp_current_dict["JENDL_LIST_NPL"]);
                    aux_JENDL_LIST_NPL_read = true;
                    validate_vartype_consistency("JENDL_LIST_NPL", SCALAR_INT, aux_last_type_read_for_JENDL_LIST_NPL);
                    aux_last_type_read_for_JENDL_LIST_NPL = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["JENDL_LIST_NPL"]), write_opts);
                    cont << cpp_draft_line;
                    {
                      int cpp_npl = py::cast<int>(cpp_current_dict["JENDL_LIST_NPL"]);
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_JENDL_LIST_NPL_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cont << cpp_draft_line;
                  }
                }
              }
              if (! cpp_found_match) {
                cpp_template = "[ MAT , 8 , 457 / SPI , PAR , 0 , 0 , 6 , 0 / \n 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ] LIST";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                // read LIST record
                cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                // assign expression to variable SPI
                var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                aux_SPI_read = true;
                validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["PAR"]), write_opts);
                // assign expression to variable PAR
                var_PAR_0d_double_Scalar = py::cast<double>(cpp_current_dict["PAR"]);
                aux_PAR_read = true;
                validate_vartype_consistency("PAR", SCALAR_DOUBLE, aux_last_type_read_for_PAR);
                aux_last_type_read_for_PAR = SCALAR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, 6, write_opts);
                cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, 6, write_opts);
                cont << cpp_draft_line;
                {
                  int cpp_npl = 6;
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  // read LIST body
                  cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    cpp_j = 0;
                  }
                  cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    cpp_j = 0;
                  }
                  cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    cpp_j = 0;
                  }
                  cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    cpp_j = 0;
                  }
                  cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    cpp_j = 0;
                  }
                  cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    cpp_j = 0;
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
                cont << cpp_draft_line;
              }
            }
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 9b44a8a45cec90ea92aa701b596f413f
// MD5 hash of the following function definition: a6aeebda8d0df2ff6a0bb5834cd37043
void write_mf8mt459_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_LE_0d_int_Scalar;
  bool aux_LE_read = false;
  vartype aux_last_type_read_for_LE = UNKNOWN;
  NestedVector<double> var_E_1d_double_NestedVector;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<int> var_NN_1d_int_NestedVector;
  vartype aux_last_type_read_for_NN = UNKNOWN;
  NestedVector<int> var_NFP_1d_int_NestedVector;
  vartype aux_last_type_read_for_NFP = UNKNOWN;
  NestedVector<NestedVector<double>> var_ZAFP_2d_double_NestedVector;
  NestedVector<double>* ptr_ZAFP_2d_idx0;
  vartype aux_last_type_read_for_ZAFP = UNKNOWN;
  NestedVector<NestedVector<double>> var_FPS_2d_double_NestedVector;
  NestedVector<double>* ptr_FPS_2d_idx0;
  vartype aux_last_type_read_for_FPS = UNKNOWN;
  NestedVector<NestedVector<double>> var_YC_2d_double_NestedVector;
  NestedVector<double>* ptr_YC_2d_idx0;
  vartype aux_last_type_read_for_YC = UNKNOWN;
  NestedVector<NestedVector<double>> var_DYC_2d_double_NestedVector;
  NestedVector<double>* ptr_DYC_2d_idx0;
  vartype aux_last_type_read_for_DYC = UNKNOWN;
  NestedVector<int> var_I_1d_int_NestedVector;
  vartype aux_last_type_read_for_I = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 8;
  int mt = 459;
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 8;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = 459;
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 8 , MT / ZA , AWR , (LE+1) , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, (py::cast<int>(cpp_current_dict["LE"])+1), write_opts);
  // assign expression to variable cpp_int_val
  cpp_int_val = (py::cast<int>(cpp_current_dict["LE"])+1);
  aux_cpp_int_val_read = true;
  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
  // assign expression to variable LE
  var_LE_0d_int_Scalar = (cpp_int_val+(-1));
  aux_LE_read = true;
  validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
  aux_last_type_read_for_LE = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 8 , MT / E , 0.0 , LE , 0 , NN , NFP / \n { ZAFP , FPS , YC , DYC } { m = 1 to NFP } ] LIST";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read LIST record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["E"][py::cast(0)]), write_opts);
  // assign expression to variable E
  var_E_1d_double_NestedVector.set(0, py::cast<double>(cpp_current_dict["E"][py::cast(0)]));
  validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
  aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LE"]), write_opts);
  if ((! (aux_LE_read == true))) {
    // assign expression to variable LE
    var_LE_0d_int_Scalar = py::cast<int>(cpp_current_dict["LE"]);
    aux_LE_read = true;
    validate_vartype_consistency("LE", SCALAR_INT, aux_last_type_read_for_LE);
    aux_last_type_read_for_LE = SCALAR_INT;
  } else {
  }
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NN"][py::cast(0)]), write_opts);
  // assign expression to variable NN
  var_NN_1d_int_NestedVector.set(0, py::cast<int>(cpp_current_dict["NN"][py::cast(0)]));
  validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
  aux_last_type_read_for_NN = NESTEDVECTOR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NFP"][py::cast(0)]), write_opts);
  // assign expression to variable NFP
  var_NFP_1d_int_NestedVector.set(0, py::cast<int>(cpp_current_dict["NFP"][py::cast(0)]));
  validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
  aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NN"][py::cast(0)]), write_opts);
  cont << cpp_draft_line;
  {
    int cpp_npl = py::cast<int>(cpp_current_dict["NN"][py::cast(0)]);
    int cpp_i = 0;
    int cpp_j = 0;
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
    // read LIST body
    ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(0);
    ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(0);
    ptr_YC_2d_idx0 = var_YC_2d_double_NestedVector.prepare(0);
    ptr_DYC_2d_idx0 = var_DYC_2d_double_NestedVector.prepare(0);

    for (int var_m_0d_int_Scalar = 1;
       var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[0]; var_m_0d_int_Scalar++) {
      bool aux_m_read = true;
      // read LIST body
      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ZAFP"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]), write_opts);
      // assign expression to variable ZAFP
      ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["ZAFP"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]));
      validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
      aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_j = 0;
      }
      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["FPS"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]), write_opts);
      // assign expression to variable FPS
      ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["FPS"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]));
      validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
      aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_j = 0;
      }
      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["YC"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]), write_opts);
      // assign expression to variable YC
      ptr_YC_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["YC"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]));
      validate_vartype_consistency("YC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YC);
      aux_last_type_read_for_YC = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_j = 0;
      }
      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DYC"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]), write_opts);
      // assign expression to variable DYC
      ptr_DYC_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DYC"][py::cast(0)][py::cast(var_m_0d_int_Scalar)]));
      validate_vartype_consistency("DYC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYC);
      aux_last_type_read_for_DYC = NESTEDVECTOR_DOUBLE;
      cpp_i++;
      cpp_j++;
      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
        cont << cpp_draft_line;
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_j = 0;
      }
    }
    if (cpp_i != cpp_npl) {
      throw std::runtime_error("not exactly NPL elements consumed");
    }
  }
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_LE_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    cpp_template = "[ MAT , 8 , MT / E , 0.0 , I , 0 , NN , NFP / \n { ZAFP , FPS , YC , DYC } { m = 1 to NFP } ] LIST";
    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
    // read LIST record
    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]), write_opts);
    if ((! var_E_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable E
      var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]));
      validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
      aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
    } else {
    }
    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["I"][py::cast(var_k_0d_int_Scalar)]), write_opts);
    // assign expression to variable I
    var_I_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["I"][py::cast(var_k_0d_int_Scalar)]));
    validate_vartype_consistency("I", NESTEDVECTOR_INT, aux_last_type_read_for_I);
    aux_last_type_read_for_I = NESTEDVECTOR_INT;
    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NN"][py::cast(var_k_0d_int_Scalar)]), write_opts);
    if ((! var_NN_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NN
      var_NN_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["NN"][py::cast(var_k_0d_int_Scalar)]));
      validate_vartype_consistency("NN", NESTEDVECTOR_INT, aux_last_type_read_for_NN);
      aux_last_type_read_for_NN = NESTEDVECTOR_INT;
    } else {
    }
    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NFP"][py::cast(var_k_0d_int_Scalar)]), write_opts);
    if ((! var_NFP_1d_int_NestedVector.contains(var_k_0d_int_Scalar))) {
      // assign expression to variable NFP
      var_NFP_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["NFP"][py::cast(var_k_0d_int_Scalar)]));
      validate_vartype_consistency("NFP", NESTEDVECTOR_INT, aux_last_type_read_for_NFP);
      aux_last_type_read_for_NFP = NESTEDVECTOR_INT;
    } else {
    }
    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NN"][py::cast(var_k_0d_int_Scalar)]), write_opts);
    cont << cpp_draft_line;
    {
      int cpp_npl = py::cast<int>(cpp_current_dict["NN"][py::cast(var_k_0d_int_Scalar)]);
      int cpp_i = 0;
      int cpp_j = 0;
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
      // read LIST body
      ptr_ZAFP_2d_idx0 = var_ZAFP_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_FPS_2d_idx0 = var_FPS_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_YC_2d_idx0 = var_YC_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
      ptr_DYC_2d_idx0 = var_DYC_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);

      for (int var_m_0d_int_Scalar = 1;
         var_m_0d_int_Scalar <= var_NFP_1d_int_NestedVector[var_k_0d_int_Scalar]; var_m_0d_int_Scalar++) {
        bool aux_m_read = true;
        // read LIST body
        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ZAFP"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
        if ((! (var_ZAFP_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_ZAFP_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable ZAFP
          ptr_ZAFP_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["ZAFP"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
          validate_vartype_consistency("ZAFP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZAFP);
          aux_last_type_read_for_ZAFP = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["FPS"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
        if ((! (var_FPS_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_FPS_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable FPS
          ptr_FPS_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["FPS"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
          validate_vartype_consistency("FPS", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_FPS);
          aux_last_type_read_for_FPS = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["YC"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
        if ((! (var_YC_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_YC_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable YC
          ptr_YC_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["YC"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
          validate_vartype_consistency("YC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_YC);
          aux_last_type_read_for_YC = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DYC"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
        if ((! (var_DYC_2d_double_NestedVector.contains(var_k_0d_int_Scalar) && var_DYC_2d_double_NestedVector[var_k_0d_int_Scalar].contains(var_m_0d_int_Scalar)))) {
          // assign expression to variable DYC
          ptr_DYC_2d_idx0->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DYC"][py::cast(var_k_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
          validate_vartype_consistency("DYC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DYC);
          aux_last_type_read_for_DYC = NESTEDVECTOR_DOUBLE;
        } else {
        }
        cpp_i++;
        cpp_j++;
        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
          cont << cpp_draft_line;
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          cpp_j = 0;
        }
      }
      if (cpp_i != cpp_npl) {
        throw std::runtime_error("not exactly NPL elements consumed");
      }
    }
    cont << cpp_draft_line;
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 1db3e473b7f130d4f0683e6401196b22
// MD5 hash of the following function definition: d3a2ad4d829ab7adb027d77ea5da25e6
void write_mf9_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 9;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 9;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 9 , MT / ZA , AWR , LIS , 0 , NS , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LIS"]), write_opts);
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LIS"]);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NS"]), write_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NS"]);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict_tmp = cpp_current_dict;
      if ((! cpp_parent_dict_tmp.contains("subsection"))) {
        cpp_parent_dict_tmp["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict_tmp["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      double var_QM_0d_double_Scalar;
      bool aux_QM_read = false;
      vartype aux_last_type_read_for_QM = UNKNOWN;
      double var_QI_0d_double_Scalar;
      bool aux_QI_read = false;
      vartype aux_last_type_read_for_QI = UNKNOWN;
      int var_IZAP_0d_int_Scalar;
      bool aux_IZAP_read = false;
      vartype aux_last_type_read_for_IZAP = UNKNOWN;
      int var_LFS_0d_int_Scalar;
      bool aux_LFS_read = false;
      vartype aux_last_type_read_for_LFS = UNKNOWN;
      std::vector<double> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      vartype aux_last_type_read_for_E = UNKNOWN;
      std::vector<double> var_Y_0d_floatvec_Scalar;
      bool aux_Y_read = false;
      vartype aux_last_type_read_for_Y = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      cpp_template = "[ MAT , 9 , MT / QM , QI , IZAP , LFS , NR , NP / E / Y ] TAB1";
      // read TAB1 record
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["QM"]), write_opts);
      // assign expression to variable QM
      var_QM_0d_double_Scalar = py::cast<double>(cpp_current_dict["QM"]);
      aux_QM_read = true;
      validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
      aux_last_type_read_for_QM = SCALAR_DOUBLE;
      cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["QI"]), write_opts);
      // assign expression to variable QI
      var_QI_0d_double_Scalar = py::cast<double>(cpp_current_dict["QI"]);
      aux_QI_read = true;
      validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
      aux_last_type_read_for_QI = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["IZAP"]), write_opts);
      // assign expression to variable IZAP
      var_IZAP_0d_int_Scalar = py::cast<int>(cpp_current_dict["IZAP"]);
      aux_IZAP_read = true;
      validate_vartype_consistency("IZAP", SCALAR_INT, aux_last_type_read_for_IZAP);
      aux_last_type_read_for_IZAP = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LFS"]), write_opts);
      // assign expression to variable LFS
      var_LFS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LFS"]);
      aux_LFS_read = true;
      validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
      aux_last_type_read_for_LFS = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
      cpp_nr_val = py::len(cpp_current_dict["INT"]);
      cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
      cpp_np_val = py::len(cpp_current_dict["E"]);
      cont << cpp_draft_line;
      tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
      tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["Y"]);
      tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
      tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
      write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
      {
        Tab1Body tab_body = tab1_body;
        // assign expression to variable E
        var_E_0d_floatvec_Scalar = tab_body.X;
        aux_E_read = true;
        validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
        aux_last_type_read_for_E = SCALAR_FLOATVEC;
        // assign expression to variable Y
        var_Y_0d_floatvec_Scalar = tab_body.Y;
        aux_Y_read = true;
        validate_vartype_consistency("Y", SCALAR_FLOATVEC, aux_last_type_read_for_Y);
        aux_last_type_read_for_Y = SCALAR_FLOATVEC;
        // assign expression to variable INT
        var_INT_0d_intvec_Scalar = tab_body.INT;
        aux_INT_read = true;
        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
        aux_last_type_read_for_INT = SCALAR_INTVEC;
        // assign expression to variable NBT
        var_NBT_0d_intvec_Scalar = tab_body.NBT;
        aux_NBT_read = true;
        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
        aux_last_type_read_for_NBT = SCALAR_INTVEC;
      }
      cont << cpp_draft_line;
      cpp_current_dict = cpp_parent_dict_tmp;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: b5ce883fcd2a78e1dee22fd8e5f23c84
// MD5 hash of the following function definition: 2e25f6a4b2080f5abd3f8aac593286b1
void write_mf10_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 10;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 10;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 10 , MT / ZA , AWR , LIS , 0 , NS , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LIS"]), write_opts);
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LIS"]);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NS"]), write_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NS"]);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict_tmp = cpp_current_dict;
      if ((! cpp_parent_dict_tmp.contains("subsection"))) {
        cpp_parent_dict_tmp["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict_tmp["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      double var_QM_0d_double_Scalar;
      bool aux_QM_read = false;
      vartype aux_last_type_read_for_QM = UNKNOWN;
      double var_QI_0d_double_Scalar;
      bool aux_QI_read = false;
      vartype aux_last_type_read_for_QI = UNKNOWN;
      int var_IZAP_0d_int_Scalar;
      bool aux_IZAP_read = false;
      vartype aux_last_type_read_for_IZAP = UNKNOWN;
      int var_LFS_0d_int_Scalar;
      bool aux_LFS_read = false;
      vartype aux_last_type_read_for_LFS = UNKNOWN;
      std::vector<double> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      vartype aux_last_type_read_for_E = UNKNOWN;
      std::vector<double> var_sigma_0d_floatvec_Scalar;
      bool aux_sigma_read = false;
      vartype aux_last_type_read_for_sigma = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      cpp_template = "[ MAT , 10 , MT / QM , QI , IZAP , LFS , NR , NP / E / sigma ] TAB1";
      // read TAB1 record
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["QM"]), write_opts);
      // assign expression to variable QM
      var_QM_0d_double_Scalar = py::cast<double>(cpp_current_dict["QM"]);
      aux_QM_read = true;
      validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
      aux_last_type_read_for_QM = SCALAR_DOUBLE;
      cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["QI"]), write_opts);
      // assign expression to variable QI
      var_QI_0d_double_Scalar = py::cast<double>(cpp_current_dict["QI"]);
      aux_QI_read = true;
      validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
      aux_last_type_read_for_QI = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["IZAP"]), write_opts);
      // assign expression to variable IZAP
      var_IZAP_0d_int_Scalar = py::cast<int>(cpp_current_dict["IZAP"]);
      aux_IZAP_read = true;
      validate_vartype_consistency("IZAP", SCALAR_INT, aux_last_type_read_for_IZAP);
      aux_last_type_read_for_IZAP = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LFS"]), write_opts);
      // assign expression to variable LFS
      var_LFS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LFS"]);
      aux_LFS_read = true;
      validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
      aux_last_type_read_for_LFS = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
      cpp_nr_val = py::len(cpp_current_dict["INT"]);
      cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
      cpp_np_val = py::len(cpp_current_dict["E"]);
      cont << cpp_draft_line;
      tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
      tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["sigma"]);
      tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
      tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
      write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
      {
        Tab1Body tab_body = tab1_body;
        // assign expression to variable E
        var_E_0d_floatvec_Scalar = tab_body.X;
        aux_E_read = true;
        validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
        aux_last_type_read_for_E = SCALAR_FLOATVEC;
        // assign expression to variable sigma
        var_sigma_0d_floatvec_Scalar = tab_body.Y;
        aux_sigma_read = true;
        validate_vartype_consistency("sigma", SCALAR_FLOATVEC, aux_last_type_read_for_sigma);
        aux_last_type_read_for_sigma = SCALAR_FLOATVEC;
        // assign expression to variable INT
        var_INT_0d_intvec_Scalar = tab_body.INT;
        aux_INT_read = true;
        validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
        aux_last_type_read_for_INT = SCALAR_INTVEC;
        // assign expression to variable NBT
        var_NBT_0d_intvec_Scalar = tab_body.NBT;
        aux_NBT_read = true;
        validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
        aux_last_type_read_for_NBT = SCALAR_INTVEC;
      }
      cont << cpp_draft_line;
      cpp_current_dict = cpp_parent_dict_tmp;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: e54487563cbd4b212af001ef1d061333
// MD5 hash of the following function definition: 8f50b70ce818f451ecb5cc1ae24be38c
void write_mf12_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LO_0d_int_Scalar;
  bool aux_LO_read = false;
  vartype aux_last_type_read_for_LO = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::vector<double> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<double> var_Y_0d_floatvec_Scalar;
  bool aux_Y_read = false;
  vartype aux_last_type_read_for_Y = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  NestedVector<double> var_Eg_1d_double_NestedVector;
  vartype aux_last_type_read_for_Eg = UNKNOWN;
  NestedVector<double> var_ES_1d_double_NestedVector;
  vartype aux_last_type_read_for_ES = UNKNOWN;
  NestedVector<int> var_LP_1d_int_NestedVector;
  vartype aux_last_type_read_for_LP = UNKNOWN;
  NestedVector<int> var_LF_1d_int_NestedVector;
  vartype aux_last_type_read_for_LF = UNKNOWN;
  int var_LG_0d_int_Scalar;
  bool aux_LG_read = false;
  vartype aux_last_type_read_for_LG = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  double var_ES_NS_0d_double_Scalar;
  bool aux_ES_NS_read = false;
  vartype aux_last_type_read_for_ES_NS = UNKNOWN;
  int var_LP_0d_int_Scalar;
  bool aux_LP_read = false;
  int cpp_int_val;
  bool aux_cpp_int_val_read = false;
  vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
  int var_NT_0d_int_Scalar;
  bool aux_NT_read = false;
  vartype aux_last_type_read_for_NT = UNKNOWN;
  NestedVector<double> var_TP_1d_double_NestedVector;
  vartype aux_last_type_read_for_TP = UNKNOWN;
  NestedVector<double> var_GP_1d_double_NestedVector;
  vartype aux_last_type_read_for_GP = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 12;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 12;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
          int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
          bool& glob_aux_LO_read = aux_LO_read;
          bool aux_LO_read = glob_aux_LO_read;
          vartype aux_last_type_read_for_LO = UNKNOWN;
          int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
          int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
          bool& glob_aux_NK_read = aux_NK_read;
          bool aux_NK_read = glob_aux_NK_read;
          vartype aux_last_type_read_for_NK = UNKNOWN;
          cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , 0 , NK , 0 ] HEAD";
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ZA", -99999.9));
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AWR", -99999.9));
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LO
          var_LO_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LO", -99999));
          aux_LO_read = true;
          validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
          aux_last_type_read_for_LO = SCALAR_INT;
          // assign expression to variable NK
          var_NK_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NK", -99999));
          aux_NK_read = true;
          validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
          aux_last_type_read_for_NK = SCALAR_INT;
          if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(1)))))))) {
            cpp_found_match = true;
          }
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , 0 , NK , 0 ] HEAD";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read CONT record
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LO"]), write_opts);
          // assign expression to variable LO
          var_LO_0d_int_Scalar = py::cast<int>(cpp_current_dict["LO"]);
          aux_LO_read = true;
          validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
          aux_last_type_read_for_LO = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NK"]), write_opts);
          // assign expression to variable NK
          var_NK_0d_int_Scalar = py::cast<int>(cpp_current_dict["NK"]);
          aux_NK_read = true;
          validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
          aux_last_type_read_for_NK = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cont << cpp_draft_line;
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((aux_NK_read == true)) && ((var_NK_0d_int_Scalar)>(1)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                cpp_template = "[ MAT , 12 , MT / 0.0 , 0.0 , 0 , 0 , NR , NP / Eint / Y ] TAB1";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                cpp_nr_val = py::len(cpp_current_dict["INT"]);
                cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
                cpp_np_val = py::len(cpp_current_dict["Eint"]);
                cont << cpp_draft_line;
                tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
                tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["Y"]);
                tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                {
                  Tab1Body tab_body = tab1_body;
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                  // assign expression to variable Y
                  var_Y_0d_floatvec_Scalar = tab_body.Y;
                  aux_Y_read = true;
                  validate_vartype_consistency("Y", SCALAR_FLOATVEC, aux_last_type_read_for_Y);
                  aux_last_type_read_for_Y = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
              }
            }
          }

          for (int var_k_0d_int_Scalar = 1;
             var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
            bool aux_k_read = true;
            cpp_template = "[ MAT , 12 , MT / Eg , ES , LP , LF , NR , NP / Eint / y ] TAB1 ( table [ k ] )";
            // read TAB1 record
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["Eg"][py::cast(var_k_0d_int_Scalar)]), write_opts);
            // assign expression to variable Eg
            var_Eg_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["Eg"][py::cast(var_k_0d_int_Scalar)]));
            validate_vartype_consistency("Eg", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Eg);
            aux_last_type_read_for_Eg = NESTEDVECTOR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["ES"][py::cast(var_k_0d_int_Scalar)]), write_opts);
            // assign expression to variable ES
            var_ES_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ES"][py::cast(var_k_0d_int_Scalar)]));
            validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
            aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LP"][py::cast(var_k_0d_int_Scalar)]), write_opts);
            // assign expression to variable LP
            var_LP_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["LP"][py::cast(var_k_0d_int_Scalar)]));
            validate_vartype_consistency("LP", NESTEDVECTOR_INT, aux_last_type_read_for_LP);
            aux_last_type_read_for_LP = NESTEDVECTOR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LF"][py::cast(var_k_0d_int_Scalar)]), write_opts);
            // assign expression to variable LF
            var_LF_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["LF"][py::cast(var_k_0d_int_Scalar)]));
            validate_vartype_consistency("LF", NESTEDVECTOR_INT, aux_last_type_read_for_LF);
            aux_last_type_read_for_LF = NESTEDVECTOR_INT;
            {
              py::dict cpp_parent_dict_tmp = cpp_current_dict;
              if ((! cpp_parent_dict_tmp.contains("table"))) {
                cpp_parent_dict_tmp["table"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict_tmp["table"];
              if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
              cpp_nr_val = py::len(cpp_current_dict["INT"]);
              cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
              cpp_np_val = py::len(cpp_current_dict["Eint"]);
              cont << cpp_draft_line;
              tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
              tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["y"]);
              tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
              tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
              write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
              // variable declarations
              std::vector<double> var_Eint_0d_floatvec_Scalar;
              bool aux_Eint_read = false;
              vartype aux_last_type_read_for_Eint = UNKNOWN;
              std::vector<double> var_y_0d_floatvec_Scalar;
              bool aux_y_read = false;
              vartype aux_last_type_read_for_y = UNKNOWN;
              std::vector<int> var_INT_0d_intvec_Scalar;
              bool aux_INT_read = false;
              vartype aux_last_type_read_for_INT = UNKNOWN;
              std::vector<int> var_NBT_0d_intvec_Scalar;
              bool aux_NBT_read = false;
              vartype aux_last_type_read_for_NBT = UNKNOWN;
              {
                Tab1Body tab_body = tab1_body;
                if ((! (aux_Eint_read == true))) {
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                } else {
                }
                // assign expression to variable y
                var_y_0d_floatvec_Scalar = tab_body.Y;
                aux_y_read = true;
                validate_vartype_consistency("y", SCALAR_FLOATVEC, aux_last_type_read_for_y);
                aux_last_type_read_for_y = SCALAR_FLOATVEC;
                if ((! (aux_INT_read == true))) {
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                } else {
                }
                if ((! (aux_NBT_read == true))) {
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                } else {
                }
              }
              cont << cpp_draft_line;
              cpp_current_dict = cpp_parent_dict_tmp;
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LO_0d_int_Scalar = var_LO_0d_int_Scalar;
            int var_LO_0d_int_Scalar = glob_var_LO_0d_int_Scalar;
            bool& glob_aux_LO_read = aux_LO_read;
            bool aux_LO_read = glob_aux_LO_read;
            vartype aux_last_type_read_for_LO = UNKNOWN;
            int& glob_var_LG_0d_int_Scalar = var_LG_0d_int_Scalar;
            int var_LG_0d_int_Scalar = glob_var_LG_0d_int_Scalar;
            bool& glob_aux_LG_read = aux_LG_read;
            bool aux_LG_read = glob_aux_LG_read;
            vartype aux_last_type_read_for_LG = UNKNOWN;
            int& glob_var_NS_0d_int_Scalar = var_NS_0d_int_Scalar;
            int var_NS_0d_int_Scalar = glob_var_NS_0d_int_Scalar;
            bool& glob_aux_NS_read = aux_NS_read;
            bool aux_NS_read = glob_aux_NS_read;
            vartype aux_last_type_read_for_NS = UNKNOWN;
            cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , LG , NS , 0 ] HEAD";
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ZA", -99999.9));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AWR", -99999.9));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LO
            var_LO_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LO", -99999));
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            // assign expression to variable LG
            var_LG_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LG", -99999));
            aux_LG_read = true;
            validate_vartype_consistency("LG", SCALAR_INT, aux_last_type_read_for_LG);
            aux_last_type_read_for_LG = SCALAR_INT;
            // assign expression to variable NS
            var_NS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NS", -99999));
            aux_NS_read = true;
            validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
            aux_last_type_read_for_NS = SCALAR_INT;
            if ((((((((aux_LO_read == true)) && ((var_LO_0d_int_Scalar)==(2)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 12 , MT / ZA , AWR , LO , LG , NS , 0 ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read CONT record
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LO"]), write_opts);
            // assign expression to variable LO
            var_LO_0d_int_Scalar = py::cast<int>(cpp_current_dict["LO"]);
            aux_LO_read = true;
            validate_vartype_consistency("LO", SCALAR_INT, aux_last_type_read_for_LO);
            aux_last_type_read_for_LO = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LG"]), write_opts);
            // assign expression to variable LG
            var_LG_0d_int_Scalar = py::cast<int>(cpp_current_dict["LG"]);
            aux_LG_read = true;
            validate_vartype_consistency("LG", SCALAR_INT, aux_last_type_read_for_LG);
            aux_last_type_read_for_LG = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NS"]), write_opts);
            // assign expression to variable NS
            var_NS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NS"]);
            aux_NS_read = true;
            validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
            aux_last_type_read_for_NS = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
            cont << cpp_draft_line;
            // evaluate if-elif-else clause
            {
              bool cpp_found_match = false;
              if (! cpp_found_match) {
                if ((((((((aux_LG_read == true)) && ((var_LG_0d_int_Scalar)==(1)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  cpp_template = "[ MAT , 12 , MT / ES_NS , 0.0 , LP , 0 , (2*NT) , NT / \n { ES , TP } { i = 1 to NT } ] LIST";
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  // read LIST record
                  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ES_NS"]), write_opts);
                  // assign expression to variable ES_NS
                  var_ES_NS_0d_double_Scalar = py::cast<double>(cpp_current_dict["ES_NS"]);
                  aux_ES_NS_read = true;
                  validate_vartype_consistency("ES_NS", SCALAR_DOUBLE, aux_last_type_read_for_ES_NS);
                  aux_last_type_read_for_ES_NS = SCALAR_DOUBLE;
                  cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LP"]), write_opts);
                  // assign expression to variable LP
                  var_LP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LP"]);
                  aux_LP_read = true;
                  validate_vartype_consistency("LP", SCALAR_INT, aux_last_type_read_for_LP);
                  aux_last_type_read_for_LP = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NT"])), write_opts);
                  // assign expression to variable cpp_int_val
                  cpp_int_val = (2*py::cast<int>(cpp_current_dict["NT"]));
                  aux_cpp_int_val_read = true;
                  validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                  aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                  // assign expression to variable NT
                  var_NT_0d_int_Scalar = (cpp_int_val/2);
                  aux_NT_read = true;
                  validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                  aux_last_type_read_for_NT = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                  if ((! (aux_NT_read == true))) {
                    // assign expression to variable NT
                    var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NT"]);
                    aux_NT_read = true;
                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                    aux_last_type_read_for_NT = SCALAR_INT;
                  } else {
                  }
                  cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NT"])), write_opts);
                  cont << cpp_draft_line;
                  {
                    int cpp_npl = (2*py::cast<int>(cpp_current_dict["NT"]));
                    int cpp_i = 0;
                    int cpp_j = 0;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read LIST body

                    for (int var_i_0d_int_Scalar = 1;
                       var_i_0d_int_Scalar <= var_NT_0d_int_Scalar; var_i_0d_int_Scalar++) {
                      bool aux_i_read = true;
                      // read LIST body
                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ES"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                      // assign expression to variable ES
                      var_ES_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["ES"][py::cast(var_i_0d_int_Scalar)]));
                      validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                      aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                      cpp_i++;
                      cpp_j++;
                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                        cont << cpp_draft_line;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        cpp_j = 0;
                      }
                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["TP"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                      // assign expression to variable TP
                      var_TP_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["TP"][py::cast(var_i_0d_int_Scalar)]));
                      validate_vartype_consistency("TP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_TP);
                      aux_last_type_read_for_TP = NESTEDVECTOR_DOUBLE;
                      cpp_i++;
                      cpp_j++;
                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                        cont << cpp_draft_line;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        cpp_j = 0;
                      }
                    }
                    if (cpp_i != cpp_npl) {
                      throw std::runtime_error("not exactly NPL elements consumed");
                    }
                  }
                  cont << cpp_draft_line;
                }
              }
              if (! cpp_found_match) {
                if (! cpp_found_match) {
                  if ((((((((aux_LG_read == true)) && ((var_LG_0d_int_Scalar)==(2)))))))) {
                    // if statement evaluation
                    cpp_found_match = true;
                    cpp_template = "[ MAT , 12 , MT / ES_NS , 0.0 , LP , 0 , ((LG+1)*NT) , NT / \n { ES , TP , GP } { i = 1 to NT } ] LIST";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read LIST record
                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ES_NS"]), write_opts);
                    // assign expression to variable ES_NS
                    var_ES_NS_0d_double_Scalar = py::cast<double>(cpp_current_dict["ES_NS"]);
                    aux_ES_NS_read = true;
                    validate_vartype_consistency("ES_NS", SCALAR_DOUBLE, aux_last_type_read_for_ES_NS);
                    aux_last_type_read_for_ES_NS = SCALAR_DOUBLE;
                    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LP"]), write_opts);
                    // assign expression to variable LP
                    var_LP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LP"]);
                    aux_LP_read = true;
                    validate_vartype_consistency("LP", SCALAR_INT, aux_last_type_read_for_LP);
                    aux_last_type_read_for_LP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_current_dict["LG"])+1)*py::cast<int>(cpp_current_dict["NT"])), write_opts);
                    // assign expression to variable cpp_int_val
                    cpp_int_val = ((py::cast<int>(cpp_current_dict["LG"])+1)*py::cast<int>(cpp_current_dict["NT"]));
                    aux_cpp_int_val_read = true;
                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                    // assign expression to variable NT
                    var_NT_0d_int_Scalar = (cpp_int_val/(var_LG_0d_int_Scalar+1));
                    aux_NT_read = true;
                    validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                    aux_last_type_read_for_NT = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                    if ((! (aux_NT_read == true))) {
                      // assign expression to variable NT
                      var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NT"]);
                      aux_NT_read = true;
                      validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                      aux_last_type_read_for_NT = SCALAR_INT;
                    } else {
                    }
                    cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_current_dict["LG"])+1)*py::cast<int>(cpp_current_dict["NT"])), write_opts);
                    cont << cpp_draft_line;
                    {
                      int cpp_npl = ((py::cast<int>(cpp_current_dict["LG"])+1)*py::cast<int>(cpp_current_dict["NT"]));
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read LIST body

                      for (int var_i_0d_int_Scalar = 1;
                         var_i_0d_int_Scalar <= var_NT_0d_int_Scalar; var_i_0d_int_Scalar++) {
                        bool aux_i_read = true;
                        // read LIST body
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ES"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                        // assign expression to variable ES
                        var_ES_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["ES"][py::cast(var_i_0d_int_Scalar)]));
                        validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                        aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["TP"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                        // assign expression to variable TP
                        var_TP_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["TP"][py::cast(var_i_0d_int_Scalar)]));
                        validate_vartype_consistency("TP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_TP);
                        aux_last_type_read_for_TP = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GP"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                        // assign expression to variable GP
                        var_GP_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["GP"][py::cast(var_i_0d_int_Scalar)]));
                        validate_vartype_consistency("GP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GP);
                        aux_last_type_read_for_GP = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cont << cpp_draft_line;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 0244722dd783f7feb5112a1d869b898f
// MD5 hash of the following function definition: 573a3e7edf44406f3c4704e88613e6cc
void write_mf13_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  std::vector<double> var_E_0d_floatvec_Scalar;
  bool aux_E_read = false;
  vartype aux_last_type_read_for_E = UNKNOWN;
  std::vector<double> var_sigma_tot_0d_floatvec_Scalar;
  bool aux_sigma_tot_read = false;
  vartype aux_last_type_read_for_sigma_tot = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 13;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 13;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 13 , MT / ZA , AWR , 0 , 0 , NK , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NK"]), write_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = py::cast<int>(cpp_current_dict["NK"]);
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_NK_read == true)) && ((var_NK_0d_int_Scalar)>(1)))))))) {
        // if statement evaluation
        cpp_found_match = true;
        cpp_template = "[ MAT , 13 , MT / 0.0 , 0.0 , 0 , 0 , NR , NP / E / sigma_tot ] TAB1";
        // read TAB1 record
        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
        cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
        cpp_nr_val = py::len(cpp_current_dict["INT"]);
        cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
        cpp_np_val = py::len(cpp_current_dict["E"]);
        cont << cpp_draft_line;
        tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
        tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["sigma_tot"]);
        tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
        tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
        write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
        {
          Tab1Body tab_body = tab1_body;
          // assign expression to variable E
          var_E_0d_floatvec_Scalar = tab_body.X;
          aux_E_read = true;
          validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
          aux_last_type_read_for_E = SCALAR_FLOATVEC;
          // assign expression to variable sigma_tot
          var_sigma_tot_0d_floatvec_Scalar = tab_body.Y;
          aux_sigma_tot_read = true;
          validate_vartype_consistency("sigma_tot", SCALAR_FLOATVEC, aux_last_type_read_for_sigma_tot);
          aux_last_type_read_for_sigma_tot = SCALAR_FLOATVEC;
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        }
        cont << cpp_draft_line;
      }
    }
  }

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict_tmp = cpp_current_dict;
      if ((! cpp_parent_dict_tmp.contains("subsection"))) {
        cpp_parent_dict_tmp["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict_tmp["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      double var_EG_0d_double_Scalar;
      bool aux_EG_read = false;
      vartype aux_last_type_read_for_EG = UNKNOWN;
      double var_ES_0d_double_Scalar;
      bool aux_ES_read = false;
      vartype aux_last_type_read_for_ES = UNKNOWN;
      int var_LP_0d_int_Scalar;
      bool aux_LP_read = false;
      vartype aux_last_type_read_for_LP = UNKNOWN;
      int var_LF_0d_int_Scalar;
      bool aux_LF_read = false;
      vartype aux_last_type_read_for_LF = UNKNOWN;
      std::vector<double> var_E_0d_floatvec_Scalar;
      bool aux_E_read = false;
      vartype aux_last_type_read_for_E = UNKNOWN;
      std::vector<double> var_sigma_0d_floatvec_Scalar;
      bool aux_sigma_read = false;
      vartype aux_last_type_read_for_sigma = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      cpp_template = "[ MAT , 13 , MT / EG , ES , LP , LF , NR , NP / E / sigma ] TAB1";
      // read TAB1 record
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["EG"]), write_opts);
      // assign expression to variable EG
      var_EG_0d_double_Scalar = py::cast<double>(cpp_current_dict["EG"]);
      aux_EG_read = true;
      validate_vartype_consistency("EG", SCALAR_DOUBLE, aux_last_type_read_for_EG);
      aux_last_type_read_for_EG = SCALAR_DOUBLE;
      cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["ES"]), write_opts);
      // assign expression to variable ES
      var_ES_0d_double_Scalar = py::cast<double>(cpp_current_dict["ES"]);
      aux_ES_read = true;
      validate_vartype_consistency("ES", SCALAR_DOUBLE, aux_last_type_read_for_ES);
      aux_last_type_read_for_ES = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LP"]), write_opts);
      // assign expression to variable LP
      var_LP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LP"]);
      aux_LP_read = true;
      validate_vartype_consistency("LP", SCALAR_INT, aux_last_type_read_for_LP);
      aux_last_type_read_for_LP = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LF"]), write_opts);
      // assign expression to variable LF
      var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LF"]);
      aux_LF_read = true;
      validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
      aux_last_type_read_for_LF = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
      cpp_nr_val = py::len(cpp_current_dict["INT"]);
      cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["E"]), write_opts);
      cpp_np_val = py::len(cpp_current_dict["E"]);
      cont << cpp_draft_line;
      tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["E"]);
      tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["sigma"]);
      tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
      tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
      write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
      {
        Tab1Body tab_body = tab1_body;
        if ((! (aux_E_read == true))) {
          // assign expression to variable E
          var_E_0d_floatvec_Scalar = tab_body.X;
          aux_E_read = true;
          validate_vartype_consistency("E", SCALAR_FLOATVEC, aux_last_type_read_for_E);
          aux_last_type_read_for_E = SCALAR_FLOATVEC;
        } else {
        }
        // assign expression to variable sigma
        var_sigma_0d_floatvec_Scalar = tab_body.Y;
        aux_sigma_read = true;
        validate_vartype_consistency("sigma", SCALAR_FLOATVEC, aux_last_type_read_for_sigma);
        aux_last_type_read_for_sigma = SCALAR_FLOATVEC;
        if ((! (aux_INT_read == true))) {
          // assign expression to variable INT
          var_INT_0d_intvec_Scalar = tab_body.INT;
          aux_INT_read = true;
          validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
          aux_last_type_read_for_INT = SCALAR_INTVEC;
        } else {
        }
        if ((! (aux_NBT_read == true))) {
          // assign expression to variable NBT
          var_NBT_0d_intvec_Scalar = tab_body.NBT;
          aux_NBT_read = true;
          validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
          aux_last_type_read_for_NBT = SCALAR_INTVEC;
        } else {
        }
      }
      cont << cpp_draft_line;
      cpp_current_dict = cpp_parent_dict_tmp;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: cbb953767d4afb465ff9cee335ea03ef
// MD5 hash of the following function definition: 515640c365edd92ccba59882a67e74f9
void write_mf14_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LI_0d_int_Scalar;
  bool aux_LI_read = false;
  vartype aux_last_type_read_for_LI = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  int var_LTT_0d_int_Scalar;
  bool aux_LTT_read = false;
  vartype aux_last_type_read_for_LTT = UNKNOWN;
  int var_NI_0d_int_Scalar;
  bool aux_NI_read = false;
  vartype aux_last_type_read_for_NI = UNKNOWN;
  NestedVector<double> var_EG_1d_double_NestedVector;
  vartype aux_last_type_read_for_EG = UNKNOWN;
  NestedVector<double> var_ES_1d_double_NestedVector;
  vartype aux_last_type_read_for_ES = UNKNOWN;
  NestedVector<int> var_NE_1d_int_NestedVector;
  vartype aux_last_type_read_for_NE = UNKNOWN;
  NestedVector<NestedVector<double>> var_E_2d_double_NestedVector;
  NestedVector<double>* ptr_E_2d_idx0;
  vartype aux_last_type_read_for_E = UNKNOWN;
  NestedVector<NestedVector<int>> var_NL_2d_int_NestedVector;
  NestedVector<int>* ptr_NL_2d_idx0;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  NestedVector<NestedVector<NestedVector<double>>> var_a_3d_double_NestedVector;
  NestedVector<double>* ptr_a_3d_idx1;
  NestedVector<NestedVector<double>>* ptr_a_3d_idx0;
  vartype aux_last_type_read_for_a = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 14;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 14;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      // if statement evaluation with lookahead
      {
        {
          // variable declarations
          int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
          int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
          bool& glob_aux_MAT_read = aux_MAT_read;
          bool aux_MAT_read = glob_aux_MAT_read;
          vartype aux_last_type_read_for_MAT = UNKNOWN;
          int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
          int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
          bool& glob_aux_MF_read = aux_MF_read;
          bool aux_MF_read = glob_aux_MF_read;
          vartype aux_last_type_read_for_MF = UNKNOWN;
          int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
          int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
          bool& glob_aux_MT_read = aux_MT_read;
          bool aux_MT_read = glob_aux_MT_read;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
          double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
          bool& glob_aux_ZA_read = aux_ZA_read;
          bool aux_ZA_read = glob_aux_ZA_read;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
          double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
          bool& glob_aux_AWR_read = aux_AWR_read;
          bool aux_AWR_read = glob_aux_AWR_read;
          vartype aux_last_type_read_for_AWR = UNKNOWN;
          int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
          int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
          bool& glob_aux_LI_read = aux_LI_read;
          bool aux_LI_read = glob_aux_LI_read;
          vartype aux_last_type_read_for_LI = UNKNOWN;
          int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
          int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
          bool& glob_aux_NK_read = aux_NK_read;
          bool aux_NK_read = glob_aux_NK_read;
          vartype aux_last_type_read_for_NK = UNKNOWN;
          cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , 0 , NK , 0 ] HEAD";
          // read CONT record
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ZA", -99999.9));
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AWR", -99999.9));
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          // assign expression to variable LI
          var_LI_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LI", -99999));
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          // assign expression to variable NK
          var_NK_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NK", -99999));
          aux_NK_read = true;
          validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
          aux_last_type_read_for_NK = SCALAR_INT;
          if ((((((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(1)))))))) {
            cpp_found_match = true;
          }
        }
        if (cpp_found_match) {
          cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , 0 , NK , 0 ] HEAD";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read CONT record
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
          // assign expression to variable ZA
          var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
          aux_ZA_read = true;
          validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
          aux_last_type_read_for_ZA = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
          // assign expression to variable AWR
          var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
          aux_AWR_read = true;
          validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
          aux_last_type_read_for_AWR = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LI"]), write_opts);
          // assign expression to variable LI
          var_LI_0d_int_Scalar = py::cast<int>(cpp_current_dict["LI"]);
          aux_LI_read = true;
          validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
          aux_last_type_read_for_LI = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NK"]), write_opts);
          // assign expression to variable NK
          var_NK_0d_int_Scalar = py::cast<int>(cpp_current_dict["NK"]);
          aux_NK_read = true;
          validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
          aux_last_type_read_for_NK = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
          cont << cpp_draft_line;
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
            int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
            bool& glob_aux_LI_read = aux_LI_read;
            bool aux_LI_read = glob_aux_LI_read;
            vartype aux_last_type_read_for_LI = UNKNOWN;
            int& glob_var_LTT_0d_int_Scalar = var_LTT_0d_int_Scalar;
            int var_LTT_0d_int_Scalar = glob_var_LTT_0d_int_Scalar;
            bool& glob_aux_LTT_read = aux_LTT_read;
            bool aux_LTT_read = glob_aux_LTT_read;
            vartype aux_last_type_read_for_LTT = UNKNOWN;
            int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
            int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
            bool& glob_aux_NK_read = aux_NK_read;
            bool aux_NK_read = glob_aux_NK_read;
            vartype aux_last_type_read_for_NK = UNKNOWN;
            int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
            int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
            bool& glob_aux_NI_read = aux_NI_read;
            bool aux_NI_read = glob_aux_NI_read;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ZA", -99999.9));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AWR", -99999.9));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LI
            var_LI_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LI", -99999));
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            // assign expression to variable LTT
            var_LTT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LTT", -99999));
            aux_LTT_read = true;
            validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
            aux_last_type_read_for_LTT = SCALAR_INT;
            // assign expression to variable NK
            var_NK_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NK", -99999));
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
            // assign expression to variable NI
            var_NI_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NI", -99999));
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
            if (((((((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))&&((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(1)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read CONT record
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LI"]), write_opts);
            // assign expression to variable LI
            var_LI_0d_int_Scalar = py::cast<int>(cpp_current_dict["LI"]);
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LTT"]), write_opts);
            // assign expression to variable LTT
            var_LTT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LTT"]);
            aux_LTT_read = true;
            validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
            aux_last_type_read_for_LTT = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NK"]), write_opts);
            // assign expression to variable NK
            var_NK_0d_int_Scalar = py::cast<int>(cpp_current_dict["NK"]);
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NI"]), write_opts);
            // assign expression to variable NI
            var_NI_0d_int_Scalar = py::cast<int>(cpp_current_dict["NI"]);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
            cont << cpp_draft_line;

            for (int var_k_0d_int_Scalar = 1;
               var_k_0d_int_Scalar <= var_NI_0d_int_Scalar; var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              cpp_template = "[ MAT , 14 , MT / EG , ES , 0 , 0 , 0 , 0 ] CONT";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read CONT record
              cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["EG"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable EG
              var_EG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["EG"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("EG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EG);
              aux_last_type_read_for_EG = NESTEDVECTOR_DOUBLE;
              cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["ES"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable ES
              var_ES_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ES"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
              aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
              cont << cpp_draft_line;
            }

            for (int var_k_0d_int_Scalar = (var_NI_0d_int_Scalar+1);
               var_k_0d_int_Scalar <= (var_NI_0d_int_Scalar+(var_NK_0d_int_Scalar-var_NI_0d_int_Scalar)); var_k_0d_int_Scalar++) {
              bool aux_k_read = true;
              cpp_template = "[ MAT , 14 , MT / EG , ES , 0 , 0 , NR , NE / E ] TAB2 ( E_interpol [ k ] )";
              // read TAB2 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["EG"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              if ((! var_EG_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
                // assign expression to variable EG
                var_EG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["EG"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("EG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EG);
                aux_last_type_read_for_EG = NESTEDVECTOR_DOUBLE;
              } else {
              }
              cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["ES"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              if ((! var_ES_1d_double_NestedVector.contains(var_k_0d_int_Scalar))) {
                // assign expression to variable ES
                var_ES_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ES"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("ES", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ES);
                aux_last_type_read_for_ES = NESTEDVECTOR_DOUBLE;
              } else {
              }
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"][py::cast(var_k_0d_int_Scalar)]), write_opts);
              // assign expression to variable NE
              var_NE_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["NE"][py::cast(var_k_0d_int_Scalar)]));
              validate_vartype_consistency("NE", NESTEDVECTOR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = NESTEDVECTOR_INT;
              {
                py::dict cpp_parent_dict_tmp = cpp_current_dict;
                if ((! cpp_parent_dict_tmp.contains("E_interpol"))) {
                  cpp_parent_dict_tmp["E_interpol"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict_tmp["E_interpol"];
                if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                  cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                }
                cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                cpp_nr_val = py::len(cpp_current_dict["INT"]);
                cont << cpp_draft_line;
                tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
                // variable declarations
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab2Body tab_body = tab2_body;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
                cpp_current_dict = cpp_parent_dict_tmp;
              }
              ptr_E_2d_idx0 = var_E_2d_double_NestedVector.prepare(var_k_0d_int_Scalar);
              ptr_a_3d_idx0 = var_a_3d_double_NestedVector.prepare(var_k_0d_int_Scalar);

              for (int var_l_0d_int_Scalar = 1;
                 var_l_0d_int_Scalar <= var_NE_1d_int_NestedVector[var_k_0d_int_Scalar]; var_l_0d_int_Scalar++) {
                bool aux_l_read = true;
                cpp_template = "[ MAT , 14 , MT / 0.0 , E , 0 , 0 , NL , 0 / \n { a } { m = 1 to NL } ] LIST";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                // read LIST record
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]), write_opts);
                // assign expression to variable E
                ptr_E_2d_idx0->set(var_l_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NL"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]), write_opts);
                // assign expression to variable NL
                ptr_NL_2d_idx0 = var_NL_2d_int_NestedVector.prepare(var_k_0d_int_Scalar);
                ptr_NL_2d_idx0->set(var_l_0d_int_Scalar, py::cast<int>(cpp_current_dict["NL"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]));
                validate_vartype_consistency("NL", NESTEDVECTOR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NL"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]), write_opts);
                cont << cpp_draft_line;
                {
                  int cpp_npl = py::cast<int>(cpp_current_dict["NL"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]);
                  int cpp_i = 0;
                  int cpp_j = 0;
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  // read LIST body
                  ptr_a_3d_idx1 = ptr_a_3d_idx0->prepare(var_l_0d_int_Scalar);

                  for (int var_m_0d_int_Scalar = 1;
                     var_m_0d_int_Scalar <= var_NL_2d_int_NestedVector[var_k_0d_int_Scalar][var_l_0d_int_Scalar]; var_m_0d_int_Scalar++) {
                    bool aux_m_read = true;
                    // read LIST body
                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["a"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
                    // assign expression to variable a
                    ptr_a_3d_idx1->set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["a"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
                    validate_vartype_consistency("a", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_a);
                    aux_last_type_read_for_a = NESTEDVECTOR_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cont << cpp_draft_line;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      cpp_j = 0;
                    }
                  }
                  if (cpp_i != cpp_npl) {
                    throw std::runtime_error("not exactly NPL elements consumed");
                  }
                }
                cont << cpp_draft_line;
              }
            }
          }
        }
      }
    }
    if (! cpp_found_match) {
      if (! cpp_found_match) {
        // if statement evaluation with lookahead
        {
          {
            // variable declarations
            int& glob_var_MAT_0d_int_Scalar = var_MAT_0d_int_Scalar;
            int var_MAT_0d_int_Scalar = glob_var_MAT_0d_int_Scalar;
            bool& glob_aux_MAT_read = aux_MAT_read;
            bool aux_MAT_read = glob_aux_MAT_read;
            vartype aux_last_type_read_for_MAT = UNKNOWN;
            int& glob_var_MF_0d_int_Scalar = var_MF_0d_int_Scalar;
            int var_MF_0d_int_Scalar = glob_var_MF_0d_int_Scalar;
            bool& glob_aux_MF_read = aux_MF_read;
            bool aux_MF_read = glob_aux_MF_read;
            vartype aux_last_type_read_for_MF = UNKNOWN;
            int& glob_var_MT_0d_int_Scalar = var_MT_0d_int_Scalar;
            int var_MT_0d_int_Scalar = glob_var_MT_0d_int_Scalar;
            bool& glob_aux_MT_read = aux_MT_read;
            bool aux_MT_read = glob_aux_MT_read;
            vartype aux_last_type_read_for_MT = UNKNOWN;
            double& glob_var_ZA_0d_double_Scalar = var_ZA_0d_double_Scalar;
            double var_ZA_0d_double_Scalar = glob_var_ZA_0d_double_Scalar;
            bool& glob_aux_ZA_read = aux_ZA_read;
            bool aux_ZA_read = glob_aux_ZA_read;
            vartype aux_last_type_read_for_ZA = UNKNOWN;
            double& glob_var_AWR_0d_double_Scalar = var_AWR_0d_double_Scalar;
            double var_AWR_0d_double_Scalar = glob_var_AWR_0d_double_Scalar;
            bool& glob_aux_AWR_read = aux_AWR_read;
            bool aux_AWR_read = glob_aux_AWR_read;
            vartype aux_last_type_read_for_AWR = UNKNOWN;
            int& glob_var_LI_0d_int_Scalar = var_LI_0d_int_Scalar;
            int var_LI_0d_int_Scalar = glob_var_LI_0d_int_Scalar;
            bool& glob_aux_LI_read = aux_LI_read;
            bool aux_LI_read = glob_aux_LI_read;
            vartype aux_last_type_read_for_LI = UNKNOWN;
            int& glob_var_LTT_0d_int_Scalar = var_LTT_0d_int_Scalar;
            int var_LTT_0d_int_Scalar = glob_var_LTT_0d_int_Scalar;
            bool& glob_aux_LTT_read = aux_LTT_read;
            bool aux_LTT_read = glob_aux_LTT_read;
            vartype aux_last_type_read_for_LTT = UNKNOWN;
            int& glob_var_NK_0d_int_Scalar = var_NK_0d_int_Scalar;
            int var_NK_0d_int_Scalar = glob_var_NK_0d_int_Scalar;
            bool& glob_aux_NK_read = aux_NK_read;
            bool aux_NK_read = glob_aux_NK_read;
            vartype aux_last_type_read_for_NK = UNKNOWN;
            int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
            int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
            bool& glob_aux_NI_read = aux_NI_read;
            bool aux_NI_read = glob_aux_NI_read;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
            // read CONT record
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("ZA", -99999.9));
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AWR", -99999.9));
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            // assign expression to variable LI
            var_LI_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LI", -99999));
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            // assign expression to variable LTT
            var_LTT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LTT", -99999));
            aux_LTT_read = true;
            validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
            aux_last_type_read_for_LTT = SCALAR_INT;
            // assign expression to variable NK
            var_NK_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NK", -99999));
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
            // assign expression to variable NI
            var_NI_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NI", -99999));
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
            if (((((((((aux_LI_read == true)) && ((var_LI_0d_int_Scalar)==(0)))))&&((((aux_LTT_read == true)) && ((var_LTT_0d_int_Scalar)==(2)))))))) {
              cpp_found_match = true;
            }
          }
          if (cpp_found_match) {
            cpp_template = "[ MAT , 14 , MT / ZA , AWR , LI , LTT , NK , NI ] HEAD";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read CONT record
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
            // assign expression to variable ZA
            var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
            aux_ZA_read = true;
            validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
            aux_last_type_read_for_ZA = SCALAR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
            // assign expression to variable AWR
            var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
            aux_AWR_read = true;
            validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
            aux_last_type_read_for_AWR = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LI"]), write_opts);
            // assign expression to variable LI
            var_LI_0d_int_Scalar = py::cast<int>(cpp_current_dict["LI"]);
            aux_LI_read = true;
            validate_vartype_consistency("LI", SCALAR_INT, aux_last_type_read_for_LI);
            aux_last_type_read_for_LI = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LTT"]), write_opts);
            // assign expression to variable LTT
            var_LTT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LTT"]);
            aux_LTT_read = true;
            validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
            aux_last_type_read_for_LTT = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NK"]), write_opts);
            // assign expression to variable NK
            var_NK_0d_int_Scalar = py::cast<int>(cpp_current_dict["NK"]);
            aux_NK_read = true;
            validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
            aux_last_type_read_for_NK = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NI"]), write_opts);
            // assign expression to variable NI
            var_NI_0d_int_Scalar = py::cast<int>(cpp_current_dict["NI"]);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
            cont << cpp_draft_line;
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: d686a05ea85d12021bed42716983796f
// MD5 hash of the following function definition: 311f6a5bd7584bd637f25da810491b8d
void write_mf15_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NC_0d_int_Scalar;
  bool aux_NC_read = false;
  vartype aux_last_type_read_for_NC = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 15;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 15;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 15 , MT / ZA , AWR , 0 , 0 , NC , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NC"]), write_opts);
  // assign expression to variable NC
  var_NC_0d_int_Scalar = py::cast<int>(cpp_current_dict["NC"]);
  aux_NC_read = true;
  validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
  aux_last_type_read_for_NC = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_j_0d_int_Scalar = 1;
     var_j_0d_int_Scalar <= var_NC_0d_int_Scalar; var_j_0d_int_Scalar++) {
    bool aux_j_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict_tmp = cpp_current_dict;
      if ((! cpp_parent_dict_tmp.contains("subsection"))) {
        cpp_parent_dict_tmp["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict_tmp["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
      // variable declarations
      int var_LF_0d_int_Scalar;
      bool aux_LF_read = false;
      vartype aux_last_type_read_for_LF = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      std::vector<int> var_INT_0d_intvec_Scalar;
      bool aux_INT_read = false;
      vartype aux_last_type_read_for_INT = UNKNOWN;
      std::vector<int> var_NBT_0d_intvec_Scalar;
      bool aux_NBT_read = false;
      vartype aux_last_type_read_for_NBT = UNKNOWN;
      NestedVector<double> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            {
              // variable declarations
              int& glob_var_LF_0d_int_Scalar = var_LF_0d_int_Scalar;
              int var_LF_0d_int_Scalar = glob_var_LF_0d_int_Scalar;
              bool& glob_aux_LF_read = aux_LF_read;
              bool aux_LF_read = glob_aux_LF_read;
              vartype aux_last_type_read_for_LF = UNKNOWN;
              cpp_template = "[ MAT , 15 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / Eint / p ] TAB1 ( rtfm_tab1 )";
              // read TAB1 record
              // assign expression to variable LF
              var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LF", -99999));
              aux_LF_read = true;
              validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
              aux_last_type_read_for_LF = SCALAR_INT;
              if ((((((((aux_LF_read == true)) && ((var_LF_0d_int_Scalar)==(1)))))))) {
                cpp_found_match = true;
              }
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 15 , MT / 0.0 , 0.0 , 0 , LF , NR , NP / Eint / p ] TAB1 ( rtfm_tab1 )";
              // read TAB1 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LF"]), write_opts);
              // assign expression to variable LF
              var_LF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LF"]);
              aux_LF_read = true;
              validate_vartype_consistency("LF", SCALAR_INT, aux_last_type_read_for_LF);
              aux_last_type_read_for_LF = SCALAR_INT;
              {
                py::dict cpp_parent_dict_tmp = cpp_current_dict;
                if ((! cpp_parent_dict_tmp.contains("rtfm_tab1"))) {
                  cpp_parent_dict_tmp["rtfm_tab1"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict_tmp["rtfm_tab1"];
                cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                cpp_nr_val = py::len(cpp_current_dict["INT"]);
                cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
                cpp_np_val = py::len(cpp_current_dict["Eint"]);
                cont << cpp_draft_line;
                tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
                tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["p"]);
                tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                // variable declarations
                std::vector<double> var_Eint_0d_floatvec_Scalar;
                bool aux_Eint_read = false;
                vartype aux_last_type_read_for_Eint = UNKNOWN;
                std::vector<double> var_p_0d_floatvec_Scalar;
                bool aux_p_read = false;
                vartype aux_last_type_read_for_p = UNKNOWN;
                std::vector<int> var_INT_0d_intvec_Scalar;
                bool aux_INT_read = false;
                vartype aux_last_type_read_for_INT = UNKNOWN;
                std::vector<int> var_NBT_0d_intvec_Scalar;
                bool aux_NBT_read = false;
                vartype aux_last_type_read_for_NBT = UNKNOWN;
                {
                  Tab1Body tab_body = tab1_body;
                  // assign expression to variable Eint
                  var_Eint_0d_floatvec_Scalar = tab_body.X;
                  aux_Eint_read = true;
                  validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
                  aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
                  // assign expression to variable p
                  var_p_0d_floatvec_Scalar = tab_body.Y;
                  aux_p_read = true;
                  validate_vartype_consistency("p", SCALAR_FLOATVEC, aux_last_type_read_for_p);
                  aux_last_type_read_for_p = SCALAR_FLOATVEC;
                  // assign expression to variable INT
                  var_INT_0d_intvec_Scalar = tab_body.INT;
                  aux_INT_read = true;
                  validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                  aux_last_type_read_for_INT = SCALAR_INTVEC;
                  // assign expression to variable NBT
                  var_NBT_0d_intvec_Scalar = tab_body.NBT;
                  aux_NBT_read = true;
                  validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                  aux_last_type_read_for_NBT = SCALAR_INTVEC;
                }
                cont << cpp_draft_line;
                cpp_current_dict = cpp_parent_dict_tmp;
              }
              cpp_template = "[ MAT , 15 , MT / 0.0 , 0.0 , 0 , 0 , NR , NE / Eint ] TAB2";
              // read TAB2 record
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
              cpp_nr_val = py::len(cpp_current_dict["INT"]);
              cont << cpp_draft_line;
              tab2_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
              tab2_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
              write_tab2_body(cpp_draft_line, tab2_body, mat, mf, mt, linenum, write_opts);
              {
                Tab2Body tab_body = tab2_body;
                // assign expression to variable INT
                var_INT_0d_intvec_Scalar = tab_body.INT;
                aux_INT_read = true;
                validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                aux_last_type_read_for_INT = SCALAR_INTVEC;
                // assign expression to variable NBT
                var_NBT_0d_intvec_Scalar = tab_body.NBT;
                aux_NBT_read = true;
                validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                aux_last_type_read_for_NBT = SCALAR_INTVEC;
              }
              cont << cpp_draft_line;

              for (int var_k_0d_int_Scalar = 1;
                 var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                bool aux_k_read = true;
                cpp_template = "[ MAT , 15 , MT / 0.0 , E , 0 , 0 , NR , NP / Egamma / g ] TAB1 ( rtfm1_tab [ k ] )";
                // read TAB1 record
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                // assign expression to variable E
                var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]));
                validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                {
                  py::dict cpp_parent_dict_tmp = cpp_current_dict;
                  if ((! cpp_parent_dict_tmp.contains("rtfm1_tab"))) {
                    cpp_parent_dict_tmp["rtfm1_tab"] = py::dict();
                  }
                  py::dict cpp_current_dict = cpp_parent_dict_tmp["rtfm1_tab"];
                  if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                    cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                  }
                  cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
                  cpp_nr_val = py::len(cpp_current_dict["INT"]);
                  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Egamma"]), write_opts);
                  cpp_np_val = py::len(cpp_current_dict["Egamma"]);
                  cont << cpp_draft_line;
                  tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Egamma"]);
                  tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["g"]);
                  tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
                  tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
                  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
                  // variable declarations
                  std::vector<double> var_Egamma_0d_floatvec_Scalar;
                  bool aux_Egamma_read = false;
                  vartype aux_last_type_read_for_Egamma = UNKNOWN;
                  std::vector<double> var_g_0d_floatvec_Scalar;
                  bool aux_g_read = false;
                  vartype aux_last_type_read_for_g = UNKNOWN;
                  std::vector<int> var_INT_0d_intvec_Scalar;
                  bool aux_INT_read = false;
                  vartype aux_last_type_read_for_INT = UNKNOWN;
                  std::vector<int> var_NBT_0d_intvec_Scalar;
                  bool aux_NBT_read = false;
                  vartype aux_last_type_read_for_NBT = UNKNOWN;
                  {
                    Tab1Body tab_body = tab1_body;
                    // assign expression to variable Egamma
                    var_Egamma_0d_floatvec_Scalar = tab_body.X;
                    aux_Egamma_read = true;
                    validate_vartype_consistency("Egamma", SCALAR_FLOATVEC, aux_last_type_read_for_Egamma);
                    aux_last_type_read_for_Egamma = SCALAR_FLOATVEC;
                    // assign expression to variable g
                    var_g_0d_floatvec_Scalar = tab_body.Y;
                    aux_g_read = true;
                    validate_vartype_consistency("g", SCALAR_FLOATVEC, aux_last_type_read_for_g);
                    aux_last_type_read_for_g = SCALAR_FLOATVEC;
                    if ((! (aux_INT_read == true))) {
                      // assign expression to variable INT
                      var_INT_0d_intvec_Scalar = tab_body.INT;
                      aux_INT_read = true;
                      validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
                      aux_last_type_read_for_INT = SCALAR_INTVEC;
                    } else {
                    }
                    if ((! (aux_NBT_read == true))) {
                      // assign expression to variable NBT
                      var_NBT_0d_intvec_Scalar = tab_body.NBT;
                      aux_NBT_read = true;
                      validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
                      aux_last_type_read_for_NBT = SCALAR_INTVEC;
                    } else {
                    }
                  }
                  cont << cpp_draft_line;
                  cpp_current_dict = cpp_parent_dict_tmp;
                }
              }
            }
          }
        }
      }
      cpp_current_dict = cpp_parent_dict_tmp;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 5557baba7f951e2762c63f317ba874b9
// MD5 hash of the following function definition: 4d5bf5bc7887a3c1e1a8c8b6f6b505d5
void write_mf23_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  double var_EPE_0d_double_Scalar;
  bool aux_EPE_read = false;
  vartype aux_last_type_read_for_EPE = UNKNOWN;
  double var_EFL_0d_double_Scalar;
  bool aux_EFL_read = false;
  vartype aux_last_type_read_for_EFL = UNKNOWN;
  std::vector<double> var_Eint_0d_floatvec_Scalar;
  bool aux_Eint_read = false;
  vartype aux_last_type_read_for_Eint = UNKNOWN;
  std::vector<double> var_sigma_0d_floatvec_Scalar;
  bool aux_sigma_read = false;
  vartype aux_last_type_read_for_sigma = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 23;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 23;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 23 , MT / ZA , AWR , 0 , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 23 , MT / EPE , EFL , 0 , 0 , NR , NP / Eint / sigma ] TAB1";
  // read TAB1 record
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["EPE"]), write_opts);
  // assign expression to variable EPE
  var_EPE_0d_double_Scalar = py::cast<double>(cpp_current_dict["EPE"]);
  aux_EPE_read = true;
  validate_vartype_consistency("EPE", SCALAR_DOUBLE, aux_last_type_read_for_EPE);
  aux_last_type_read_for_EPE = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["EFL"]), write_opts);
  // assign expression to variable EFL
  var_EFL_0d_double_Scalar = py::cast<double>(cpp_current_dict["EFL"]);
  aux_EFL_read = true;
  validate_vartype_consistency("EFL", SCALAR_DOUBLE, aux_last_type_read_for_EFL);
  aux_last_type_read_for_EFL = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
  cpp_nr_val = py::len(cpp_current_dict["INT"]);
  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["Eint"]), write_opts);
  cpp_np_val = py::len(cpp_current_dict["Eint"]);
  cont << cpp_draft_line;
  tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["Eint"]);
  tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["sigma"]);
  tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
  tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
  {
    Tab1Body tab_body = tab1_body;
    // assign expression to variable Eint
    var_Eint_0d_floatvec_Scalar = tab_body.X;
    aux_Eint_read = true;
    validate_vartype_consistency("Eint", SCALAR_FLOATVEC, aux_last_type_read_for_Eint);
    aux_last_type_read_for_Eint = SCALAR_FLOATVEC;
    // assign expression to variable sigma
    var_sigma_0d_floatvec_Scalar = tab_body.Y;
    aux_sigma_read = true;
    validate_vartype_consistency("sigma", SCALAR_FLOATVEC, aux_last_type_read_for_sigma);
    aux_last_type_read_for_sigma = SCALAR_FLOATVEC;
    // assign expression to variable INT
    var_INT_0d_intvec_Scalar = tab_body.INT;
    aux_INT_read = true;
    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
    aux_last_type_read_for_INT = SCALAR_INTVEC;
    // assign expression to variable NBT
    var_NBT_0d_intvec_Scalar = tab_body.NBT;
    aux_NBT_read = true;
    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
    aux_last_type_read_for_NBT = SCALAR_INTVEC;
  }
  cont << cpp_draft_line;
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 3f70d967823f46b1bb1f3b072c33eced
// MD5 hash of the following function definition: 1b46359b89047aa659acd29f1dccade0
void write_mf26_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 26;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 26;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 20ce9f620fd87cc4c048529da1906a0e
// MD5 hash of the following function definition: d94b22133bb2278e1442e50694f5ccc9
void write_mf27_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  double var_Z_0d_double_Scalar;
  bool aux_Z_read = false;
  vartype aux_last_type_read_for_Z = UNKNOWN;
  std::vector<double> var_xint_0d_floatvec_Scalar;
  bool aux_xint_read = false;
  vartype aux_last_type_read_for_xint = UNKNOWN;
  std::vector<double> var_H_0d_floatvec_Scalar;
  bool aux_H_read = false;
  vartype aux_last_type_read_for_H = UNKNOWN;
  std::vector<int> var_INT_0d_intvec_Scalar;
  bool aux_INT_read = false;
  vartype aux_last_type_read_for_INT = UNKNOWN;
  std::vector<int> var_NBT_0d_intvec_Scalar;
  bool aux_NBT_read = false;
  vartype aux_last_type_read_for_NBT = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 27;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 27;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 27 , MT / ZA , AWR , 0 , 0 , 0 , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;
  cpp_template = "[ MAT , 27 , MT / 0.0 , Z , 0 , 0 , NR , NP / xint / H ] TAB1";
  // read TAB1 record
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["Z"]), write_opts);
  // assign expression to variable Z
  var_Z_0d_double_Scalar = py::cast<double>(cpp_current_dict["Z"]);
  aux_Z_read = true;
  validate_vartype_consistency("Z", SCALAR_DOUBLE, aux_last_type_read_for_Z);
  aux_last_type_read_for_Z = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::len(cpp_current_dict["INT"]), write_opts);
  cpp_nr_val = py::len(cpp_current_dict["INT"]);
  cpp_write_field<int>(cpp_draft_line, 5, py::len(cpp_current_dict["xint"]), write_opts);
  cpp_np_val = py::len(cpp_current_dict["xint"]);
  cont << cpp_draft_line;
  tab1_body.X = py::cast<std::vector<double>>(cpp_current_dict["xint"]);
  tab1_body.Y = py::cast<std::vector<double>>(cpp_current_dict["H"]);
  tab1_body.INT = py::cast<std::vector<int>>(cpp_current_dict["INT"]);
  tab1_body.NBT = py::cast<std::vector<int>>(cpp_current_dict["NBT"]);
  write_tab1_body(cpp_draft_line, tab1_body, mat, mf, mt, linenum, write_opts);
  {
    Tab1Body tab_body = tab1_body;
    // assign expression to variable xint
    var_xint_0d_floatvec_Scalar = tab_body.X;
    aux_xint_read = true;
    validate_vartype_consistency("xint", SCALAR_FLOATVEC, aux_last_type_read_for_xint);
    aux_last_type_read_for_xint = SCALAR_FLOATVEC;
    // assign expression to variable H
    var_H_0d_floatvec_Scalar = tab_body.Y;
    aux_H_read = true;
    validate_vartype_consistency("H", SCALAR_FLOATVEC, aux_last_type_read_for_H);
    aux_last_type_read_for_H = SCALAR_FLOATVEC;
    // assign expression to variable INT
    var_INT_0d_intvec_Scalar = tab_body.INT;
    aux_INT_read = true;
    validate_vartype_consistency("INT", SCALAR_INTVEC, aux_last_type_read_for_INT);
    aux_last_type_read_for_INT = SCALAR_INTVEC;
    // assign expression to variable NBT
    var_NBT_0d_intvec_Scalar = tab_body.NBT;
    aux_NBT_read = true;
    validate_vartype_consistency("NBT", SCALAR_INTVEC, aux_last_type_read_for_NBT);
    aux_last_type_read_for_NBT = SCALAR_INTVEC;
  }
  cont << cpp_draft_line;
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 04f3c92d2aa669d9b265ca0bc15b6e1f
// MD5 hash of the following function definition: 75c8e499dd7944d508b6eb4001fe9db6
void write_mf28_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 28;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 28;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 485a4917898fb80f8e6522571893a9e5
// MD5 hash of the following function definition: 6c2e6cd7e9282e4b5cc9a1dfc3ea39ab
void write_mf31_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_MTL_0d_int_Scalar;
  bool aux_MTL_read = false;
  vartype aux_last_type_read_for_MTL = UNKNOWN;
  int var_NL_0d_int_Scalar;
  bool aux_NL_read = false;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 31;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 31;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 31 , MT / ZA , AWR , 0 , MTL , 0 , NL ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["MTL"]), write_opts);
  // assign expression to variable MTL
  var_MTL_0d_int_Scalar = py::cast<int>(cpp_current_dict["MTL"]);
  aux_MTL_read = true;
  validate_vartype_consistency("MTL", SCALAR_INT, aux_last_type_read_for_MTL);
  aux_last_type_read_for_MTL = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NL"]), write_opts);
  // assign expression to variable NL
  var_NL_0d_int_Scalar = py::cast<int>(cpp_current_dict["NL"]);
  aux_NL_read = true;
  validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
  aux_last_type_read_for_NL = SCALAR_INT;
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_MTL_read == true)) && ((var_MTL_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;

        for (int var_n_0d_int_Scalar = 1;
           var_n_0d_int_Scalar <= var_NL_0d_int_Scalar; var_n_0d_int_Scalar++) {
          bool aux_n_read = true;
          // open section subsection
          {
            py::dict cpp_parent_dict_tmp = cpp_current_dict;
            if ((! cpp_parent_dict_tmp.contains("subsection"))) {
              cpp_parent_dict_tmp["subsection"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict_tmp["subsection"];
            if ((! cpp_current_dict.contains(py::cast(var_n_0d_int_Scalar)))) {
              cpp_current_dict[py::cast(var_n_0d_int_Scalar)] = py::dict();
            }
            cpp_current_dict = cpp_current_dict[py::cast(var_n_0d_int_Scalar)];
            // variable declarations
            double var_XMF1_0d_double_Scalar;
            bool aux_XMF1_read = false;
            vartype aux_last_type_read_for_XMF1 = UNKNOWN;
            double var_XLFS1_0d_double_Scalar;
            bool aux_XLFS1_read = false;
            vartype aux_last_type_read_for_XLFS1 = UNKNOWN;
            int var_MAT1_0d_int_Scalar;
            bool aux_MAT1_read = false;
            vartype aux_last_type_read_for_MAT1 = UNKNOWN;
            int var_MT1_0d_int_Scalar;
            bool aux_MT1_read = false;
            vartype aux_last_type_read_for_MT1 = UNKNOWN;
            int var_NC_0d_int_Scalar;
            bool aux_NC_read = false;
            vartype aux_last_type_read_for_NC = UNKNOWN;
            int var_NI_0d_int_Scalar;
            bool aux_NI_read = false;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            cpp_template = "[ MAT , 31 , MT / XMF1 , XLFS1 , MAT1 , MT1 , NC , NI ] CONT";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read CONT record
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["XMF1"]), write_opts);
            // assign expression to variable XMF1
            var_XMF1_0d_double_Scalar = py::cast<double>(cpp_current_dict["XMF1"]);
            aux_XMF1_read = true;
            validate_vartype_consistency("XMF1", SCALAR_DOUBLE, aux_last_type_read_for_XMF1);
            aux_last_type_read_for_XMF1 = SCALAR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["XLFS1"]), write_opts);
            // assign expression to variable XLFS1
            var_XLFS1_0d_double_Scalar = py::cast<double>(cpp_current_dict["XLFS1"]);
            aux_XLFS1_read = true;
            validate_vartype_consistency("XLFS1", SCALAR_DOUBLE, aux_last_type_read_for_XLFS1);
            aux_last_type_read_for_XLFS1 = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["MAT1"]), write_opts);
            // assign expression to variable MAT1
            var_MAT1_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT1"]);
            aux_MAT1_read = true;
            validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
            aux_last_type_read_for_MAT1 = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["MT1"]), write_opts);
            // assign expression to variable MT1
            var_MT1_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT1"]);
            aux_MT1_read = true;
            validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
            aux_last_type_read_for_MT1 = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NC"]), write_opts);
            // assign expression to variable NC
            var_NC_0d_int_Scalar = py::cast<int>(cpp_current_dict["NC"]);
            aux_NC_read = true;
            validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
            aux_last_type_read_for_NC = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NI"]), write_opts);
            // assign expression to variable NI
            var_NI_0d_int_Scalar = py::cast<int>(cpp_current_dict["NI"]);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
            cont << cpp_draft_line;

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NC_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section nc_subsection
              {
                py::dict cpp_parent_dict_tmp = cpp_current_dict;
                if ((! cpp_parent_dict_tmp.contains("nc_subsection"))) {
                  cpp_parent_dict_tmp["nc_subsection"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict_tmp["nc_subsection"];
                if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                  cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                }
                cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                // variable declarations
                int var_LTY_0d_int_Scalar;
                bool aux_LTY_read = false;
                vartype aux_last_type_read_for_LTY = UNKNOWN;
                double var_E1_0d_double_Scalar;
                bool aux_E1_read = false;
                vartype aux_last_type_read_for_E1 = UNKNOWN;
                double var_E2_0d_double_Scalar;
                bool aux_E2_read = false;
                vartype aux_last_type_read_for_E2 = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NCI_0d_int_Scalar;
                bool aux_NCI_read = false;
                vartype aux_last_type_read_for_NCI = UNKNOWN;
                NestedVector<double> var_C_1d_double_NestedVector;
                vartype aux_last_type_read_for_C = UNKNOWN;
                NestedVector<double> var_XMT_1d_double_NestedVector;
                vartype aux_last_type_read_for_XMT = UNKNOWN;
                int var_MATS_0d_int_Scalar;
                bool aux_MATS_read = false;
                vartype aux_last_type_read_for_MATS = UNKNOWN;
                int var_MTS_0d_int_Scalar;
                bool aux_MTS_read = false;
                vartype aux_last_type_read_for_MTS = UNKNOWN;
                int var_NEI_0d_int_Scalar;
                bool aux_NEI_read = false;
                vartype aux_last_type_read_for_NEI = UNKNOWN;
                double var_XMFS_0d_double_Scalar;
                bool aux_XMFS_read = false;
                vartype aux_last_type_read_for_XMFS = UNKNOWN;
                double var_XLFSS_0d_double_Scalar;
                bool aux_XLFSS_read = false;
                vartype aux_last_type_read_for_XLFSS = UNKNOWN;
                NestedVector<double> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                NestedVector<double> var_WE_1d_double_NestedVector;
                vartype aux_last_type_read_for_WE = UNKNOWN;
                cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                // read CONT record
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LTY"]), write_opts);
                // assign expression to variable LTY
                var_LTY_0d_int_Scalar = py::cast<int>(cpp_current_dict["LTY"]);
                aux_LTY_read = true;
                validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                aux_last_type_read_for_LTY = SCALAR_INT;
                cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                cont << cpp_draft_line;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if ((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(0)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      cpp_template = "[ MAT , 31 , MT / E1 , E2 , 0 , 0 , (2*NCI) , NCI / \n { C , XMT } { i = 1 to NCI } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read LIST record
                      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["E1"]), write_opts);
                      // assign expression to variable E1
                      var_E1_0d_double_Scalar = py::cast<double>(cpp_current_dict["E1"]);
                      aux_E1_read = true;
                      validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                      aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                      cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E2"]), write_opts);
                      // assign expression to variable E2
                      var_E2_0d_double_Scalar = py::cast<double>(cpp_current_dict["E2"]);
                      aux_E2_read = true;
                      validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                      aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NCI"])), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (2*py::cast<int>(cpp_current_dict["NCI"]));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NCI
                      var_NCI_0d_int_Scalar = (cpp_int_val/2);
                      aux_NCI_read = true;
                      validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                      aux_last_type_read_for_NCI = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NCI"]), write_opts);
                      if ((! (aux_NCI_read == true))) {
                        // assign expression to variable NCI
                        var_NCI_0d_int_Scalar = py::cast<int>(cpp_current_dict["NCI"]);
                        aux_NCI_read = true;
                        validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                        aux_last_type_read_for_NCI = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NCI"])), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (2*py::cast<int>(cpp_current_dict["NCI"]));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST body

                        for (int var_i_0d_int_Scalar = 1;
                           var_i_0d_int_Scalar <= var_NCI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                          bool aux_i_read = true;
                          // read LIST body
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["C"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                          // assign expression to variable C
                          var_C_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["C"][py::cast(var_i_0d_int_Scalar)]));
                          validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
                          aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["XMT"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                          // assign expression to variable XMT
                          var_XMT_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["XMT"][py::cast(var_i_0d_int_Scalar)]));
                          validate_vartype_consistency("XMT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_XMT);
                          aux_last_type_read_for_XMT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if (((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)>=(1)))))&&((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)<=(3)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 31 , MT / E1 , E2 , MATS , MTS , ((2*NEI)+2) , NEI / \n XMFS , XLFSS , { E , WE } { i = 1 to NEI } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["E1"]), write_opts);
                        // assign expression to variable E1
                        var_E1_0d_double_Scalar = py::cast<double>(cpp_current_dict["E1"]);
                        aux_E1_read = true;
                        validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                        aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                        cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E2"]), write_opts);
                        // assign expression to variable E2
                        var_E2_0d_double_Scalar = py::cast<double>(cpp_current_dict["E2"]);
                        aux_E2_read = true;
                        validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                        aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["MATS"]), write_opts);
                        // assign expression to variable MATS
                        var_MATS_0d_int_Scalar = py::cast<int>(cpp_current_dict["MATS"]);
                        aux_MATS_read = true;
                        validate_vartype_consistency("MATS", SCALAR_INT, aux_last_type_read_for_MATS);
                        aux_last_type_read_for_MATS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["MTS"]), write_opts);
                        // assign expression to variable MTS
                        var_MTS_0d_int_Scalar = py::cast<int>(cpp_current_dict["MTS"]);
                        aux_MTS_read = true;
                        validate_vartype_consistency("MTS", SCALAR_INT, aux_last_type_read_for_MTS);
                        aux_last_type_read_for_MTS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, ((2*py::cast<int>(cpp_current_dict["NEI"]))+2), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = ((2*py::cast<int>(cpp_current_dict["NEI"]))+2);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NEI
                        var_NEI_0d_int_Scalar = ((cpp_int_val+(-2))/2);
                        aux_NEI_read = true;
                        validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                        aux_last_type_read_for_NEI = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NEI"]), write_opts);
                        if ((! (aux_NEI_read == true))) {
                          // assign expression to variable NEI
                          var_NEI_0d_int_Scalar = py::cast<int>(cpp_current_dict["NEI"]);
                          aux_NEI_read = true;
                          validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                          aux_last_type_read_for_NEI = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, ((2*py::cast<int>(cpp_current_dict["NEI"]))+2), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = ((2*py::cast<int>(cpp_current_dict["NEI"]))+2);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["XMFS"]), write_opts);
                          // assign expression to variable XMFS
                          var_XMFS_0d_double_Scalar = py::cast<double>(cpp_current_dict["XMFS"]);
                          aux_XMFS_read = true;
                          validate_vartype_consistency("XMFS", SCALAR_DOUBLE, aux_last_type_read_for_XMFS);
                          aux_last_type_read_for_XMFS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["XLFSS"]), write_opts);
                          // assign expression to variable XLFSS
                          var_XLFSS_0d_double_Scalar = py::cast<double>(cpp_current_dict["XLFSS"]);
                          aux_XLFSS_read = true;
                          validate_vartype_consistency("XLFSS", SCALAR_DOUBLE, aux_last_type_read_for_XLFSS);
                          aux_last_type_read_for_XLFSS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }

                          for (int var_i_0d_int_Scalar = 1;
                             var_i_0d_int_Scalar <= var_NEI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                            bool aux_i_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["WE"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                            // assign expression to variable WE
                            var_WE_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["WE"][py::cast(var_i_0d_int_Scalar)]));
                            validate_vartype_consistency("WE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_WE);
                            aux_last_type_read_for_WE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
                cpp_current_dict = cpp_parent_dict_tmp;
              }
            }

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NI_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section ni_subsection
              {
                py::dict cpp_parent_dict_tmp = cpp_current_dict;
                if ((! cpp_parent_dict_tmp.contains("ni_subsection"))) {
                  cpp_parent_dict_tmp["ni_subsection"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict_tmp["ni_subsection"];
                if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                  cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                }
                cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                // variable declarations
                int var_LT_0d_int_Scalar;
                bool aux_LT_read = false;
                vartype aux_last_type_read_for_LT = UNKNOWN;
                int var_LB_0d_int_Scalar;
                bool aux_LB_read = false;
                vartype aux_last_type_read_for_LB = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NP_0d_int_Scalar;
                bool aux_NP_read = false;
                vartype aux_last_type_read_for_NP = UNKNOWN;
                NestedVector<double> var_Ek_1d_double_NestedVector;
                vartype aux_last_type_read_for_Ek = UNKNOWN;
                NestedVector<double> var_Fk_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fk = UNKNOWN;
                NestedVector<double> var_El_1d_double_NestedVector;
                vartype aux_last_type_read_for_El = UNKNOWN;
                NestedVector<double> var_Fl_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fl = UNKNOWN;
                int var_LS_0d_int_Scalar;
                bool aux_LS_read = false;
                vartype aux_last_type_read_for_LS = UNKNOWN;
                int var_NE_0d_int_Scalar;
                bool aux_NE_read = false;
                vartype aux_last_type_read_for_NE = UNKNOWN;
                NestedVector<double> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                Matrix2d<double> var_F_2d_double_Matrix2d;
                vartype aux_last_type_read_for_F = UNKNOWN;
                int var_NER_0d_int_Scalar;
                bool aux_NER_read = false;
                vartype aux_last_type_read_for_NER = UNKNOWN;
                int var_NEC_0d_int_Scalar;
                bool aux_NEC_read = false;
                vartype aux_last_type_read_for_NEC = UNKNOWN;
                NestedVector<double> var_ER_1d_double_NestedVector;
                vartype aux_last_type_read_for_ER = UNKNOWN;
                NestedVector<double> var_EC_1d_double_NestedVector;
                vartype aux_last_type_read_for_EC = UNKNOWN;
                NestedVector<double> var_F_1d_double_NestedVector;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                        int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                        bool& glob_aux_LT_read = aux_LT_read;
                        bool aux_LT_read = glob_aux_LT_read;
                        vartype aux_last_type_read_for_LT = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_cpp_int_val = cpp_int_val;
                        int cpp_int_val = glob_cpp_int_val;
                        bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                        bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                        int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                        bool& glob_aux_NP_read = aux_NP_read;
                        bool aux_NP_read = glob_aux_NP_read;
                        vartype aux_last_type_read_for_NP = UNKNOWN;
                        cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                        // read LIST record
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LT", -99999));
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = (2*py::cast<int>(cpp_current_dict.attr("get")("NP", -99999)));
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NP", -99999));
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)>=(0)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)<=(4)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LT"]), write_opts);
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LT"]);
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NP"])), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = (2*py::cast<int>(cpp_current_dict["NP"]));
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NP"]), write_opts);
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NP"]);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NP"])), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = (2*py::cast<int>(cpp_current_dict["NP"]));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= (var_NP_0d_int_Scalar-var_LT_0d_int_Scalar); var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Ek"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable Ek
                            var_Ek_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["Ek"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("Ek", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ek);
                            aux_last_type_read_for_Ek = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Fk"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable Fk
                            var_Fk_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["Fk"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("Fk", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fk);
                            aux_last_type_read_for_Fk = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_LT_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["El"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable El
                            var_El_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["El"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("El", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_El);
                            aux_last_type_read_for_El = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Fl"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable Fl
                            var_Fl_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["Fl"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("Fl", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fl);
                            aux_last_type_read_for_Fl = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          // read LIST record
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LS", -99999));
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NE", -99999));
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE-1))+1) , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LS"]), write_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LS"]);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_current_dict["NE"])*(py::cast<int>(cpp_current_dict["NE"])-1))+1), write_opts);
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_current_dict["NE"])*(py::cast<int>(cpp_current_dict["NE"])-1))+1), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = ((py::cast<int>(cpp_current_dict["NE"])*(py::cast<int>(cpp_current_dict["NE"])-1))+1);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = 1;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)][py::cast(var_kp_0d_int_Scalar)]), write_opts);
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)][py::cast(var_kp_0d_int_Scalar)]);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          // read LIST record
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LS", -99999));
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NE", -99999));
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE+1))/2) , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LS"]), write_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LS"]);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_current_dict["NE"])*(py::cast<int>(cpp_current_dict["NE"])+1))/2), write_opts);
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_current_dict["NE"])*(py::cast<int>(cpp_current_dict["NE"])+1))/2), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = ((py::cast<int>(cpp_current_dict["NE"])*(py::cast<int>(cpp_current_dict["NE"])+1))/2);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = var_k_0d_int_Scalar;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)][py::cast(var_kp_0d_int_Scalar)]), write_opts);
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)][py::cast(var_kp_0d_int_Scalar)]);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NER_0d_int_Scalar = var_NER_0d_int_Scalar;
                          int var_NER_0d_int_Scalar = glob_var_NER_0d_int_Scalar;
                          bool& glob_aux_NER_read = aux_NER_read;
                          bool aux_NER_read = glob_aux_NER_read;
                          vartype aux_last_type_read_for_NER = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NEC_0d_int_Scalar = var_NEC_0d_int_Scalar;
                          int var_NEC_0d_int_Scalar = glob_var_NEC_0d_int_Scalar;
                          bool& glob_aux_NEC_read = aux_NEC_read;
                          bool aux_NEC_read = glob_aux_NEC_read;
                          vartype aux_last_type_read_for_NEC = UNKNOWN;
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                          // read LIST record
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NER", -99999));
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (1+(py::cast<int>(cpp_current_dict.attr("get")("NER", -99999))*py::cast<int>(cpp_current_dict.attr("get")("NEC", -99999))));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NEC
                          var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                          aux_NEC_read = true;
                          validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                          aux_last_type_read_for_NEC = SCALAR_INT;
                          if ((! (aux_NER_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (1+(py::cast<int>(cpp_current_dict.attr("get")("NER", -99999))*py::cast<int>(cpp_current_dict.attr("get")("NEC", -99999))));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                          } else {
                          }
                          if ((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(6)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , 0 , LB , (1+(NER*NEC)) , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NER"]), write_opts);
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = py::cast<int>(cpp_current_dict["NER"]);
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, (1+(py::cast<int>(cpp_current_dict["NER"])*py::cast<int>(cpp_current_dict["NEC"]))), write_opts);
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (1+(py::cast<int>(cpp_current_dict["NER"])*py::cast<int>(cpp_current_dict["NEC"])));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NEC
                          var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                          aux_NEC_read = true;
                          validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                          aux_last_type_read_for_NEC = SCALAR_INT;
                          if ((! (aux_NER_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (1+(py::cast<int>(cpp_current_dict["NER"])*py::cast<int>(cpp_current_dict["NEC"])));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, (1+(py::cast<int>(cpp_current_dict["NER"])*py::cast<int>(cpp_current_dict["NEC"]))), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = (1+(py::cast<int>(cpp_current_dict["NER"])*py::cast<int>(cpp_current_dict["NEC"])));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NER_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable ER
                              var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                              aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NEC_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["EC"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable EC
                              var_EC_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["EC"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("EC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EC);
                              aux_last_type_read_for_EC = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NER_0d_int_Scalar-1), 1, (var_NEC_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NER_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_l_0d_int_Scalar = 1;
                                 var_l_0d_int_Scalar <= (var_NEC_0d_int_Scalar-1); var_l_0d_int_Scalar++) {
                                bool aux_l_read = true;
                                // read LIST body
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]), write_opts);
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_l_0d_int_Scalar) = py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                          int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                          bool& glob_aux_LT_read = aux_LT_read;
                          bool aux_LT_read = glob_aux_LT_read;
                          vartype aux_last_type_read_for_LT = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                          int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                          bool& glob_aux_NP_read = aux_NP_read;
                          bool aux_NP_read = glob_aux_NP_read;
                          vartype aux_last_type_read_for_NP = UNKNOWN;
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                          // read LIST record
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LT", -99999));
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (2*py::cast<int>(cpp_current_dict.attr("get")("NP", -99999)));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NP", -99999));
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                          if ((((((((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(8))))))||(((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(9)))))))))&&((((aux_LT_read == true)) && ((var_LT_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 31 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LT"]), write_opts);
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LT"]);
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NP"])), write_opts);
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (2*py::cast<int>(cpp_current_dict["NP"]));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NP"]), write_opts);
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NP"]);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NP"])), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = (2*py::cast<int>(cpp_current_dict["NP"]));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable F
                              var_F_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                }
                cpp_current_dict = cpp_parent_dict_tmp;
              }
            }
            cpp_current_dict = cpp_parent_dict_tmp;
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 89a763d6f809f216a36f99ade3a07a08
// MD5 hash of the following function definition: 60259da622fbaedd01b6a50ce5056a93
void write_mf32_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NIS_0d_int_Scalar;
  bool aux_NIS_read = false;
  vartype aux_last_type_read_for_NIS = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 32;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 32;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 32 , 151 / ZA , AWR , 0 , 0 , NIS , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NIS"]), write_opts);
  // assign expression to variable NIS
  var_NIS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NIS"]);
  aux_NIS_read = true;
  validate_vartype_consistency("NIS", SCALAR_INT, aux_last_type_read_for_NIS);
  aux_last_type_read_for_NIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_i_0d_int_Scalar = 1;
     var_i_0d_int_Scalar <= var_NIS_0d_int_Scalar; var_i_0d_int_Scalar++) {
    bool aux_i_read = true;
    // open section isotope
    {
      py::dict cpp_parent_dict_tmp = cpp_current_dict;
      if ((! cpp_parent_dict_tmp.contains("isotope"))) {
        cpp_parent_dict_tmp["isotope"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict_tmp["isotope"];
      if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
      // variable declarations
      double var_ZAI_0d_double_Scalar;
      bool aux_ZAI_read = false;
      vartype aux_last_type_read_for_ZAI = UNKNOWN;
      double var_ABN_0d_double_Scalar;
      bool aux_ABN_read = false;
      vartype aux_last_type_read_for_ABN = UNKNOWN;
      int var_LFW_0d_int_Scalar;
      bool aux_LFW_read = false;
      vartype aux_last_type_read_for_LFW = UNKNOWN;
      int var_NER_0d_int_Scalar;
      bool aux_NER_read = false;
      vartype aux_last_type_read_for_NER = UNKNOWN;
      cpp_template = "[ MAT , 32 , 151 / ZAI , ABN , 0 , LFW , NER , 0 ] CONT";
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
      // read CONT record
      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZAI"]), write_opts);
      // assign expression to variable ZAI
      var_ZAI_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZAI"]);
      aux_ZAI_read = true;
      validate_vartype_consistency("ZAI", SCALAR_DOUBLE, aux_last_type_read_for_ZAI);
      aux_last_type_read_for_ZAI = SCALAR_DOUBLE;
      cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["ABN"]), write_opts);
      // assign expression to variable ABN
      var_ABN_0d_double_Scalar = py::cast<double>(cpp_current_dict["ABN"]);
      aux_ABN_read = true;
      validate_vartype_consistency("ABN", SCALAR_DOUBLE, aux_last_type_read_for_ABN);
      aux_last_type_read_for_ABN = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LFW"]), write_opts);
      // assign expression to variable LFW
      var_LFW_0d_int_Scalar = py::cast<int>(cpp_current_dict["LFW"]);
      aux_LFW_read = true;
      validate_vartype_consistency("LFW", SCALAR_INT, aux_last_type_read_for_LFW);
      aux_last_type_read_for_LFW = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NER"]), write_opts);
      // assign expression to variable NER
      var_NER_0d_int_Scalar = py::cast<int>(cpp_current_dict["NER"]);
      aux_NER_read = true;
      validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
      aux_last_type_read_for_NER = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
      cont << cpp_draft_line;

      for (int var_j_0d_int_Scalar = 1;
         var_j_0d_int_Scalar <= var_NER_0d_int_Scalar; var_j_0d_int_Scalar++) {
        bool aux_j_read = true;
        // open section range
        {
          py::dict cpp_parent_dict_tmp = cpp_current_dict;
          if ((! cpp_parent_dict_tmp.contains("range"))) {
            cpp_parent_dict_tmp["range"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict_tmp["range"];
          if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
            cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
          }
          cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
          // variable declarations
          double var_EL_0d_double_Scalar;
          bool aux_EL_read = false;
          vartype aux_last_type_read_for_EL = UNKNOWN;
          double var_EH_0d_double_Scalar;
          bool aux_EH_read = false;
          vartype aux_last_type_read_for_EH = UNKNOWN;
          int var_LRU_0d_int_Scalar;
          bool aux_LRU_read = false;
          vartype aux_last_type_read_for_LRU = UNKNOWN;
          int var_LRF_0d_int_Scalar;
          bool aux_LRF_read = false;
          vartype aux_last_type_read_for_LRF = UNKNOWN;
          int var_NRO_0d_int_Scalar;
          bool aux_NRO_read = false;
          vartype aux_last_type_read_for_NRO = UNKNOWN;
          int var_NAPS_0d_int_Scalar;
          bool aux_NAPS_read = false;
          vartype aux_last_type_read_for_NAPS = UNKNOWN;
          int var_NI_0d_int_Scalar;
          bool aux_NI_read = false;
          vartype aux_last_type_read_for_NI = UNKNOWN;
          double var_SPI_0d_double_Scalar;
          bool aux_SPI_read = false;
          vartype aux_last_type_read_for_SPI = UNKNOWN;
          double var_AP_0d_double_Scalar;
          bool aux_AP_read = false;
          vartype aux_last_type_read_for_AP = UNKNOWN;
          int var_LCOMP_0d_int_Scalar;
          bool aux_LCOMP_read = false;
          vartype aux_last_type_read_for_LCOMP = UNKNOWN;
          int var_NLS_0d_int_Scalar;
          bool aux_NLS_read = false;
          vartype aux_last_type_read_for_NLS = UNKNOWN;
          int var_ISR_0d_int_Scalar;
          bool aux_ISR_read = false;
          vartype aux_last_type_read_for_ISR = UNKNOWN;
          double var_DAP_0d_double_Scalar;
          bool aux_DAP_read = false;
          vartype aux_last_type_read_for_DAP = UNKNOWN;
          double var_AWRI_0d_double_Scalar;
          bool aux_AWRI_read = false;
          vartype aux_last_type_read_for_AWRI = UNKNOWN;
          int var_NSRS_0d_int_Scalar;
          bool aux_NSRS_read = false;
          vartype aux_last_type_read_for_NSRS = UNKNOWN;
          int var_NLRS_0d_int_Scalar;
          bool aux_NLRS_read = false;
          vartype aux_last_type_read_for_NLRS = UNKNOWN;
          int var_MLS_0d_int_Scalar;
          bool aux_MLS_read = false;
          vartype aux_last_type_read_for_MLS = UNKNOWN;
          NestedVector<double> var_DAP_1d_double_NestedVector;
          int var_JCH_0d_int_Scalar;
          bool aux_JCH_read = false;
          vartype aux_last_type_read_for_JCH = UNKNOWN;
          int cpp_int_val;
          bool aux_cpp_int_val_read = false;
          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
          int var_NCH_0d_int_Scalar;
          bool aux_NCH_read = false;
          vartype aux_last_type_read_for_NCH = UNKNOWN;
          Matrix2d<double> var_DAP_2d_double_Matrix2d;
          double var_QX_0d_double_Scalar;
          bool aux_QX_read = false;
          vartype aux_last_type_read_for_QX = UNKNOWN;
          int var_LRX_0d_int_Scalar;
          bool aux_LRX_read = false;
          vartype aux_last_type_read_for_LRX = UNKNOWN;
          int var_NRSA_0d_int_Scalar;
          bool aux_NRSA_read = false;
          vartype aux_last_type_read_for_NRSA = UNKNOWN;
          NestedVector<double> var_ER_1d_double_NestedVector;
          vartype aux_last_type_read_for_ER = UNKNOWN;
          NestedVector<double> var_AJ_1d_double_NestedVector;
          vartype aux_last_type_read_for_AJ = UNKNOWN;
          NestedVector<double> var_GT_1d_double_NestedVector;
          vartype aux_last_type_read_for_GT = UNKNOWN;
          NestedVector<double> var_GN_1d_double_NestedVector;
          vartype aux_last_type_read_for_GN = UNKNOWN;
          NestedVector<double> var_GG_1d_double_NestedVector;
          vartype aux_last_type_read_for_GG = UNKNOWN;
          NestedVector<double> var_GF_1d_double_NestedVector;
          vartype aux_last_type_read_for_GF = UNKNOWN;
          NestedVector<double> var_DER_1d_double_NestedVector;
          vartype aux_last_type_read_for_DER = UNKNOWN;
          NestedVector<double> var_DGN_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGN = UNKNOWN;
          NestedVector<double> var_DGG_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGG = UNKNOWN;
          NestedVector<double> var_DGF_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGF = UNKNOWN;
          int var_NDIGIT_0d_int_Scalar;
          bool aux_NDIGIT_read = false;
          vartype aux_last_type_read_for_NDIGIT = UNKNOWN;
          int var_NNN_0d_int_Scalar;
          bool aux_NNN_read = false;
          vartype aux_last_type_read_for_NNN = UNKNOWN;
          int var_NM_0d_int_Scalar;
          bool aux_NM_read = false;
          vartype aux_last_type_read_for_NM = UNKNOWN;
          NestedVector<int> var_II_1d_int_NestedVector;
          vartype aux_last_type_read_for_II = UNKNOWN;
          NestedVector<int> var_JJ_1d_int_NestedVector;
          vartype aux_last_type_read_for_JJ = UNKNOWN;
          NestedVector<std::vector<int>> var_KIJ_1d_intvec_NestedVector;
          vartype aux_last_type_read_for_KIJ = UNKNOWN;
          int var_LAD_0d_int_Scalar;
          bool aux_LAD_read = false;
          vartype aux_last_type_read_for_LAD = UNKNOWN;
          double var_APL_0d_double_Scalar;
          bool aux_APL_read = false;
          vartype aux_last_type_read_for_APL = UNKNOWN;
          NestedVector<double> var_GFA_1d_double_NestedVector;
          vartype aux_last_type_read_for_GFA = UNKNOWN;
          NestedVector<double> var_GFB_1d_double_NestedVector;
          vartype aux_last_type_read_for_GFB = UNKNOWN;
          NestedVector<double> var_DGFA_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGFA = UNKNOWN;
          NestedVector<double> var_DGFB_1d_double_NestedVector;
          vartype aux_last_type_read_for_DGFB = UNKNOWN;
          int var_IFG_0d_int_Scalar;
          bool aux_IFG_read = false;
          vartype aux_last_type_read_for_IFG = UNKNOWN;
          int var_NJS_0d_int_Scalar;
          bool aux_NJS_read = false;
          vartype aux_last_type_read_for_NJS = UNKNOWN;
          int var_NJCH_0d_int_Scalar;
          bool aux_NJCH_read = false;
          vartype aux_last_type_read_for_NJCH = UNKNOWN;
          int var_NPP_0d_int_Scalar;
          bool aux_NPP_read = false;
          vartype aux_last_type_read_for_NPP = UNKNOWN;
          int var_NJSX_0d_int_Scalar;
          bool aux_NJSX_read = false;
          vartype aux_last_type_read_for_NJSX = UNKNOWN;
          NestedVector<double> var_MA_1d_double_NestedVector;
          vartype aux_last_type_read_for_MA = UNKNOWN;
          NestedVector<double> var_MB_1d_double_NestedVector;
          vartype aux_last_type_read_for_MB = UNKNOWN;
          NestedVector<double> var_ZA_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZA = UNKNOWN;
          NestedVector<double> var_ZB_1d_double_NestedVector;
          vartype aux_last_type_read_for_ZB = UNKNOWN;
          NestedVector<double> var_IA_1d_double_NestedVector;
          vartype aux_last_type_read_for_IA = UNKNOWN;
          NestedVector<double> var_IB_1d_double_NestedVector;
          vartype aux_last_type_read_for_IB = UNKNOWN;
          NestedVector<double> var_Q_1d_double_NestedVector;
          vartype aux_last_type_read_for_Q = UNKNOWN;
          NestedVector<double> var_PNT_1d_double_NestedVector;
          vartype aux_last_type_read_for_PNT = UNKNOWN;
          NestedVector<double> var_SHF_1d_double_NestedVector;
          vartype aux_last_type_read_for_SHF = UNKNOWN;
          NestedVector<double> var_MT_1d_double_NestedVector;
          vartype aux_last_type_read_for_MT = UNKNOWN;
          NestedVector<double> var_PA_1d_double_NestedVector;
          vartype aux_last_type_read_for_PA = UNKNOWN;
          NestedVector<double> var_PB_1d_double_NestedVector;
          vartype aux_last_type_read_for_PB = UNKNOWN;
          int var_MPAR_0d_int_Scalar;
          bool aux_MPAR_read = false;
          vartype aux_last_type_read_for_MPAR = UNKNOWN;
          int var_NPAR_0d_int_Scalar;
          bool aux_NPAR_read = false;
          vartype aux_last_type_read_for_NPAR = UNKNOWN;
          Matrix2d<double> var_RV_2d_double_Matrix2d;
          vartype aux_last_type_read_for_RV = UNKNOWN;
          cpp_template = "[ MAT , 32 , 151 / EL , EH , LRU , LRF , NRO , NAPS ] CONT";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read CONT record
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["EL"]), write_opts);
          // assign expression to variable EL
          var_EL_0d_double_Scalar = py::cast<double>(cpp_current_dict["EL"]);
          aux_EL_read = true;
          validate_vartype_consistency("EL", SCALAR_DOUBLE, aux_last_type_read_for_EL);
          aux_last_type_read_for_EL = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["EH"]), write_opts);
          // assign expression to variable EH
          var_EH_0d_double_Scalar = py::cast<double>(cpp_current_dict["EH"]);
          aux_EH_read = true;
          validate_vartype_consistency("EH", SCALAR_DOUBLE, aux_last_type_read_for_EH);
          aux_last_type_read_for_EH = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LRU"]), write_opts);
          // assign expression to variable LRU
          var_LRU_0d_int_Scalar = py::cast<int>(cpp_current_dict["LRU"]);
          aux_LRU_read = true;
          validate_vartype_consistency("LRU", SCALAR_INT, aux_last_type_read_for_LRU);
          aux_last_type_read_for_LRU = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LRF"]), write_opts);
          // assign expression to variable LRF
          var_LRF_0d_int_Scalar = py::cast<int>(cpp_current_dict["LRF"]);
          aux_LRF_read = true;
          validate_vartype_consistency("LRF", SCALAR_INT, aux_last_type_read_for_LRF);
          aux_last_type_read_for_LRF = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NRO"]), write_opts);
          // assign expression to variable NRO
          var_NRO_0d_int_Scalar = py::cast<int>(cpp_current_dict["NRO"]);
          aux_NRO_read = true;
          validate_vartype_consistency("NRO", SCALAR_INT, aux_last_type_read_for_NRO);
          aux_last_type_read_for_NRO = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NAPS"]), write_opts);
          // assign expression to variable NAPS
          var_NAPS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NAPS"]);
          aux_NAPS_read = true;
          validate_vartype_consistency("NAPS", SCALAR_INT, aux_last_type_read_for_NAPS);
          aux_last_type_read_for_NAPS = SCALAR_INT;
          cont << cpp_draft_line;
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              if ((((((((aux_NRO_read == true)) && ((var_NRO_0d_int_Scalar)!=(0)))))))) {
                // if statement evaluation
                cpp_found_match = true;
                cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , 0 , NI ] CONT";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                // read CONT record
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NI"]), write_opts);
                // assign expression to variable NI
                var_NI_0d_int_Scalar = py::cast<int>(cpp_current_dict["NI"]);
                aux_NI_read = true;
                validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
                aux_last_type_read_for_NI = SCALAR_INT;
                cont << cpp_draft_line;
              }
            }
          }
          // evaluate if-elif-else clause
          {
            bool cpp_found_match = false;
            if (! cpp_found_match) {
              // if statement evaluation with lookahead
              {
                {
                  // variable declarations
                  double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                  double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                  bool& glob_aux_EL_read = aux_EL_read;
                  bool aux_EL_read = glob_aux_EL_read;
                  vartype aux_last_type_read_for_EL = UNKNOWN;
                  double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                  double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                  bool& glob_aux_EH_read = aux_EH_read;
                  bool aux_EH_read = glob_aux_EH_read;
                  vartype aux_last_type_read_for_EH = UNKNOWN;
                  int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                  int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                  bool& glob_aux_LRU_read = aux_LRU_read;
                  bool aux_LRU_read = glob_aux_LRU_read;
                  vartype aux_last_type_read_for_LRU = UNKNOWN;
                  int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                  int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                  bool& glob_aux_LRF_read = aux_LRF_read;
                  bool aux_LRF_read = glob_aux_LRF_read;
                  vartype aux_last_type_read_for_LRF = UNKNOWN;
                  int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                  int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                  bool& glob_aux_NRO_read = aux_NRO_read;
                  bool aux_NRO_read = glob_aux_NRO_read;
                  vartype aux_last_type_read_for_NRO = UNKNOWN;
                  int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                  int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                  bool& glob_aux_NAPS_read = aux_NAPS_read;
                  bool aux_NAPS_read = glob_aux_NAPS_read;
                  vartype aux_last_type_read_for_NAPS = UNKNOWN;
                  int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                  int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                  bool& glob_aux_NI_read = aux_NI_read;
                  bool aux_NI_read = glob_aux_NI_read;
                  vartype aux_last_type_read_for_NI = UNKNOWN;
                  double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                  double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                  bool& glob_aux_SPI_read = aux_SPI_read;
                  bool aux_SPI_read = glob_aux_SPI_read;
                  vartype aux_last_type_read_for_SPI = UNKNOWN;
                  double& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                  double var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                  bool& glob_aux_AP_read = aux_AP_read;
                  bool aux_AP_read = glob_aux_AP_read;
                  vartype aux_last_type_read_for_AP = UNKNOWN;
                  int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                  int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                  bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                  bool aux_LCOMP_read = glob_aux_LCOMP_read;
                  vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                  int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                  int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                  bool& glob_aux_NLS_read = aux_NLS_read;
                  bool aux_NLS_read = glob_aux_NLS_read;
                  vartype aux_last_type_read_for_NLS = UNKNOWN;
                  int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                  int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                  bool& glob_aux_ISR_read = aux_ISR_read;
                  bool aux_ISR_read = glob_aux_ISR_read;
                  vartype aux_last_type_read_for_ISR = UNKNOWN;
                  cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                  // read CONT record
                  // assign expression to variable SPI
                  var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("SPI", -99999.9));
                  aux_SPI_read = true;
                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                  // assign expression to variable AP
                  var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AP", -99999.9));
                  aux_AP_read = true;
                  validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                  aux_last_type_read_for_AP = SCALAR_DOUBLE;
                  // assign expression to variable LCOMP
                  var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LCOMP", -99999));
                  aux_LCOMP_read = true;
                  validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                  aux_last_type_read_for_LCOMP = SCALAR_INT;
                  // assign expression to variable NLS
                  var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NLS", -99999));
                  aux_NLS_read = true;
                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                  aux_last_type_read_for_NLS = SCALAR_INT;
                  // assign expression to variable ISR
                  var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("ISR", -99999));
                  aux_ISR_read = true;
                  validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                  aux_last_type_read_for_ISR = SCALAR_INT;
                  if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(0)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&(((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))))))) {
                    cpp_found_match = true;
                  }
                }
                if (cpp_found_match) {
                  cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  // read CONT record
                  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                  // assign expression to variable SPI
                  var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                  aux_SPI_read = true;
                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AP"]), write_opts);
                  // assign expression to variable AP
                  var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict["AP"]);
                  aux_AP_read = true;
                  validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                  aux_last_type_read_for_AP = SCALAR_DOUBLE;
                  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LCOMP"]), write_opts);
                  // assign expression to variable LCOMP
                  var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCOMP"]);
                  aux_LCOMP_read = true;
                  validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                  aux_last_type_read_for_LCOMP = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                  // assign expression to variable NLS
                  var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                  aux_NLS_read = true;
                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                  aux_last_type_read_for_NLS = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["ISR"]), write_opts);
                  // assign expression to variable ISR
                  var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict["ISR"]);
                  aux_ISR_read = true;
                  validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                  aux_last_type_read_for_ISR = SCALAR_INT;
                  cont << cpp_draft_line;
                  // evaluate if-elif-else clause
                  {
                    bool cpp_found_match = false;
                    if (! cpp_found_match) {
                      if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)!=(0)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , DAP , 0 , 0 , 0 , 0 ] CONT";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read CONT record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["DAP"]), write_opts);
                        // assign expression to variable DAP
                        var_DAP_0d_double_Scalar = py::cast<double>(cpp_current_dict["DAP"]);
                        aux_DAP_read = true;
                        validate_vartype_consistency("DAP", SCALAR_DOUBLE, aux_last_type_read_for_DAP);
                        aux_last_type_read_for_DAP = SCALAR_DOUBLE;
                        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                        cont << cpp_draft_line;
                      }
                    }
                  }

                  for (int var_k_0d_int_Scalar = 1;
                     var_k_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                    bool aux_k_read = true;
                    // open section somesec
                    {
                      py::dict cpp_parent_dict_tmp = cpp_current_dict;
                      if ((! cpp_parent_dict_tmp.contains("somesec"))) {
                        cpp_parent_dict_tmp["somesec"] = py::dict();
                      }
                      py::dict cpp_current_dict = cpp_parent_dict_tmp["somesec"];
                      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                      }
                      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                      // variable declarations
                      double var_AWRI_0d_double_Scalar;
                      bool aux_AWRI_read = false;
                      vartype aux_last_type_read_for_AWRI = UNKNOWN;
                      int var_L_0d_int_Scalar;
                      bool aux_L_read = false;
                      vartype aux_last_type_read_for_L = UNKNOWN;
                      int cpp_int_val;
                      bool aux_cpp_int_val_read = false;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int var_NRS_0d_int_Scalar;
                      bool aux_NRS_read = false;
                      vartype aux_last_type_read_for_NRS = UNKNOWN;
                      NestedVector<double> var_ER_1d_double_NestedVector;
                      vartype aux_last_type_read_for_ER = UNKNOWN;
                      NestedVector<double> var_AJ_1d_double_NestedVector;
                      vartype aux_last_type_read_for_AJ = UNKNOWN;
                      NestedVector<double> var_GT_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GT = UNKNOWN;
                      NestedVector<double> var_GN_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GN = UNKNOWN;
                      NestedVector<double> var_GG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GG = UNKNOWN;
                      NestedVector<double> var_GF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GF = UNKNOWN;
                      NestedVector<double> var_DE2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DE2 = UNKNOWN;
                      NestedVector<double> var_DN2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DN2 = UNKNOWN;
                      NestedVector<double> var_DNDG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DNDG = UNKNOWN;
                      NestedVector<double> var_DG2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DG2 = UNKNOWN;
                      NestedVector<double> var_DNDF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DNDF = UNKNOWN;
                      NestedVector<double> var_DGDF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DGDF = UNKNOWN;
                      NestedVector<double> var_DF2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DF2 = UNKNOWN;
                      NestedVector<double> var_DJDN_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJDN = UNKNOWN;
                      NestedVector<double> var_DJDG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJDG = UNKNOWN;
                      NestedVector<double> var_DJDF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJDF = UNKNOWN;
                      NestedVector<double> var_DJ2_1d_double_NestedVector;
                      vartype aux_last_type_read_for_DJ2 = UNKNOWN;
                      cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , L , 0 , (18*NRS) , NRS / \n { ER , AJ , GT , GN , GG , GF , \n DE2 , DN2 , DNDG , DG2 , DNDF , DGDF , \n DF2 , DJDN , DJDG , DJDF , DJ2 , 0.0 } { m = 1 to NRS } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read LIST record
                      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AWRI"]), write_opts);
                      // assign expression to variable AWRI
                      var_AWRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWRI"]);
                      aux_AWRI_read = true;
                      validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                      aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                      cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["L"]), write_opts);
                      // assign expression to variable L
                      var_L_0d_int_Scalar = py::cast<int>(cpp_current_dict["L"]);
                      aux_L_read = true;
                      validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                      aux_last_type_read_for_L = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, (18*py::cast<int>(cpp_current_dict["NRS"])), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (18*py::cast<int>(cpp_current_dict["NRS"]));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NRS
                      var_NRS_0d_int_Scalar = (cpp_int_val/18);
                      aux_NRS_read = true;
                      validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                      aux_last_type_read_for_NRS = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NRS"]), write_opts);
                      if ((! (aux_NRS_read == true))) {
                        // assign expression to variable NRS
                        var_NRS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NRS"]);
                        aux_NRS_read = true;
                        validate_vartype_consistency("NRS", SCALAR_INT, aux_last_type_read_for_NRS);
                        aux_last_type_read_for_NRS = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (18*py::cast<int>(cpp_current_dict["NRS"])), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (18*py::cast<int>(cpp_current_dict["NRS"]));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST body

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NRS_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // read LIST body
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable ER
                          var_ER_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["ER"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                          aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable AJ
                          var_AJ_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                          aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GT"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable GT
                          var_GT_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["GT"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                          aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GN"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable GN
                          var_GN_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["GN"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                          aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GG"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable GG
                          var_GG_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["GG"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                          aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GF"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable GF
                          var_GF_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["GF"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                          aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DE2"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable DE2
                          var_DE2_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DE2"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("DE2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DE2);
                          aux_last_type_read_for_DE2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DN2"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable DN2
                          var_DN2_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DN2"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("DN2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DN2);
                          aux_last_type_read_for_DN2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DNDG"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable DNDG
                          var_DNDG_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DNDG"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("DNDG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DNDG);
                          aux_last_type_read_for_DNDG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DG2"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable DG2
                          var_DG2_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DG2"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("DG2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DG2);
                          aux_last_type_read_for_DG2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DNDF"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable DNDF
                          var_DNDF_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DNDF"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("DNDF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DNDF);
                          aux_last_type_read_for_DNDF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DGDF"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable DGDF
                          var_DGDF_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DGDF"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("DGDF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGDF);
                          aux_last_type_read_for_DGDF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DF2"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable DF2
                          var_DF2_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DF2"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("DF2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DF2);
                          aux_last_type_read_for_DF2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DJDN"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable DJDN
                          var_DJDN_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DJDN"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("DJDN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJDN);
                          aux_last_type_read_for_DJDN = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DJDG"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable DJDG
                          var_DJDG_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DJDG"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("DJDG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJDG);
                          aux_last_type_read_for_DJDG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DJDF"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable DJDF
                          var_DJDF_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DJDF"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("DJDF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJDF);
                          aux_last_type_read_for_DJDF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DJ2"][py::cast(var_m_0d_int_Scalar)]), write_opts);
                          // assign expression to variable DJ2
                          var_DJ2_1d_double_NestedVector.set(var_m_0d_int_Scalar, py::cast<double>(cpp_current_dict["DJ2"][py::cast(var_m_0d_int_Scalar)]));
                          validate_vartype_consistency("DJ2", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DJ2);
                          aux_last_type_read_for_DJ2 = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                      cpp_current_dict = cpp_parent_dict_tmp;
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    double& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    double var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                    int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                    bool& glob_aux_NLS_read = aux_NLS_read;
                    bool aux_NLS_read = glob_aux_NLS_read;
                    vartype aux_last_type_read_for_NLS = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("SPI", -99999.9));
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AP", -99999.9));
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LCOMP", -99999));
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NLS", -99999));
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("ISR", -99999));
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(1)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&(((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read CONT record
                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AP"]), write_opts);
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict["AP"]);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LCOMP"]), write_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCOMP"]);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["ISR"]), write_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict["ISR"]);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    cont << cpp_draft_line;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , DAP , 0 , 0 , 0 , 0 ] CONT";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read CONT record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["DAP"]), write_opts);
                          // assign expression to variable DAP
                          var_DAP_0d_double_Scalar = py::cast<double>(cpp_current_dict["DAP"]);
                          aux_DAP_read = true;
                          validate_vartype_consistency("DAP", SCALAR_DOUBLE, aux_last_type_read_for_DAP);
                          aux_last_type_read_for_DAP = SCALAR_DOUBLE;
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                          cont << cpp_draft_line;
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , 0 , 0 , NSRS , NLRS ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read CONT record
                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AWRI"]), write_opts);
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWRI"]);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NSRS"]), write_opts);
                    // assign expression to variable NSRS
                    var_NSRS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NSRS"]);
                    aux_NSRS_read = true;
                    validate_vartype_consistency("NSRS", SCALAR_INT, aux_last_type_read_for_NSRS);
                    aux_last_type_read_for_NSRS = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NLRS"]), write_opts);
                    // assign expression to variable NLRS
                    var_NLRS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLRS"]);
                    aux_NLRS_read = true;
                    validate_vartype_consistency("NLRS", SCALAR_INT, aux_last_type_read_for_NLRS);
                    aux_last_type_read_for_NLRS = SCALAR_INT;
                    cont << cpp_draft_line;

                    for (int var_p_0d_int_Scalar = 1;
                       var_p_0d_int_Scalar <= var_NSRS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                      bool aux_p_read = true;
                      // open section nsrs_subsec
                      {
                        py::dict cpp_parent_dict_tmp = cpp_current_dict;
                        if ((! cpp_parent_dict_tmp.contains("nsrs_subsec"))) {
                          cpp_parent_dict_tmp["nsrs_subsec"] = py::dict();
                        }
                        py::dict cpp_current_dict = cpp_parent_dict_tmp["nsrs_subsec"];
                        if ((! cpp_current_dict.contains(py::cast(var_p_0d_int_Scalar)))) {
                          cpp_current_dict[py::cast(var_p_0d_int_Scalar)] = py::dict();
                        }
                        cpp_current_dict = cpp_current_dict[py::cast(var_p_0d_int_Scalar)];
                        // variable declarations
                        int var_MPAR_0d_int_Scalar;
                        bool aux_MPAR_read = false;
                        vartype aux_last_type_read_for_MPAR = UNKNOWN;
                        int var_NRB_0d_int_Scalar;
                        bool aux_NRB_read = false;
                        vartype aux_last_type_read_for_NRB = UNKNOWN;
                        NestedVector<double> var_ER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_ER = UNKNOWN;
                        NestedVector<double> var_AJ_1d_double_NestedVector;
                        vartype aux_last_type_read_for_AJ = UNKNOWN;
                        NestedVector<double> var_GT_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GT = UNKNOWN;
                        NestedVector<double> var_GN_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GN = UNKNOWN;
                        NestedVector<double> var_GG_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GG = UNKNOWN;
                        NestedVector<double> var_GF_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GF = UNKNOWN;
                        Matrix2d<double> var_V_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_V = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , MPAR , 0 , ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2)) , NRB / \n { ER , AJ , GT , GN , GG , GF } { k = 1 to NRB } , \n { { V } { n = m to (MPAR*NRB) } } { m = 1 to (MPAR*NRB) } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["MPAR"]), write_opts);
                        // assign expression to variable MPAR
                        var_MPAR_0d_int_Scalar = py::cast<int>(cpp_current_dict["MPAR"]);
                        aux_MPAR_read = true;
                        validate_vartype_consistency("MPAR", SCALAR_INT, aux_last_type_read_for_MPAR);
                        aux_last_type_read_for_MPAR = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NRB"]), write_opts);
                        // assign expression to variable NRB
                        var_NRB_0d_int_Scalar = py::cast<int>(cpp_current_dict["NRB"]);
                        aux_NRB_read = true;
                        validate_vartype_consistency("NRB", SCALAR_INT, aux_last_type_read_for_NRB);
                        aux_last_type_read_for_NRB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, ((6*py::cast<int>(cpp_current_dict["NRB"]))+(((py::cast<int>(cpp_current_dict["MPAR"])*py::cast<int>(cpp_current_dict["NRB"]))*((py::cast<int>(cpp_current_dict["MPAR"])*py::cast<int>(cpp_current_dict["NRB"]))+1))/2)), write_opts);
                        if ((! (aux_MPAR_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for MPAR because this variable could not be isolated.");
                        } else {
                        }
                        if ((! (aux_NRB_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for NRB because this variable could not be isolated.");
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, ((6*py::cast<int>(cpp_current_dict["NRB"]))+(((py::cast<int>(cpp_current_dict["MPAR"])*py::cast<int>(cpp_current_dict["NRB"]))*((py::cast<int>(cpp_current_dict["MPAR"])*py::cast<int>(cpp_current_dict["NRB"]))+1))/2)), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = ((6*py::cast<int>(cpp_current_dict["NRB"]))+(((py::cast<int>(cpp_current_dict["MPAR"])*py::cast<int>(cpp_current_dict["NRB"]))*((py::cast<int>(cpp_current_dict["MPAR"])*py::cast<int>(cpp_current_dict["NRB"]))+1))/2));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NRB_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable AJ
                            var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                            aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GT"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable GT
                            var_GT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GT"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                            aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GN"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable GN
                            var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GN"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                            aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable GG
                            var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                            aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GF"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable GF
                            var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GF"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                            aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          var_V_2d_double_Matrix2d.init(1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), 1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), true, false);

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body

                            for (int var_n_0d_int_Scalar = var_m_0d_int_Scalar;
                               var_n_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_n_0d_int_Scalar++) {
                              bool aux_n_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["V"][py::cast(var_m_0d_int_Scalar)][py::cast(var_n_0d_int_Scalar)]), write_opts);
                              // assign expression to variable V
                              var_V_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = py::cast<double>(cpp_current_dict["V"][py::cast(var_m_0d_int_Scalar)][py::cast(var_n_0d_int_Scalar)]);
                              validate_vartype_consistency("V", MATRIX2D_DOUBLE, aux_last_type_read_for_V);
                              aux_last_type_read_for_V = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                        cpp_current_dict = cpp_parent_dict_tmp;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    double& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    double var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_NLS_0d_int_Scalar = var_NLS_0d_int_Scalar;
                    int var_NLS_0d_int_Scalar = glob_var_NLS_0d_int_Scalar;
                    bool& glob_aux_NLS_read = aux_NLS_read;
                    bool aux_NLS_read = glob_aux_NLS_read;
                    vartype aux_last_type_read_for_NLS = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("SPI", -99999.9));
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AP", -99999.9));
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LCOMP", -99999));
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NLS", -99999));
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("ISR", -99999));
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(1)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(3)))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , NLS , ISR ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read CONT record
                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AP"]), write_opts);
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict["AP"]);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LCOMP"]), write_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCOMP"]);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                    // assign expression to variable NLS
                    var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                    aux_NLS_read = true;
                    validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                    aux_last_type_read_for_NLS = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["ISR"]), write_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict["ISR"]);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    cont << cpp_draft_line;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , MLS , 1 / \n { DAP } { k = 1 to MLS } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["MLS"]), write_opts);
                          // assign expression to variable MLS
                          var_MLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["MLS"]);
                          aux_MLS_read = true;
                          validate_vartype_consistency("MLS", SCALAR_INT, aux_last_type_read_for_MLS);
                          aux_last_type_read_for_MLS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, 1, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["MLS"]), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = py::cast<int>(cpp_current_dict["MLS"]);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_MLS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DAP"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable DAP
                              var_DAP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["DAP"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("DAP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DAP);
                              aux_last_type_read_for_DAP = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , 0 , 0 , NSRS , NLRS ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read CONT record
                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AWRI"]), write_opts);
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWRI"]);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NSRS"]), write_opts);
                    // assign expression to variable NSRS
                    var_NSRS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NSRS"]);
                    aux_NSRS_read = true;
                    validate_vartype_consistency("NSRS", SCALAR_INT, aux_last_type_read_for_NSRS);
                    aux_last_type_read_for_NSRS = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NLRS"]), write_opts);
                    // assign expression to variable NLRS
                    var_NLRS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLRS"]);
                    aux_NLRS_read = true;
                    validate_vartype_consistency("NLRS", SCALAR_INT, aux_last_type_read_for_NLRS);
                    aux_last_type_read_for_NLRS = SCALAR_INT;
                    cont << cpp_draft_line;

                    for (int var_p_0d_int_Scalar = 1;
                       var_p_0d_int_Scalar <= var_NSRS_0d_int_Scalar; var_p_0d_int_Scalar++) {
                      bool aux_p_read = true;
                      // open section nsrs_subsec
                      {
                        py::dict cpp_parent_dict_tmp = cpp_current_dict;
                        if ((! cpp_parent_dict_tmp.contains("nsrs_subsec"))) {
                          cpp_parent_dict_tmp["nsrs_subsec"] = py::dict();
                        }
                        py::dict cpp_current_dict = cpp_parent_dict_tmp["nsrs_subsec"];
                        if ((! cpp_current_dict.contains(py::cast(var_p_0d_int_Scalar)))) {
                          cpp_current_dict[py::cast(var_p_0d_int_Scalar)] = py::dict();
                        }
                        cpp_current_dict = cpp_current_dict[py::cast(var_p_0d_int_Scalar)];
                        // variable declarations
                        int var_MPAR_0d_int_Scalar;
                        bool aux_MPAR_read = false;
                        vartype aux_last_type_read_for_MPAR = UNKNOWN;
                        int var_NRB_0d_int_Scalar;
                        bool aux_NRB_read = false;
                        vartype aux_last_type_read_for_NRB = UNKNOWN;
                        NestedVector<double> var_ER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_ER = UNKNOWN;
                        NestedVector<double> var_AJ_1d_double_NestedVector;
                        vartype aux_last_type_read_for_AJ = UNKNOWN;
                        NestedVector<double> var_GN_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GN = UNKNOWN;
                        NestedVector<double> var_GG_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GG = UNKNOWN;
                        NestedVector<double> var_GFA_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GFA = UNKNOWN;
                        NestedVector<double> var_GFB_1d_double_NestedVector;
                        vartype aux_last_type_read_for_GFB = UNKNOWN;
                        Matrix2d<double> var_V_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_V = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , MPAR , 0 , ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2)) , NRB / \n { ER , AJ , GN , GG , GFA , GFB } { k = 1 to NRB } , \n { { V } { n = m to (MPAR*NRB) } } { m = 1 to (MPAR*NRB) } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["MPAR"]), write_opts);
                        // assign expression to variable MPAR
                        var_MPAR_0d_int_Scalar = py::cast<int>(cpp_current_dict["MPAR"]);
                        aux_MPAR_read = true;
                        validate_vartype_consistency("MPAR", SCALAR_INT, aux_last_type_read_for_MPAR);
                        aux_last_type_read_for_MPAR = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NRB"]), write_opts);
                        // assign expression to variable NRB
                        var_NRB_0d_int_Scalar = py::cast<int>(cpp_current_dict["NRB"]);
                        aux_NRB_read = true;
                        validate_vartype_consistency("NRB", SCALAR_INT, aux_last_type_read_for_NRB);
                        aux_last_type_read_for_NRB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, ((6*py::cast<int>(cpp_current_dict["NRB"]))+(((py::cast<int>(cpp_current_dict["MPAR"])*py::cast<int>(cpp_current_dict["NRB"]))*((py::cast<int>(cpp_current_dict["MPAR"])*py::cast<int>(cpp_current_dict["NRB"]))+1))/2)), write_opts);
                        if ((! (aux_MPAR_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for MPAR because this variable could not be isolated.");
                        } else {
                        }
                        if ((! (aux_NRB_read == true))) {
                          throw std::runtime_error("The equation ((6*NRB)+(((MPAR*NRB)*((MPAR*NRB)+1))/2))==value cannot be solved for NRB because this variable could not be isolated.");
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, ((6*py::cast<int>(cpp_current_dict["NRB"]))+(((py::cast<int>(cpp_current_dict["MPAR"])*py::cast<int>(cpp_current_dict["NRB"]))*((py::cast<int>(cpp_current_dict["MPAR"])*py::cast<int>(cpp_current_dict["NRB"]))+1))/2)), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = ((6*py::cast<int>(cpp_current_dict["NRB"]))+(((py::cast<int>(cpp_current_dict["MPAR"])*py::cast<int>(cpp_current_dict["NRB"]))*((py::cast<int>(cpp_current_dict["MPAR"])*py::cast<int>(cpp_current_dict["NRB"]))+1))/2));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NRB_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable AJ
                            var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                            aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GN"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable GN
                            var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GN"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                            aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable GG
                            var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                            aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GFA"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable GFA
                            var_GFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GFA"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("GFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFA);
                            aux_last_type_read_for_GFA = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GFB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable GFB
                            var_GFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GFB"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("GFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFB);
                            aux_last_type_read_for_GFB = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          var_V_2d_double_Matrix2d.init(1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), 1, (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar), true, false);

                          for (int var_m_0d_int_Scalar = 1;
                             var_m_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_m_0d_int_Scalar++) {
                            bool aux_m_read = true;
                            // read LIST body

                            for (int var_n_0d_int_Scalar = var_m_0d_int_Scalar;
                               var_n_0d_int_Scalar <= (var_MPAR_0d_int_Scalar*var_NRB_0d_int_Scalar); var_n_0d_int_Scalar++) {
                              bool aux_n_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["V"][py::cast(var_m_0d_int_Scalar)][py::cast(var_n_0d_int_Scalar)]), write_opts);
                              // assign expression to variable V
                              var_V_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = py::cast<double>(cpp_current_dict["V"][py::cast(var_m_0d_int_Scalar)][py::cast(var_n_0d_int_Scalar)]);
                              validate_vartype_consistency("V", MATRIX2D_DOUBLE, aux_last_type_read_for_V);
                              aux_last_type_read_for_V = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                        cpp_current_dict = cpp_parent_dict_tmp;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , LCOMP , 0 , ISR ] CONT";
                    // read CONT record
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LCOMP", -99999));
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("ISR", -99999));
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(1)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(7)))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , LCOMP , 0 , ISR ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read CONT record
                    cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LCOMP"]), write_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCOMP"]);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["ISR"]), write_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict["ISR"]);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    cont << cpp_draft_line;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , JCH , (1+((NCH-1)/6)) / \n { { DAP } { n = 1 to NCH } } { m = 1 to (JCH/NCH) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["JCH"]), write_opts);
                          // assign expression to variable JCH
                          var_JCH_0d_int_Scalar = py::cast<int>(cpp_current_dict["JCH"]);
                          aux_JCH_read = true;
                          validate_vartype_consistency("JCH", SCALAR_INT, aux_last_type_read_for_JCH);
                          aux_last_type_read_for_JCH = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, (1+((py::cast<int>(cpp_current_dict["NCH"])-1)/6)), write_opts);
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (1+((py::cast<int>(cpp_current_dict["NCH"])-1)/6));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NCH
                          var_NCH_0d_int_Scalar = ((((((1/6)*(-1))+1)*(-1))+cpp_int_val)/(1/6));
                          aux_NCH_read = true;
                          validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                          aux_last_type_read_for_NCH = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["JCH"]), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = py::cast<int>(cpp_current_dict["JCH"]);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body
                            var_DAP_2d_double_Matrix2d.init(1, (var_JCH_0d_int_Scalar/var_NCH_0d_int_Scalar), 1, var_NCH_0d_int_Scalar, false, false);

                            for (int var_m_0d_int_Scalar = 1;
                               var_m_0d_int_Scalar <= (var_JCH_0d_int_Scalar/var_NCH_0d_int_Scalar); var_m_0d_int_Scalar++) {
                              bool aux_m_read = true;
                              // read LIST body

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // read LIST body
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DAP"][py::cast(var_m_0d_int_Scalar)][py::cast(var_n_0d_int_Scalar)]), write_opts);
                                // assign expression to variable DAP
                                var_DAP_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = py::cast<double>(cpp_current_dict["DAP"][py::cast(var_m_0d_int_Scalar)][py::cast(var_n_0d_int_Scalar)]);
                                validate_vartype_consistency("DAP", MATRIX2D_DOUBLE, aux_last_type_read_for_DAP);
                                aux_last_type_read_for_DAP = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , 0 , 0 , NSRS , 0 ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read CONT record
                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AWRI"]), write_opts);
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWRI"]);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NSRS"]), write_opts);
                    // assign expression to variable NSRS
                    var_NSRS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NSRS"]);
                    aux_NSRS_read = true;
                    validate_vartype_consistency("NSRS", SCALAR_INT, aux_last_type_read_for_NSRS);
                    aux_last_type_read_for_NSRS = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                    cont << cpp_draft_line;

                    for (int var_k_0d_int_Scalar = 1;
                       var_k_0d_int_Scalar <= var_NSRS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                      bool aux_k_read = true;
                      // open section nsrs_subsec
                      {
                        py::dict cpp_parent_dict_tmp = cpp_current_dict;
                        if ((! cpp_parent_dict_tmp.contains("nsrs_subsec"))) {
                          cpp_parent_dict_tmp["nsrs_subsec"] = py::dict();
                        }
                        py::dict cpp_current_dict = cpp_parent_dict_tmp["nsrs_subsec"];
                        if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
                          cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
                        }
                        cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
                        // variable declarations
                        int var_NJSX_0d_int_Scalar;
                        bool aux_NJSX_read = false;
                        vartype aux_last_type_read_for_NJSX = UNKNOWN;
                        int var_N_0d_int_Scalar;
                        bool aux_N_read = false;
                        vartype aux_last_type_read_for_N = UNKNOWN;
                        int var_NPARB_0d_int_Scalar;
                        bool aux_NPARB_read = false;
                        vartype aux_last_type_read_for_NPARB = UNKNOWN;
                        Matrix2d<double> var_V_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_V = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NJSX , 0 , 0 , 0 ] CONT";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read CONT record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["NJSX"]), write_opts);
                        // assign expression to variable NJSX
                        var_NJSX_0d_int_Scalar = py::cast<int>(cpp_current_dict["NJSX"]);
                        aux_NJSX_read = true;
                        validate_vartype_consistency("NJSX", SCALAR_INT, aux_last_type_read_for_NJSX);
                        aux_last_type_read_for_NJSX = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                        cont << cpp_draft_line;

                        for (int var_m_0d_int_Scalar = 1;
                           var_m_0d_int_Scalar <= var_NJSX_0d_int_Scalar; var_m_0d_int_Scalar++) {
                          bool aux_m_read = true;
                          // open section J_pi_group
                          {
                            py::dict cpp_parent_dict_tmp = cpp_current_dict;
                            if ((! cpp_parent_dict_tmp.contains("J_pi_group"))) {
                              cpp_parent_dict_tmp["J_pi_group"] = py::dict();
                            }
                            py::dict cpp_current_dict = cpp_parent_dict_tmp["J_pi_group"];
                            if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                              cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                            }
                            cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                            // variable declarations
                            int var_NCH_0d_int_Scalar;
                            bool aux_NCH_read = false;
                            vartype aux_last_type_read_for_NCH = UNKNOWN;
                            int var_NRB_0d_int_Scalar;
                            bool aux_NRB_read = false;
                            vartype aux_last_type_read_for_NRB = UNKNOWN;
                            NestedVector<double> var_ER_1d_double_NestedVector;
                            vartype aux_last_type_read_for_ER = UNKNOWN;
                            Matrix2d<double> var_GAM_2d_double_Matrix2d;
                            vartype aux_last_type_read_for_GAM = UNKNOWN;
                            cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NCH , NRB , (6*NX) , NX / \n { ER , { GAM } { q = 1 to NCH } \n { 0.0 } { r = 1 to num_zeros } } { p = 1 to NRB } ] LIST";
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST record
                            cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                            cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["NCH"]), write_opts);
                            if ((! (aux_NCH_read == true))) {
                              // assign expression to variable NCH
                              var_NCH_0d_int_Scalar = py::cast<int>(cpp_current_dict["NCH"]);
                              aux_NCH_read = true;
                              validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                              aux_last_type_read_for_NCH = SCALAR_INT;
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["NRB"]), write_opts);
                            // assign expression to variable NRB
                            var_NRB_0d_int_Scalar = py::cast<int>(cpp_current_dict["NRB"]);
                            aux_NRB_read = true;
                            validate_vartype_consistency("NRB", SCALAR_INT, aux_last_type_read_for_NRB);
                            aux_last_type_read_for_NRB = SCALAR_INT;
                            cpp_write_field<int>(cpp_draft_line, 4, (6*((((1+py::cast<int>(cpp_current_dict["NCH"]))+((5-py::cast<int>(cpp_current_dict["NCH"]))%6))*py::cast<int>(cpp_current_dict["NRB"]))/6)), write_opts);
                            if ((! (aux_NCH_read == true))) {
                              throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRB)/6))==value cannot be solved for NCH because the modulo operator is not supported.");
                            } else {
                            }
                            if ((! (aux_NRB_read == true))) {
                              throw std::runtime_error("The equation (6*((((1+NCH)+((5-NCH)%6))*NRB)/6))==value cannot be solved for NRB because the modulo operator is not supported.");
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 5, ((((1+py::cast<int>(cpp_current_dict["NCH"]))+((5-py::cast<int>(cpp_current_dict["NCH"]))%6))*py::cast<int>(cpp_current_dict["NRB"]))/6), write_opts);
                            if ((! (aux_NCH_read == true))) {
                              throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRB)/6)==value cannot be solved for NCH because the modulo operator is not supported.");
                            } else {
                            }
                            if ((! (aux_NRB_read == true))) {
                              throw std::runtime_error("The equation ((((1+NCH)+((5-NCH)%6))*NRB)/6)==value cannot be solved for NRB because the modulo operator is not supported.");
                            } else {
                            }
                            cpp_write_field<int>(cpp_draft_line, 4, (6*((((1+py::cast<int>(cpp_current_dict["NCH"]))+((5-py::cast<int>(cpp_current_dict["NCH"]))%6))*py::cast<int>(cpp_current_dict["NRB"]))/6)), write_opts);
                            cont << cpp_draft_line;
                            {
                              int cpp_npl = (6*((((1+py::cast<int>(cpp_current_dict["NCH"]))+((5-py::cast<int>(cpp_current_dict["NCH"]))%6))*py::cast<int>(cpp_current_dict["NRB"]))/6));
                              int cpp_i = 0;
                              int cpp_j = 0;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              // read LIST body
                              var_GAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRB_0d_int_Scalar, false, false);

                              for (int var_p_0d_int_Scalar = 1;
                                 var_p_0d_int_Scalar <= var_NRB_0d_int_Scalar; var_p_0d_int_Scalar++) {
                                bool aux_p_read = true;
                                // read LIST body
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"][py::cast(var_p_0d_int_Scalar)]), write_opts);
                                // assign expression to variable ER
                                var_ER_1d_double_NestedVector.set(var_p_0d_int_Scalar, py::cast<double>(cpp_current_dict["ER"][py::cast(var_p_0d_int_Scalar)]));
                                validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                                aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }

                                for (int var_q_0d_int_Scalar = 1;
                                   var_q_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_q_0d_int_Scalar++) {
                                  bool aux_q_read = true;
                                  // read LIST body
                                  cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GAM"][py::cast(var_q_0d_int_Scalar)][py::cast(var_p_0d_int_Scalar)]), write_opts);
                                  // assign expression to variable GAM
                                  var_GAM_2d_double_Matrix2d(var_q_0d_int_Scalar, var_p_0d_int_Scalar) = py::cast<double>(cpp_current_dict["GAM"][py::cast(var_q_0d_int_Scalar)][py::cast(var_p_0d_int_Scalar)]);
                                  validate_vartype_consistency("GAM", MATRIX2D_DOUBLE, aux_last_type_read_for_GAM);
                                  aux_last_type_read_for_GAM = MATRIX2D_DOUBLE;
                                  cpp_i++;
                                  cpp_j++;
                                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                    cont << cpp_draft_line;
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                    cpp_j = 0;
                                  }
                                }

                                for (int var_r_0d_int_Scalar = 1;
                                   var_r_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_r_0d_int_Scalar++) {
                                  bool aux_r_read = true;
                                  // read LIST body
                                  cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                                  cpp_i++;
                                  cpp_j++;
                                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                    cont << cpp_draft_line;
                                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                    cpp_j = 0;
                                  }
                                }
                              }
                              if (cpp_i != cpp_npl) {
                                throw std::runtime_error("not exactly NPL elements consumed");
                              }
                            }
                            cont << cpp_draft_line;
                            cpp_current_dict = cpp_parent_dict_tmp;
                          }
                        }
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , N , NPARB / \n { { V } { q = p to NPARB } } { p = 1 to NPARB } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["N"]), write_opts);
                        // assign expression to variable N
                        var_N_0d_int_Scalar = py::cast<int>(cpp_current_dict["N"]);
                        aux_N_read = true;
                        validate_vartype_consistency("N", SCALAR_INT, aux_last_type_read_for_N);
                        aux_last_type_read_for_N = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NPARB"]), write_opts);
                        // assign expression to variable NPARB
                        var_NPARB_0d_int_Scalar = py::cast<int>(cpp_current_dict["NPARB"]);
                        aux_NPARB_read = true;
                        validate_vartype_consistency("NPARB", SCALAR_INT, aux_last_type_read_for_NPARB);
                        aux_last_type_read_for_NPARB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["N"]), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = py::cast<int>(cpp_current_dict["N"]);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body
                          var_V_2d_double_Matrix2d.init(1, var_NPARB_0d_int_Scalar, 1, var_NPARB_0d_int_Scalar, true, false);

                          for (int var_p_0d_int_Scalar = 1;
                             var_p_0d_int_Scalar <= var_NPARB_0d_int_Scalar; var_p_0d_int_Scalar++) {
                            bool aux_p_read = true;
                            // read LIST body

                            for (int var_q_0d_int_Scalar = var_p_0d_int_Scalar;
                               var_q_0d_int_Scalar <= var_NPARB_0d_int_Scalar; var_q_0d_int_Scalar++) {
                              bool aux_q_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["V"][py::cast(var_p_0d_int_Scalar)][py::cast(var_q_0d_int_Scalar)]), write_opts);
                              // assign expression to variable V
                              var_V_2d_double_Matrix2d(var_p_0d_int_Scalar, var_q_0d_int_Scalar) = py::cast<double>(cpp_current_dict["V"][py::cast(var_p_0d_int_Scalar)][py::cast(var_q_0d_int_Scalar)]);
                              validate_vartype_consistency("V", MATRIX2D_DOUBLE, aux_last_type_read_for_V);
                              aux_last_type_read_for_V = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                        cpp_current_dict = cpp_parent_dict_tmp;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    double& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    double var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , 0 , ISR ] CONT";
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("SPI", -99999.9));
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AP", -99999.9));
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LCOMP", -99999));
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("ISR", -99999));
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(2)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&(((((((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(1))))))||(((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(2)))))))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , LCOMP , 0 , ISR ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read CONT record
                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AP"]), write_opts);
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict["AP"]);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LCOMP"]), write_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCOMP"]);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["ISR"]), write_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict["ISR"]);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    cont << cpp_draft_line;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , DAP , 0 , 0 , 0 , 0 ] CONT";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read CONT record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["DAP"]), write_opts);
                          // assign expression to variable DAP
                          var_DAP_0d_double_Scalar = py::cast<double>(cpp_current_dict["DAP"]);
                          aux_DAP_read = true;
                          validate_vartype_consistency("DAP", SCALAR_DOUBLE, aux_last_type_read_for_DAP);
                          aux_last_type_read_for_DAP = SCALAR_DOUBLE;
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                          cont << cpp_draft_line;
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , QX , 0 , LRX , (12*NRSA) , NRSA / \n { ER , AJ , GT , GN , GG , GF , \n DER , 0.0 , 0.0 , DGN , DGG , DGF } { k = 1 to NRSA } ] LIST";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read LIST record
                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AWRI"]), write_opts);
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWRI"]);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["QX"]), write_opts);
                    // assign expression to variable QX
                    var_QX_0d_double_Scalar = py::cast<double>(cpp_current_dict["QX"]);
                    aux_QX_read = true;
                    validate_vartype_consistency("QX", SCALAR_DOUBLE, aux_last_type_read_for_QX);
                    aux_last_type_read_for_QX = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LRX"]), write_opts);
                    // assign expression to variable LRX
                    var_LRX_0d_int_Scalar = py::cast<int>(cpp_current_dict["LRX"]);
                    aux_LRX_read = true;
                    validate_vartype_consistency("LRX", SCALAR_INT, aux_last_type_read_for_LRX);
                    aux_last_type_read_for_LRX = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_current_dict["NRSA"])), write_opts);
                    // assign expression to variable cpp_int_val
                    cpp_int_val = (12*py::cast<int>(cpp_current_dict["NRSA"]));
                    aux_cpp_int_val_read = true;
                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                    // assign expression to variable NRSA
                    var_NRSA_0d_int_Scalar = (cpp_int_val/12);
                    aux_NRSA_read = true;
                    validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                    aux_last_type_read_for_NRSA = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NRSA"]), write_opts);
                    if ((! (aux_NRSA_read == true))) {
                      // assign expression to variable NRSA
                      var_NRSA_0d_int_Scalar = py::cast<int>(cpp_current_dict["NRSA"]);
                      aux_NRSA_read = true;
                      validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                      aux_last_type_read_for_NRSA = SCALAR_INT;
                    } else {
                    }
                    cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_current_dict["NRSA"])), write_opts);
                    cont << cpp_draft_line;
                    {
                      int cpp_npl = (12*py::cast<int>(cpp_current_dict["NRSA"]));
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_NRSA_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable ER
                        var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                        aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable AJ
                        var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                        aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GT"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable GT
                        var_GT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GT"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("GT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GT);
                        aux_last_type_read_for_GT = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GN"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable GN
                        var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GN"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                        aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable GG
                        var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                        aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GF"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable GF
                        var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GF"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                        aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable DER
                        var_DER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["DER"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("DER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DER);
                        aux_last_type_read_for_DER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DGN"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable DGN
                        var_DGN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["DGN"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("DGN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGN);
                        aux_last_type_read_for_DGN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DGG"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable DGG
                        var_DGG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["DGG"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("DGG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGG);
                        aux_last_type_read_for_DGG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DGF"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable DGF
                        var_DGF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["DGF"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("DGF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGF);
                        aux_last_type_read_for_DGF = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cont << cpp_draft_line;
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NDIGIT , NNN , NM , 0 ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read CONT record
                    cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["NDIGIT"]), write_opts);
                    // assign expression to variable NDIGIT
                    var_NDIGIT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NDIGIT"]);
                    aux_NDIGIT_read = true;
                    validate_vartype_consistency("NDIGIT", SCALAR_INT, aux_last_type_read_for_NDIGIT);
                    aux_last_type_read_for_NDIGIT = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["NNN"]), write_opts);
                    // assign expression to variable NNN
                    var_NNN_0d_int_Scalar = py::cast<int>(cpp_current_dict["NNN"]);
                    aux_NNN_read = true;
                    validate_vartype_consistency("NNN", SCALAR_INT, aux_last_type_read_for_NNN);
                    aux_last_type_read_for_NNN = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NM"]), write_opts);
                    // assign expression to variable NM
                    var_NM_0d_int_Scalar = py::cast<int>(cpp_current_dict["NM"]);
                    aux_NM_read = true;
                    validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
                    aux_last_type_read_for_NM = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                    cont << cpp_draft_line;

                    for (int var_k_0d_int_Scalar = 1;
                       var_k_0d_int_Scalar <= var_NM_0d_int_Scalar; var_k_0d_int_Scalar++) {
                      bool aux_k_read = true;
                      {
                        cpp_template = "[ MAT , 32 , 151 / II , JJ , KIJ { NDIGIT } ] INTG";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        int cpp_ndigit = var_NDIGIT_0d_int_Scalar;
                        if ((cpp_ndigit < 2 || cpp_ndigit > 6)) {
                          throw std::runtime_error("invalid NDIGIT (must be between 2 and 6)");
                        }
                        cpp_write_custom_int_field(cpp_draft_line, 0, 5, py::cast<int>(cpp_current_dict["II"][py::cast(var_k_0d_int_Scalar)]));
                        cpp_write_custom_int_field(cpp_draft_line, 5, 5, py::cast<int>(cpp_current_dict["JJ"][py::cast(var_k_0d_int_Scalar)]));
                        // assign expression to variable II
                        var_II_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["II"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("II", NESTEDVECTOR_INT, aux_last_type_read_for_II);
                        aux_last_type_read_for_II = NESTEDVECTOR_INT;
                        // assign expression to variable JJ
                        var_JJ_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["JJ"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("JJ", NESTEDVECTOR_INT, aux_last_type_read_for_JJ);
                        aux_last_type_read_for_JJ = NESTEDVECTOR_INT;
                        int cpp_step = cpp_ndigit + 1;
                        int cpp_end = 65;
                        int cpp_start;
                        if (cpp_ndigit <= 5) {
                          cpp_start = 11;
                        } else {
                          cpp_start = 10;
                        }
                        std::vector<int> cpp_intvec;
                        int elpos = 0;
                        for (int cpp_i = cpp_start; cpp_i < cpp_end; cpp_i += cpp_step) {
                        cpp_write_custom_int_field(cpp_draft_line, cpp_i, cpp_step, py::cast<int>(cpp_current_dict["KIJ"][py::cast(var_k_0d_int_Scalar)][py::cast(elpos)]));
                          cpp_intvec.push_back(py::cast<int>(cpp_current_dict["KIJ"][py::cast(var_k_0d_int_Scalar)][py::cast(elpos)]));
                          elpos++;
                        }
                        // assign expression to variable KIJ
                        var_KIJ_1d_intvec_NestedVector.set(var_k_0d_int_Scalar, cpp_intvec);
                        validate_vartype_consistency("KIJ", NESTEDVECTOR_INTVEC, aux_last_type_read_for_KIJ);
                        aux_last_type_read_for_KIJ = NESTEDVECTOR_INTVEC;
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    double& glob_var_SPI_0d_double_Scalar = var_SPI_0d_double_Scalar;
                    double var_SPI_0d_double_Scalar = glob_var_SPI_0d_double_Scalar;
                    bool& glob_aux_SPI_read = aux_SPI_read;
                    bool aux_SPI_read = glob_aux_SPI_read;
                    vartype aux_last_type_read_for_SPI = UNKNOWN;
                    double& glob_var_AP_0d_double_Scalar = var_AP_0d_double_Scalar;
                    double var_AP_0d_double_Scalar = glob_var_AP_0d_double_Scalar;
                    bool& glob_aux_AP_read = aux_AP_read;
                    bool aux_AP_read = glob_aux_AP_read;
                    vartype aux_last_type_read_for_AP = UNKNOWN;
                    int& glob_var_LAD_0d_int_Scalar = var_LAD_0d_int_Scalar;
                    int var_LAD_0d_int_Scalar = glob_var_LAD_0d_int_Scalar;
                    bool& glob_aux_LAD_read = aux_LAD_read;
                    bool aux_LAD_read = glob_aux_LAD_read;
                    vartype aux_last_type_read_for_LAD = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , LAD , LCOMP , 0 , ISR ] CONT";
                    // read CONT record
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("SPI", -99999.9));
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("AP", -99999.9));
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    // assign expression to variable LAD
                    var_LAD_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LAD", -99999));
                    aux_LAD_read = true;
                    validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                    aux_last_type_read_for_LAD = SCALAR_INT;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LCOMP", -99999));
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("ISR", -99999));
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(2)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(3)))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / SPI , AP , LAD , LCOMP , 0 , ISR ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read CONT record
                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                    // assign expression to variable SPI
                    var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                    aux_SPI_read = true;
                    validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                    aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                    cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AP"]), write_opts);
                    // assign expression to variable AP
                    var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict["AP"]);
                    aux_AP_read = true;
                    validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                    aux_last_type_read_for_AP = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LAD"]), write_opts);
                    // assign expression to variable LAD
                    var_LAD_0d_int_Scalar = py::cast<int>(cpp_current_dict["LAD"]);
                    aux_LAD_read = true;
                    validate_vartype_consistency("LAD", SCALAR_INT, aux_last_type_read_for_LAD);
                    aux_last_type_read_for_LAD = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LCOMP"]), write_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCOMP"]);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["ISR"]), write_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict["ISR"]);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    cont << cpp_draft_line;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , MLS , 1 / \n { DAP } { k = 1 to MLS } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["MLS"]), write_opts);
                          // assign expression to variable MLS
                          var_MLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["MLS"]);
                          aux_MLS_read = true;
                          validate_vartype_consistency("MLS", SCALAR_INT, aux_last_type_read_for_MLS);
                          aux_last_type_read_for_MLS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, 1, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["MLS"]), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = py::cast<int>(cpp_current_dict["MLS"]);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_MLS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DAP"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable DAP
                              var_DAP_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["DAP"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("DAP", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DAP);
                              aux_last_type_read_for_DAP = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / AWRI , APL , 0 , 0 , (12*NRSA) , NRSA / \n { ER , AJ , GN , GG , GFA , GFB , \n DER , 0.0 , DGN , DGG , DGFA , DGFB } { k = 1 to NRSA } ] LIST";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read LIST record
                    cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AWRI"]), write_opts);
                    // assign expression to variable AWRI
                    var_AWRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWRI"]);
                    aux_AWRI_read = true;
                    validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                    aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                    cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["APL"]), write_opts);
                    // assign expression to variable APL
                    var_APL_0d_double_Scalar = py::cast<double>(cpp_current_dict["APL"]);
                    aux_APL_read = true;
                    validate_vartype_consistency("APL", SCALAR_DOUBLE, aux_last_type_read_for_APL);
                    aux_last_type_read_for_APL = SCALAR_DOUBLE;
                    cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_current_dict["NRSA"])), write_opts);
                    // assign expression to variable cpp_int_val
                    cpp_int_val = (12*py::cast<int>(cpp_current_dict["NRSA"]));
                    aux_cpp_int_val_read = true;
                    validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                    aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                    // assign expression to variable NRSA
                    var_NRSA_0d_int_Scalar = (cpp_int_val/12);
                    aux_NRSA_read = true;
                    validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                    aux_last_type_read_for_NRSA = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NRSA"]), write_opts);
                    if ((! (aux_NRSA_read == true))) {
                      // assign expression to variable NRSA
                      var_NRSA_0d_int_Scalar = py::cast<int>(cpp_current_dict["NRSA"]);
                      aux_NRSA_read = true;
                      validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                      aux_last_type_read_for_NRSA = SCALAR_INT;
                    } else {
                    }
                    cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_current_dict["NRSA"])), write_opts);
                    cont << cpp_draft_line;
                    {
                      int cpp_npl = (12*py::cast<int>(cpp_current_dict["NRSA"]));
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_NRSA_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable ER
                        var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                        aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable AJ
                        var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                        aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GN"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable GN
                        var_GN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GN"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("GN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GN);
                        aux_last_type_read_for_GN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable GG
                        var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                        aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GFA"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable GFA
                        var_GFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GFA"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("GFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFA);
                        aux_last_type_read_for_GFA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GFB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable GFB
                        var_GFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GFB"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("GFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GFB);
                        aux_last_type_read_for_GFB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable DER
                        var_DER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["DER"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("DER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DER);
                        aux_last_type_read_for_DER = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DGN"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable DGN
                        var_DGN_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["DGN"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("DGN", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGN);
                        aux_last_type_read_for_DGN = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DGG"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable DGG
                        var_DGG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["DGG"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("DGG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGG);
                        aux_last_type_read_for_DGG = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DGFA"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable DGFA
                        var_DGFA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["DGFA"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("DGFA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGFA);
                        aux_last_type_read_for_DGFA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DGFB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable DGFB
                        var_DGFB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["DGFB"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("DGFB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DGFB);
                        aux_last_type_read_for_DGFB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cont << cpp_draft_line;
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NDIGIT , NNN , NM , 0 ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read CONT record
                    cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["NDIGIT"]), write_opts);
                    // assign expression to variable NDIGIT
                    var_NDIGIT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NDIGIT"]);
                    aux_NDIGIT_read = true;
                    validate_vartype_consistency("NDIGIT", SCALAR_INT, aux_last_type_read_for_NDIGIT);
                    aux_last_type_read_for_NDIGIT = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["NNN"]), write_opts);
                    // assign expression to variable NNN
                    var_NNN_0d_int_Scalar = py::cast<int>(cpp_current_dict["NNN"]);
                    aux_NNN_read = true;
                    validate_vartype_consistency("NNN", SCALAR_INT, aux_last_type_read_for_NNN);
                    aux_last_type_read_for_NNN = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NM"]), write_opts);
                    // assign expression to variable NM
                    var_NM_0d_int_Scalar = py::cast<int>(cpp_current_dict["NM"]);
                    aux_NM_read = true;
                    validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
                    aux_last_type_read_for_NM = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                    cont << cpp_draft_line;

                    for (int var_k_0d_int_Scalar = 1;
                       var_k_0d_int_Scalar <= var_NM_0d_int_Scalar; var_k_0d_int_Scalar++) {
                      bool aux_k_read = true;
                      {
                        cpp_template = "[ MAT , 32 , 151 / II , JJ , KIJ { NDIGIT } ] INTG";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        int cpp_ndigit = var_NDIGIT_0d_int_Scalar;
                        if ((cpp_ndigit < 2 || cpp_ndigit > 6)) {
                          throw std::runtime_error("invalid NDIGIT (must be between 2 and 6)");
                        }
                        cpp_write_custom_int_field(cpp_draft_line, 0, 5, py::cast<int>(cpp_current_dict["II"][py::cast(var_k_0d_int_Scalar)]));
                        cpp_write_custom_int_field(cpp_draft_line, 5, 5, py::cast<int>(cpp_current_dict["JJ"][py::cast(var_k_0d_int_Scalar)]));
                        // assign expression to variable II
                        var_II_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["II"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("II", NESTEDVECTOR_INT, aux_last_type_read_for_II);
                        aux_last_type_read_for_II = NESTEDVECTOR_INT;
                        // assign expression to variable JJ
                        var_JJ_1d_int_NestedVector.set(var_k_0d_int_Scalar, py::cast<int>(cpp_current_dict["JJ"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("JJ", NESTEDVECTOR_INT, aux_last_type_read_for_JJ);
                        aux_last_type_read_for_JJ = NESTEDVECTOR_INT;
                        int cpp_step = cpp_ndigit + 1;
                        int cpp_end = 65;
                        int cpp_start;
                        if (cpp_ndigit <= 5) {
                          cpp_start = 11;
                        } else {
                          cpp_start = 10;
                        }
                        std::vector<int> cpp_intvec;
                        int elpos = 0;
                        for (int cpp_i = cpp_start; cpp_i < cpp_end; cpp_i += cpp_step) {
                        cpp_write_custom_int_field(cpp_draft_line, cpp_i, cpp_step, py::cast<int>(cpp_current_dict["KIJ"][py::cast(var_k_0d_int_Scalar)][py::cast(elpos)]));
                          cpp_intvec.push_back(py::cast<int>(cpp_current_dict["KIJ"][py::cast(var_k_0d_int_Scalar)][py::cast(elpos)]));
                          elpos++;
                        }
                        // assign expression to variable KIJ
                        var_KIJ_1d_intvec_NestedVector.set(var_k_0d_int_Scalar, cpp_intvec);
                        validate_vartype_consistency("KIJ", NESTEDVECTOR_INTVEC, aux_last_type_read_for_KIJ);
                        aux_last_type_read_for_KIJ = NESTEDVECTOR_INTVEC;
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                // if statement evaluation with lookahead
                {
                  {
                    // variable declarations
                    double& glob_var_EL_0d_double_Scalar = var_EL_0d_double_Scalar;
                    double var_EL_0d_double_Scalar = glob_var_EL_0d_double_Scalar;
                    bool& glob_aux_EL_read = aux_EL_read;
                    bool aux_EL_read = glob_aux_EL_read;
                    vartype aux_last_type_read_for_EL = UNKNOWN;
                    double& glob_var_EH_0d_double_Scalar = var_EH_0d_double_Scalar;
                    double var_EH_0d_double_Scalar = glob_var_EH_0d_double_Scalar;
                    bool& glob_aux_EH_read = aux_EH_read;
                    bool aux_EH_read = glob_aux_EH_read;
                    vartype aux_last_type_read_for_EH = UNKNOWN;
                    int& glob_var_LRU_0d_int_Scalar = var_LRU_0d_int_Scalar;
                    int var_LRU_0d_int_Scalar = glob_var_LRU_0d_int_Scalar;
                    bool& glob_aux_LRU_read = aux_LRU_read;
                    bool aux_LRU_read = glob_aux_LRU_read;
                    vartype aux_last_type_read_for_LRU = UNKNOWN;
                    int& glob_var_LRF_0d_int_Scalar = var_LRF_0d_int_Scalar;
                    int var_LRF_0d_int_Scalar = glob_var_LRF_0d_int_Scalar;
                    bool& glob_aux_LRF_read = aux_LRF_read;
                    bool aux_LRF_read = glob_aux_LRF_read;
                    vartype aux_last_type_read_for_LRF = UNKNOWN;
                    int& glob_var_NRO_0d_int_Scalar = var_NRO_0d_int_Scalar;
                    int var_NRO_0d_int_Scalar = glob_var_NRO_0d_int_Scalar;
                    bool& glob_aux_NRO_read = aux_NRO_read;
                    bool aux_NRO_read = glob_aux_NRO_read;
                    vartype aux_last_type_read_for_NRO = UNKNOWN;
                    int& glob_var_NAPS_0d_int_Scalar = var_NAPS_0d_int_Scalar;
                    int var_NAPS_0d_int_Scalar = glob_var_NAPS_0d_int_Scalar;
                    bool& glob_aux_NAPS_read = aux_NAPS_read;
                    bool aux_NAPS_read = glob_aux_NAPS_read;
                    vartype aux_last_type_read_for_NAPS = UNKNOWN;
                    int& glob_var_NI_0d_int_Scalar = var_NI_0d_int_Scalar;
                    int var_NI_0d_int_Scalar = glob_var_NI_0d_int_Scalar;
                    bool& glob_aux_NI_read = aux_NI_read;
                    bool aux_NI_read = glob_aux_NI_read;
                    vartype aux_last_type_read_for_NI = UNKNOWN;
                    int& glob_var_IFG_0d_int_Scalar = var_IFG_0d_int_Scalar;
                    int var_IFG_0d_int_Scalar = glob_var_IFG_0d_int_Scalar;
                    bool& glob_aux_IFG_read = aux_IFG_read;
                    bool aux_IFG_read = glob_aux_IFG_read;
                    vartype aux_last_type_read_for_IFG = UNKNOWN;
                    int& glob_var_LCOMP_0d_int_Scalar = var_LCOMP_0d_int_Scalar;
                    int var_LCOMP_0d_int_Scalar = glob_var_LCOMP_0d_int_Scalar;
                    bool& glob_aux_LCOMP_read = aux_LCOMP_read;
                    bool aux_LCOMP_read = glob_aux_LCOMP_read;
                    vartype aux_last_type_read_for_LCOMP = UNKNOWN;
                    int& glob_var_NJS_0d_int_Scalar = var_NJS_0d_int_Scalar;
                    int var_NJS_0d_int_Scalar = glob_var_NJS_0d_int_Scalar;
                    bool& glob_aux_NJS_read = aux_NJS_read;
                    bool aux_NJS_read = glob_aux_NJS_read;
                    vartype aux_last_type_read_for_NJS = UNKNOWN;
                    int& glob_var_ISR_0d_int_Scalar = var_ISR_0d_int_Scalar;
                    int var_ISR_0d_int_Scalar = glob_var_ISR_0d_int_Scalar;
                    bool& glob_aux_ISR_read = aux_ISR_read;
                    bool aux_ISR_read = glob_aux_ISR_read;
                    vartype aux_last_type_read_for_ISR = UNKNOWN;
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , IFG , LCOMP , NJS , ISR ] CONT";
                    // read CONT record
                    // assign expression to variable IFG
                    var_IFG_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("IFG", -99999));
                    aux_IFG_read = true;
                    validate_vartype_consistency("IFG", SCALAR_INT, aux_last_type_read_for_IFG);
                    aux_last_type_read_for_IFG = SCALAR_INT;
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LCOMP", -99999));
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    // assign expression to variable NJS
                    var_NJS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NJS", -99999));
                    aux_NJS_read = true;
                    validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                    aux_last_type_read_for_NJS = SCALAR_INT;
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("ISR", -99999));
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    if ((((((((((aux_LCOMP_read == true)) && ((var_LCOMP_0d_int_Scalar)==(2)))))&&((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(1)))))&&((((aux_LRF_read == true)) && ((var_LRF_0d_int_Scalar)==(7)))))))) {
                      cpp_found_match = true;
                    }
                  }
                  if (cpp_found_match) {
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , IFG , LCOMP , NJS , ISR ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read CONT record
                    cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["IFG"]), write_opts);
                    // assign expression to variable IFG
                    var_IFG_0d_int_Scalar = py::cast<int>(cpp_current_dict["IFG"]);
                    aux_IFG_read = true;
                    validate_vartype_consistency("IFG", SCALAR_INT, aux_last_type_read_for_IFG);
                    aux_last_type_read_for_IFG = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LCOMP"]), write_opts);
                    // assign expression to variable LCOMP
                    var_LCOMP_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCOMP"]);
                    aux_LCOMP_read = true;
                    validate_vartype_consistency("LCOMP", SCALAR_INT, aux_last_type_read_for_LCOMP);
                    aux_last_type_read_for_LCOMP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NJS"]), write_opts);
                    // assign expression to variable NJS
                    var_NJS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NJS"]);
                    aux_NJS_read = true;
                    validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                    aux_last_type_read_for_NJS = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["ISR"]), write_opts);
                    // assign expression to variable ISR
                    var_ISR_0d_int_Scalar = py::cast<int>(cpp_current_dict["ISR"]);
                    aux_ISR_read = true;
                    validate_vartype_consistency("ISR", SCALAR_INT, aux_last_type_read_for_ISR);
                    aux_last_type_read_for_ISR = SCALAR_INT;
                    cont << cpp_draft_line;
                    // evaluate if-elif-else clause
                    {
                      bool cpp_found_match = false;
                      if (! cpp_found_match) {
                        if ((((((((aux_ISR_read == true)) && ((var_ISR_0d_int_Scalar)>(0)))))))) {
                          // if statement evaluation
                          cpp_found_match = true;
                          cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , 0 , NJCH , (1+((NJCH-1)/6)) / \n { { DAP } { n = 1 to (NJCH/NJS) } } { m = 1 to (NJCH/NJS) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NJCH"]), write_opts);
                          // assign expression to variable NJCH
                          var_NJCH_0d_int_Scalar = py::cast<int>(cpp_current_dict["NJCH"]);
                          aux_NJCH_read = true;
                          validate_vartype_consistency("NJCH", SCALAR_INT, aux_last_type_read_for_NJCH);
                          aux_last_type_read_for_NJCH = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, (1+((py::cast<int>(cpp_current_dict["NJCH"])-1)/6)), write_opts);
                          if ((! (aux_NJCH_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (1+((py::cast<int>(cpp_current_dict["NJCH"])-1)/6));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NJCH
                            var_NJCH_0d_int_Scalar = ((((((1/6)*(-1))+1)*(-1))+cpp_int_val)/(1/6));
                            aux_NJCH_read = true;
                            validate_vartype_consistency("NJCH", SCALAR_INT, aux_last_type_read_for_NJCH);
                            aux_last_type_read_for_NJCH = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NJCH"]), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = py::cast<int>(cpp_current_dict["NJCH"]);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body
                            var_DAP_2d_double_Matrix2d.init(1, (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar), 1, (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar), false, false);

                            for (int var_m_0d_int_Scalar = 1;
                               var_m_0d_int_Scalar <= (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar); var_m_0d_int_Scalar++) {
                              bool aux_m_read = true;
                              // read LIST body

                              for (int var_n_0d_int_Scalar = 1;
                                 var_n_0d_int_Scalar <= (var_NJCH_0d_int_Scalar/var_NJS_0d_int_Scalar); var_n_0d_int_Scalar++) {
                                bool aux_n_read = true;
                                // read LIST body
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DAP"][py::cast(var_m_0d_int_Scalar)][py::cast(var_n_0d_int_Scalar)]), write_opts);
                                // assign expression to variable DAP
                                var_DAP_2d_double_Matrix2d(var_m_0d_int_Scalar, var_n_0d_int_Scalar) = py::cast<double>(cpp_current_dict["DAP"][py::cast(var_m_0d_int_Scalar)][py::cast(var_n_0d_int_Scalar)]);
                                validate_vartype_consistency("DAP", MATRIX2D_DOUBLE, aux_last_type_read_for_DAP);
                                aux_last_type_read_for_DAP = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NPP , NJSX , (12*NPP) , (2*NPP) / \n { MA , MB , ZA , ZB , IA , IB , \n Q , PNT , SHF , MT , PA , PB } { k = 1 to NPP } ] LIST";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read LIST record
                    cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["NPP"]), write_opts);
                    // assign expression to variable NPP
                    var_NPP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NPP"]);
                    aux_NPP_read = true;
                    validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                    aux_last_type_read_for_NPP = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["NJSX"]), write_opts);
                    // assign expression to variable NJSX
                    var_NJSX_0d_int_Scalar = py::cast<int>(cpp_current_dict["NJSX"]);
                    aux_NJSX_read = true;
                    validate_vartype_consistency("NJSX", SCALAR_INT, aux_last_type_read_for_NJSX);
                    aux_last_type_read_for_NJSX = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_current_dict["NPP"])), write_opts);
                    if ((! (aux_NPP_read == true))) {
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (12*py::cast<int>(cpp_current_dict["NPP"]));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NPP
                      var_NPP_0d_int_Scalar = (cpp_int_val/12);
                      aux_NPP_read = true;
                      validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                      aux_last_type_read_for_NPP = SCALAR_INT;
                    } else {
                    }
                    cpp_write_field<int>(cpp_draft_line, 5, (2*py::cast<int>(cpp_current_dict["NPP"])), write_opts);
                    if ((! (aux_NPP_read == true))) {
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (2*py::cast<int>(cpp_current_dict["NPP"]));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NPP
                      var_NPP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NPP_read = true;
                      validate_vartype_consistency("NPP", SCALAR_INT, aux_last_type_read_for_NPP);
                      aux_last_type_read_for_NPP = SCALAR_INT;
                    } else {
                    }
                    cpp_write_field<int>(cpp_draft_line, 4, (12*py::cast<int>(cpp_current_dict["NPP"])), write_opts);
                    cont << cpp_draft_line;
                    {
                      int cpp_npl = (12*py::cast<int>(cpp_current_dict["NPP"]));
                      int cpp_i = 0;
                      int cpp_j = 0;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read LIST body

                      for (int var_k_0d_int_Scalar = 1;
                         var_k_0d_int_Scalar <= var_NPP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                        bool aux_k_read = true;
                        // read LIST body
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["MA"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable MA
                        var_MA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["MA"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("MA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MA);
                        aux_last_type_read_for_MA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["MB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable MB
                        var_MB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["MB"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("MB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MB);
                        aux_last_type_read_for_MB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ZA"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable ZA
                        var_ZA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ZA"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("ZA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZA);
                        aux_last_type_read_for_ZA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ZB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable ZB
                        var_ZB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ZB"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("ZB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ZB);
                        aux_last_type_read_for_ZB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["IA"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable IA
                        var_IA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["IA"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("IA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IA);
                        aux_last_type_read_for_IA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["IB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable IB
                        var_IB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["IB"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("IB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_IB);
                        aux_last_type_read_for_IB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Q"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable Q
                        var_Q_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["Q"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("Q", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Q);
                        aux_last_type_read_for_Q = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["PNT"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable PNT
                        var_PNT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["PNT"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("PNT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PNT);
                        aux_last_type_read_for_PNT = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["SHF"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable SHF
                        var_SHF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["SHF"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("SHF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SHF);
                        aux_last_type_read_for_SHF = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["MT"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable MT
                        var_MT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["MT"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("MT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_MT);
                        aux_last_type_read_for_MT = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["PA"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable PA
                        var_PA_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["PA"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("PA", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PA);
                        aux_last_type_read_for_PA = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["PB"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                        // assign expression to variable PB
                        var_PB_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["PB"][py::cast(var_k_0d_int_Scalar)]));
                        validate_vartype_consistency("PB", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PB);
                        aux_last_type_read_for_PB = NESTEDVECTOR_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                      }
                      if (cpp_i != cpp_npl) {
                        throw std::runtime_error("not exactly NPL elements consumed");
                      }
                    }
                    cont << cpp_draft_line;

                    for (int var_q_0d_int_Scalar = 1;
                       var_q_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_q_0d_int_Scalar++) {
                      bool aux_q_read = true;
                      // open section somesec
                      {
                        py::dict cpp_parent_dict_tmp = cpp_current_dict;
                        if ((! cpp_parent_dict_tmp.contains("somesec"))) {
                          cpp_parent_dict_tmp["somesec"] = py::dict();
                        }
                        py::dict cpp_current_dict = cpp_parent_dict_tmp["somesec"];
                        if ((! cpp_current_dict.contains(py::cast(var_q_0d_int_Scalar)))) {
                          cpp_current_dict[py::cast(var_q_0d_int_Scalar)] = py::dict();
                        }
                        cpp_current_dict = cpp_current_dict[py::cast(var_q_0d_int_Scalar)];
                        // variable declarations
                        double var_AJ_0d_double_Scalar;
                        bool aux_AJ_read = false;
                        vartype aux_last_type_read_for_AJ = UNKNOWN;
                        double var_PJ_0d_double_Scalar;
                        bool aux_PJ_read = false;
                        vartype aux_last_type_read_for_PJ = UNKNOWN;
                        int cpp_int_val;
                        bool aux_cpp_int_val_read = false;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int var_NCH_0d_int_Scalar;
                        bool aux_NCH_read = false;
                        vartype aux_last_type_read_for_NCH = UNKNOWN;
                        NestedVector<double> var_PPI_1d_double_NestedVector;
                        vartype aux_last_type_read_for_PPI = UNKNOWN;
                        NestedVector<double> var_L_1d_double_NestedVector;
                        vartype aux_last_type_read_for_L = UNKNOWN;
                        NestedVector<double> var_SCH_1d_double_NestedVector;
                        vartype aux_last_type_read_for_SCH = UNKNOWN;
                        NestedVector<double> var_BND_1d_double_NestedVector;
                        vartype aux_last_type_read_for_BND = UNKNOWN;
                        NestedVector<double> var_APE_1d_double_NestedVector;
                        vartype aux_last_type_read_for_APE = UNKNOWN;
                        NestedVector<double> var_APT_1d_double_NestedVector;
                        vartype aux_last_type_read_for_APT = UNKNOWN;
                        int var_NRSA_0d_int_Scalar;
                        bool aux_NRSA_read = false;
                        vartype aux_last_type_read_for_NRSA = UNKNOWN;
                        NestedVector<double> var_ER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_ER = UNKNOWN;
                        Matrix2d<double> var_GAM_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_GAM = UNKNOWN;
                        NestedVector<double> var_DER_1d_double_NestedVector;
                        vartype aux_last_type_read_for_DER = UNKNOWN;
                        Matrix2d<double> var_DGAM_2d_double_Matrix2d;
                        vartype aux_last_type_read_for_DGAM = UNKNOWN;
                        cpp_template = "[ MAT , 32 , 151 / AJ , PJ , 0 , 0 , (6*NCH) , NCH / \n { PPI , L , SCH , BND , APE , APT } { k = 1 to NCH } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AJ"]), write_opts);
                        // assign expression to variable AJ
                        var_AJ_0d_double_Scalar = py::cast<double>(cpp_current_dict["AJ"]);
                        aux_AJ_read = true;
                        validate_vartype_consistency("AJ", SCALAR_DOUBLE, aux_last_type_read_for_AJ);
                        aux_last_type_read_for_AJ = SCALAR_DOUBLE;
                        cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["PJ"]), write_opts);
                        // assign expression to variable PJ
                        var_PJ_0d_double_Scalar = py::cast<double>(cpp_current_dict["PJ"]);
                        aux_PJ_read = true;
                        validate_vartype_consistency("PJ", SCALAR_DOUBLE, aux_last_type_read_for_PJ);
                        aux_last_type_read_for_PJ = SCALAR_DOUBLE;
                        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NCH"])), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = (6*py::cast<int>(cpp_current_dict["NCH"]));
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NCH
                        var_NCH_0d_int_Scalar = (cpp_int_val/6);
                        aux_NCH_read = true;
                        validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                        aux_last_type_read_for_NCH = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NCH"]), write_opts);
                        if ((! (aux_NCH_read == true))) {
                          // assign expression to variable NCH
                          var_NCH_0d_int_Scalar = py::cast<int>(cpp_current_dict["NCH"]);
                          aux_NCH_read = true;
                          validate_vartype_consistency("NCH", SCALAR_INT, aux_last_type_read_for_NCH);
                          aux_last_type_read_for_NCH = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NCH"])), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = (6*py::cast<int>(cpp_current_dict["NCH"]));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["PPI"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable PPI
                            var_PPI_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["PPI"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("PPI", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_PPI);
                            aux_last_type_read_for_PPI = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["L"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable L
                            var_L_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["L"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("L", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_L);
                            aux_last_type_read_for_L = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["SCH"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable SCH
                            var_SCH_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["SCH"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("SCH", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_SCH);
                            aux_last_type_read_for_SCH = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["BND"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable BND
                            var_BND_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["BND"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("BND", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_BND);
                            aux_last_type_read_for_BND = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["APE"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable APE
                            var_APE_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["APE"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("APE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APE);
                            aux_last_type_read_for_APE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["APT"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable APT
                            var_APT_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["APT"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("APT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_APT);
                            aux_last_type_read_for_APT = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                        cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , 0 , NRSA , (12*NX) , NX / \n { ER , { GAM } { p = 1 to NCH } , { 0.0 } { r = 1 to num_zeros } \n DER , { DGAM } { p = 1 to NCH } , { 0.0 } { r = 1 to num_zeros } \n } { k = 1 to NRSA } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["NRSA"]), write_opts);
                        // assign expression to variable NRSA
                        var_NRSA_0d_int_Scalar = py::cast<int>(cpp_current_dict["NRSA"]);
                        aux_NRSA_read = true;
                        validate_vartype_consistency("NRSA", SCALAR_INT, aux_last_type_read_for_NRSA);
                        aux_last_type_read_for_NRSA = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, (12*((((2*(py::cast<int>(cpp_current_dict["NCH"])+1))+(2*((5-py::cast<int>(cpp_current_dict["NCH"]))%6)))*py::cast<int>(cpp_current_dict["NRSA"]))/12)), write_opts);
                        if ((! (aux_NCH_read == true))) {
                          throw std::runtime_error("The equation (12*((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12))==value cannot be solved for NCH because the modulo operator is not supported.");
                        } else {
                        }
                        if ((! (aux_NRSA_read == true))) {
                          throw std::runtime_error("The equation (12*((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12))==value cannot be solved for NRSA because the modulo operator is not supported.");
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 5, ((((2*(py::cast<int>(cpp_current_dict["NCH"])+1))+(2*((5-py::cast<int>(cpp_current_dict["NCH"]))%6)))*py::cast<int>(cpp_current_dict["NRSA"]))/12), write_opts);
                        if ((! (aux_NCH_read == true))) {
                          throw std::runtime_error("The equation ((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12)==value cannot be solved for NCH because the modulo operator is not supported.");
                        } else {
                        }
                        if ((! (aux_NRSA_read == true))) {
                          throw std::runtime_error("The equation ((((2*(NCH+1))+(2*((5-NCH)%6)))*NRSA)/12)==value cannot be solved for NRSA because the modulo operator is not supported.");
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, (12*((((2*(py::cast<int>(cpp_current_dict["NCH"])+1))+(2*((5-py::cast<int>(cpp_current_dict["NCH"]))%6)))*py::cast<int>(cpp_current_dict["NRSA"]))/12)), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = (12*((((2*(py::cast<int>(cpp_current_dict["NCH"])+1))+(2*((5-py::cast<int>(cpp_current_dict["NCH"]))%6)))*py::cast<int>(cpp_current_dict["NRSA"]))/12));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body
                          var_GAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRSA_0d_int_Scalar, false, false);
                          var_DGAM_2d_double_Matrix2d.init(1, var_NCH_0d_int_Scalar, 1, var_NRSA_0d_int_Scalar, false, false);

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_NRSA_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }

                            for (int var_p_0d_int_Scalar = 1;
                               var_p_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_p_0d_int_Scalar++) {
                              bool aux_p_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GAM"][py::cast(var_p_0d_int_Scalar)][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable GAM
                              var_GAM_2d_double_Matrix2d(var_p_0d_int_Scalar, var_k_0d_int_Scalar) = py::cast<double>(cpp_current_dict["GAM"][py::cast(var_p_0d_int_Scalar)][py::cast(var_k_0d_int_Scalar)]);
                              validate_vartype_consistency("GAM", MATRIX2D_DOUBLE, aux_last_type_read_for_GAM);
                              aux_last_type_read_for_GAM = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }

                            for (int var_r_0d_int_Scalar = 1;
                               var_r_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_r_0d_int_Scalar++) {
                              bool aux_r_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable DER
                            var_DER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["DER"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("DER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_DER);
                            aux_last_type_read_for_DER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }

                            for (int var_p_0d_int_Scalar = 1;
                               var_p_0d_int_Scalar <= var_NCH_0d_int_Scalar; var_p_0d_int_Scalar++) {
                              bool aux_p_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["DGAM"][py::cast(var_p_0d_int_Scalar)][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable DGAM
                              var_DGAM_2d_double_Matrix2d(var_p_0d_int_Scalar, var_k_0d_int_Scalar) = py::cast<double>(cpp_current_dict["DGAM"][py::cast(var_p_0d_int_Scalar)][py::cast(var_k_0d_int_Scalar)]);
                              validate_vartype_consistency("DGAM", MATRIX2D_DOUBLE, aux_last_type_read_for_DGAM);
                              aux_last_type_read_for_DGAM = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }

                            for (int var_r_0d_int_Scalar = 1;
                               var_r_0d_int_Scalar <= ((5-var_NCH_0d_int_Scalar)%6); var_r_0d_int_Scalar++) {
                              bool aux_r_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, 0.0, write_opts);
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                        cpp_current_dict = cpp_parent_dict_tmp;
                      }
                    }
                    cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , NDIGIT , NNN , NM , 0 ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read CONT record
                    cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["NDIGIT"]), write_opts);
                    // assign expression to variable NDIGIT
                    var_NDIGIT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NDIGIT"]);
                    aux_NDIGIT_read = true;
                    validate_vartype_consistency("NDIGIT", SCALAR_INT, aux_last_type_read_for_NDIGIT);
                    aux_last_type_read_for_NDIGIT = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["NNN"]), write_opts);
                    // assign expression to variable NNN
                    var_NNN_0d_int_Scalar = py::cast<int>(cpp_current_dict["NNN"]);
                    aux_NNN_read = true;
                    validate_vartype_consistency("NNN", SCALAR_INT, aux_last_type_read_for_NNN);
                    aux_last_type_read_for_NNN = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NM"]), write_opts);
                    // assign expression to variable NM
                    var_NM_0d_int_Scalar = py::cast<int>(cpp_current_dict["NM"]);
                    aux_NM_read = true;
                    validate_vartype_consistency("NM", SCALAR_INT, aux_last_type_read_for_NM);
                    aux_last_type_read_for_NM = SCALAR_INT;
                    cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                    cont << cpp_draft_line;

                    for (int var_q_0d_int_Scalar = 1;
                       var_q_0d_int_Scalar <= var_NM_0d_int_Scalar; var_q_0d_int_Scalar++) {
                      bool aux_q_read = true;
                      {
                        cpp_template = "[ MAT , 32 , 151 / II , JJ , KIJ { NDIGIT } ] INTG";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        int cpp_ndigit = var_NDIGIT_0d_int_Scalar;
                        if ((cpp_ndigit < 2 || cpp_ndigit > 6)) {
                          throw std::runtime_error("invalid NDIGIT (must be between 2 and 6)");
                        }
                        cpp_write_custom_int_field(cpp_draft_line, 0, 5, py::cast<int>(cpp_current_dict["II"][py::cast(var_q_0d_int_Scalar)]));
                        cpp_write_custom_int_field(cpp_draft_line, 5, 5, py::cast<int>(cpp_current_dict["JJ"][py::cast(var_q_0d_int_Scalar)]));
                        // assign expression to variable II
                        var_II_1d_int_NestedVector.set(var_q_0d_int_Scalar, py::cast<int>(cpp_current_dict["II"][py::cast(var_q_0d_int_Scalar)]));
                        validate_vartype_consistency("II", NESTEDVECTOR_INT, aux_last_type_read_for_II);
                        aux_last_type_read_for_II = NESTEDVECTOR_INT;
                        // assign expression to variable JJ
                        var_JJ_1d_int_NestedVector.set(var_q_0d_int_Scalar, py::cast<int>(cpp_current_dict["JJ"][py::cast(var_q_0d_int_Scalar)]));
                        validate_vartype_consistency("JJ", NESTEDVECTOR_INT, aux_last_type_read_for_JJ);
                        aux_last_type_read_for_JJ = NESTEDVECTOR_INT;
                        int cpp_step = cpp_ndigit + 1;
                        int cpp_end = 65;
                        int cpp_start;
                        if (cpp_ndigit <= 5) {
                          cpp_start = 11;
                        } else {
                          cpp_start = 10;
                        }
                        std::vector<int> cpp_intvec;
                        int elpos = 0;
                        for (int cpp_i = cpp_start; cpp_i < cpp_end; cpp_i += cpp_step) {
                        cpp_write_custom_int_field(cpp_draft_line, cpp_i, cpp_step, py::cast<int>(cpp_current_dict["KIJ"][py::cast(var_q_0d_int_Scalar)][py::cast(elpos)]));
                          cpp_intvec.push_back(py::cast<int>(cpp_current_dict["KIJ"][py::cast(var_q_0d_int_Scalar)][py::cast(elpos)]));
                          elpos++;
                        }
                        // assign expression to variable KIJ
                        var_KIJ_1d_intvec_NestedVector.set(var_q_0d_int_Scalar, cpp_intvec);
                        validate_vartype_consistency("KIJ", NESTEDVECTOR_INTVEC, aux_last_type_read_for_KIJ);
                        aux_last_type_read_for_KIJ = NESTEDVECTOR_INTVEC;
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
              }
            }
            if (! cpp_found_match) {
              if (! cpp_found_match) {
                if ((((((((aux_LRU_read == true)) && ((var_LRU_0d_int_Scalar)==(2)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  cpp_template = "[ MAT , 32 , 151 / SPI , AP , 0 , 0 , NLS , 0 ] CONT";
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  // read CONT record
                  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["SPI"]), write_opts);
                  // assign expression to variable SPI
                  var_SPI_0d_double_Scalar = py::cast<double>(cpp_current_dict["SPI"]);
                  aux_SPI_read = true;
                  validate_vartype_consistency("SPI", SCALAR_DOUBLE, aux_last_type_read_for_SPI);
                  aux_last_type_read_for_SPI = SCALAR_DOUBLE;
                  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AP"]), write_opts);
                  // assign expression to variable AP
                  var_AP_0d_double_Scalar = py::cast<double>(cpp_current_dict["AP"]);
                  aux_AP_read = true;
                  validate_vartype_consistency("AP", SCALAR_DOUBLE, aux_last_type_read_for_AP);
                  aux_last_type_read_for_AP = SCALAR_DOUBLE;
                  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NLS"]), write_opts);
                  // assign expression to variable NLS
                  var_NLS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NLS"]);
                  aux_NLS_read = true;
                  validate_vartype_consistency("NLS", SCALAR_INT, aux_last_type_read_for_NLS);
                  aux_last_type_read_for_NLS = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                  cont << cpp_draft_line;

                  for (int var_q_0d_int_Scalar = 1;
                     var_q_0d_int_Scalar <= var_NLS_0d_int_Scalar; var_q_0d_int_Scalar++) {
                    bool aux_q_read = true;
                    // open section l_group
                    {
                      py::dict cpp_parent_dict_tmp = cpp_current_dict;
                      if ((! cpp_parent_dict_tmp.contains("l_group"))) {
                        cpp_parent_dict_tmp["l_group"] = py::dict();
                      }
                      py::dict cpp_current_dict = cpp_parent_dict_tmp["l_group"];
                      if ((! cpp_current_dict.contains(py::cast(var_q_0d_int_Scalar)))) {
                        cpp_current_dict[py::cast(var_q_0d_int_Scalar)] = py::dict();
                      }
                      cpp_current_dict = cpp_current_dict[py::cast(var_q_0d_int_Scalar)];
                      // variable declarations
                      double var_AWRI_0d_double_Scalar;
                      bool aux_AWRI_read = false;
                      vartype aux_last_type_read_for_AWRI = UNKNOWN;
                      int var_L_0d_int_Scalar;
                      bool aux_L_read = false;
                      vartype aux_last_type_read_for_L = UNKNOWN;
                      int cpp_int_val;
                      bool aux_cpp_int_val_read = false;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int var_NJS_0d_int_Scalar;
                      bool aux_NJS_read = false;
                      vartype aux_last_type_read_for_NJS = UNKNOWN;
                      NestedVector<double> var_D_1d_double_NestedVector;
                      vartype aux_last_type_read_for_D = UNKNOWN;
                      NestedVector<double> var_AJ_1d_double_NestedVector;
                      vartype aux_last_type_read_for_AJ = UNKNOWN;
                      NestedVector<double> var_GNO_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GNO = UNKNOWN;
                      NestedVector<double> var_GG_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GG = UNKNOWN;
                      NestedVector<double> var_GF_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GF = UNKNOWN;
                      NestedVector<double> var_GX_1d_double_NestedVector;
                      vartype aux_last_type_read_for_GX = UNKNOWN;
                      cpp_template = "[ MAT , 32 , 151 / AWRI , 0.0 , L , 0 , (6*NJS) , NJS / \n { D , AJ , GNO , GG , GF , GX } { k = 1 to NJS } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read LIST record
                      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["AWRI"]), write_opts);
                      // assign expression to variable AWRI
                      var_AWRI_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWRI"]);
                      aux_AWRI_read = true;
                      validate_vartype_consistency("AWRI", SCALAR_DOUBLE, aux_last_type_read_for_AWRI);
                      aux_last_type_read_for_AWRI = SCALAR_DOUBLE;
                      cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["L"]), write_opts);
                      // assign expression to variable L
                      var_L_0d_int_Scalar = py::cast<int>(cpp_current_dict["L"]);
                      aux_L_read = true;
                      validate_vartype_consistency("L", SCALAR_INT, aux_last_type_read_for_L);
                      aux_last_type_read_for_L = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NJS"])), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (6*py::cast<int>(cpp_current_dict["NJS"]));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NJS
                      var_NJS_0d_int_Scalar = (cpp_int_val/6);
                      aux_NJS_read = true;
                      validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                      aux_last_type_read_for_NJS = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NJS"]), write_opts);
                      if ((! (aux_NJS_read == true))) {
                        // assign expression to variable NJS
                        var_NJS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NJS"]);
                        aux_NJS_read = true;
                        validate_vartype_consistency("NJS", SCALAR_INT, aux_last_type_read_for_NJS);
                        aux_last_type_read_for_NJS = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (6*py::cast<int>(cpp_current_dict["NJS"])), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (6*py::cast<int>(cpp_current_dict["NJS"]));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST body

                        for (int var_k_0d_int_Scalar = 1;
                           var_k_0d_int_Scalar <= var_NJS_0d_int_Scalar; var_k_0d_int_Scalar++) {
                          bool aux_k_read = true;
                          // read LIST body
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["D"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                          // assign expression to variable D
                          var_D_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["D"][py::cast(var_k_0d_int_Scalar)]));
                          validate_vartype_consistency("D", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_D);
                          aux_last_type_read_for_D = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                          // assign expression to variable AJ
                          var_AJ_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["AJ"][py::cast(var_k_0d_int_Scalar)]));
                          validate_vartype_consistency("AJ", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_AJ);
                          aux_last_type_read_for_AJ = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GNO"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                          // assign expression to variable GNO
                          var_GNO_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GNO"][py::cast(var_k_0d_int_Scalar)]));
                          validate_vartype_consistency("GNO", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GNO);
                          aux_last_type_read_for_GNO = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                          // assign expression to variable GG
                          var_GG_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GG"][py::cast(var_k_0d_int_Scalar)]));
                          validate_vartype_consistency("GG", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GG);
                          aux_last_type_read_for_GG = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GF"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                          // assign expression to variable GF
                          var_GF_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GF"][py::cast(var_k_0d_int_Scalar)]));
                          validate_vartype_consistency("GF", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GF);
                          aux_last_type_read_for_GF = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["GX"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                          // assign expression to variable GX
                          var_GX_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["GX"][py::cast(var_k_0d_int_Scalar)]));
                          validate_vartype_consistency("GX", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_GX);
                          aux_last_type_read_for_GX = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                      cpp_current_dict = cpp_parent_dict_tmp;
                    }
                  }
                  cpp_template = "[ MAT , 32 , 151 / 0.0 , 0.0 , MPAR , 0 , ((NPAR*(NPAR+1))/2) , NPAR / \n { { RV } { q = p to NPAR } } { p = 1 to NPAR } ] LIST";
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  // read LIST record
                  cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                  cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["MPAR"]), write_opts);
                  // assign expression to variable MPAR
                  var_MPAR_0d_int_Scalar = py::cast<int>(cpp_current_dict["MPAR"]);
                  aux_MPAR_read = true;
                  validate_vartype_consistency("MPAR", SCALAR_INT, aux_last_type_read_for_MPAR);
                  aux_last_type_read_for_MPAR = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NPAR"]), write_opts);
                  // assign expression to variable NPAR
                  var_NPAR_0d_int_Scalar = py::cast<int>(cpp_current_dict["NPAR"]);
                  aux_NPAR_read = true;
                  validate_vartype_consistency("NPAR", SCALAR_INT, aux_last_type_read_for_NPAR);
                  aux_last_type_read_for_NPAR = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_current_dict["NPAR"])*(py::cast<int>(cpp_current_dict["NPAR"])+1))/2), write_opts);
                  if ((! (aux_NPAR_read == true))) {
                    throw std::runtime_error("The equation ((NPAR*(NPAR+1))/2)==value cannot be solved for NPAR because this variable could not be isolated.");
                  } else {
                  }
                  cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_current_dict["NPAR"])*(py::cast<int>(cpp_current_dict["NPAR"])+1))/2), write_opts);
                  cont << cpp_draft_line;
                  {
                    int cpp_npl = ((py::cast<int>(cpp_current_dict["NPAR"])*(py::cast<int>(cpp_current_dict["NPAR"])+1))/2);
                    int cpp_i = 0;
                    int cpp_j = 0;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read LIST body
                    var_RV_2d_double_Matrix2d.init(1, var_NPAR_0d_int_Scalar, 1, var_NPAR_0d_int_Scalar, true, false);

                    for (int var_p_0d_int_Scalar = 1;
                       var_p_0d_int_Scalar <= var_NPAR_0d_int_Scalar; var_p_0d_int_Scalar++) {
                      bool aux_p_read = true;
                      // read LIST body

                      for (int var_q_0d_int_Scalar = var_p_0d_int_Scalar;
                         var_q_0d_int_Scalar <= var_NPAR_0d_int_Scalar; var_q_0d_int_Scalar++) {
                        bool aux_q_read = true;
                        // read LIST body
                        cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["RV"][py::cast(var_p_0d_int_Scalar)][py::cast(var_q_0d_int_Scalar)]), write_opts);
                        // assign expression to variable RV
                        var_RV_2d_double_Matrix2d(var_p_0d_int_Scalar, var_q_0d_int_Scalar) = py::cast<double>(cpp_current_dict["RV"][py::cast(var_p_0d_int_Scalar)][py::cast(var_q_0d_int_Scalar)]);
                        validate_vartype_consistency("RV", MATRIX2D_DOUBLE, aux_last_type_read_for_RV);
                        aux_last_type_read_for_RV = MATRIX2D_DOUBLE;
                        cpp_i++;
                        cpp_j++;
                        if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                          cont << cpp_draft_line;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          cpp_j = 0;
                        }
                      }
                    }
                    if (cpp_i != cpp_npl) {
                      throw std::runtime_error("not exactly NPL elements consumed");
                    }
                  }
                  cont << cpp_draft_line;
                }
              }
            }
          }
          cpp_current_dict = cpp_parent_dict_tmp;
        }
      }
      cpp_current_dict = cpp_parent_dict_tmp;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 284c3ace698a427c06623ccd760dca26
// MD5 hash of the following function definition: 5266ba00413f1f1c446bc8abdfe0201d
void write_mf33_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_MTL_0d_int_Scalar;
  bool aux_MTL_read = false;
  vartype aux_last_type_read_for_MTL = UNKNOWN;
  int var_NL_0d_int_Scalar;
  bool aux_NL_read = false;
  vartype aux_last_type_read_for_NL = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 33;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 33;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 33 , MT / ZA , AWR , 0 , MTL , 0 , NL ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["MTL"]), write_opts);
  // assign expression to variable MTL
  var_MTL_0d_int_Scalar = py::cast<int>(cpp_current_dict["MTL"]);
  aux_MTL_read = true;
  validate_vartype_consistency("MTL", SCALAR_INT, aux_last_type_read_for_MTL);
  aux_last_type_read_for_MTL = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NL"]), write_opts);
  // assign expression to variable NL
  var_NL_0d_int_Scalar = py::cast<int>(cpp_current_dict["NL"]);
  aux_NL_read = true;
  validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
  aux_last_type_read_for_NL = SCALAR_INT;
  cont << cpp_draft_line;
  // evaluate if-elif-else clause
  {
    bool cpp_found_match = false;
    if (! cpp_found_match) {
      if ((((((((aux_MTL_read == true)) && ((var_MTL_0d_int_Scalar)==(0)))))))) {
        // if statement evaluation
        cpp_found_match = true;

        for (int var_n_0d_int_Scalar = 1;
           var_n_0d_int_Scalar <= var_NL_0d_int_Scalar; var_n_0d_int_Scalar++) {
          bool aux_n_read = true;
          // open section subsection
          {
            py::dict cpp_parent_dict_tmp = cpp_current_dict;
            if ((! cpp_parent_dict_tmp.contains("subsection"))) {
              cpp_parent_dict_tmp["subsection"] = py::dict();
            }
            py::dict cpp_current_dict = cpp_parent_dict_tmp["subsection"];
            if ((! cpp_current_dict.contains(py::cast(var_n_0d_int_Scalar)))) {
              cpp_current_dict[py::cast(var_n_0d_int_Scalar)] = py::dict();
            }
            cpp_current_dict = cpp_current_dict[py::cast(var_n_0d_int_Scalar)];
            // variable declarations
            double var_XMF1_0d_double_Scalar;
            bool aux_XMF1_read = false;
            vartype aux_last_type_read_for_XMF1 = UNKNOWN;
            double var_XLFS1_0d_double_Scalar;
            bool aux_XLFS1_read = false;
            vartype aux_last_type_read_for_XLFS1 = UNKNOWN;
            int var_MAT1_0d_int_Scalar;
            bool aux_MAT1_read = false;
            vartype aux_last_type_read_for_MAT1 = UNKNOWN;
            int var_MT1_0d_int_Scalar;
            bool aux_MT1_read = false;
            vartype aux_last_type_read_for_MT1 = UNKNOWN;
            int var_NC_0d_int_Scalar;
            bool aux_NC_read = false;
            vartype aux_last_type_read_for_NC = UNKNOWN;
            int var_NI_0d_int_Scalar;
            bool aux_NI_read = false;
            vartype aux_last_type_read_for_NI = UNKNOWN;
            cpp_template = "[ MAT , 33 , MT / XMF1 , XLFS1 , MAT1 , MT1 , NC , NI ] CONT";
            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
            // read CONT record
            cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["XMF1"]), write_opts);
            // assign expression to variable XMF1
            var_XMF1_0d_double_Scalar = py::cast<double>(cpp_current_dict["XMF1"]);
            aux_XMF1_read = true;
            validate_vartype_consistency("XMF1", SCALAR_DOUBLE, aux_last_type_read_for_XMF1);
            aux_last_type_read_for_XMF1 = SCALAR_DOUBLE;
            cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["XLFS1"]), write_opts);
            // assign expression to variable XLFS1
            var_XLFS1_0d_double_Scalar = py::cast<double>(cpp_current_dict["XLFS1"]);
            aux_XLFS1_read = true;
            validate_vartype_consistency("XLFS1", SCALAR_DOUBLE, aux_last_type_read_for_XLFS1);
            aux_last_type_read_for_XLFS1 = SCALAR_DOUBLE;
            cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["MAT1"]), write_opts);
            // assign expression to variable MAT1
            var_MAT1_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT1"]);
            aux_MAT1_read = true;
            validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
            aux_last_type_read_for_MAT1 = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["MT1"]), write_opts);
            // assign expression to variable MT1
            var_MT1_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT1"]);
            aux_MT1_read = true;
            validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
            aux_last_type_read_for_MT1 = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NC"]), write_opts);
            // assign expression to variable NC
            var_NC_0d_int_Scalar = py::cast<int>(cpp_current_dict["NC"]);
            aux_NC_read = true;
            validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
            aux_last_type_read_for_NC = SCALAR_INT;
            cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NI"]), write_opts);
            // assign expression to variable NI
            var_NI_0d_int_Scalar = py::cast<int>(cpp_current_dict["NI"]);
            aux_NI_read = true;
            validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
            aux_last_type_read_for_NI = SCALAR_INT;
            cont << cpp_draft_line;

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NC_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section nc_subsection
              {
                py::dict cpp_parent_dict_tmp = cpp_current_dict;
                if ((! cpp_parent_dict_tmp.contains("nc_subsection"))) {
                  cpp_parent_dict_tmp["nc_subsection"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict_tmp["nc_subsection"];
                if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                  cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                }
                cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                // variable declarations
                int var_LTY_0d_int_Scalar;
                bool aux_LTY_read = false;
                vartype aux_last_type_read_for_LTY = UNKNOWN;
                double var_E1_0d_double_Scalar;
                bool aux_E1_read = false;
                vartype aux_last_type_read_for_E1 = UNKNOWN;
                double var_E2_0d_double_Scalar;
                bool aux_E2_read = false;
                vartype aux_last_type_read_for_E2 = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NCI_0d_int_Scalar;
                bool aux_NCI_read = false;
                vartype aux_last_type_read_for_NCI = UNKNOWN;
                NestedVector<double> var_C_1d_double_NestedVector;
                vartype aux_last_type_read_for_C = UNKNOWN;
                NestedVector<double> var_XMT_1d_double_NestedVector;
                vartype aux_last_type_read_for_XMT = UNKNOWN;
                int var_MATS_0d_int_Scalar;
                bool aux_MATS_read = false;
                vartype aux_last_type_read_for_MATS = UNKNOWN;
                int var_MTS_0d_int_Scalar;
                bool aux_MTS_read = false;
                vartype aux_last_type_read_for_MTS = UNKNOWN;
                int var_NEI_0d_int_Scalar;
                bool aux_NEI_read = false;
                vartype aux_last_type_read_for_NEI = UNKNOWN;
                double var_XMFS_0d_double_Scalar;
                bool aux_XMFS_read = false;
                vartype aux_last_type_read_for_XMFS = UNKNOWN;
                double var_XLFSS_0d_double_Scalar;
                bool aux_XLFSS_read = false;
                vartype aux_last_type_read_for_XLFSS = UNKNOWN;
                NestedVector<double> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                NestedVector<double> var_WE_1d_double_NestedVector;
                vartype aux_last_type_read_for_WE = UNKNOWN;
                cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                // read CONT record
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LTY"]), write_opts);
                // assign expression to variable LTY
                var_LTY_0d_int_Scalar = py::cast<int>(cpp_current_dict["LTY"]);
                aux_LTY_read = true;
                validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                aux_last_type_read_for_LTY = SCALAR_INT;
                cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                cont << cpp_draft_line;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if ((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(0)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      cpp_template = "[ MAT , 33 , MT / E1 , E2 , 0 , 0 , (2*NCI) , NCI / \n { C , XMT } { i = 1 to NCI } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read LIST record
                      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["E1"]), write_opts);
                      // assign expression to variable E1
                      var_E1_0d_double_Scalar = py::cast<double>(cpp_current_dict["E1"]);
                      aux_E1_read = true;
                      validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                      aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                      cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E2"]), write_opts);
                      // assign expression to variable E2
                      var_E2_0d_double_Scalar = py::cast<double>(cpp_current_dict["E2"]);
                      aux_E2_read = true;
                      validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                      aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NCI"])), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (2*py::cast<int>(cpp_current_dict["NCI"]));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NCI
                      var_NCI_0d_int_Scalar = (cpp_int_val/2);
                      aux_NCI_read = true;
                      validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                      aux_last_type_read_for_NCI = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NCI"]), write_opts);
                      if ((! (aux_NCI_read == true))) {
                        // assign expression to variable NCI
                        var_NCI_0d_int_Scalar = py::cast<int>(cpp_current_dict["NCI"]);
                        aux_NCI_read = true;
                        validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                        aux_last_type_read_for_NCI = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NCI"])), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (2*py::cast<int>(cpp_current_dict["NCI"]));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST body

                        for (int var_i_0d_int_Scalar = 1;
                           var_i_0d_int_Scalar <= var_NCI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                          bool aux_i_read = true;
                          // read LIST body
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["C"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                          // assign expression to variable C
                          var_C_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["C"][py::cast(var_i_0d_int_Scalar)]));
                          validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
                          aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["XMT"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                          // assign expression to variable XMT
                          var_XMT_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["XMT"][py::cast(var_i_0d_int_Scalar)]));
                          validate_vartype_consistency("XMT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_XMT);
                          aux_last_type_read_for_XMT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      if (((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)>=(1)))))&&((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)<=(3)))))))) {
                        // if statement evaluation
                        cpp_found_match = true;
                        cpp_template = "[ MAT , 33 , MT / E1 , E2 , MATS , MTS , ((2*NEI)+2) , NEI / \n XMFS , XLFSS , { E , WE } { i = 1 to NEI } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["E1"]), write_opts);
                        // assign expression to variable E1
                        var_E1_0d_double_Scalar = py::cast<double>(cpp_current_dict["E1"]);
                        aux_E1_read = true;
                        validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                        aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                        cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E2"]), write_opts);
                        // assign expression to variable E2
                        var_E2_0d_double_Scalar = py::cast<double>(cpp_current_dict["E2"]);
                        aux_E2_read = true;
                        validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                        aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["MATS"]), write_opts);
                        // assign expression to variable MATS
                        var_MATS_0d_int_Scalar = py::cast<int>(cpp_current_dict["MATS"]);
                        aux_MATS_read = true;
                        validate_vartype_consistency("MATS", SCALAR_INT, aux_last_type_read_for_MATS);
                        aux_last_type_read_for_MATS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["MTS"]), write_opts);
                        // assign expression to variable MTS
                        var_MTS_0d_int_Scalar = py::cast<int>(cpp_current_dict["MTS"]);
                        aux_MTS_read = true;
                        validate_vartype_consistency("MTS", SCALAR_INT, aux_last_type_read_for_MTS);
                        aux_last_type_read_for_MTS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, ((2*py::cast<int>(cpp_current_dict["NEI"]))+2), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = ((2*py::cast<int>(cpp_current_dict["NEI"]))+2);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NEI
                        var_NEI_0d_int_Scalar = ((cpp_int_val+(-2))/2);
                        aux_NEI_read = true;
                        validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                        aux_last_type_read_for_NEI = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NEI"]), write_opts);
                        if ((! (aux_NEI_read == true))) {
                          // assign expression to variable NEI
                          var_NEI_0d_int_Scalar = py::cast<int>(cpp_current_dict["NEI"]);
                          aux_NEI_read = true;
                          validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                          aux_last_type_read_for_NEI = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, ((2*py::cast<int>(cpp_current_dict["NEI"]))+2), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = ((2*py::cast<int>(cpp_current_dict["NEI"]))+2);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["XMFS"]), write_opts);
                          // assign expression to variable XMFS
                          var_XMFS_0d_double_Scalar = py::cast<double>(cpp_current_dict["XMFS"]);
                          aux_XMFS_read = true;
                          validate_vartype_consistency("XMFS", SCALAR_DOUBLE, aux_last_type_read_for_XMFS);
                          aux_last_type_read_for_XMFS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["XLFSS"]), write_opts);
                          // assign expression to variable XLFSS
                          var_XLFSS_0d_double_Scalar = py::cast<double>(cpp_current_dict["XLFSS"]);
                          aux_XLFSS_read = true;
                          validate_vartype_consistency("XLFSS", SCALAR_DOUBLE, aux_last_type_read_for_XLFSS);
                          aux_last_type_read_for_XLFSS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }

                          for (int var_i_0d_int_Scalar = 1;
                             var_i_0d_int_Scalar <= var_NEI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                            bool aux_i_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["WE"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                            // assign expression to variable WE
                            var_WE_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["WE"][py::cast(var_i_0d_int_Scalar)]));
                            validate_vartype_consistency("WE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_WE);
                            aux_last_type_read_for_WE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
                cpp_current_dict = cpp_parent_dict_tmp;
              }
            }

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NI_0d_int_Scalar; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              // open section ni_subsection
              {
                py::dict cpp_parent_dict_tmp = cpp_current_dict;
                if ((! cpp_parent_dict_tmp.contains("ni_subsection"))) {
                  cpp_parent_dict_tmp["ni_subsection"] = py::dict();
                }
                py::dict cpp_current_dict = cpp_parent_dict_tmp["ni_subsection"];
                if ((! cpp_current_dict.contains(py::cast(var_m_0d_int_Scalar)))) {
                  cpp_current_dict[py::cast(var_m_0d_int_Scalar)] = py::dict();
                }
                cpp_current_dict = cpp_current_dict[py::cast(var_m_0d_int_Scalar)];
                // variable declarations
                int var_LT_0d_int_Scalar;
                bool aux_LT_read = false;
                vartype aux_last_type_read_for_LT = UNKNOWN;
                int var_LB_0d_int_Scalar;
                bool aux_LB_read = false;
                vartype aux_last_type_read_for_LB = UNKNOWN;
                int cpp_int_val;
                bool aux_cpp_int_val_read = false;
                vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                int var_NP_0d_int_Scalar;
                bool aux_NP_read = false;
                vartype aux_last_type_read_for_NP = UNKNOWN;
                NestedVector<double> var_Ek_1d_double_NestedVector;
                vartype aux_last_type_read_for_Ek = UNKNOWN;
                NestedVector<double> var_Fk_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fk = UNKNOWN;
                NestedVector<double> var_El_1d_double_NestedVector;
                vartype aux_last_type_read_for_El = UNKNOWN;
                NestedVector<double> var_Fl_1d_double_NestedVector;
                vartype aux_last_type_read_for_Fl = UNKNOWN;
                int var_LS_0d_int_Scalar;
                bool aux_LS_read = false;
                vartype aux_last_type_read_for_LS = UNKNOWN;
                int var_NE_0d_int_Scalar;
                bool aux_NE_read = false;
                vartype aux_last_type_read_for_NE = UNKNOWN;
                NestedVector<double> var_E_1d_double_NestedVector;
                vartype aux_last_type_read_for_E = UNKNOWN;
                Matrix2d<double> var_F_2d_double_Matrix2d;
                vartype aux_last_type_read_for_F = UNKNOWN;
                int var_NER_0d_int_Scalar;
                bool aux_NER_read = false;
                vartype aux_last_type_read_for_NER = UNKNOWN;
                int var_NEC_0d_int_Scalar;
                bool aux_NEC_read = false;
                vartype aux_last_type_read_for_NEC = UNKNOWN;
                NestedVector<double> var_ER_1d_double_NestedVector;
                vartype aux_last_type_read_for_ER = UNKNOWN;
                NestedVector<double> var_EC_1d_double_NestedVector;
                vartype aux_last_type_read_for_EC = UNKNOWN;
                NestedVector<double> var_F_1d_double_NestedVector;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                        int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                        bool& glob_aux_LT_read = aux_LT_read;
                        bool aux_LT_read = glob_aux_LT_read;
                        vartype aux_last_type_read_for_LT = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_cpp_int_val = cpp_int_val;
                        int cpp_int_val = glob_cpp_int_val;
                        bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                        bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                        int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                        bool& glob_aux_NP_read = aux_NP_read;
                        bool aux_NP_read = glob_aux_NP_read;
                        vartype aux_last_type_read_for_NP = UNKNOWN;
                        cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                        // read LIST record
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LT", -99999));
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = (2*py::cast<int>(cpp_current_dict.attr("get")("NP", -99999)));
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NP", -99999));
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)>=(0)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)<=(4)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { k = 1 to (NP-LT) } \n { El , Fl } { k = 1 to LT } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LT"]), write_opts);
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LT"]);
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NP"])), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = (2*py::cast<int>(cpp_current_dict["NP"]));
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NP"]), write_opts);
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NP"]);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NP"])), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = (2*py::cast<int>(cpp_current_dict["NP"]));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= (var_NP_0d_int_Scalar-var_LT_0d_int_Scalar); var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Ek"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable Ek
                            var_Ek_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["Ek"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("Ek", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ek);
                            aux_last_type_read_for_Ek = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Fk"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable Fk
                            var_Fk_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["Fk"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("Fk", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fk);
                            aux_last_type_read_for_Fk = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }

                          for (int var_k_0d_int_Scalar = 1;
                             var_k_0d_int_Scalar <= var_LT_0d_int_Scalar; var_k_0d_int_Scalar++) {
                            bool aux_k_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["El"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable El
                            var_El_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["El"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("El", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_El);
                            aux_last_type_read_for_El = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Fl"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                            // assign expression to variable Fl
                            var_Fl_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["Fl"][py::cast(var_k_0d_int_Scalar)]));
                            validate_vartype_consistency("Fl", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fl);
                            aux_last_type_read_for_Fl = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          // read LIST record
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LS", -99999));
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NE", -99999));
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE-1))+1) , NE / \n { E } { k = 1 to NE } { { F } { kp = 1 to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LS"]), write_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LS"]);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_current_dict["NE"])*(py::cast<int>(cpp_current_dict["NE"])-1))+1), write_opts);
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE-1))+1)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_current_dict["NE"])*(py::cast<int>(cpp_current_dict["NE"])-1))+1), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = ((py::cast<int>(cpp_current_dict["NE"])*(py::cast<int>(cpp_current_dict["NE"])-1))+1);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = 1;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)][py::cast(var_kp_0d_int_Scalar)]), write_opts);
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)][py::cast(var_kp_0d_int_Scalar)]);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                          int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                          bool& glob_aux_LS_read = aux_LS_read;
                          bool aux_LS_read = glob_aux_LS_read;
                          vartype aux_last_type_read_for_LS = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                          int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                          bool& glob_aux_NE_read = aux_NE_read;
                          bool aux_NE_read = glob_aux_NE_read;
                          vartype aux_last_type_read_for_NE = UNKNOWN;
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          // read LIST record
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LS", -99999));
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NE", -99999));
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LS , LB , ((NE*(NE+1))/2) , NE / \n { E } { k = 1 to NE } { { F } { kp = k to (NE-1) } } { k = 1 to (NE-1) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LS"]), write_opts);
                          // assign expression to variable LS
                          var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LS"]);
                          aux_LS_read = true;
                          validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                          aux_last_type_read_for_LS = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
                          // assign expression to variable NE
                          var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
                          aux_NE_read = true;
                          validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                          aux_last_type_read_for_NE = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_current_dict["NE"])*(py::cast<int>(cpp_current_dict["NE"])+1))/2), write_opts);
                          if ((! (aux_NE_read == true))) {
                            throw std::runtime_error("The equation ((NE*(NE+1))/2)==value cannot be solved for NE because this variable could not be isolated.");
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, ((py::cast<int>(cpp_current_dict["NE"])*(py::cast<int>(cpp_current_dict["NE"])+1))/2), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = ((py::cast<int>(cpp_current_dict["NE"])*(py::cast<int>(cpp_current_dict["NE"])+1))/2);
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NE_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_kp_0d_int_Scalar = var_k_0d_int_Scalar;
                                 var_kp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_kp_0d_int_Scalar++) {
                                bool aux_kp_read = true;
                                // read LIST body
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)][py::cast(var_kp_0d_int_Scalar)]), write_opts);
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_kp_0d_int_Scalar) = py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)][py::cast(var_kp_0d_int_Scalar)]);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_var_NER_0d_int_Scalar = var_NER_0d_int_Scalar;
                          int var_NER_0d_int_Scalar = glob_var_NER_0d_int_Scalar;
                          bool& glob_aux_NER_read = aux_NER_read;
                          bool aux_NER_read = glob_aux_NER_read;
                          vartype aux_last_type_read_for_NER = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NEC_0d_int_Scalar = var_NEC_0d_int_Scalar;
                          int var_NEC_0d_int_Scalar = glob_var_NEC_0d_int_Scalar;
                          bool& glob_aux_NEC_read = aux_NEC_read;
                          bool aux_NEC_read = glob_aux_NEC_read;
                          vartype aux_last_type_read_for_NEC = UNKNOWN;
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                          // read LIST record
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NER", -99999));
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (1+(py::cast<int>(cpp_current_dict.attr("get")("NER", -99999))*py::cast<int>(cpp_current_dict.attr("get")("NEC", -99999))));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NEC
                          var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                          aux_NEC_read = true;
                          validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                          aux_last_type_read_for_NEC = SCALAR_INT;
                          if ((! (aux_NER_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (1+(py::cast<int>(cpp_current_dict.attr("get")("NER", -99999))*py::cast<int>(cpp_current_dict.attr("get")("NEC", -99999))));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                          } else {
                          }
                          if ((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(6)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , 0 , LB , (1+(NER*NEC)) , NER / \n { ER } { k = 1 to NER } { EC } { k = 1 to NEC } \n { { F } { l = 1 to (NEC-1) } } { k = 1 to (NER-1) } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NER"]), write_opts);
                          // assign expression to variable NER
                          var_NER_0d_int_Scalar = py::cast<int>(cpp_current_dict["NER"]);
                          aux_NER_read = true;
                          validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                          aux_last_type_read_for_NER = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, (1+(py::cast<int>(cpp_current_dict["NER"])*py::cast<int>(cpp_current_dict["NEC"]))), write_opts);
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (1+(py::cast<int>(cpp_current_dict["NER"])*py::cast<int>(cpp_current_dict["NEC"])));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NEC
                          var_NEC_0d_int_Scalar = ((cpp_int_val+(-1))/var_NER_0d_int_Scalar);
                          aux_NEC_read = true;
                          validate_vartype_consistency("NEC", SCALAR_INT, aux_last_type_read_for_NEC);
                          aux_last_type_read_for_NEC = SCALAR_INT;
                          if ((! (aux_NER_read == true))) {
                            // assign expression to variable cpp_int_val
                            cpp_int_val = (1+(py::cast<int>(cpp_current_dict["NER"])*py::cast<int>(cpp_current_dict["NEC"])));
                            aux_cpp_int_val_read = true;
                            validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                            aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                            // assign expression to variable NER
                            var_NER_0d_int_Scalar = ((cpp_int_val+(-1))/var_NEC_0d_int_Scalar);
                            aux_NER_read = true;
                            validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                            aux_last_type_read_for_NER = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, (1+(py::cast<int>(cpp_current_dict["NER"])*py::cast<int>(cpp_current_dict["NEC"]))), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = (1+(py::cast<int>(cpp_current_dict["NER"])*py::cast<int>(cpp_current_dict["NEC"])));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NER_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable ER
                              var_ER_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["ER"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                              aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NEC_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["EC"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable EC
                              var_EC_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["EC"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("EC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EC);
                              aux_last_type_read_for_EC = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                            var_F_2d_double_Matrix2d.init(1, (var_NER_0d_int_Scalar-1), 1, (var_NEC_0d_int_Scalar-1), false, false);

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= (var_NER_0d_int_Scalar-1); var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body

                              for (int var_l_0d_int_Scalar = 1;
                                 var_l_0d_int_Scalar <= (var_NEC_0d_int_Scalar-1); var_l_0d_int_Scalar++) {
                                bool aux_l_read = true;
                                // read LIST body
                                cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]), write_opts);
                                // assign expression to variable F
                                var_F_2d_double_Matrix2d(var_k_0d_int_Scalar, var_l_0d_int_Scalar) = py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]);
                                validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                                aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                                cpp_i++;
                                cpp_j++;
                                if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                  cont << cpp_draft_line;
                                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                  cpp_j = 0;
                                }
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                  if (! cpp_found_match) {
                    if (! cpp_found_match) {
                      // if statement evaluation with lookahead
                      {
                        {
                          // variable declarations
                          int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                          int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                          bool& glob_aux_LT_read = aux_LT_read;
                          bool aux_LT_read = glob_aux_LT_read;
                          vartype aux_last_type_read_for_LT = UNKNOWN;
                          int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                          int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                          bool& glob_aux_LB_read = aux_LB_read;
                          bool aux_LB_read = glob_aux_LB_read;
                          vartype aux_last_type_read_for_LB = UNKNOWN;
                          int& glob_cpp_int_val = cpp_int_val;
                          int cpp_int_val = glob_cpp_int_val;
                          bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                          bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                          vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                          int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                          int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                          bool& glob_aux_NP_read = aux_NP_read;
                          bool aux_NP_read = glob_aux_NP_read;
                          vartype aux_last_type_read_for_NP = UNKNOWN;
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                          // read LIST record
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LT", -99999));
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (2*py::cast<int>(cpp_current_dict.attr("get")("NP", -99999)));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NP", -99999));
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                          if ((((((((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(8))))))||(((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(9)))))))))&&((((aux_LT_read == true)) && ((var_LT_0d_int_Scalar)==(0)))))))) {
                            cpp_found_match = true;
                          }
                        }
                        if (cpp_found_match) {
                          cpp_template = "[ MAT , 33 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { k = 1 to NP } ] LIST";
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST record
                          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LT"]), write_opts);
                          // assign expression to variable LT
                          var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LT"]);
                          aux_LT_read = true;
                          validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                          aux_last_type_read_for_LT = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                          // assign expression to variable LB
                          var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                          aux_LB_read = true;
                          validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                          aux_last_type_read_for_LB = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NP"])), write_opts);
                          // assign expression to variable cpp_int_val
                          cpp_int_val = (2*py::cast<int>(cpp_current_dict["NP"]));
                          aux_cpp_int_val_read = true;
                          validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                          aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = (cpp_int_val/2);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NP"]), write_opts);
                          if ((! (aux_NP_read == true))) {
                            // assign expression to variable NP
                            var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NP"]);
                            aux_NP_read = true;
                            validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                            aux_last_type_read_for_NP = SCALAR_INT;
                          } else {
                          }
                          cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NP"])), write_opts);
                          cont << cpp_draft_line;
                          {
                            int cpp_npl = (2*py::cast<int>(cpp_current_dict["NP"]));
                            int cpp_i = 0;
                            int cpp_j = 0;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            // read LIST body

                            for (int var_k_0d_int_Scalar = 1;
                               var_k_0d_int_Scalar <= var_NP_0d_int_Scalar; var_k_0d_int_Scalar++) {
                              bool aux_k_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable E
                              var_E_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                              aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)]), write_opts);
                              // assign expression to variable F
                              var_F_1d_double_NestedVector.set(var_k_0d_int_Scalar, py::cast<double>(cpp_current_dict["F"][py::cast(var_k_0d_int_Scalar)]));
                              validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                            if (cpp_i != cpp_npl) {
                              throw std::runtime_error("not exactly NPL elements consumed");
                            }
                          }
                          cont << cpp_draft_line;
                        }
                      }
                    }
                  }
                }
                cpp_current_dict = cpp_parent_dict_tmp;
              }
            }
            cpp_current_dict = cpp_parent_dict_tmp;
          }
        }
      }
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 8421256b750ec19b722b38ddb32ece21
// MD5 hash of the following function definition: 8ee9bbc776b3cc7bffdef938361bb751
void write_mf34_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LTT_0d_int_Scalar;
  bool aux_LTT_read = false;
  vartype aux_last_type_read_for_LTT = UNKNOWN;
  int var_NMT1_0d_int_Scalar;
  bool aux_NMT1_read = false;
  vartype aux_last_type_read_for_NMT1 = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 34;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 34;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 34 , MT / ZA , AWR , 0 , LTT , 0 , NMT1 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LTT"]), write_opts);
  // assign expression to variable LTT
  var_LTT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LTT"]);
  aux_LTT_read = true;
  validate_vartype_consistency("LTT", SCALAR_INT, aux_last_type_read_for_LTT);
  aux_last_type_read_for_LTT = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NMT1"]), write_opts);
  // assign expression to variable NMT1
  var_NMT1_0d_int_Scalar = py::cast<int>(cpp_current_dict["NMT1"]);
  aux_NMT1_read = true;
  validate_vartype_consistency("NMT1", SCALAR_INT, aux_last_type_read_for_NMT1);
  aux_last_type_read_for_NMT1 = SCALAR_INT;
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NMT1_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict_tmp = cpp_current_dict;
      if ((! cpp_parent_dict_tmp.contains("subsection"))) {
        cpp_parent_dict_tmp["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict_tmp["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      int var_MAT1_0d_int_Scalar;
      bool aux_MAT1_read = false;
      vartype aux_last_type_read_for_MAT1 = UNKNOWN;
      int var_MT1_0d_int_Scalar;
      bool aux_MT1_read = false;
      vartype aux_last_type_read_for_MT1 = UNKNOWN;
      int var_NL_0d_int_Scalar;
      bool aux_NL_read = false;
      vartype aux_last_type_read_for_NL = UNKNOWN;
      NestedVector<int> var_L_1d_int_NestedVector;
      vartype aux_last_type_read_for_L = UNKNOWN;
      NestedVector<int> var_L1_1d_int_NestedVector;
      vartype aux_last_type_read_for_L1 = UNKNOWN;
      int var_LCT_0d_int_Scalar;
      bool aux_LCT_read = false;
      vartype aux_last_type_read_for_LCT = UNKNOWN;
      NestedVector<int> var_NI_1d_int_NestedVector;
      vartype aux_last_type_read_for_NI = UNKNOWN;
      NestedVector<NestedVector<int>> var_LS_2d_int_NestedVector;
      NestedVector<int>* ptr_LS_2d_idx0;
      vartype aux_last_type_read_for_LS = UNKNOWN;
      NestedVector<NestedVector<int>> var_LB_2d_int_NestedVector;
      NestedVector<int>* ptr_LB_2d_idx0;
      vartype aux_last_type_read_for_LB = UNKNOWN;
      NestedVector<NestedVector<int>> var_NT_2d_int_NestedVector;
      NestedVector<int>* ptr_NT_2d_idx0;
      vartype aux_last_type_read_for_NT = UNKNOWN;
      NestedVector<NestedVector<int>> var_NE_2d_int_NestedVector;
      NestedVector<int>* ptr_NE_2d_idx0;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      NestedVector<NestedVector<NestedVector<double>>> var_Data_3d_double_NestedVector;
      NestedVector<double>* ptr_Data_3d_idx1;
      NestedVector<NestedVector<double>>* ptr_Data_3d_idx0;
      vartype aux_last_type_read_for_Data = UNKNOWN;
      int var_NL1_0d_int_Scalar;
      bool aux_NL1_read = false;
      vartype aux_last_type_read_for_NL1 = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            {
              // variable declarations
              int& glob_var_MAT1_0d_int_Scalar = var_MAT1_0d_int_Scalar;
              int var_MAT1_0d_int_Scalar = glob_var_MAT1_0d_int_Scalar;
              bool& glob_aux_MAT1_read = aux_MAT1_read;
              bool aux_MAT1_read = glob_aux_MAT1_read;
              vartype aux_last_type_read_for_MAT1 = UNKNOWN;
              int& glob_var_MT1_0d_int_Scalar = var_MT1_0d_int_Scalar;
              int var_MT1_0d_int_Scalar = glob_var_MT1_0d_int_Scalar;
              bool& glob_aux_MT1_read = aux_MT1_read;
              bool aux_MT1_read = glob_aux_MT1_read;
              vartype aux_last_type_read_for_MT1 = UNKNOWN;
              int& glob_var_NL_0d_int_Scalar = var_NL_0d_int_Scalar;
              int var_NL_0d_int_Scalar = glob_var_NL_0d_int_Scalar;
              bool& glob_aux_NL_read = aux_NL_read;
              bool aux_NL_read = glob_aux_NL_read;
              vartype aux_last_type_read_for_NL = UNKNOWN;
              cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , MAT1 , MT1 , NL , NL ] CONT";
              // read CONT record
              // assign expression to variable MAT1
              var_MAT1_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("MAT1", -99999));
              aux_MAT1_read = true;
              validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
              aux_last_type_read_for_MAT1 = SCALAR_INT;
              // assign expression to variable MT1
              var_MT1_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("MT1", -99999));
              aux_MT1_read = true;
              validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
              aux_last_type_read_for_MT1 = SCALAR_INT;
              // assign expression to variable NL
              var_NL_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NL", -99999));
              aux_NL_read = true;
              validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
              aux_last_type_read_for_NL = SCALAR_INT;
              if ((! (aux_NL_read == true))) {
                // assign expression to variable NL
                var_NL_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NL", -99999));
                aux_NL_read = true;
                validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = SCALAR_INT;
              } else {
              }
              if (((((((((aux_MT1_read == true)) && ((var_MT1_0d_int_Scalar)==(0))))))||(((((aux_MT_read == true)) && ((var_MT_0d_int_Scalar)==(var_MT1_0d_int_Scalar)))))))) {
                cpp_found_match = true;
              }
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , MAT1 , MT1 , NL , NL ] CONT";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read CONT record
              cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["MAT1"]), write_opts);
              // assign expression to variable MAT1
              var_MAT1_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT1"]);
              aux_MAT1_read = true;
              validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
              aux_last_type_read_for_MAT1 = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["MT1"]), write_opts);
              // assign expression to variable MT1
              var_MT1_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT1"]);
              aux_MT1_read = true;
              validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
              aux_last_type_read_for_MT1 = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NL"]), write_opts);
              // assign expression to variable NL
              var_NL_0d_int_Scalar = py::cast<int>(cpp_current_dict["NL"]);
              aux_NL_read = true;
              validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
              aux_last_type_read_for_NL = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NL"]), write_opts);
              if ((! (aux_NL_read == true))) {
                // assign expression to variable NL
                var_NL_0d_int_Scalar = py::cast<int>(cpp_current_dict["NL"]);
                aux_NL_read = true;
                validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
                aux_last_type_read_for_NL = SCALAR_INT;
              } else {
              }
              cont << cpp_draft_line;

              for (int var_n_0d_int_Scalar = 1;
                 var_n_0d_int_Scalar <= ((var_NL_0d_int_Scalar*(var_NL_0d_int_Scalar+1))/2); var_n_0d_int_Scalar++) {
                bool aux_n_read = true;
                // evaluate if-elif-else clause
                {
                  bool cpp_found_match = false;
                  if (! cpp_found_match) {
                    if ((((((((aux_n_read == true)) && ((var_n_0d_int_Scalar)==(1)))))))) {
                      // if statement evaluation
                      cpp_found_match = true;
                      cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , LCT , NI ] CONT";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read CONT record
                      cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                      cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["L"][py::cast(var_n_0d_int_Scalar)]), write_opts);
                      // assign expression to variable L
                      var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_current_dict["L"][py::cast(var_n_0d_int_Scalar)]));
                      validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                      aux_last_type_read_for_L = NESTEDVECTOR_INT;
                      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["L1"][py::cast(var_n_0d_int_Scalar)]), write_opts);
                      // assign expression to variable L1
                      var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_current_dict["L1"][py::cast(var_n_0d_int_Scalar)]));
                      validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                      aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                      cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["LCT"]), write_opts);
                      // assign expression to variable LCT
                      var_LCT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCT"]);
                      aux_LCT_read = true;
                      validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
                      aux_last_type_read_for_LCT = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NI"][py::cast(var_n_0d_int_Scalar)]), write_opts);
                      // assign expression to variable NI
                      var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_current_dict["NI"][py::cast(var_n_0d_int_Scalar)]));
                      validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                      aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                      cont << cpp_draft_line;
                    }
                  }
                  if (! cpp_found_match) {
                    cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , 0 , NI ] CONT";
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read CONT record
                    cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                    cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["L"][py::cast(var_n_0d_int_Scalar)]), write_opts);
                    // assign expression to variable L
                    var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_current_dict["L"][py::cast(var_n_0d_int_Scalar)]));
                    validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                    aux_last_type_read_for_L = NESTEDVECTOR_INT;
                    cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["L1"][py::cast(var_n_0d_int_Scalar)]), write_opts);
                    // assign expression to variable L1
                    var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_current_dict["L1"][py::cast(var_n_0d_int_Scalar)]));
                    validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                    aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                    cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                    cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NI"][py::cast(var_n_0d_int_Scalar)]), write_opts);
                    // assign expression to variable NI
                    var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_current_dict["NI"][py::cast(var_n_0d_int_Scalar)]));
                    validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                    aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                    cont << cpp_draft_line;
                  }
                }
                ptr_LS_2d_idx0 = var_LS_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                ptr_LB_2d_idx0 = var_LB_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                ptr_NE_2d_idx0 = var_NE_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                ptr_Data_3d_idx0 = var_Data_3d_double_NestedVector.prepare(var_n_0d_int_Scalar);

                for (int var_m_0d_int_Scalar = 1;
                   var_m_0d_int_Scalar <= var_NI_1d_int_NestedVector[var_n_0d_int_Scalar]; var_m_0d_int_Scalar++) {
                  bool aux_m_read = true;
                  cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { Data } { q = 1 to NT } ] LIST";
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  // read LIST record
                  cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                  cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LS"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
                  // assign expression to variable LS
                  ptr_LS_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_current_dict["LS"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
                  validate_vartype_consistency("LS", NESTEDVECTOR_INT, aux_last_type_read_for_LS);
                  aux_last_type_read_for_LS = NESTEDVECTOR_INT;
                  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
                  // assign expression to variable LB
                  ptr_LB_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_current_dict["LB"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
                  validate_vartype_consistency("LB", NESTEDVECTOR_INT, aux_last_type_read_for_LB);
                  aux_last_type_read_for_LB = NESTEDVECTOR_INT;
                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
                  // assign expression to variable NT
                  ptr_NT_2d_idx0 = var_NT_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
                  ptr_NT_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_current_dict["NT"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
                  validate_vartype_consistency("NT", NESTEDVECTOR_INT, aux_last_type_read_for_NT);
                  aux_last_type_read_for_NT = NESTEDVECTOR_INT;
                  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
                  // assign expression to variable NE
                  ptr_NE_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_current_dict["NE"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
                  validate_vartype_consistency("NE", NESTEDVECTOR_INT, aux_last_type_read_for_NE);
                  aux_last_type_read_for_NE = NESTEDVECTOR_INT;
                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
                  cont << cpp_draft_line;
                  {
                    int cpp_npl = py::cast<int>(cpp_current_dict["NT"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]);
                    int cpp_i = 0;
                    int cpp_j = 0;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    // read LIST body
                    ptr_Data_3d_idx1 = ptr_Data_3d_idx0->prepare(var_m_0d_int_Scalar);

                    for (int var_q_0d_int_Scalar = 1;
                       var_q_0d_int_Scalar <= var_NT_2d_int_NestedVector[var_n_0d_int_Scalar][var_m_0d_int_Scalar]; var_q_0d_int_Scalar++) {
                      bool aux_q_read = true;
                      // read LIST body
                      cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Data"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)][py::cast(var_q_0d_int_Scalar)]), write_opts);
                      // assign expression to variable Data
                      ptr_Data_3d_idx1->set(var_q_0d_int_Scalar, py::cast<double>(cpp_current_dict["Data"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)][py::cast(var_q_0d_int_Scalar)]));
                      validate_vartype_consistency("Data", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Data);
                      aux_last_type_read_for_Data = NESTEDVECTOR_DOUBLE;
                      cpp_i++;
                      cpp_j++;
                      if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                        cont << cpp_draft_line;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        cpp_j = 0;
                      }
                    }
                    if (cpp_i != cpp_npl) {
                      throw std::runtime_error("not exactly NPL elements consumed");
                    }
                  }
                  cont << cpp_draft_line;
                }
              }
            }
          }
        }
        if (! cpp_found_match) {
          cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , MAT1 , MT1 , NL , NL1 ] CONT";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read CONT record
          cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
          cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["MAT1"]), write_opts);
          // assign expression to variable MAT1
          var_MAT1_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT1"]);
          aux_MAT1_read = true;
          validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
          aux_last_type_read_for_MAT1 = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["MT1"]), write_opts);
          // assign expression to variable MT1
          var_MT1_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT1"]);
          aux_MT1_read = true;
          validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
          aux_last_type_read_for_MT1 = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NL"]), write_opts);
          // assign expression to variable NL
          var_NL_0d_int_Scalar = py::cast<int>(cpp_current_dict["NL"]);
          aux_NL_read = true;
          validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
          aux_last_type_read_for_NL = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NL1"]), write_opts);
          // assign expression to variable NL1
          var_NL1_0d_int_Scalar = py::cast<int>(cpp_current_dict["NL1"]);
          aux_NL1_read = true;
          validate_vartype_consistency("NL1", SCALAR_INT, aux_last_type_read_for_NL1);
          aux_last_type_read_for_NL1 = SCALAR_INT;
          cont << cpp_draft_line;

          for (int var_n_0d_int_Scalar = 1;
             var_n_0d_int_Scalar <= (var_NL_0d_int_Scalar*var_NL1_0d_int_Scalar); var_n_0d_int_Scalar++) {
            bool aux_n_read = true;
            // evaluate if-elif-else clause
            {
              bool cpp_found_match = false;
              if (! cpp_found_match) {
                if ((((((((aux_n_read == true)) && ((var_n_0d_int_Scalar)==(1)))))))) {
                  // if statement evaluation
                  cpp_found_match = true;
                  cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , LCT , NI ] CONT";
                  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                  // read CONT record
                  cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                  cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["L"][py::cast(var_n_0d_int_Scalar)]), write_opts);
                  // assign expression to variable L
                  var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_current_dict["L"][py::cast(var_n_0d_int_Scalar)]));
                  validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                  aux_last_type_read_for_L = NESTEDVECTOR_INT;
                  cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["L1"][py::cast(var_n_0d_int_Scalar)]), write_opts);
                  // assign expression to variable L1
                  var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_current_dict["L1"][py::cast(var_n_0d_int_Scalar)]));
                  validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                  aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["LCT"]), write_opts);
                  // assign expression to variable LCT
                  var_LCT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LCT"]);
                  aux_LCT_read = true;
                  validate_vartype_consistency("LCT", SCALAR_INT, aux_last_type_read_for_LCT);
                  aux_last_type_read_for_LCT = SCALAR_INT;
                  cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NI"][py::cast(var_n_0d_int_Scalar)]), write_opts);
                  // assign expression to variable NI
                  var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_current_dict["NI"][py::cast(var_n_0d_int_Scalar)]));
                  validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                  aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                  cont << cpp_draft_line;
                }
              }
              if (! cpp_found_match) {
                cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , L , L1 , 0 , NI ] CONT";
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                // read CONT record
                cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["L"][py::cast(var_n_0d_int_Scalar)]), write_opts);
                // assign expression to variable L
                var_L_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_current_dict["L"][py::cast(var_n_0d_int_Scalar)]));
                validate_vartype_consistency("L", NESTEDVECTOR_INT, aux_last_type_read_for_L);
                aux_last_type_read_for_L = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["L1"][py::cast(var_n_0d_int_Scalar)]), write_opts);
                // assign expression to variable L1
                var_L1_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_current_dict["L1"][py::cast(var_n_0d_int_Scalar)]));
                validate_vartype_consistency("L1", NESTEDVECTOR_INT, aux_last_type_read_for_L1);
                aux_last_type_read_for_L1 = NESTEDVECTOR_INT;
                cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NI"][py::cast(var_n_0d_int_Scalar)]), write_opts);
                // assign expression to variable NI
                var_NI_1d_int_NestedVector.set(var_n_0d_int_Scalar, py::cast<int>(cpp_current_dict["NI"][py::cast(var_n_0d_int_Scalar)]));
                validate_vartype_consistency("NI", NESTEDVECTOR_INT, aux_last_type_read_for_NI);
                aux_last_type_read_for_NI = NESTEDVECTOR_INT;
                cont << cpp_draft_line;
              }
            }
            ptr_LS_2d_idx0 = var_LS_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
            ptr_LB_2d_idx0 = var_LB_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
            ptr_NE_2d_idx0 = var_NE_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
            ptr_Data_3d_idx0 = var_Data_3d_double_NestedVector.prepare(var_n_0d_int_Scalar);

            for (int var_m_0d_int_Scalar = 1;
               var_m_0d_int_Scalar <= var_NI_1d_int_NestedVector[var_n_0d_int_Scalar]; var_m_0d_int_Scalar++) {
              bool aux_m_read = true;
              cpp_template = "[ MAT , 34 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { Data } { q = 1 to NT } ] LIST";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read LIST record
              cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
              cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LS"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
              // assign expression to variable LS
              ptr_LS_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_current_dict["LS"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
              validate_vartype_consistency("LS", NESTEDVECTOR_INT, aux_last_type_read_for_LS);
              aux_last_type_read_for_LS = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
              // assign expression to variable LB
              ptr_LB_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_current_dict["LB"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
              validate_vartype_consistency("LB", NESTEDVECTOR_INT, aux_last_type_read_for_LB);
              aux_last_type_read_for_LB = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
              // assign expression to variable NT
              ptr_NT_2d_idx0 = var_NT_2d_int_NestedVector.prepare(var_n_0d_int_Scalar);
              ptr_NT_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_current_dict["NT"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
              validate_vartype_consistency("NT", NESTEDVECTOR_INT, aux_last_type_read_for_NT);
              aux_last_type_read_for_NT = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
              // assign expression to variable NE
              ptr_NE_2d_idx0->set(var_m_0d_int_Scalar, py::cast<int>(cpp_current_dict["NE"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]));
              validate_vartype_consistency("NE", NESTEDVECTOR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = NESTEDVECTOR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]), write_opts);
              cont << cpp_draft_line;
              {
                int cpp_npl = py::cast<int>(cpp_current_dict["NT"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)]);
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                // read LIST body
                ptr_Data_3d_idx1 = ptr_Data_3d_idx0->prepare(var_m_0d_int_Scalar);

                for (int var_q_0d_int_Scalar = 1;
                   var_q_0d_int_Scalar <= var_NT_2d_int_NestedVector[var_n_0d_int_Scalar][var_m_0d_int_Scalar]; var_q_0d_int_Scalar++) {
                  bool aux_q_read = true;
                  // read LIST body
                  cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Data"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)][py::cast(var_q_0d_int_Scalar)]), write_opts);
                  // assign expression to variable Data
                  ptr_Data_3d_idx1->set(var_q_0d_int_Scalar, py::cast<double>(cpp_current_dict["Data"][py::cast(var_n_0d_int_Scalar)][py::cast(var_m_0d_int_Scalar)][py::cast(var_q_0d_int_Scalar)]));
                  validate_vartype_consistency("Data", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Data);
                  aux_last_type_read_for_Data = NESTEDVECTOR_DOUBLE;
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    cpp_j = 0;
                  }
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
              cont << cpp_draft_line;
            }
          }
        }
      }
      cpp_current_dict = cpp_parent_dict_tmp;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: ef5fac1c99989a26cffcf79262c5c69c
// MD5 hash of the following function definition: 837f00a5ee7668e0e88facc018b38279
void write_mf35_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_NK_0d_int_Scalar;
  bool aux_NK_read = false;
  vartype aux_last_type_read_for_NK = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 35;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 35;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 35 , MT / ZA , AWR , 0 , 0 , NK , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NK"]), write_opts);
  // assign expression to variable NK
  var_NK_0d_int_Scalar = py::cast<int>(cpp_current_dict["NK"]);
  aux_NK_read = true;
  validate_vartype_consistency("NK", SCALAR_INT, aux_last_type_read_for_NK);
  aux_last_type_read_for_NK = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NK_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict_tmp = cpp_current_dict;
      if ((! cpp_parent_dict_tmp.contains("subsection"))) {
        cpp_parent_dict_tmp["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict_tmp["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      double var_E1_0d_double_Scalar;
      bool aux_E1_read = false;
      vartype aux_last_type_read_for_E1 = UNKNOWN;
      double var_E2_0d_double_Scalar;
      bool aux_E2_read = false;
      vartype aux_last_type_read_for_E2 = UNKNOWN;
      int var_LS_0d_int_Scalar;
      bool aux_LS_read = false;
      vartype aux_last_type_read_for_LS = UNKNOWN;
      int var_LB_0d_int_Scalar;
      bool aux_LB_read = false;
      vartype aux_last_type_read_for_LB = UNKNOWN;
      int var_NT_0d_int_Scalar;
      bool aux_NT_read = false;
      vartype aux_last_type_read_for_NT = UNKNOWN;
      int var_NE_0d_int_Scalar;
      bool aux_NE_read = false;
      vartype aux_last_type_read_for_NE = UNKNOWN;
      NestedVector<double> var_E_1d_double_NestedVector;
      vartype aux_last_type_read_for_E = UNKNOWN;
      Matrix2d<double> var_F_2d_double_Matrix2d;
      vartype aux_last_type_read_for_F = UNKNOWN;
      // evaluate if-elif-else clause
      {
        bool cpp_found_match = false;
        if (! cpp_found_match) {
          // if statement evaluation with lookahead
          {
            {
              // variable declarations
              double& glob_var_E1_0d_double_Scalar = var_E1_0d_double_Scalar;
              double var_E1_0d_double_Scalar = glob_var_E1_0d_double_Scalar;
              bool& glob_aux_E1_read = aux_E1_read;
              bool aux_E1_read = glob_aux_E1_read;
              vartype aux_last_type_read_for_E1 = UNKNOWN;
              double& glob_var_E2_0d_double_Scalar = var_E2_0d_double_Scalar;
              double var_E2_0d_double_Scalar = glob_var_E2_0d_double_Scalar;
              bool& glob_aux_E2_read = aux_E2_read;
              bool aux_E2_read = glob_aux_E2_read;
              vartype aux_last_type_read_for_E2 = UNKNOWN;
              int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
              int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
              bool& glob_aux_LS_read = aux_LS_read;
              bool aux_LS_read = glob_aux_LS_read;
              vartype aux_last_type_read_for_LS = UNKNOWN;
              int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
              int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
              bool& glob_aux_LB_read = aux_LB_read;
              bool aux_LB_read = glob_aux_LB_read;
              vartype aux_last_type_read_for_LB = UNKNOWN;
              int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
              int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
              bool& glob_aux_NT_read = aux_NT_read;
              bool aux_NT_read = glob_aux_NT_read;
              vartype aux_last_type_read_for_NT = UNKNOWN;
              int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
              int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
              bool& glob_aux_NE_read = aux_NE_read;
              bool aux_NE_read = glob_aux_NE_read;
              vartype aux_last_type_read_for_NE = UNKNOWN;
              cpp_template = "[ MAT , 35 , MT / E1 , E2 , LS , LB , NT , NE / \n { E } { i = 1 to NE } , { { F } { j = i to (NE-1) } } { i = 1 to (NE-1) } ] LIST";
              // read LIST record
              // assign expression to variable E1
              var_E1_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("E1", -99999.9));
              aux_E1_read = true;
              validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
              aux_last_type_read_for_E1 = SCALAR_DOUBLE;
              // assign expression to variable E2
              var_E2_0d_double_Scalar = py::cast<double>(cpp_current_dict.attr("get")("E2", -99999.9));
              aux_E2_read = true;
              validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
              aux_last_type_read_for_E2 = SCALAR_DOUBLE;
              // assign expression to variable LS
              var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LS", -99999));
              aux_LS_read = true;
              validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
              aux_last_type_read_for_LS = SCALAR_INT;
              // assign expression to variable LB
              var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
              aux_LB_read = true;
              validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
              aux_last_type_read_for_LB = SCALAR_INT;
              // assign expression to variable NT
              var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NT", -99999));
              aux_NT_read = true;
              validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
              aux_last_type_read_for_NT = SCALAR_INT;
              // assign expression to variable NE
              var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NE", -99999));
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              if (((((((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(7)))))))) {
                cpp_found_match = true;
              }
            }
            if (cpp_found_match) {
              cpp_template = "[ MAT , 35 , MT / E1 , E2 , LS , LB , NT , NE / \n { E } { i = 1 to NE } , { { F } { j = i to (NE-1) } } { i = 1 to (NE-1) } ] LIST";
              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
              // read LIST record
              cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["E1"]), write_opts);
              // assign expression to variable E1
              var_E1_0d_double_Scalar = py::cast<double>(cpp_current_dict["E1"]);
              aux_E1_read = true;
              validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
              aux_last_type_read_for_E1 = SCALAR_DOUBLE;
              cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E2"]), write_opts);
              // assign expression to variable E2
              var_E2_0d_double_Scalar = py::cast<double>(cpp_current_dict["E2"]);
              aux_E2_read = true;
              validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
              aux_last_type_read_for_E2 = SCALAR_DOUBLE;
              cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LS"]), write_opts);
              // assign expression to variable LS
              var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LS"]);
              aux_LS_read = true;
              validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
              aux_last_type_read_for_LS = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
              // assign expression to variable LB
              var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
              aux_LB_read = true;
              validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
              aux_last_type_read_for_LB = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
              // assign expression to variable NT
              var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NT"]);
              aux_NT_read = true;
              validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
              aux_last_type_read_for_NT = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
              // assign expression to variable NE
              var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
              aux_NE_read = true;
              validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
              aux_last_type_read_for_NE = SCALAR_INT;
              cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
              cont << cpp_draft_line;
              {
                int cpp_npl = py::cast<int>(cpp_current_dict["NT"]);
                int cpp_i = 0;
                int cpp_j = 0;
                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                // read LIST body

                for (int var_i_0d_int_Scalar = 1;
                   var_i_0d_int_Scalar <= var_NE_0d_int_Scalar; var_i_0d_int_Scalar++) {
                  bool aux_i_read = true;
                  // read LIST body
                  cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                  // assign expression to variable E
                  var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]));
                  validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                  aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                  cpp_i++;
                  cpp_j++;
                  if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                    cont << cpp_draft_line;
                    cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                    cpp_j = 0;
                  }
                }
                var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                for (int var_i_0d_int_Scalar = 1;
                   var_i_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_i_0d_int_Scalar++) {
                  bool aux_i_read = true;
                  // read LIST body

                  for (int var_j_0d_int_Scalar = var_i_0d_int_Scalar;
                     var_j_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_j_0d_int_Scalar++) {
                    bool aux_j_read = true;
                    // read LIST body
                    cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]), write_opts);
                    // assign expression to variable F
                    var_F_2d_double_Matrix2d(var_i_0d_int_Scalar, var_j_0d_int_Scalar) = py::cast<double>(cpp_current_dict["F"][py::cast(var_i_0d_int_Scalar)][py::cast(var_j_0d_int_Scalar)]);
                    validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                    aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                    cpp_i++;
                    cpp_j++;
                    if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                      cont << cpp_draft_line;
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      cpp_j = 0;
                    }
                  }
                }
                if (cpp_i != cpp_npl) {
                  throw std::runtime_error("not exactly NPL elements consumed");
                }
              }
              cont << cpp_draft_line;
            }
          }
        }
      }
      cpp_current_dict = cpp_parent_dict_tmp;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}


// MD5 hash of ENDF recipe underlying the following function: 9762b69b4ad00343103fe284b177ae48
// MD5 hash of the following function definition: fcbeea06d64862e218193c6b2f3251cc
void write_mf40_ostream(
  std::ostream& cont, py::dict endf_dict, WritingOptions &write_opts
) {
  std::vector<int> cpp_intvec;
  std::vector<double> cpp_floatvec;
  std::string cpp_template;
  double cpp_float_val;
  int cpp_nr_val;
  int cpp_np_val;
  Tab1Body tab1_body;
  Tab2Body tab2_body;  py::dict cpp_parent_dict_tmp;
  py::dict cpp_current_dict = endf_dict;
  // variable declarations
  int var_MAT_0d_int_Scalar;
  bool aux_MAT_read = false;
  vartype aux_last_type_read_for_MAT = UNKNOWN;
  int var_MF_0d_int_Scalar;
  bool aux_MF_read = false;
  vartype aux_last_type_read_for_MF = UNKNOWN;
  int var_MT_0d_int_Scalar;
  bool aux_MT_read = false;
  vartype aux_last_type_read_for_MT = UNKNOWN;
  double var_ZA_0d_double_Scalar;
  bool aux_ZA_read = false;
  vartype aux_last_type_read_for_ZA = UNKNOWN;
  double var_AWR_0d_double_Scalar;
  bool aux_AWR_read = false;
  vartype aux_last_type_read_for_AWR = UNKNOWN;
  int var_LIS_0d_int_Scalar;
  bool aux_LIS_read = false;
  vartype aux_last_type_read_for_LIS = UNKNOWN;
  int var_NS_0d_int_Scalar;
  bool aux_NS_read = false;
  vartype aux_last_type_read_for_NS = UNKNOWN;
  int mat = py::cast<int>(cpp_current_dict["MAT"]);
  int mf = 40;
  int mt = py::cast<int>(cpp_current_dict["MT"]);
  cpp_current_dict["MAT"] = mat;
  cpp_current_dict["MF"] = mf;
  cpp_current_dict["MT"] = mt;
  // assign expression to variable MAT
  var_MAT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT"]);
  aux_MAT_read = true;
  validate_vartype_consistency("MAT", SCALAR_INT, aux_last_type_read_for_MAT);
  aux_last_type_read_for_MAT = SCALAR_INT;
  // assign expression to variable MF
  var_MF_0d_int_Scalar = 40;
  aux_MF_read = true;
  validate_vartype_consistency("MF", SCALAR_INT, aux_last_type_read_for_MF);
  aux_last_type_read_for_MF = SCALAR_INT;
  // assign expression to variable MT
  var_MT_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT"]);
  aux_MT_read = true;
  validate_vartype_consistency("MT", SCALAR_INT, aux_last_type_read_for_MT);
  aux_last_type_read_for_MT = SCALAR_INT;
  std::string cpp_line;
  std::string cpp_draft_line;
  int linenum = 0;
  if ((mf == 0 && mt == 0)) {
    linenum = -1;
  }
  cpp_template = "[ MAT , 40 , MT / ZA , AWR , LIS , 0 , NS , 0 ] HEAD";
  cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
  // read CONT record
  cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["ZA"]), write_opts);
  // assign expression to variable ZA
  var_ZA_0d_double_Scalar = py::cast<double>(cpp_current_dict["ZA"]);
  aux_ZA_read = true;
  validate_vartype_consistency("ZA", SCALAR_DOUBLE, aux_last_type_read_for_ZA);
  aux_last_type_read_for_ZA = SCALAR_DOUBLE;
  cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["AWR"]), write_opts);
  // assign expression to variable AWR
  var_AWR_0d_double_Scalar = py::cast<double>(cpp_current_dict["AWR"]);
  aux_AWR_read = true;
  validate_vartype_consistency("AWR", SCALAR_DOUBLE, aux_last_type_read_for_AWR);
  aux_last_type_read_for_AWR = SCALAR_DOUBLE;
  cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LIS"]), write_opts);
  // assign expression to variable LIS
  var_LIS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LIS"]);
  aux_LIS_read = true;
  validate_vartype_consistency("LIS", SCALAR_INT, aux_last_type_read_for_LIS);
  aux_last_type_read_for_LIS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
  cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NS"]), write_opts);
  // assign expression to variable NS
  var_NS_0d_int_Scalar = py::cast<int>(cpp_current_dict["NS"]);
  aux_NS_read = true;
  validate_vartype_consistency("NS", SCALAR_INT, aux_last_type_read_for_NS);
  aux_last_type_read_for_NS = SCALAR_INT;
  cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
  cont << cpp_draft_line;

  for (int var_k_0d_int_Scalar = 1;
     var_k_0d_int_Scalar <= var_NS_0d_int_Scalar; var_k_0d_int_Scalar++) {
    bool aux_k_read = true;
    // open section subsection
    {
      py::dict cpp_parent_dict_tmp = cpp_current_dict;
      if ((! cpp_parent_dict_tmp.contains("subsection"))) {
        cpp_parent_dict_tmp["subsection"] = py::dict();
      }
      py::dict cpp_current_dict = cpp_parent_dict_tmp["subsection"];
      if ((! cpp_current_dict.contains(py::cast(var_k_0d_int_Scalar)))) {
        cpp_current_dict[py::cast(var_k_0d_int_Scalar)] = py::dict();
      }
      cpp_current_dict = cpp_current_dict[py::cast(var_k_0d_int_Scalar)];
      // variable declarations
      double var_QM_0d_double_Scalar;
      bool aux_QM_read = false;
      vartype aux_last_type_read_for_QM = UNKNOWN;
      double var_QI_0d_double_Scalar;
      bool aux_QI_read = false;
      vartype aux_last_type_read_for_QI = UNKNOWN;
      int var_IZAP_0d_int_Scalar;
      bool aux_IZAP_read = false;
      vartype aux_last_type_read_for_IZAP = UNKNOWN;
      int var_LFS_0d_int_Scalar;
      bool aux_LFS_read = false;
      vartype aux_last_type_read_for_LFS = UNKNOWN;
      int var_NL_0d_int_Scalar;
      bool aux_NL_read = false;
      vartype aux_last_type_read_for_NL = UNKNOWN;
      cpp_template = "[ MAT , 40 , MT / QM , QI , IZAP , LFS , 0 , NL ] CONT";
      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
      // read CONT record
      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["QM"]), write_opts);
      // assign expression to variable QM
      var_QM_0d_double_Scalar = py::cast<double>(cpp_current_dict["QM"]);
      aux_QM_read = true;
      validate_vartype_consistency("QM", SCALAR_DOUBLE, aux_last_type_read_for_QM);
      aux_last_type_read_for_QM = SCALAR_DOUBLE;
      cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["QI"]), write_opts);
      // assign expression to variable QI
      var_QI_0d_double_Scalar = py::cast<double>(cpp_current_dict["QI"]);
      aux_QI_read = true;
      validate_vartype_consistency("QI", SCALAR_DOUBLE, aux_last_type_read_for_QI);
      aux_last_type_read_for_QI = SCALAR_DOUBLE;
      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["IZAP"]), write_opts);
      // assign expression to variable IZAP
      var_IZAP_0d_int_Scalar = py::cast<int>(cpp_current_dict["IZAP"]);
      aux_IZAP_read = true;
      validate_vartype_consistency("IZAP", SCALAR_INT, aux_last_type_read_for_IZAP);
      aux_last_type_read_for_IZAP = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LFS"]), write_opts);
      // assign expression to variable LFS
      var_LFS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LFS"]);
      aux_LFS_read = true;
      validate_vartype_consistency("LFS", SCALAR_INT, aux_last_type_read_for_LFS);
      aux_last_type_read_for_LFS = SCALAR_INT;
      cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NL"]), write_opts);
      // assign expression to variable NL
      var_NL_0d_int_Scalar = py::cast<int>(cpp_current_dict["NL"]);
      aux_NL_read = true;
      validate_vartype_consistency("NL", SCALAR_INT, aux_last_type_read_for_NL);
      aux_last_type_read_for_NL = SCALAR_INT;
      cont << cpp_draft_line;

      for (int var_i_0d_int_Scalar = 1;
         var_i_0d_int_Scalar <= var_NL_0d_int_Scalar; var_i_0d_int_Scalar++) {
        bool aux_i_read = true;
        // open section subsubsec
        {
          py::dict cpp_parent_dict_tmp = cpp_current_dict;
          if ((! cpp_parent_dict_tmp.contains("subsubsec"))) {
            cpp_parent_dict_tmp["subsubsec"] = py::dict();
          }
          py::dict cpp_current_dict = cpp_parent_dict_tmp["subsubsec"];
          if ((! cpp_current_dict.contains(py::cast(var_i_0d_int_Scalar)))) {
            cpp_current_dict[py::cast(var_i_0d_int_Scalar)] = py::dict();
          }
          cpp_current_dict = cpp_current_dict[py::cast(var_i_0d_int_Scalar)];
          // variable declarations
          double var_XMF1_0d_double_Scalar;
          bool aux_XMF1_read = false;
          vartype aux_last_type_read_for_XMF1 = UNKNOWN;
          double var_XLFS1_0d_double_Scalar;
          bool aux_XLFS1_read = false;
          vartype aux_last_type_read_for_XLFS1 = UNKNOWN;
          int var_MAT1_0d_int_Scalar;
          bool aux_MAT1_read = false;
          vartype aux_last_type_read_for_MAT1 = UNKNOWN;
          int var_MT1_0d_int_Scalar;
          bool aux_MT1_read = false;
          vartype aux_last_type_read_for_MT1 = UNKNOWN;
          int var_NC_0d_int_Scalar;
          bool aux_NC_read = false;
          vartype aux_last_type_read_for_NC = UNKNOWN;
          int var_NI_0d_int_Scalar;
          bool aux_NI_read = false;
          vartype aux_last_type_read_for_NI = UNKNOWN;
          cpp_template = "[ MAT , 40 , MT / XMF1 , XLFS1 , MAT1 , MT1 , NC , NI ] CONT";
          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
          // read CONT record
          cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["XMF1"]), write_opts);
          // assign expression to variable XMF1
          var_XMF1_0d_double_Scalar = py::cast<double>(cpp_current_dict["XMF1"]);
          aux_XMF1_read = true;
          validate_vartype_consistency("XMF1", SCALAR_DOUBLE, aux_last_type_read_for_XMF1);
          aux_last_type_read_for_XMF1 = SCALAR_DOUBLE;
          cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["XLFS1"]), write_opts);
          // assign expression to variable XLFS1
          var_XLFS1_0d_double_Scalar = py::cast<double>(cpp_current_dict["XLFS1"]);
          aux_XLFS1_read = true;
          validate_vartype_consistency("XLFS1", SCALAR_DOUBLE, aux_last_type_read_for_XLFS1);
          aux_last_type_read_for_XLFS1 = SCALAR_DOUBLE;
          cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["MAT1"]), write_opts);
          // assign expression to variable MAT1
          var_MAT1_0d_int_Scalar = py::cast<int>(cpp_current_dict["MAT1"]);
          aux_MAT1_read = true;
          validate_vartype_consistency("MAT1", SCALAR_INT, aux_last_type_read_for_MAT1);
          aux_last_type_read_for_MAT1 = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["MT1"]), write_opts);
          // assign expression to variable MT1
          var_MT1_0d_int_Scalar = py::cast<int>(cpp_current_dict["MT1"]);
          aux_MT1_read = true;
          validate_vartype_consistency("MT1", SCALAR_INT, aux_last_type_read_for_MT1);
          aux_last_type_read_for_MT1 = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NC"]), write_opts);
          // assign expression to variable NC
          var_NC_0d_int_Scalar = py::cast<int>(cpp_current_dict["NC"]);
          aux_NC_read = true;
          validate_vartype_consistency("NC", SCALAR_INT, aux_last_type_read_for_NC);
          aux_last_type_read_for_NC = SCALAR_INT;
          cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NI"]), write_opts);
          // assign expression to variable NI
          var_NI_0d_int_Scalar = py::cast<int>(cpp_current_dict["NI"]);
          aux_NI_read = true;
          validate_vartype_consistency("NI", SCALAR_INT, aux_last_type_read_for_NI);
          aux_last_type_read_for_NI = SCALAR_INT;
          cont << cpp_draft_line;

          for (int var_j_0d_int_Scalar = 1;
             var_j_0d_int_Scalar <= var_NC_0d_int_Scalar; var_j_0d_int_Scalar++) {
            bool aux_j_read = true;
            // open section nc_subsubsubsec
            {
              py::dict cpp_parent_dict_tmp = cpp_current_dict;
              if ((! cpp_parent_dict_tmp.contains("nc_subsubsubsec"))) {
                cpp_parent_dict_tmp["nc_subsubsubsec"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict_tmp["nc_subsubsubsec"];
              if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
              // variable declarations
              int var_LTY_0d_int_Scalar;
              bool aux_LTY_read = false;
              vartype aux_last_type_read_for_LTY = UNKNOWN;
              double var_E1_0d_double_Scalar;
              bool aux_E1_read = false;
              vartype aux_last_type_read_for_E1 = UNKNOWN;
              double var_E2_0d_double_Scalar;
              bool aux_E2_read = false;
              vartype aux_last_type_read_for_E2 = UNKNOWN;
              int cpp_int_val;
              bool aux_cpp_int_val_read = false;
              vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
              int var_NCI_0d_int_Scalar;
              bool aux_NCI_read = false;
              vartype aux_last_type_read_for_NCI = UNKNOWN;
              NestedVector<double> var_C_1d_double_NestedVector;
              vartype aux_last_type_read_for_C = UNKNOWN;
              NestedVector<double> var_XMT_1d_double_NestedVector;
              vartype aux_last_type_read_for_XMT = UNKNOWN;
              int var_MATS_0d_int_Scalar;
              bool aux_MATS_read = false;
              vartype aux_last_type_read_for_MATS = UNKNOWN;
              int var_MTS_0d_int_Scalar;
              bool aux_MTS_read = false;
              vartype aux_last_type_read_for_MTS = UNKNOWN;
              int var_NEI_0d_int_Scalar;
              bool aux_NEI_read = false;
              vartype aux_last_type_read_for_NEI = UNKNOWN;
              double var_XMFS_0d_double_Scalar;
              bool aux_XMFS_read = false;
              vartype aux_last_type_read_for_XMFS = UNKNOWN;
              double var_XLFSS_0d_double_Scalar;
              bool aux_XLFSS_read = false;
              vartype aux_last_type_read_for_XLFSS = UNKNOWN;
              NestedVector<double> var_E_1d_double_NestedVector;
              vartype aux_last_type_read_for_E = UNKNOWN;
              NestedVector<double> var_WE_1d_double_NestedVector;
              vartype aux_last_type_read_for_WE = UNKNOWN;
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  // if statement evaluation with lookahead
                  {
                    {
                      // variable declarations
                      int& glob_var_LTY_0d_int_Scalar = var_LTY_0d_int_Scalar;
                      int var_LTY_0d_int_Scalar = glob_var_LTY_0d_int_Scalar;
                      bool& glob_aux_LTY_read = aux_LTY_read;
                      bool aux_LTY_read = glob_aux_LTY_read;
                      vartype aux_last_type_read_for_LTY = UNKNOWN;
                      cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                      // read CONT record
                      // assign expression to variable LTY
                      var_LTY_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LTY", -99999));
                      aux_LTY_read = true;
                      validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                      aux_last_type_read_for_LTY = SCALAR_INT;
                      if ((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(0)))))))) {
                        cpp_found_match = true;
                      }
                    }
                    if (cpp_found_match) {
                      cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read CONT record
                      cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                      cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LTY"]), write_opts);
                      // assign expression to variable LTY
                      var_LTY_0d_int_Scalar = py::cast<int>(cpp_current_dict["LTY"]);
                      aux_LTY_read = true;
                      validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                      aux_last_type_read_for_LTY = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                      cont << cpp_draft_line;
                      cpp_template = "[ MAT , 40 , MT / E1 , E2 , 0 , 0 , (2*NCI) , NCI / \n { C , XMT } { i = 1 to NCI } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read LIST record
                      cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["E1"]), write_opts);
                      // assign expression to variable E1
                      var_E1_0d_double_Scalar = py::cast<double>(cpp_current_dict["E1"]);
                      aux_E1_read = true;
                      validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                      aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                      cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E2"]), write_opts);
                      // assign expression to variable E2
                      var_E2_0d_double_Scalar = py::cast<double>(cpp_current_dict["E2"]);
                      aux_E2_read = true;
                      validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                      aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                      cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 3, 0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NCI"])), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (2*py::cast<int>(cpp_current_dict["NCI"]));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NCI
                      var_NCI_0d_int_Scalar = (cpp_int_val/2);
                      aux_NCI_read = true;
                      validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                      aux_last_type_read_for_NCI = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NCI"]), write_opts);
                      if ((! (aux_NCI_read == true))) {
                        // assign expression to variable NCI
                        var_NCI_0d_int_Scalar = py::cast<int>(cpp_current_dict["NCI"]);
                        aux_NCI_read = true;
                        validate_vartype_consistency("NCI", SCALAR_INT, aux_last_type_read_for_NCI);
                        aux_last_type_read_for_NCI = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NCI"])), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (2*py::cast<int>(cpp_current_dict["NCI"]));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST body

                        for (int var_i_0d_int_Scalar = 1;
                           var_i_0d_int_Scalar <= var_NCI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                          bool aux_i_read = true;
                          // read LIST body
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["C"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                          // assign expression to variable C
                          var_C_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["C"][py::cast(var_i_0d_int_Scalar)]));
                          validate_vartype_consistency("C", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_C);
                          aux_last_type_read_for_C = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["XMT"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                          // assign expression to variable XMT
                          var_XMT_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["XMT"][py::cast(var_i_0d_int_Scalar)]));
                          validate_vartype_consistency("XMT", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_XMT);
                          aux_last_type_read_for_XMT = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LTY_0d_int_Scalar = var_LTY_0d_int_Scalar;
                        int var_LTY_0d_int_Scalar = glob_var_LTY_0d_int_Scalar;
                        bool& glob_aux_LTY_read = aux_LTY_read;
                        bool aux_LTY_read = glob_aux_LTY_read;
                        vartype aux_last_type_read_for_LTY = UNKNOWN;
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                        // read CONT record
                        // assign expression to variable LTY
                        var_LTY_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LTY", -99999));
                        aux_LTY_read = true;
                        validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                        aux_last_type_read_for_LTY = SCALAR_INT;
                        if ((((((((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(1))))))||(((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(2))))))||(((((aux_LTY_read == true)) && ((var_LTY_0d_int_Scalar)==(3)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LTY , 0 , 0 ] CONT";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read CONT record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LTY"]), write_opts);
                        // assign expression to variable LTY
                        var_LTY_0d_int_Scalar = py::cast<int>(cpp_current_dict["LTY"]);
                        aux_LTY_read = true;
                        validate_vartype_consistency("LTY", SCALAR_INT, aux_last_type_read_for_LTY);
                        aux_last_type_read_for_LTY = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 5, 0, write_opts);
                        cont << cpp_draft_line;
                        cpp_template = "[ MAT , 40 , MT / E1 , E2 , MATS , MTS , ((2*NEI)+2) , NEI / \n XMFS , XLFSS , { E , WE } { i = 1 to NEI } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, py::cast<double>(cpp_current_dict["E1"]), write_opts);
                        // assign expression to variable E1
                        var_E1_0d_double_Scalar = py::cast<double>(cpp_current_dict["E1"]);
                        aux_E1_read = true;
                        validate_vartype_consistency("E1", SCALAR_DOUBLE, aux_last_type_read_for_E1);
                        aux_last_type_read_for_E1 = SCALAR_DOUBLE;
                        cpp_write_field<double>(cpp_draft_line, 1, py::cast<double>(cpp_current_dict["E2"]), write_opts);
                        // assign expression to variable E2
                        var_E2_0d_double_Scalar = py::cast<double>(cpp_current_dict["E2"]);
                        aux_E2_read = true;
                        validate_vartype_consistency("E2", SCALAR_DOUBLE, aux_last_type_read_for_E2);
                        aux_last_type_read_for_E2 = SCALAR_DOUBLE;
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["MATS"]), write_opts);
                        // assign expression to variable MATS
                        var_MATS_0d_int_Scalar = py::cast<int>(cpp_current_dict["MATS"]);
                        aux_MATS_read = true;
                        validate_vartype_consistency("MATS", SCALAR_INT, aux_last_type_read_for_MATS);
                        aux_last_type_read_for_MATS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["MTS"]), write_opts);
                        // assign expression to variable MTS
                        var_MTS_0d_int_Scalar = py::cast<int>(cpp_current_dict["MTS"]);
                        aux_MTS_read = true;
                        validate_vartype_consistency("MTS", SCALAR_INT, aux_last_type_read_for_MTS);
                        aux_last_type_read_for_MTS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, ((2*py::cast<int>(cpp_current_dict["NEI"]))+2), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = ((2*py::cast<int>(cpp_current_dict["NEI"]))+2);
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NEI
                        var_NEI_0d_int_Scalar = ((cpp_int_val+(-2))/2);
                        aux_NEI_read = true;
                        validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                        aux_last_type_read_for_NEI = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NEI"]), write_opts);
                        if ((! (aux_NEI_read == true))) {
                          // assign expression to variable NEI
                          var_NEI_0d_int_Scalar = py::cast<int>(cpp_current_dict["NEI"]);
                          aux_NEI_read = true;
                          validate_vartype_consistency("NEI", SCALAR_INT, aux_last_type_read_for_NEI);
                          aux_last_type_read_for_NEI = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, ((2*py::cast<int>(cpp_current_dict["NEI"]))+2), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = ((2*py::cast<int>(cpp_current_dict["NEI"]))+2);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["XMFS"]), write_opts);
                          // assign expression to variable XMFS
                          var_XMFS_0d_double_Scalar = py::cast<double>(cpp_current_dict["XMFS"]);
                          aux_XMFS_read = true;
                          validate_vartype_consistency("XMFS", SCALAR_DOUBLE, aux_last_type_read_for_XMFS);
                          aux_last_type_read_for_XMFS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["XLFSS"]), write_opts);
                          // assign expression to variable XLFSS
                          var_XLFSS_0d_double_Scalar = py::cast<double>(cpp_current_dict["XLFSS"]);
                          aux_XLFSS_read = true;
                          validate_vartype_consistency("XLFSS", SCALAR_DOUBLE, aux_last_type_read_for_XLFSS);
                          aux_last_type_read_for_XLFSS = SCALAR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }

                          for (int var_i_0d_int_Scalar = 1;
                             var_i_0d_int_Scalar <= var_NEI_0d_int_Scalar; var_i_0d_int_Scalar++) {
                            bool aux_i_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_i_0d_int_Scalar)]));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["WE"][py::cast(var_i_0d_int_Scalar)]), write_opts);
                            // assign expression to variable WE
                            var_WE_1d_double_NestedVector.set(var_i_0d_int_Scalar, py::cast<double>(cpp_current_dict["WE"][py::cast(var_i_0d_int_Scalar)]));
                            validate_vartype_consistency("WE", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_WE);
                            aux_last_type_read_for_WE = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
              }
              cpp_current_dict = cpp_parent_dict_tmp;
            }
          }

          for (int var_j_0d_int_Scalar = 1;
             var_j_0d_int_Scalar <= var_NI_0d_int_Scalar; var_j_0d_int_Scalar++) {
            bool aux_j_read = true;
            // open section ni_subsubsubsec
            {
              py::dict cpp_parent_dict_tmp = cpp_current_dict;
              if ((! cpp_parent_dict_tmp.contains("ni_subsubsubsec"))) {
                cpp_parent_dict_tmp["ni_subsubsubsec"] = py::dict();
              }
              py::dict cpp_current_dict = cpp_parent_dict_tmp["ni_subsubsubsec"];
              if ((! cpp_current_dict.contains(py::cast(var_j_0d_int_Scalar)))) {
                cpp_current_dict[py::cast(var_j_0d_int_Scalar)] = py::dict();
              }
              cpp_current_dict = cpp_current_dict[py::cast(var_j_0d_int_Scalar)];
              // variable declarations
              int var_LT_0d_int_Scalar;
              bool aux_LT_read = false;
              vartype aux_last_type_read_for_LT = UNKNOWN;
              int var_LB_0d_int_Scalar;
              bool aux_LB_read = false;
              vartype aux_last_type_read_for_LB = UNKNOWN;
              int cpp_int_val;
              bool aux_cpp_int_val_read = false;
              vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
              int var_NP_0d_int_Scalar;
              bool aux_NP_read = false;
              vartype aux_last_type_read_for_NP = UNKNOWN;
              NestedVector<double> var_Ek_1d_double_NestedVector;
              vartype aux_last_type_read_for_Ek = UNKNOWN;
              NestedVector<double> var_Fk_1d_double_NestedVector;
              vartype aux_last_type_read_for_Fk = UNKNOWN;
              NestedVector<double> var_El_1d_double_NestedVector;
              vartype aux_last_type_read_for_El = UNKNOWN;
              NestedVector<double> var_Fl_1d_double_NestedVector;
              vartype aux_last_type_read_for_Fl = UNKNOWN;
              int var_LS_0d_int_Scalar;
              bool aux_LS_read = false;
              vartype aux_last_type_read_for_LS = UNKNOWN;
              int var_NT_0d_int_Scalar;
              bool aux_NT_read = false;
              vartype aux_last_type_read_for_NT = UNKNOWN;
              int var_NE_0d_int_Scalar;
              bool aux_NE_read = false;
              vartype aux_last_type_read_for_NE = UNKNOWN;
              NestedVector<double> var_E_1d_double_NestedVector;
              vartype aux_last_type_read_for_E = UNKNOWN;
              Matrix2d<double> var_F_2d_double_Matrix2d;
              vartype aux_last_type_read_for_F = UNKNOWN;
              int var_NER_0d_int_Scalar;
              bool aux_NER_read = false;
              vartype aux_last_type_read_for_NER = UNKNOWN;
              NestedVector<double> var_ER_1d_double_NestedVector;
              vartype aux_last_type_read_for_ER = UNKNOWN;
              NestedVector<double> var_EC_1d_double_NestedVector;
              vartype aux_last_type_read_for_EC = UNKNOWN;
              NestedVector<double> var_F_1d_double_NestedVector;
              // evaluate if-elif-else clause
              {
                bool cpp_found_match = false;
                if (! cpp_found_match) {
                  // if statement evaluation with lookahead
                  {
                    {
                      // variable declarations
                      int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                      int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                      bool& glob_aux_LT_read = aux_LT_read;
                      bool aux_LT_read = glob_aux_LT_read;
                      vartype aux_last_type_read_for_LT = UNKNOWN;
                      int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                      int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                      bool& glob_aux_LB_read = aux_LB_read;
                      bool aux_LB_read = glob_aux_LB_read;
                      vartype aux_last_type_read_for_LB = UNKNOWN;
                      int& glob_cpp_int_val = cpp_int_val;
                      int cpp_int_val = glob_cpp_int_val;
                      bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                      bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                      vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                      int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                      int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                      bool& glob_aux_NP_read = aux_NP_read;
                      bool aux_NP_read = glob_aux_NP_read;
                      vartype aux_last_type_read_for_NP = UNKNOWN;
                      cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { q = 1 to (NP-LT) } \n { El , Fl } { q = 1 to LT } ] LIST";
                      // read LIST record
                      // assign expression to variable LT
                      var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LT", -99999));
                      aux_LT_read = true;
                      validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                      aux_last_type_read_for_LT = SCALAR_INT;
                      // assign expression to variable LB
                      var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                      aux_LB_read = true;
                      validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                      aux_last_type_read_for_LB = SCALAR_INT;
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (2*py::cast<int>(cpp_current_dict.attr("get")("NP", -99999)));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NP
                      var_NP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NP_read = true;
                      validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                      aux_last_type_read_for_NP = SCALAR_INT;
                      if ((! (aux_NP_read == true))) {
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NP", -99999));
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                      } else {
                      }
                      if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)>=(0)))))&&((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)<=(4)))))))) {
                        cpp_found_match = true;
                      }
                    }
                    if (cpp_found_match) {
                      cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { Ek , Fk } { q = 1 to (NP-LT) } \n { El , Fl } { q = 1 to LT } ] LIST";
                      cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                      // read LIST record
                      cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                      cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                      cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LT"]), write_opts);
                      // assign expression to variable LT
                      var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LT"]);
                      aux_LT_read = true;
                      validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                      aux_last_type_read_for_LT = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                      // assign expression to variable LB
                      var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                      aux_LB_read = true;
                      validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                      aux_last_type_read_for_LB = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NP"])), write_opts);
                      // assign expression to variable cpp_int_val
                      cpp_int_val = (2*py::cast<int>(cpp_current_dict["NP"]));
                      aux_cpp_int_val_read = true;
                      validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                      aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                      // assign expression to variable NP
                      var_NP_0d_int_Scalar = (cpp_int_val/2);
                      aux_NP_read = true;
                      validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                      aux_last_type_read_for_NP = SCALAR_INT;
                      cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NP"]), write_opts);
                      if ((! (aux_NP_read == true))) {
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NP"]);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                      } else {
                      }
                      cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NP"])), write_opts);
                      cont << cpp_draft_line;
                      {
                        int cpp_npl = (2*py::cast<int>(cpp_current_dict["NP"]));
                        int cpp_i = 0;
                        int cpp_j = 0;
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST body

                        for (int var_q_0d_int_Scalar = 1;
                           var_q_0d_int_Scalar <= (var_NP_0d_int_Scalar-var_LT_0d_int_Scalar); var_q_0d_int_Scalar++) {
                          bool aux_q_read = true;
                          // read LIST body
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Ek"][py::cast(var_q_0d_int_Scalar)]), write_opts);
                          // assign expression to variable Ek
                          var_Ek_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<double>(cpp_current_dict["Ek"][py::cast(var_q_0d_int_Scalar)]));
                          validate_vartype_consistency("Ek", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Ek);
                          aux_last_type_read_for_Ek = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Fk"][py::cast(var_q_0d_int_Scalar)]), write_opts);
                          // assign expression to variable Fk
                          var_Fk_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<double>(cpp_current_dict["Fk"][py::cast(var_q_0d_int_Scalar)]));
                          validate_vartype_consistency("Fk", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fk);
                          aux_last_type_read_for_Fk = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                        }

                        for (int var_q_0d_int_Scalar = 1;
                           var_q_0d_int_Scalar <= var_LT_0d_int_Scalar; var_q_0d_int_Scalar++) {
                          bool aux_q_read = true;
                          // read LIST body
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["El"][py::cast(var_q_0d_int_Scalar)]), write_opts);
                          // assign expression to variable El
                          var_El_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<double>(cpp_current_dict["El"][py::cast(var_q_0d_int_Scalar)]));
                          validate_vartype_consistency("El", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_El);
                          aux_last_type_read_for_El = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                          cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["Fl"][py::cast(var_q_0d_int_Scalar)]), write_opts);
                          // assign expression to variable Fl
                          var_Fl_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<double>(cpp_current_dict["Fl"][py::cast(var_q_0d_int_Scalar)]));
                          validate_vartype_consistency("Fl", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_Fl);
                          aux_last_type_read_for_Fl = NESTEDVECTOR_DOUBLE;
                          cpp_i++;
                          cpp_j++;
                          if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                            cont << cpp_draft_line;
                            cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                            cpp_j = 0;
                          }
                        }
                        if (cpp_i != cpp_npl) {
                          throw std::runtime_error("not exactly NPL elements consumed");
                        }
                      }
                      cont << cpp_draft_line;
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                        int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                        bool& glob_aux_LS_read = aux_LS_read;
                        bool aux_LS_read = glob_aux_LS_read;
                        vartype aux_last_type_read_for_LS = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                        int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                        bool& glob_aux_NT_read = aux_NT_read;
                        bool aux_NT_read = glob_aux_NT_read;
                        vartype aux_last_type_read_for_NT = UNKNOWN;
                        int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                        int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                        bool& glob_aux_NE_read = aux_NE_read;
                        bool aux_NE_read = glob_aux_NE_read;
                        vartype aux_last_type_read_for_NE = UNKNOWN;
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = 1 to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                        // read LIST record
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LS", -99999));
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NT", -99999));
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NE", -99999));
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(0)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = 1 to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LS"]), write_opts);
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LS"]);
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NT"]);
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = py::cast<int>(cpp_current_dict["NT"]);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NE_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_q_0d_int_Scalar)]), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_q_0d_int_Scalar)]));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), false, false);

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body

                            for (int var_qp_0d_int_Scalar = 1;
                               var_qp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_qp_0d_int_Scalar++) {
                              bool aux_qp_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_q_0d_int_Scalar)][py::cast(var_qp_0d_int_Scalar)]), write_opts);
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_q_0d_int_Scalar, var_qp_0d_int_Scalar) = py::cast<double>(cpp_current_dict["F"][py::cast(var_q_0d_int_Scalar)][py::cast(var_qp_0d_int_Scalar)]);
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LS_0d_int_Scalar = var_LS_0d_int_Scalar;
                        int var_LS_0d_int_Scalar = glob_var_LS_0d_int_Scalar;
                        bool& glob_aux_LS_read = aux_LS_read;
                        bool aux_LS_read = glob_aux_LS_read;
                        vartype aux_last_type_read_for_LS = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                        int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                        bool& glob_aux_NT_read = aux_NT_read;
                        bool aux_NT_read = glob_aux_NT_read;
                        vartype aux_last_type_read_for_NT = UNKNOWN;
                        int& glob_var_NE_0d_int_Scalar = var_NE_0d_int_Scalar;
                        int var_NE_0d_int_Scalar = glob_var_NE_0d_int_Scalar;
                        bool& glob_aux_NE_read = aux_NE_read;
                        bool aux_NE_read = glob_aux_NE_read;
                        vartype aux_last_type_read_for_NE = UNKNOWN;
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = q to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                        // read LIST record
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LS", -99999));
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NT", -99999));
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NE", -99999));
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        if (((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(5)))))&&((((aux_LS_read == true)) && ((var_LS_0d_int_Scalar)==(1)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LS , LB , NT , NE / \n { E } { q = 1 to NE } { { F } { qp = q to (NE-1) } } { q = 1 to (NE-1) } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LS"]), write_opts);
                        // assign expression to variable LS
                        var_LS_0d_int_Scalar = py::cast<int>(cpp_current_dict["LS"]);
                        aux_LS_read = true;
                        validate_vartype_consistency("LS", SCALAR_INT, aux_last_type_read_for_LS);
                        aux_last_type_read_for_LS = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NT"]);
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NE"]), write_opts);
                        // assign expression to variable NE
                        var_NE_0d_int_Scalar = py::cast<int>(cpp_current_dict["NE"]);
                        aux_NE_read = true;
                        validate_vartype_consistency("NE", SCALAR_INT, aux_last_type_read_for_NE);
                        aux_last_type_read_for_NE = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = py::cast<int>(cpp_current_dict["NT"]);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NE_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_q_0d_int_Scalar)]), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_q_0d_int_Scalar)]));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NE_0d_int_Scalar-1), 1, (var_NE_0d_int_Scalar-1), true, false);

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body

                            for (int var_qp_0d_int_Scalar = var_q_0d_int_Scalar;
                               var_qp_0d_int_Scalar <= (var_NE_0d_int_Scalar-1); var_qp_0d_int_Scalar++) {
                              bool aux_qp_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_q_0d_int_Scalar)][py::cast(var_qp_0d_int_Scalar)]), write_opts);
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_q_0d_int_Scalar, var_qp_0d_int_Scalar) = py::cast<double>(cpp_current_dict["F"][py::cast(var_q_0d_int_Scalar)][py::cast(var_qp_0d_int_Scalar)]);
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_var_NT_0d_int_Scalar = var_NT_0d_int_Scalar;
                        int var_NT_0d_int_Scalar = glob_var_NT_0d_int_Scalar;
                        bool& glob_aux_NT_read = aux_NT_read;
                        bool aux_NT_read = glob_aux_NT_read;
                        vartype aux_last_type_read_for_NT = UNKNOWN;
                        int& glob_var_NER_0d_int_Scalar = var_NER_0d_int_Scalar;
                        int var_NER_0d_int_Scalar = glob_var_NER_0d_int_Scalar;
                        bool& glob_aux_NER_read = aux_NER_read;
                        bool aux_NER_read = glob_aux_NER_read;
                        vartype aux_last_type_read_for_NER = UNKNOWN;
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { q = 1 to NER } { EC } { q = 1 to ((NT-1)/NER) } \n { { F } { l = 1 to (((NT-1)/NER)-1) } } { q = 1 to (NER-1) } ] LIST";
                        // read LIST record
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NT", -99999));
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        // assign expression to variable NER
                        var_NER_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NER", -99999));
                        aux_NER_read = true;
                        validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                        aux_last_type_read_for_NER = SCALAR_INT;
                        if ((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(6)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , 0 , LB , NT , NER / \n { ER } { q = 1 to NER } { EC } { q = 1 to ((NT-1)/NER) } \n { { F } { l = 1 to (((NT-1)/NER)-1) } } { q = 1 to (NER-1) } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, 0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                        // assign expression to variable NT
                        var_NT_0d_int_Scalar = py::cast<int>(cpp_current_dict["NT"]);
                        aux_NT_read = true;
                        validate_vartype_consistency("NT", SCALAR_INT, aux_last_type_read_for_NT);
                        aux_last_type_read_for_NT = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NER"]), write_opts);
                        // assign expression to variable NER
                        var_NER_0d_int_Scalar = py::cast<int>(cpp_current_dict["NER"]);
                        aux_NER_read = true;
                        validate_vartype_consistency("NER", SCALAR_INT, aux_last_type_read_for_NER);
                        aux_last_type_read_for_NER = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, py::cast<int>(cpp_current_dict["NT"]), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = py::cast<int>(cpp_current_dict["NT"]);
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NER_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["ER"][py::cast(var_q_0d_int_Scalar)]), write_opts);
                            // assign expression to variable ER
                            var_ER_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<double>(cpp_current_dict["ER"][py::cast(var_q_0d_int_Scalar)]));
                            validate_vartype_consistency("ER", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_ER);
                            aux_last_type_read_for_ER = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= ((var_NT_0d_int_Scalar-1)/var_NER_0d_int_Scalar); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["EC"][py::cast(var_q_0d_int_Scalar)]), write_opts);
                            // assign expression to variable EC
                            var_EC_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<double>(cpp_current_dict["EC"][py::cast(var_q_0d_int_Scalar)]));
                            validate_vartype_consistency("EC", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_EC);
                            aux_last_type_read_for_EC = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          var_F_2d_double_Matrix2d.init(1, (var_NER_0d_int_Scalar-1), 1, (((var_NT_0d_int_Scalar-1)/var_NER_0d_int_Scalar)-1), false, false);

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= (var_NER_0d_int_Scalar-1); var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body

                            for (int var_l_0d_int_Scalar = 1;
                               var_l_0d_int_Scalar <= (((var_NT_0d_int_Scalar-1)/var_NER_0d_int_Scalar)-1); var_l_0d_int_Scalar++) {
                              bool aux_l_read = true;
                              // read LIST body
                              cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_q_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]), write_opts);
                              // assign expression to variable F
                              var_F_2d_double_Matrix2d(var_q_0d_int_Scalar, var_l_0d_int_Scalar) = py::cast<double>(cpp_current_dict["F"][py::cast(var_q_0d_int_Scalar)][py::cast(var_l_0d_int_Scalar)]);
                              validate_vartype_consistency("F", MATRIX2D_DOUBLE, aux_last_type_read_for_F);
                              aux_last_type_read_for_F = MATRIX2D_DOUBLE;
                              cpp_i++;
                              cpp_j++;
                              if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                                cont << cpp_draft_line;
                                cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                                cpp_j = 0;
                              }
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
                if (! cpp_found_match) {
                  if (! cpp_found_match) {
                    // if statement evaluation with lookahead
                    {
                      {
                        // variable declarations
                        int& glob_var_LT_0d_int_Scalar = var_LT_0d_int_Scalar;
                        int var_LT_0d_int_Scalar = glob_var_LT_0d_int_Scalar;
                        bool& glob_aux_LT_read = aux_LT_read;
                        bool aux_LT_read = glob_aux_LT_read;
                        vartype aux_last_type_read_for_LT = UNKNOWN;
                        int& glob_var_LB_0d_int_Scalar = var_LB_0d_int_Scalar;
                        int var_LB_0d_int_Scalar = glob_var_LB_0d_int_Scalar;
                        bool& glob_aux_LB_read = aux_LB_read;
                        bool aux_LB_read = glob_aux_LB_read;
                        vartype aux_last_type_read_for_LB = UNKNOWN;
                        int& glob_cpp_int_val = cpp_int_val;
                        int cpp_int_val = glob_cpp_int_val;
                        bool& glob_aux_cpp_int_val_read = aux_cpp_int_val_read;
                        bool aux_cpp_int_val_read = glob_aux_cpp_int_val_read;
                        vartype aux_last_type_read_for_cpp_int_val = UNKNOWN;
                        int& glob_var_NP_0d_int_Scalar = var_NP_0d_int_Scalar;
                        int var_NP_0d_int_Scalar = glob_var_NP_0d_int_Scalar;
                        bool& glob_aux_NP_read = aux_NP_read;
                        bool aux_NP_read = glob_aux_NP_read;
                        vartype aux_last_type_read_for_NP = UNKNOWN;
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { q = 1 to NP } ] LIST";
                        // read LIST record
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LT", -99999));
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("LB", -99999));
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        // assign expression to variable cpp_int_val
                        cpp_int_val = (2*py::cast<int>(cpp_current_dict.attr("get")("NP", -99999)));
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict.attr("get")("NP", -99999));
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                        if ((((((((((((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(8))))))||(((((aux_LB_read == true)) && ((var_LB_0d_int_Scalar)==(9)))))))))&&((((aux_LT_read == true)) && ((var_LT_0d_int_Scalar)==(0)))))))) {
                          cpp_found_match = true;
                        }
                      }
                      if (cpp_found_match) {
                        cpp_template = "[ MAT , 40 , MT / 0.0 , 0.0 , LT , LB , (2*NP) , NP / \n { E , F } { q = 1 to NP } ] LIST";
                        cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                        // read LIST record
                        cpp_write_field<double>(cpp_draft_line, 0, 0.0, write_opts);
                        cpp_write_field<double>(cpp_draft_line, 1, 0.0, write_opts);
                        cpp_write_field<int>(cpp_draft_line, 2, py::cast<int>(cpp_current_dict["LT"]), write_opts);
                        // assign expression to variable LT
                        var_LT_0d_int_Scalar = py::cast<int>(cpp_current_dict["LT"]);
                        aux_LT_read = true;
                        validate_vartype_consistency("LT", SCALAR_INT, aux_last_type_read_for_LT);
                        aux_last_type_read_for_LT = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 3, py::cast<int>(cpp_current_dict["LB"]), write_opts);
                        // assign expression to variable LB
                        var_LB_0d_int_Scalar = py::cast<int>(cpp_current_dict["LB"]);
                        aux_LB_read = true;
                        validate_vartype_consistency("LB", SCALAR_INT, aux_last_type_read_for_LB);
                        aux_last_type_read_for_LB = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NP"])), write_opts);
                        // assign expression to variable cpp_int_val
                        cpp_int_val = (2*py::cast<int>(cpp_current_dict["NP"]));
                        aux_cpp_int_val_read = true;
                        validate_vartype_consistency("cpp_int_val", SCALAR_INT, aux_last_type_read_for_cpp_int_val);
                        aux_last_type_read_for_cpp_int_val = SCALAR_INT;
                        // assign expression to variable NP
                        var_NP_0d_int_Scalar = (cpp_int_val/2);
                        aux_NP_read = true;
                        validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                        aux_last_type_read_for_NP = SCALAR_INT;
                        cpp_write_field<int>(cpp_draft_line, 5, py::cast<int>(cpp_current_dict["NP"]), write_opts);
                        if ((! (aux_NP_read == true))) {
                          // assign expression to variable NP
                          var_NP_0d_int_Scalar = py::cast<int>(cpp_current_dict["NP"]);
                          aux_NP_read = true;
                          validate_vartype_consistency("NP", SCALAR_INT, aux_last_type_read_for_NP);
                          aux_last_type_read_for_NP = SCALAR_INT;
                        } else {
                        }
                        cpp_write_field<int>(cpp_draft_line, 4, (2*py::cast<int>(cpp_current_dict["NP"])), write_opts);
                        cont << cpp_draft_line;
                        {
                          int cpp_npl = (2*py::cast<int>(cpp_current_dict["NP"]));
                          int cpp_i = 0;
                          int cpp_j = 0;
                          cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                          // read LIST body

                          for (int var_q_0d_int_Scalar = 1;
                             var_q_0d_int_Scalar <= var_NP_0d_int_Scalar; var_q_0d_int_Scalar++) {
                            bool aux_q_read = true;
                            // read LIST body
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["E"][py::cast(var_q_0d_int_Scalar)]), write_opts);
                            // assign expression to variable E
                            var_E_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<double>(cpp_current_dict["E"][py::cast(var_q_0d_int_Scalar)]));
                            validate_vartype_consistency("E", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_E);
                            aux_last_type_read_for_E = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                            cpp_write_field<double>(cpp_draft_line, cpp_j, py::cast<double>(cpp_current_dict["F"][py::cast(var_q_0d_int_Scalar)]), write_opts);
                            // assign expression to variable F
                            var_F_1d_double_NestedVector.set(var_q_0d_int_Scalar, py::cast<double>(cpp_current_dict["F"][py::cast(var_q_0d_int_Scalar)]));
                            validate_vartype_consistency("F", NESTEDVECTOR_DOUBLE, aux_last_type_read_for_F);
                            aux_last_type_read_for_F = NESTEDVECTOR_DOUBLE;
                            cpp_i++;
                            cpp_j++;
                            if ((cpp_j > 5 && cpp_i < cpp_npl)) {
                              cont << cpp_draft_line;
                              cpp_draft_line = cpp_prepare_line(mat, mf, mt, linenum);
                              cpp_j = 0;
                            }
                          }
                          if (cpp_i != cpp_npl) {
                            throw std::runtime_error("not exactly NPL elements consumed");
                          }
                        }
                        cont << cpp_draft_line;
                      }
                    }
                  }
                }
              }
              cpp_current_dict = cpp_parent_dict_tmp;
            }
          }
          cpp_current_dict = cpp_parent_dict_tmp;
        }
      }
      cpp_current_dict = cpp_parent_dict_tmp;
    }
  }
  cpp_draft_line = cpp_prepare_send(mat, mf, write_opts);
  cont << cpp_draft_line;
}
void write_endf_ostream(std::ostream& cont, py::dict endf_dict, py::object exclude, py::object include, WritingOptions write_opts=default_writing_options()) {
  int mat;
  int mf;
  int mt;
  int last_mat = -9999;
  int last_mf = -9999;
  int last_mt = -9999;
  bool section_encountered = false;
  bool found_tpid = false;
  auto d = py::reinterpret_borrow<py::dict>(endf_dict);
  py::object mf_keys = d.attr("keys")();
  std::vector<int> sorted_mf_keys;
  for (auto mf_key : mf_keys) {
    sorted_mf_keys.push_back(py::cast<int>(mf_key));
  }
  std::sort(sorted_mf_keys.begin(), sorted_mf_keys.end());
  std::map<int, std::vector<int>> sorted_mfmt_keys;
  for (auto mf_key : sorted_mf_keys) {
    py::object mt_keys = d[py::cast(mf_key)].attr("keys")();
  std::vector<int> sorted_mt_keys;
    for (auto mt_key : mt_keys) {
      sorted_mt_keys.push_back(py::cast<int>(mt_key));
    }
    std::sort(sorted_mt_keys.begin(), sorted_mt_keys.end());
    sorted_mfmt_keys[mf_key] = sorted_mt_keys;
  }
  for (auto mf_key : sorted_mf_keys) {
    py::dict mf_dict = d[py::cast(mf_key)];
    std::vector<int> sorted_mt_keys = sorted_mfmt_keys[mf_key];
    for (auto mt_key : sorted_mt_keys) {
      py::object mt_dict = mf_dict[py::cast(mt_key)];
      mf = mf_key;
      mt = mt_key;
      if ((! should_parse_section(mf, mt, exclude, include))) {
        continue;
      }
      if ((section_encountered && mf != last_mf && mf != 0 && last_mf != 0)) {
        cont << cpp_prepare_send(mat, 0, write_opts);
      }
      if (mf == 0 && mt == 0) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf0mt0_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 1 && mt == 460) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf1mt460_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 1 && mt == 458) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf1mt458_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 1 && mt == 456) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf1mt456_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 1 && mt == 455) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf1mt455_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 1 && mt == 452) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf1mt452_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 1 && mt == 451) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf1mt451_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 2 && mt == 151) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf2mt151_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 3) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf3_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 4) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf4_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 5) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf5_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 6) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf6_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 7 && mt == 451) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf7mt451_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 7 && mt == 4) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf7mt4_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 7 && mt == 2) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf7mt2_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 8 && mt == 459) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf8mt459_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 8 && mt == 457) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf8mt457_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 8 && mt == 454) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf8mt454_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 8) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf8_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 9) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf9_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 10) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf10_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 12) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf12_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 13) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf13_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 14) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf14_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 15) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf15_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 23) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf23_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 26) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf26_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 27) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf27_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 28) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf28_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 31) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf31_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 32) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf32_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 33) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf33_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 34) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf34_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 35) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf35_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else if (mf == 40) {
        if (py::isinstance<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)])) {
          write_mf40_ostream(cont, py::cast<py::dict>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        } else {
          write_section_verbatim(cont, py::cast<py::list>(endf_dict[py::cast(mf)][py::cast(mt)]), write_opts);
        }
        mat = get_mat_from_mfmt_section(mt_dict);
        section_encountered = true;
      } else {
      }
      last_mat = mat;
      last_mf = mf;
      last_mt = mt;
    }
  }
  cont << cpp_prepare_send(mat, 0, write_opts);
  cont << cpp_prepare_send(0, 0, write_opts);
  cont << cpp_prepare_send(-1, 0, write_opts);
}

std::string write_mf0mt0(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf0mt0_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf1mt451(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf1mt451_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf1mt452(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf1mt452_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf1mt455(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf1mt455_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf1mt456(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf1mt456_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf1mt458(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf1mt458_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf1mt460(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf1mt460_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf2mt151(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf2mt151_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf3(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf3_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf4(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf4_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf5(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf5_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf6(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf6_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf7mt2(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf7mt2_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf7mt4(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf7mt4_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf7mt451(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf7mt451_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf8(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf8_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf8mt454(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf8mt454_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf8mt457(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf8mt457_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf8mt459(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf8mt459_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf9(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf9_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf10(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf10_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf12(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf12_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf13(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf13_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf14(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf14_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf15(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf15_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf23(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf23_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf26(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf26_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf27(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf27_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf28(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf28_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf31(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf31_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf32(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf32_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf33(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf33_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf34(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf34_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf35(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf35_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_mf40(py::dict endf_dict, WritingOptions write_opts) {
  std::ostringstream oss;
  write_mf40_ostream(oss, endf_dict, write_opts);
  return oss.str();
}

std::string write_endf(py::dict endf_dict, py::object exclude, py::object include, WritingOptions write_opts) {
  std::ostringstream oss;
  write_endf_ostream(oss, endf_dict, exclude, include, write_opts);
  return oss.str();
}

void write_mf0mt0_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf0mt0_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf1mt451_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf1mt451_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf1mt452_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf1mt452_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf1mt455_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf1mt455_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf1mt456_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf1mt456_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf1mt458_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf1mt458_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf1mt460_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf1mt460_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf2mt151_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf2mt151_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf3_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf3_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf4_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf4_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf5_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf5_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf6_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf6_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf7mt2_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf7mt2_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf7mt4_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf7mt4_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf7mt451_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf7mt451_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf8_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf8_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf8mt454_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf8mt454_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf8mt457_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf8mt457_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf8mt459_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf8mt459_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf9_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf9_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf10_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf10_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf12_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf12_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf13_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf13_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf14_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf14_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf15_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf15_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf23_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf23_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf26_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf26_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf27_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf27_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf28_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf28_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf31_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf31_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf32_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf32_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf33_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf33_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf34_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf34_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf35_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf35_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_mf40_file(std::string& filename, py::dict endf_dict, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_mf40_ostream(outfile, endf_dict, write_opts);
  outfile.close();
}

void write_endf_file(std::string& filename, py::dict endf_dict, py::object exclude, py::object include, WritingOptions write_opts) {
  std::ofstream outfile(filename);
  if ((! outfile.is_open())) {
    throw std::ofstream::failure("failed to open file " + filename);
  }
  write_endf_ostream(outfile, endf_dict, exclude, include, write_opts);
  outfile.close();
}



PYBIND11_MODULE(jendl, m) {

  // static bool parsing_options_registered = false;
  // if (! parsing_options_registered) {
  //   py::class_<ParsingOptions>(m, "ParsingOptions")
  //     .def(py::init<>())
  //     .def_readwrite("ignore_number_mismatch", &ParsingOptions::ignore_number_mismatch)
  //     .def_readwrite("ignore_zero_mismatch", &ParsingOptions::ignore_zero_mismatch)
  //     .def_readwrite("ignore_varspec_mismatch", &ParsingOptions::ignore_varspec_mismatch)
  //     .def_readwrite("accept_spaces", &ParsingOptions::accept_spaces)
  //     .def_readwrite("ignore_blank_lines", &ParsingOptions::ignore_blank_lines)
  //     .def_readwrite("ignore_send_records", &ParsingOptions::ignore_send_records)
  //     .def_readwrite("ignore_missing_tpid", &ParsingOptions::ignore_missing_tpid)
  //     .def_readwrite("validate_control_records", &ParsingOptions::validate_control_records);
  //   parsing_options_registered = true;
  // }
  m.def("parse_endf", &parse_endf, "parsing function", py::arg("cont"), py::arg("exclude") = py::none(), py::arg("include") = py::none(), py::arg("parse_opts") = false);
  m.def("parse_endf_file", &parse_endf_file, "parsing function", py::arg("filename"), py::arg("exclude") = py::none(), py::arg("include") = py::none(), py::arg("parse_opts") = default_parsing_options());
  m.def("write_endf", &write_endf, "parsing function", py::arg("endf_dict"), py::arg("exclude") = py::none(), py::arg("include") = py::none(), py::arg("WritingOptions") = false);
  m.def("write_endf_file", &write_endf_file, "parsing function", py::arg("filename"), py::arg("endf_dict"), py::arg("exclude") = py::none(), py::arg("include") = py::none(), py::arg("write_opts") = default_writing_options());
}
